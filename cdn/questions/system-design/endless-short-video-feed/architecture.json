{
  "key": "A",
  "title": "Architecture / High-level design",
  "blocks": [
    {
      "type": "text",
      "text": "The architecture must keep playback fast and scrolling smooth. Treat this as a client pipeline: feed shell + visibility tracking + prefetch manager + media loader + playback controller. The UI should be driven by a single active player and a bounded cache."
    },
    {
      "type": "divider"
    },
    {
      "type": "columns",
      "columns": [
        {
          "blocks": [
            {
              "type": "text",
              "text": "**Client architecture**\n- Feed shell + virtualized list\n- Visibility observer (viewport + direction)\n- Video card component with lifecycle hooks\n- Prefetch manager (next 2-3)\n- Playback controller (single active player)"
            }
          ]
        },
        {
          "blocks": [
            {
              "type": "text",
              "text": "**Delivery pipeline**\n- CDN for segmented media\n- Adaptive bitrate (ABR) selection\n- Client cache with TTL + LRU\n- Retry + fallback for slow networks\n- Analytics hooks for playback health"
            }
          ]
        }
      ]
    },
    {
      "type": "table",
      "title": "Core modules to mention",
      "columns": [
        "Module",
        "Responsibility",
        "Why it matters"
      ],
      "rows": [
        [
          "FeedShell",
          "Loads metadata + manages virtualized list",
          "Controls DOM size and scroll performance"
        ],
        [
          "VisibilityObserver",
          "Detects active card + scroll direction",
          "Drives autoplay and prefetch window"
        ],
        [
          "PrefetchManager",
          "Queues upcoming media requests",
          "Improves time-to-first-frame"
        ],
        [
          "PlaybackController",
          "Ensures a single active player",
          "Prevents multiple decoders running"
        ],
        [
          "MediaCache",
          "Caches poster + segments (TTL/LRU)",
          "Reduces network churn"
        ]
      ]
    },
    {
      "type": "divider"
    },
    {
      "type": "steps",
      "title": "High-level data flow",
      "steps": [
        {
          "title": "1) Fetch metadata",
          "text": "Load feed metadata (id, poster, media URLs, duration) and render the first card."
        },
        {
          "title": "2) Start playback",
          "text": "When the first card enters the viewport, the PlaybackController starts playback and records TTFF."
        },
        {
          "title": "3) Prefetch",
          "text": "PrefetchManager schedules the next 2-3 videos based on scroll direction and idle time."
        },
        {
          "title": "4) Adapt quality",
          "text": "ABR chooses a lower bitrate on slow networks; upgrade when stable."
        },
        {
          "title": "5) Cleanup",
          "text": "Pause offscreen videos, cancel downloads, and evict cache entries via LRU."
        }
      ]
    },
    {
      "type": "callout",
      "variant": "success",
      "title": "Key message",
      "text": "You win by controlling the pipeline: visibility drives playback, a small prefetch window drives instant play, and a bounded cache keeps memory predictable."
    },
    {
      "type": "divider"
    },
    {
      "type": "table",
      "title": "Component boundaries to call out",
      "columns": [
        "Boundary",
        "Reason"
      ],
      "rows": [
        [
          "UI shell vs feature module",
          "Independent deploys and safe rollouts"
        ],
        [
          "Ingest vs render",
          "Prevents re-render storms"
        ],
        [
          "Cache vs view model",
          "Keeps UI deterministic"
        ]
      ]
    },
    {
      "type": "callout",
      "variant": "info",
      "title": "Explain the data flow",
      "text": "State the pipeline explicitly: fetch -> normalize -> cache -> view model -> render. This shows you understand front-end architecture beyond UI widgets."
    }
  ]
}
