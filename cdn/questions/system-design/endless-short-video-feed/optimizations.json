{
  "key": "O",
  "title": "Optimizations and deep dive",
  "blocks": [
    {
      "type": "text",
      "text": "Optimizations should protect the render pipeline and reduce playback stalls. The deep dive here is about controlling network, CPU, and memory while keeping playback instant."
    },
    {
      "type": "divider"
    },
    {
      "type": "checklist",
      "title": "Frontend performance strategies",
      "items": [
        "Preconnect to CDN and warm the first media request.",
        "Prefetch next N videos during idle time; cancel on rapid scroll.",
        "Virtualize offscreen items and keep DOM size bounded.",
        "Pause/stop playback when cards exit the viewport.",
        "Use low-res posters and upgrade when stable.",
        "Throttle scroll-driven state updates to avoid re-render storms."
      ]
    },
    {
      "type": "checklist",
      "title": "Playback reliability",
      "items": [
        "Adaptive bitrate (ABR) with conservative downshift.",
        "Fallback to low-res or poster-only on bad networks.",
        "Abort in-flight requests when the user skips quickly.",
        "Capture errors with a retry UI and silent auto-retry."
      ]
    },
    {
      "type": "table",
      "title": "Performance targets you can quote",
      "columns": [
        "Metric",
        "Target",
        "Why it matters"
      ],
      "rows": [
        [
          "Time-to-first-frame",
          "<= 1.0s",
          "Perceived instant playback"
        ],
        [
          "Rebuffer rate",
          "< 1%",
          "Smooth session quality"
        ],
        [
          "INP",
          "<= 200ms",
          "Fast touch/scroll feedback"
        ],
        [
          "Dropped frames",
          "< 2%",
          "Visible jank control"
        ]
      ]
    },
    {
      "type": "stats",
      "items": [
        {
          "label": "Prefetch window",
          "value": "2-3 videos",
          "helperText": "Keep memory bounded and speed high."
        },
        {
          "label": "Scroll budget",
          "value": "16ms",
          "helperText": "Frame budget for smooth scrolling."
        },
        {
          "label": "TTFF budget",
          "value": "<= 1.0s",
          "helperText": "Primary success metric."
        }
      ]
    },
    {
      "type": "callout",
      "variant": "warning",
      "title": "What sinks candidates",
      "text": "Vague answers like “use CDN” without showing how prefetching, cancellation, and playback lifecycle actually work on the client."
    },
    {
      "type": "divider"
    },
    {
      "type": "steps",
      "title": "Deep dive: preventing jank",
      "steps": [
        {
          "title": "1) Batch updates",
          "text": "Apply updates on a cadence (100-250ms) instead of per event."
        },
        {
          "title": "2) Bound the DOM",
          "text": "Virtualize long lists or carousels so DOM size stays small."
        },
        {
          "title": "3) Cancel stale work",
          "text": "Abort prefetches or network work when user intent changes."
        },
        {
          "title": "4) Measure",
          "text": "Log LCP/INP and feature-specific KPIs to validate rollout."
        }
      ]
    }
  ]
}
