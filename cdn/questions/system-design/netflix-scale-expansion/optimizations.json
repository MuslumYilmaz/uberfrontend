{
  "key": "O",
  "title": "Optimizations and deep dive",
  "blocks": [
    {
      "type": "text",
      "text": "Your answer should show you can keep the UI fast and resilient at scale. Focus on rendering budgets, cache strategy, and safe rollout."
    },
    {
      "type": "divider"
    },
    {
      "type": "checklist",
      "title": "Frontend performance strategies",
      "items": [
        "Route-level code splitting + prefetch on idle.",
        "Virtualization for large carousels.",
        "Memoization to avoid re-render storms.",
        "Batch UI updates (100-250ms).",
        "Priority loading for above-the-fold content."
      ]
    },
    {
      "type": "checklist",
      "title": "Reliability and rollout",
      "items": [
        "Feature flags with gradual rollout.",
        "Fallback UI when data is slow or missing.",
        "Regional rollouts + fast rollback.",
        "Monitoring Web Vitals + custom UX metrics.",
        "Error boundaries to isolate failures."
      ]
    },
    {
      "type": "table",
      "title": "Metrics to report",
      "columns": [
        "Metric",
        "Target",
        "Why it matters"
      ],
      "rows": [
        [
          "LCP",
          "<= 2.5s",
          "Core page load health"
        ],
        [
          "INP",
          "<= 200ms",
          "Interaction quality"
        ],
        [
          "Error rate",
          "< 0.5%",
          "Reliability"
        ],
        [
          "Carousel FPS",
          "60 FPS",
          "Smooth interaction"
        ]
      ]
    },
    {
      "type": "stats",
      "items": [
        {
          "label": "Frame budget",
          "value": "16ms",
          "helperText": "Avoid dropped frames during updates."
        },
        {
          "label": "Cache TTL",
          "value": "30-120s",
          "helperText": "Short-lived for dynamic data."
        },
        {
          "label": "Rollback goal",
          "value": "< 5 minutes",
          "helperText": "Fast disable if metrics regress."
        }
      ]
    },
    {
      "type": "callout",
      "variant": "warning",
      "title": "What sinks candidates",
      "text": "Vague answers like 'just scale servers.' You must show concrete frontend trade-offs: rendering, caching, and rollout control."
    },
    {
      "type": "divider"
    },
    {
      "type": "steps",
      "title": "Deep dive: preventing jank",
      "steps": [
        {
          "title": "1) Batch updates",
          "text": "Apply updates on a cadence (100-250ms) instead of per event."
        },
        {
          "title": "2) Bound the DOM",
          "text": "Virtualize long lists or carousels so DOM size stays small."
        },
        {
          "title": "3) Cancel stale work",
          "text": "Abort prefetches or network work when user intent changes."
        },
        {
          "title": "4) Measure",
          "text": "Log LCP/INP and feature-specific KPIs to validate rollout."
        }
      ]
    },
    {
      "type": "divider"
    },
    {
      "type": "table",
      "title": "Backpressure policy",
      "columns": [
        "Scenario",
        "Policy",
        "Why"
      ],
      "rows": [
        [
          "Burst spikes",
          "Batch + drop low-priority",
          "Protect FPS"
        ],
        [
          "Slow device",
          "Lower render cadence",
          "Keep UI responsive"
        ],
        [
          "User paused",
          "Render badge only",
          "Avoid wasted work"
        ]
      ]
    }
  ]
}
