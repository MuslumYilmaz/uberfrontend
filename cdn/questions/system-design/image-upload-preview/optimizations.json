{
    "key": "O",
    "title": "Optimizations & Deep dive",
    "blocks": [
        {
            "type": "text",
            "text": "In this step, the interviewer checks whether you can take a simple Image Upload & Preview component and still think about performance, UX polish, accessibility edge cases, and long-running sessions (memory leaks). You should show that you know how to keep it smooth and robust, not just \"it works on my machine\"."
        },
        {
            "type": "divider"
        },
        {
            "type": "columns",
            "columns": [
                {
                    "blocks": [
                        {
                            "type": "text",
                            "text": "**How you should frame optimizations:**\n\"The component is small, but there are still real problems to solve: preventing memory leaks from object URLs, keeping mobile UX clean, handling repeated selections without flicker, and making sure errors/statuses are clearly communicated to assistive tech. I’d also design it so we can extend it to drag-and-drop or multi-image uploads later without rewriting everything.\""
                        }
                    ]
                },
                {
                    "blocks": [
                        {
                            "type": "text",
                            "text": "**What the interviewer listens for:**\n- Awareness of **object URL lifecycle** and memory management.\n- Handling **fast user interactions** (selecting multiple times quickly).\n- Smooth, non-janky **loading transitions** and clear status changes.\n- Strong **accessibility** even in error and edge states.\n- A path to **extend** the component (drag-and-drop, multi-image) safely."
                        }
                    ]
                }
            ]
        },
        {
            "type": "callout",
            "variant": "info",
            "title": "How you should act here",
            "text": "Pick a few realistic risks — memory leaks, ugly transitions, confusing errors, mobile layout — and explain specifically how you avoid them: where you revoke object URLs, how you structure timers, how you keep focus and ARIA states in sync with the status."
        },
        {
            "type": "divider"
        },
        {
            "type": "columns",
            "columns": [
                {
                    "blocks": [
                        {
                            "type": "checklist",
                            "title": "Performance & memory hygiene",
                            "items": [
                                "Revoke old `previewUrl` **every time** a new file is accepted or the component unmounts (e.g. cleanup in a `useEffect` / onDestroy hook).",
                                "Only call `URL.createObjectURL` **after** validation passes, so you never create URLs for rejected files.",
                                "Keep the state small: store just the `File` and `previewUrl`, not large base64 strings.",
                                "Use a simple **status enum** instead of heavy, nested objects to avoid unnecessary re-renders.",
                                "Avoid expensive image operations on the main thread; for basic preview, rely on the browser’s native `<img>` rendering.",
                                "If you later support multi-image, consider a **max number of thumbnails** and lazy rendering if the list grows."
                            ]
                        }
                    ]
                },
                {
                    "blocks": [
                        {
                            "type": "checklist",
                            "title": "UX & accessibility polish",
                            "items": [
                                "Ensure the main control is a clear, focusable target (button or label-wrap around file input) with descriptive text.",
                                "Display error messages in a region with `role=\"alert\"` or wired via `aria-describedby` so screen readers announce them immediately.",
                                "Use distinct visual cues for each state (idle, uploading, uploaded, error), not just color changes.",
                                "Make sure \"Replace\" and \"Remove\" are reachable by keyboard and have clear labels (not just icons).",
                                "On error, keep focus in a sensible place (e.g. on the control or on the first action), so the user can fix the problem quickly.",
                                "On mobile, avoid cramped layouts: give enough padding around the button, preview, and actions so taps are reliable."
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "type": "table",
            "title": "Deep-dive angles you can bring up",
            "columns": [
                "Topic",
                "Risk",
                "How you address it"
            ],
            "rows": [
                [
                    "Object URL lifecycle",
                    "Creating many previews without revoking old URLs can leak memory over time.",
                    "Track the current `previewUrl` in state and always revoke the previous one on replace/remove and on unmount. Only create URLs when validation has passed."
                ],
                [
                    "Fast repeated selections",
                    "User quickly selects multiple files; timers and state can get out of sync.",
                    "Store the current upload token (e.g. a simple counter) and only apply `simulateUpload` results if the token still matches the latest selection."
                ],
                [
                    "Loading/Uploaded transitions",
                    "Sudden jumps between idle → uploaded can feel confusing.",
                    "Always go through a short `uploading` state (1–2s) with a clear spinner or skeleton and progress text (e.g. \"Uploading…\")."
                ],
                [
                    "Error feedback",
                    "Users see a red border but don’t know why the file was rejected.",
                    "Show a specific error message (\"File too large\" vs \"Unsupported format\") and make sure it’s associated with the control via ARIA."
                ],
                [
                    "Mobile & responsiveness",
                    "On small screens, the preview or actions might overflow or become hard to tap.",
                    "Use a simple vertical layout on mobile: button on top, preview below, actions stacked, and set max-width / max-height for the image with `object-fit: cover` or `contain`."
                ]
            ]
        },
        {
            "type": "steps",
            "title": "Example deep-dive: upload simulation & cancellation",
            "steps": [
                {
                    "title": "1. Start fake upload with a token",
                    "text": "Whenever a valid file is selected, increment an internal `uploadId` and capture it locally. Set `status = 'uploading'` and schedule a timeout based on `fakeUploadMs`."
                },
                {
                    "title": "2. Ignore stale completions",
                    "text": "When the timeout fires, compare its captured `uploadId` with the current one in state. If they do not match, ignore the completion because a newer file has been selected."
                },
                {
                    "title": "3. Handle remove during upload",
                    "text": "If the user hits Remove while uploading, clear the timeout (if you have a reference) or increment `uploadId` and reset state. That way, any later timeout will be ignored."
                },
                {
                    "title": "4. Sync callbacks with state",
                    "text": "Only call `onUploadComplete` if the upload is still the latest and the component is not in an error or removed state."
                }
            ]
        },
        {
            "type": "stats",
            "items": [
                {
                    "label": "Main risk",
                    "value": "Object URL leaks",
                    "helperText": "Always revoke URLs on replace/remove/unmount."
                },
                {
                    "label": "Key UX lever",
                    "value": "Clear states",
                    "helperText": "Idle, uploading, uploaded, error all look and sound different."
                },
                {
                    "label": "Deep-dive hook",
                    "value": "Simulated cancelation",
                    "helperText": "Use an upload token/id to ignore stale results."
                }
            ]
        },
        {
            "type": "callout",
            "variant": "warning",
            "title": "Key message to land",
            "text": "Even for a small image picker, you can talk like a strong frontend engineer: you manage object URLs carefully, keep state transitions predictable, handle fast user interactions safely, and make the component accessible and mobile-friendly by design."
        }
    ]
}