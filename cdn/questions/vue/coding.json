[
  {
    "id": "vue-counter",
    "title": "Vue Counter (Guarded Decrement)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "easy",
    "importance": 3,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "event-handlers",
      "basics"
    ],
    "description": {
      "summary": "Build a Vue 3 counter component with increment/decrement and a zero floor. Use reactive state and guard the decrement so it never goes negative. Call out disabled states and clean template logic. Concepts: vue, components, reactivity, event handlers, basics. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render the counter UI as the main component.",
          "Display the current count value.",
          "Provide '+' and '−' buttons to increment and decrement.",
          "Prevent the count from ever going below 0.",
          "Include a 'Reset' button that sets the count back to 0."
        ],
        "expectedBehavior": [
          "Initial count starts at 0.",
          "Clicking '+' increases the count by 1.",
          "Clicking '−' decreases the count by 1, but never below 0.",
          "Clicking 'Reset' sets the count back to 0.",
          "The '−' button is disabled when the count is 0."
        ],
        "implementationNotes": [
          "Use Vue 3's Composition API with `ref` to store the count.",
          "Use a `computed` property to determine when the count is zero and disable the decrement button.",
          "Keep everything in a single `<App.vue>` component for this exercise."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Basic component structure",
          "Click event handlers",
          "Guarded state updates"
        ]
      }
    },
    "starterCodeHint": "Implement the counter logic inside `<script setup>`. Use `ref(0)` for the value and a `computed` property for the disabled state of the decrement button.",
    "solutionBlock": {
      "overview": "Use Vue 3's Composition API with `ref(0)` for the count and a `computed` property that returns `true` when the count is 0. The '+' button increments the ref, the '−' button decrements but is guarded so the value never becomes negative, and 'Reset' sets it back to 0.\n\n**Key ideas**\n- Store count in a single `ref`.\n- Derive disabled state from a `computed` value.\n- Guard the decrement so it never sets a negative value. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "Single component with guarded decrement",
          "prose": "Keep all logic inside `<script setup>` in `App.vue`. Use `const count = ref(0)` to create reactive state. Define a computed property `isZero` that checks `count.value === 0` and bind it to `:disabled` on the decrement button. Implement `inc`, `dec`, and `reset` as simple functions that mutate `count.value`, with `dec` checking that the value is greater than 0 before decrementing. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Updating `count` without guarding against negatives, allowing the value to go below 0.",
          "Forgetting to use `.value` when reading or writing refs inside `<script setup>`.",
          "Deriving `isZero` manually and forgetting to update it when count changes instead of using `computed`."
        ],
        "techniques": [
          "Using `ref` for local reactive state in Vue 3.",
          "Using `computed` to derive boolean UI state (disabled button).",
          "Keeping state and handlers co-located with the component template."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-counter.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-counter"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-counter-solution.v1.json",
    "access": "free",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Vue 3 Counter with Guarded Decrement and Reset Logic",
      "description": "Create a Vue counter with reactive state, increment and decrement actions, zero-floor protection, and disabled UI states that stay synced with value changes."
    }
  },
  {
    "id": "vue-contact-form-starter",
    "title": "Contact Form (Single File Component + Fetch)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "vue",
      "forms",
      "http",
      "validation",
      "user-input"
    ],
    "description": {
      "summary": "Build a contact form in a Vue 3 single file component using the Composition API. You will only work inside &lt;script setup&gt; in App.vue. The template and styles are already provided for you. Validate the user's input and send the form data with a POST request to https://jsonplaceholder.typicode.com/posts, showing loading, success, and error states. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Use Vue 3's Composition API in a single-file component (App.vue).",
          "Use refs to track form fields: name, email, and message.",
          "Make all fields required; validate email with a basic email pattern and require a minimum length for the message (e.g. at least 10 characters).",
          "Disable the submit button while the form is invalid or while a request is in progress.",
          "On submit, send a POST request with the form body to https://jsonplaceholder.typicode.com/posts.",
          "Show a success message if the request succeeds and an error message if it fails."
        ],
        "expectedBehavior": [
          "Initially, the submit button is disabled until all fields are valid.",
          "If the user attempts to submit invalid data, validation error messages are shown for the affected fields once they have been touched.",
          "On a valid submit, a POST request is sent and the button is disabled while the request is in flight.",
          "On success, show the message: \"Your message has been sent. Thank you!\" and optionally reset the form.",
          "On error, show the message: \"Something went wrong. Please try again.\" and allow the user to submit again."
        ],
        "implementationNotes": [
          "Work only in <script setup> of App.vue. The template and CSS are already wired up.",
          "Use refs for field values and for 'touched' flags to control when to show validation messages.",
          "Derive booleans like nameIsValid, emailIsValid, messageIsValid, and formIsValid from the current values.",
          "Use the fetch API to send a POST request to https://jsonplaceholder.typicode.com/posts with a JSON body.",
          "Track an isSubmitting ref to control the disabled state and avoid double submissions.",
          "Use successMessage and errorMessage refs for user feedback."
        ],
        "techFocus": [
          "Vue 3 Composition API (refs and derived state)",
          "Form validation and UX (touched state, inline errors, disabled submit)",
          "Basic fetch usage and request lifecycle handling from a component",
          "Single File Component structure with <template> and <script setup>"
        ]
      }
    },
    "starterCodeHint": "Focus exclusively on <script setup> inside App.vue. Use refs for name, email, and message, plus separate 'touched' flags. Derive a formIsValid boolean and implement an async handleSubmit that POSTs to https://jsonplaceholder.typicode.com/posts and updates successMessage / errorMessage.",
    "solutionBlock": {
      "overview": "This exercise combines a Vue 3 single file component, the Composition API, and an HTTP POST request. You will define refs for name, email, and message, along with 'touched' flags to control when to show validation errors. Derived booleans like nameIsValid, emailIsValid, messageIsValid, and formIsValid drive both inline error messages and the disabled state of the submit button.\n\nOn submit, you prevent the default form behavior, mark all fields as touched, clear previous messages, and guard against invalid input. If the form is valid, you set isSubmitting to true and use fetch to POST the JSON payload to https://jsonplaceholder.typicode.com/posts. Depending on the response, you either show \"Your message has been sent. Thank you!\" and reset the form or show \"Something went wrong. Please try again.\" and keep the current values for another attempt.\n\n**Test cases**\n- With all fields empty, the submit button is disabled.\n- Typing an invalid email keeps the form invalid and disabled.\n- Blurring out of empty fields marks them as touched and shows validation errors.\n- With valid inputs, clicking submit triggers a POST request and disables the button while the request is in flight.\n- On success, the success message appears and the fields are cleared.\n- On error, the error message appears and the user can try again.",
      "approaches": [
        {
          "title": "Single file component with refs, derived validity, and fetch",
          "prose": "Keep everything inside App.vue using <script setup>. Use refs for name, email, message, and for touched flags (touchedName, touchedEmail, touchedMessage). Derive nameIsValid, emailIsValid, and messageIsValid as booleans, and then combine them into formIsValid. In the template, bind fields with v-model, show error messages when a field is both touched and invalid, and disable the submit button when !formIsValid or isSubmitting is true.\n\nIn handleSubmit, call event.preventDefault(), mark all fields as touched, clear successMessage and errorMessage, and if the form is valid, set isSubmitting to true and send a fetch POST request to https://jsonplaceholder.typicode.com/posts with a JSON body. On a successful response, show the success message and reset the fields and touched flags. On failure, show the error message and leave the fields as-is.",
          "codeTs": "<template>\n  <main class=\"main\">\n    <section class=\"section\">\n      <h1>Contact Us (Solution)</h1>\n\n      <form class=\"panel\" novalidate @submit=\"handleSubmit\">\n        <div class=\"field\">\n          <label for=\"name\">Name</label>\n          <input\n            id=\"name\"\n            type=\"text\"\n            v-model=\"name\"\n            @blur=\"touchedName = true\"\n          />\n          <p v-if=\"touchedName && !nameIsValid\" class=\"error\">Name is required.</p>\n        </div>\n\n        <div class=\"field\">\n          <label for=\"email\">Email</label>\n          <input\n            id=\"email\"\n            type=\"email\"\n            v-model=\"email\"\n            @blur=\"touchedEmail = true\"\n          />\n          <p v-if=\"touchedEmail && !email\" class=\"error\">Email is required.</p>\n          <p v-if=\"touchedEmail && email && !emailIsValid\" class=\"error\">Enter a valid email address.</p>\n        </div>\n\n        <div class=\"field\">\n          <label for=\"message\">Message</label>\n          <textarea\n            id=\"message\"\n            rows=\"4\"\n            v-model=\"message\"\n            @blur=\"touchedMessage = true\"\n          />\n          <p v-if=\"touchedMessage && !message\" class=\"error\">Message is required.</p>\n          <p\n            v-if=\"touchedMessage && message && !messageIsValid\"\n            class=\"error\"\n          >\n            Message should be at least 10 characters.\n          </p>\n        </div>\n\n        <button\n          type=\"submit\"\n          class=\"primary\"\n          :disabled=\"!formIsValid || isSubmitting\"\n        >\n          {{ isSubmitting ? 'Sending…' : 'Send message' }}\n        </button>\n\n        <p v-if=\"successMessage\" class=\"success\">{{ successMessage }}</p>\n        <p v-if=\"errorMessage\" class=\"error\">{{ errorMessage }}</p>\n      </form>\n    </section>\n  </main>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed } from 'vue';\n\nconst name = ref('');\nconst email = ref('');\nconst message = ref('');\n\nconst touchedName = ref(false);\nconst touchedEmail = ref(false);\nconst touchedMessage = ref(false);\n\nconst isSubmitting = ref(false);\nconst successMessage = ref('');\nconst errorMessage = ref('');\n\nconst nameIsValid = computed(() => name.value.trim().length > 0);\nconst emailIsValid = computed(() => /\\S+@\\S+\\.\\S+/.test(email.value));\nconst messageIsValid = computed(() => message.value.trim().length >= 10);\n\nconst formIsValid = computed(\n  () => nameIsValid.value && emailIsValid.value && messageIsValid.value\n);\n\nconst handleSubmit = async (event: any) => {\n  event.preventDefault();\n\n  touchedName.value = true;\n  touchedEmail.value = true;\n  touchedMessage.value = true;\n\n  successMessage.value = '';\n  errorMessage.value = '';\n\n  if (!formIsValid.value) {\n    return;\n  }\n\n  isSubmitting.value = true;\n\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/posts', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        name: name.value,\n        email: email.value,\n        message: message.value\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error('Request failed');\n    }\n\n    successMessage.value = 'Your message has been sent. Thank you!';\n\n    name.value = '';\n    email.value = '';\n    message.value = '';\n    touchedName.value = false;\n    touchedEmail.value = false;\n    touchedMessage.value = false;\n  } catch (error) {\n    errorMessage.value = 'Something went wrong. Please try again.';\n  } finally {\n    isSubmitting.value = false;\n  }\n};\n</script>\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to call event.preventDefault() in handleSubmit, which causes a full page reload.",
          "Not using separate 'touched' refs, which makes it hard to control when validation messages appear.",
          "Allowing the user to submit while the form is invalid or while a request is still in flight.",
          "Not handling failed responses from fetch, leaving the user without feedback on errors."
        ],
        "techniques": [
          "Using refs for field values and for UX flags like 'touched' and 'isSubmitting'.",
          "Deriving all validity booleans (nameIsValid, emailIsValid, messageIsValid, formIsValid) with computed.",
          "Using fetch for a simple JSON POST request from a component.",
          "Driving button disabled state and inline messages directly from derived state."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-contact-form.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-contact-form-starter"
    },
    "companies": [],
    "solutionAsset": "assets/sb/vue/solution/vue-contact-form-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Vue Contact Form with Validation and POST Request Handling",
      "description": "Implement a Vue 3 script setup form with v-model inputs, submit validation, fetch POST integration, and clear loading success error feedback states."
    }
  },
  {
    "id": "vue-todo-list",
    "title": "Todo List (Refs + List Rendering)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "vue",
      "lists",
      "state-management",
      "event-handlers",
      "forms"
    ],
    "description": {
      "summary": "Build a small Todo List in Vue 3 using the Composition API and &lt;script setup&gt;. Users should be able to add tasks, mark them as completed, remove individual tasks, and clear all completed tasks. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render a Todo List as the main UI in App.vue.",
          "Use a text input and 'Add' button to create new todos.",
          "Display todos in a list using v-for.",
          "Each todo should have a checkbox to toggle completion and a 'Remove' button.",
          "Provide a 'Clear completed' button that removes all completed todos when clicked."
        ],
        "expectedBehavior": [
          "Clicking 'Add' with non-empty trimmed text adds a new todo to the list and clears the input.",
          "Checking a todo's checkbox toggles its completed state and visually marks it (line-through).",
          "Clicking 'Remove' deletes that specific todo.",
          "Clicking 'Clear completed' removes all todos where done === true.",
          "An empty state message is shown when there are no todos."
        ],
        "implementationNotes": [
          "Use `ref('')` for the controlled input value (newTask).",
          "Store the list of todos in a `ref<Todo[]>([])` where each todo has `id`, `text`, and `done`.",
          "Use `computed` for simple derived state like `hasTodos`.",
          "Implement helpers `addTask`, `toggleTask`, `removeTask`, and `clearCompleted` inside `<script setup>`.",
          "Keep everything in a single App.vue component."
        ],
        "techFocus": [
          "Vue 3 Composition API with refs and computed",
          "List rendering with v-for and keys",
          "Immutable style array updates (map/filter) for clarity",
          "Basic component-level state management"
        ]
      }
    },
    "starterCodeHint": "Work only inside `<script setup>` in App.vue. Use `const newTask = ref('')` and `const todos = ref([] as Todo[])`. Implement `addTask`, `toggleTask(id)`, `removeTask(id)`, and `clearCompleted()` and wire them to the template via @click / @change.",
    "solutionBlock": {
      "overview": "Use a single Vue 3 SFC with `<script setup>` to manage the todo list. Track the input value in `newTask` and store todos in a `ref` array with `{ id, text, done }`. A `computed` property `hasTodos` drives the empty state and footer visibility. Actions (`addTask`, `toggleTask`, `removeTask`, `clearCompleted`) update the `todos` array, and the template uses `v-for` to render items plus a checkbox and Remove button.\n\n**Key ideas**\n- Keep all state in refs inside `<script setup>`.\n- Use `v-for` + `:key` for list rendering.\n- Use immutable updates (`map` / `filter`) for clear toggling and removal.\n- Drive simple UI states (empty vs list, footer visibility) from computed values.",
      "approaches": [
        {
          "title": "Single component with ref-backed list and immutable updates",
          "prose": "Define `type Todo = { id: number; text: string; done: boolean }` and create `const newTask = ref('')` plus `const todos = ref([] as Todo[])`. `addTask` trims `newTask.value`, bails on empty, and appends a new todo with a unique `id` (e.g. `Date.now()`). `toggleTask(id)` replaces the array with `todos.value.map(todo => todo.id === id ? { ...todo, done: !todo.done } : todo)`. `removeTask(id)` and `clearCompleted()` use `filter` to drop items. A `hasTodos` computed returns `todos.value.length > 0` and controls whether you show the empty message or the list."
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating todos in place without updating the ref value in a way that keeps the code clear.",
          "Adding empty or whitespace-only tasks by forgetting to trim the input.",
          "Forgetting to use `:key` in `v-for`, which can lead to odd checkbox behaviour.",
          "Toggling completion without visually reflecting it (missing the `done` class binding)."
        ],
        "techniques": [
          "Using refs for both scalar and array state.",
          "Using computed for derived flags such as `hasTodos`.",
          "Updating arrays immutably to keep logic simple and predictable.",
          "Binding classes dynamically with `:class` for completed todos."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-todo-list.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-todo-list"
    },
    "companies": [],
    "solutionAsset": "assets/sb/vue/solution/vue-todo-list-solution.v1.json",
    "access": "free",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Create a Vue 3 Todo List with Add Toggle Remove and Clear Completed",
      "description": "Build a Composition API todo app with reactive lists, immutable-style updates, task completion toggles, and bulk cleanup of completed items."
    }
  },
  {
    "id": "vue-image-slider",
    "title": "Image Slider (Basic Navigation)",
    "type": "coding",
    "technology": "vue",
    "companies": [
      "amazon",
      "google"
    ],
    "difficulty": "easy",
    "importance": 4,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "arrays",
      "event-handlers"
    ],
    "description": {
      "summary": "Create a basic image slider with next/prev controls and an active index. Guard the index at bounds, update the displayed image and label, and keep disabled states in sync with index. Concepts: vue, components, reactivity. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render the image slider UI as the main component.",
          "Display exactly one slide at a time with an image and a caption.",
          "Show the current position as 'Slide X of Y'.",
          "Provide 'Previous' and 'Next' buttons to move between slides.",
          "Disable 'Previous' on the first slide and 'Next' on the last slide.",
          "Render dot indicators for each slide and allow clicking a dot to jump directly to that slide."
        ],
        "expectedBehavior": [
          "Initial slide is the first one in the list.",
          "Clicking 'Next' moves forward by one slide until the last slide.",
          "Clicking 'Previous' moves backward by one slide until the first slide.",
          "The 'Previous' button is disabled on the first slide.",
          "The 'Next' button is disabled on the last slide.",
          "Clicking a dot jumps to the corresponding slide and updates the active dot state."
        ],
        "implementationNotes": [
          "Use Vue 3's Composition API with `ref` to store the current index.",
          "Keep the slides in a constant array of objects with `id`, `title`, and `imageUrl`.",
          "Use `computed` properties for `totalSlides`, `currentSlide`, `canGoPrev`, and `canGoNext`.",
          "Implement small helper functions: `goTo(index)`, `prev()`, and `next()`.",
          "Make sure navigation is guarded (do not go before the first slide or after the last slide)."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Derived state for UI (current slide, canGoPrev/canGoNext)",
          "Event handlers for navigation",
          "Working with arrays of data in a component"
        ]
      }
    },
    "starterCodeHint": "Define a `slides` array in `<script setup>` and track the current slide index in a `ref(0)`. Use `computed` values for the current slide, total slide count, and whether previous/next are allowed. Implement `goTo`, `prev`, and `next` to update the index safely.",
    "solutionBlock": {
      "overview": "Model the image slider as an array of slide objects and a single reactive index stored in a `ref`. Use `computed` properties to derive the current slide, total slide count, and whether the user can go to the previous or next slide. Expose three handlers: `goTo(index)` for jumping to a specific slide (guarded by bounds), `prev()` for moving one step left when possible, and `next()` for moving one step right when possible.\n\n**Key ideas**\n- Store only the current index as reactive state; everything else is derived.\n- Use `computed` for `currentSlide`, `canGoPrev`, and `canGoNext` so the template stays simple.\n- Guard navigation so the index never goes out of range. Key concepts: vue, components, reactivity.",
      "approaches": [
        {
          "title": "Single component slider with derived navigation state",
          "prose": "Keep all slider logic inside `<script setup>` in `App.vue`. Use a constant `slides` array and a `ref(0)` for `currentIndex`. Derive `totalSlides`, `currentSlide`, `canGoPrev`, and `canGoNext` with `computed` so the template can be mostly declarative. Implement `goTo(index)` with a simple bounds check, and use it from the dot buttons. Implement `prev()` and `next()` to decrement/increment the index only when the corresponding `canGoPrev`/`canGoNext` flags are true. This keeps the component predictable and easy to test."
        }
      ],
      "notes": {
        "pitfalls": [
          "Letting the index go below 0 or above the last slide index.",
          "Accessing `slides[currentIndex]` without guarding, which can return `undefined` if the index is wrong.",
          "Duplicating logic in multiple places instead of using `computed` for derived values."
        ],
        "techniques": [
          "Using `ref` for reactive state in Vue 3.",
          "Using `computed` to derive booleans and current-entity data from primitive state.",
          "Driving both the main view and the small dot indicators from the same single source of truth."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-image-slider.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-image-slider"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-image-slider-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 1,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Vue Image Slider with Prev Next and Disabled Boundaries",
      "description": "Implement an index-driven slider that updates image and labels, blocks out-of-range navigation, and keeps button disabled states in sync."
    }
  },
  {
    "id": "vue-tabs-switcher",
    "title": "Vue Tabs / Multi-View Switcher",
    "type": "coding",
    "technology": "vue",
    "companies": [
      "amazon"
    ],
    "difficulty": "easy",
    "importance": 3,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "conditional-rendering",
      "basics"
    ],
    "description": {
      "summary": "Implement Vue 3 tabs using a single activeTab state. Buttons update the active tab, and conditional rendering shows one panel at a time. Include clear active styles and keyboard-friendly button semantics. Concepts: vue, components, reactivity. Vue focus: keep activeTab in a ref and render with v-if. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render a tabbed UI with three tabs labeled \"Overview\", \"Details\", and \"Settings\".",
          "Track which tab is currently active and visually highlight it.",
          "Render only the active tab's content at a time."
        ],
        "expectedBehavior": [
          "The initial active tab should be \"Overview\".",
          "Clicking a tab makes it the active tab.",
          "Only the active tab's panel is visible at any time.",
          "The active tab button has a distinct visual style (e.g., filled pill) compared to inactive ones."
        ],
        "implementationNotes": [
          "Use Vue 3's Composition API with `ref` to store the currently active tab.",
          "Model the tab id as a string union (e.g., `'overview' | 'details' | 'settings'`).",
          "Use a helper function like `isActive(tab)` to drive both active styles and conditional rendering.",
          "Keep everything in a single `<App.vue>` component for this exercise."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`)",
          "Basic component structure",
          "Click event handlers",
          "Conditional rendering based on reactive state"
        ]
      }
    },
    "starterCodeHint": "Implement the tab state and handlers inside `<script setup>`. Use `ref('overview')` for the active tab and a small helper like `isActive(tab)` to decide which tab is highlighted and which panel is shown.",
    "solutionBlock": {
      "overview": "Use Vue 3's Composition API with a single `ref` holding the active tab id. The tab buttons update that ref when clicked, and a helper like `isActive(tab)` is used in the template for both styling and conditional rendering.\n\n**Key ideas**\n- Store the active tab id in a single `ref`.\n- Drive the active pill style and visible panel from the same source of truth.\n- Keep all logic colocated with the component template using `<script setup>`. Key concepts: vue, components, reactivity.",
      "approaches": [
        {
          "title": "Single component with `activeTab` ref and helper function",
          "prose": "Keep all logic inside `<script setup>` in `App.vue`. Use `const activeTab = ref('overview')` to define the initial tab. Define a helper `const isActive = (tab: TabId) => activeTab.value === tab` and use it both for button classes and for `v-if` panels. Implement `selectTab(tab)` so it sets `activeTab.value = tab` when a tab button is clicked."
        }
      ],
      "notes": {
        "pitfalls": [
          "Using multiple booleans (`isOverview`, `isDetails`, `isSettings`) instead of a single tab id.",
          "Forgetting to visually differentiate the active tab from inactive ones.",
          "Rendering all panels at once instead of conditionally rendering only the active one."
        ],
        "techniques": [
          "Using `ref` for local reactive state in Vue 3.",
          "Using helper functions to keep the template clean.",
          "Driving both styles and rendering from one reactive value."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-tabs.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-tabs-switcher"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-tabs-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Implement a Vue Tabs Switcher with Single Active Panel Rendering",
      "description": "Use one activeTab state to switch views, render a single panel with conditional directives, and provide clear active styling with keyboard-friendly controls."
    }
  },
  {
    "id": "vue-filterable-user-list",
    "title": "Vue Filterable / Searchable User List",
    "type": "coding",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "lists",
      "forms",
      "filtering"
    ],
    "description": {
      "summary": "Build a Vue 3 filterable list using search text and role filters. Derive filtered results with computed properties and keep the source list immutable. Show an empty state when no results match. Concepts: vue, components, reactivity. Vue focus: derive filtered lists with computed properties. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render a filter UI and a list of users as the main component.",
          "Use a fixed in-memory list of users (name, role, active flag).",
          "Provide a text input that filters by name (case-insensitive).",
          "Provide a role dropdown (All, Admin, Editor, Viewer) that filters by role.",
          "Provide a checkbox that, when checked, shows only active users.",
          "Render the filtered list below the controls."
        ],
        "expectedBehavior": [
          "Initially, all users are shown.",
          "Typing in the search box filters users whose name includes the search text (case-insensitive).",
          "Changing the role dropdown filters by that role (or shows all roles when \"All\" is selected).",
          "Checking the \"Only active users\" checkbox hides inactive users.",
          "When no users match the filters, an empty state message is shown instead of an empty list."
        ],
        "implementationNotes": [
          "Keep the user data in a fixed array inside the component (no fetch or API).",
          "Use Vue 3's Composition API (`ref`, `computed`) in `<script setup>` to store filter state and derive the filtered list.",
          "Treat the inputs as controlled with `v-model` bound to the reactive state.",
          "Derive a `filteredUsers` computed from the base list + current filters.",
          "You can mention memoization or performance considerations in discussion, but the plain computed is enough for this exercise."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Controlled inputs with `v-model`",
          "Derived state for filtered lists",
          "Rendering lists with `v-for` and keys"
        ]
      }
    },
    "starterCodeHint": "Define a constant USERS array with name, role, and active. Use `ref` for `searchTerm`, `selectedRole`, and `showOnlyActive`, and derive `filteredUsers` in a `computed` that applies all three filters.",
    "solutionBlock": {
      "overview": "The core of this exercise is combining three filters (search text, role selection, and an \"only active\" toggle) into a single derived list without mutating the original user data.\n\n**Key ideas**\n- Keep the base `USERS` list as a plain constant.\n- Use `ref` for `searchTerm`, `selectedRole`, and `showOnlyActive`.\n- Use a `computed` `filteredUsers` that applies all filters in sequence.\n- Render `filteredUsers` with `v-for`, and show an empty state when it is empty.\n\n**Test cases**\n- Default render shows all users.\n- Typing a partial name filters to matching users.\n- Changing the role filter to `Admin` shows only admins, `All` restores all roles.\n- Ticking \"Only active users\" hides inactive users.\n- When filters exclude all users, a \"no users\" message is rendered. Key concepts: vue, components, reactivity.",
      "approaches": [
        {
          "title": "Single `<App.vue>` with `ref` state and computed `filteredUsers`",
          "prose": "Keep everything in `App.vue` using `<script setup>`. Declare a constant `USERS` array for the data. Use `ref('')` for the search term, `ref<'all' | 'admin' | 'editor' | 'viewer'>('all')` for the role filter, and `ref(false)` for the active-only toggle. Derive `filteredUsers` with a `computed` that normalizes the search term to lower-case, optionally filters on role when not `\"all\"`, and optionally filters out inactive users when `showOnlyActive` is true.\n\nUse `v-model` on the text input, select, and checkbox so the UI is fully controlled. In the template, `v-for` over `filteredUsers`, render name, a small badge for the role, and a status pill for active vs inactive. If `filteredUsers.length === 0`, render an `li` with an empty state message.",
          "proseCode": "The full solution is shown in the SDK solution JSON: it wires `ref` state with `v-model`, computes `filteredUsers`, and renders the list with matching styling."
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating the original `USERS` array instead of deriving a filtered list.",
          "Forgetting to normalize search term and name to the same case.",
          "Applying only one filter and ignoring role or `showOnlyActive`.",
          "Trying to update reactive refs without using `.value` inside `<script setup>`."
        ],
        "techniques": [
          "Using `ref` for local component state in Vue 3.",
          "Using `computed` for derived lists.",
          "`v-model` on text, select, and checkbox inputs.",
          "Using `v-for` with `:key` for stable list rendering."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-filterable-user-list.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-filterable-user-list"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-filterable-user-list-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 0,
      "passCritical": 0,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Filterable User List in Vue with Search and Role Filters",
      "description": "Derive filtered user results using computed properties, combine text and role criteria, preserve original data, and show empty-state feedback when no matches exist."
    }
  },
  {
    "id": "vue-accordion-faq",
    "title": "Vue Accordion / FAQ Component",
    "type": "coding",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "vue",
      "components",
      "composition-api",
      "props",
      "state-management"
    ],
    "description": {
      "summary": "Build a simple FAQ (accordion) UI in Vue 3 using reactive state. Clicking a question should toggle its answer. By default, only one item can be open at a time, but the user can enable a mode where multiple items can stay open. Vue focus: manage open state with refs and emit toggle events from item components. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Use Vue 3 with a single <App.vue> root component as the main entry.",
          "Render a FAQ card with 3–4 FAQ items (question + answer).",
          "Clicking a question toggles its answer open/closed.",
          "In the default mode, only one FAQ item can be open at a time.",
          "Add a control (e.g. a checkbox) to switch to 'allow multiple open' mode.",
          "In 'allow multiple open' mode, more than one FAQ item can be open at the same time.",
          "Use a child <FaqItem> component for a single FAQ row."
        ],
        "expectedBehavior": [
          "Initially all FAQ items are closed.",
          "Clicking a closed question opens its answer.",
          "In single-open mode: opening one item closes any other open item.",
          "Switching to multi-open mode keeps currently open items and allows opening more.",
          "Clicking an open question closes it in both modes."
        ],
        "implementationNotes": [
          "Keep the FAQ data (question + answer) in the parent component using a simple array.",
          "Use Vue 3's `<script setup>` syntax and Composition API.",
          "Track open items in the parent via a `ref<number[]>` that stores open indexes.",
          "Create a child `<FaqItem>` component that takes `question`, `answer`, and `isOpen` as props and emits a `toggle` event when clicked.",
          "Use `v-for` to render the list of FAQ items."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Lifting state up to the parent",
          "Child communication via props and emits",
          "Single vs multi selection using an array of open indexes"
        ]
      }
    },
    "starterCodeHint": "Keep FAQ data in the parent and use a `ref<number[]>` to store open item indexes. Implement `isItemOpen(index)`, `onItemToggle(index)`, and `onToggleAllowMultiple()` inside `<script setup>` and pass `isOpen` / `@toggle` to a child `<FaqItem>` component.",
    "solutionBlock": {
      "overview": "The key to this exercise is to have the parent component fully control which FAQ items are open. The parent stores the FAQ data (question + answer) and an array of open indexes in a `ref<number[]>`. Each child `<FaqItem>` is stateless and only receives `isOpen` plus an `@toggle` callback.\n\nIn single-open mode, the `openIndexes` ref behaves like a radio group: it is either empty or contains a single index. In multi-open mode, it behaves like a set of indexes. Toggling between modes requires normalizing the `openIndexes` array when going back to single-open mode.\n\n**Key ideas**\n- Keep all UI state (which items are open, whether multiple are allowed) in the parent.\n- Represent open items as an array of indexes (`ref<number[]>`).\n- Use a child component that simply renders UI and emits `toggle` when clicked.\n- Derive `isItemOpen(index)` from the `openIndexes` array.",
      "approaches": [
        {
          "title": "Parent-controlled openIndexes with a child <FaqItem> component",
          "prose": "In `<App.vue>`, define:\n\n- A simple `faqItems` array of `{ question, answer }` objects.\n- `const allowMultiple = ref(false)` to track mode.\n- `const openIndexes = ref<number[]>([])` to store which items are open.\n\nImplement helpers:\n- `const isItemOpen = (index: number) => openIndexes.value.includes(index);`\n- `const onItemToggle = (index: number) => { ... }` that toggles the index depending on `allowMultiple.value`.\n\nIn multi-open mode, treat `openIndexes.value` as a set: remove the index if present, otherwise add it. In single-open mode, either set it to `[index]` or `[]`. Pass these down to `<FaqItem>` via props and `@toggle` to keep the child simple and reusable.\n\n`<FaqItem>` itself uses `defineProps` for `question`, `answer`, and `isOpen`, and `defineEmits` to emit a `toggle` event when its header button is clicked."
        }
      ],
      "notes": {
        "pitfalls": [
          "Letting each `<FaqItem>` manage its own open state, which makes it hard to enforce the 'only one open' rule.",
          "Using a single `ref<number | null>` for `openIndex` and then trying to hack multi-open behavior into it.",
          "Mutating the `openIndexes.value` array in place instead of assigning a new array (harder to reason about)."
        ],
        "techniques": [
          "Using `ref<number[]>` to represent a collection of selected items in Vue 3.",
          "Using `defineProps` / `defineEmits` in `<script setup>` for clean parent–child communication.",
          "Deriving `isItemOpen` from an index array to support both single and multi selection with the same state shape."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-accordion-faq.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-accordion-faq"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-accordion-faq-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Vue 3 Accordion FAQ with Single or Multi-Open Modes",
      "description": "Implement an FAQ accordion with reactive open state, item toggle handling, and optional multi-open behavior for clean and predictable interactions."
    }
  },
  {
    "id": "vue-pagination-table",
    "title": "Vue Paginated Data Table",
    "type": "coding",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "pagination",
      "arrays"
    ],
    "description": {
      "summary": "Build a simple paginated data table in Vue 3 that shows a static list of users. Display 5 rows per page, with Previous / Next controls and a \"Page X of Y\" indicator. Disable the navigation buttons appropriately on the first and last pages. Vue focus: keep page index in a ref and derive page slices with computed. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render the table UI as the main <App.vue> component.",
          "Use a static list (around 20 users) with id, name, email, and role.",
          "Show 5 rows per page.",
          "Add \"Previous\" and \"Next\" buttons to change the current page.",
          "Display the current page and total pages (for example \"Page 2 of 4\").",
          "Disable \"Previous\" on the first page and \"Next\" on the last page."
        ],
        "expectedBehavior": [
          "Initial render shows the first 5 users (page 1).",
          "Clicking \"Next\" advances by 5 users until the last page.",
          "Clicking \"Previous\" moves back by 5 users until the first page.",
          "On the first page, \"Previous\" is disabled and does nothing when clicked.",
          "On the last page, \"Next\" is disabled and does nothing when clicked.",
          "The label \"Page X of Y\" always matches the current page."
        ],
        "implementationNotes": [
          "Use Vue 3's Composition API with `ref` and `computed` in `<script setup>`.",
          "Store the current page index in a `ref` (0-based).",
          "Keep a constant `PAGE_SIZE = 5` and derive start/end indices from the current page.",
          "Use a `computed` for the current slice of users and for the \"first/last page\" flags."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Derived state from minimal source of truth",
          "Array slicing with `slice(start, end)`",
          "Handling UI edge cases for first/last pages"
        ]
      }
    },
    "starterCodeHint": "Keep all logic inside `<script setup lang=\"ts\">`. Use `const currentPage = ref(0)` for page state, a constant `PAGE_SIZE = 5`, and `computed` properties to derive the current page slice, total pages, and button disabled state.",
    "solutionBlock": {
      "overview": "This exercise is about managing a single piece of state: the current page. The full users array stays static in the component. From that, you derive the paged slice, total page count, and booleans indicating when you are on the first or last page.\n\n**Core ideas**\n- `currentPage` is a `ref(0)` and represents a 0-based index.\n- `PAGE_SIZE` is a constant (5 rows per page).\n- `totalPages` is a `computed` that uses `Math.ceil(USERS.length / PAGE_SIZE)`.\n- A `computed` for `pagedUsers` uses `slice(start, end)` where `start = currentPage.value * PAGE_SIZE`.\n- `isFirstPage` and `isLastPage` are `computed` booleans used to disable navigation buttons and guard the handlers.\n\n**Test cases**\n- Initial render → first 5 users, label shows `Page 1 of N`, Previous disabled.\n- Clicking Next repeatedly walks through the list and disables Next on the last page.\n- Clicking Previous repeatedly walks back and disables Previous on the first page.\n- The page label always matches the current page index.",
      "approaches": [
        {
          "title": "Single component with derived pagination slice",
          "prose": "Keep everything in `App.vue` using `<script setup lang=\"ts\">`. Define the users array and `PAGE_SIZE` as constants. Store `currentPage` in a `ref(0)`. Then create `computed` properties for `totalPages`, `pagedUsers`, `isFirstPage`, and `isLastPage`. The `goPrevious` and `goNext` handlers simply adjust `currentPage.value` within bounds. The template renders the table rows from `pagedUsers` and binds disabled state and click handlers on the Previous / Next buttons."
        }
      ],
      "notes": {
        "pitfalls": [
          "Treating `currentPage` as 1-based while doing `slice` calculations, causing off-by-one bugs.",
          "Letting `currentPage` go below 0 or above `totalPages - 1` because handlers aren’t guarded.",
          "Deriving the slice inline in the template instead of a named `computed`, which makes the code harder to read.",
          "Forgetting to use `.value` when reading/writing `ref`s inside `<script setup>`."
        ],
        "techniques": [
          "Using `ref` and `computed` to derive view state from minimal data.",
          "Using array `slice(start, end)` for pagination.",
          "Co-locating state and logic with the template in a single file component."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-pagination-table.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-pagination-table"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-pagination-table-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 0,
      "passCritical": 0,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Create a Paginated Data Table in Vue 3 with Prev and Next Controls",
      "description": "Build client-side pagination with page index state, computed row slices, and boundary-safe Previous or Next navigation plus page indicators."
    }
  },
  {
    "id": "vue-theme-toggle",
    "title": "Vue Theme Toggle with Persisted Light/Dark Mode",
    "type": "coding",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "vue",
      "composition-api",
      "state-management",
      "local-storage",
      "theming"
    ],
    "description": {
      "summary": "Add a global light/dark theme toggle in the top-right of the page using Vue 3. The selected theme should be stored in localStorage and restored when the page reloads. Vue focus: use a global ref/composable to persist theme in localStorage and apply a root attribute. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render a main page layout with a simple content card and a theme toggle control in the top-right corner.",
          "Support two themes: \"light\" and \"dark\".",
          "Store the current theme in a single source of truth (e.g. a module-level ref / small theme composable).",
          "Persist the selected theme in localStorage under a stable key.",
          "On initial load, read the theme from localStorage and apply it before the user interacts.",
          "Apply the theme at the document level by setting `data-theme` on `<html>`, so that the existing CSS can react to it.",
          "You only need to edit `/src/App.vue` (the template and `<script setup>`). The CSS files are already wired to respond to `data-theme` and should be left as-is."
        ],
        "expectedBehavior": [
          "By default, the app starts in light mode if there is no previous theme stored.",
          "If the user toggles to dark mode, the page background, text, and card colors change.",
          "Reloading the page keeps the user’s last theme selection (light or dark).",
          "The toggle UI (label or icon) always reflects the actual current theme.",
          "Switching themes is instant and does not require a full reload."
        ],
        "implementationNotes": [
          "Use Vue 3’s Composition API with a `ref<'light' | 'dark'>` to hold the current theme.",
          "Read from `window.localStorage` using a stable key (for example `uf-theme`) and validate the stored value.",
          "Apply the theme to `document.documentElement` via `setAttribute('data-theme', theme)` so the CSS can use `:root[data-theme='dark']` / `html[data-theme='dark'] ...` selectors.",
          "Encapsulate the side-effects (localStorage read/write + DOM attribute update) in a couple of helper functions instead of scattering them across the component.",
          "Avoid duplicating theme logic in multiple places; treat the theme ref as the single source of truth and derive `isDark` from it via `computed`."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Simple global-ish state via a module-level ref or mini composable",
          "Side-effects and initialization logic in `<script setup>`",
          "Using localStorage safely in a browser environment",
          "Simple theming by driving `data-theme` on `<html>` and letting existing CSS respond"
        ]
      }
    },
    "starterCodeHint": "Create a `Theme` type (`'light' | 'dark'`) and a `ref<Theme>('light')` that holds the current theme. On startup, read a stored value from `localStorage` (if running in the browser), validate it, and call a helper that sets `document.documentElement.dataset.theme`. Derive an `isDark` computed from the theme and wire the toggle button to a `toggleTheme()` function that flips between `'light'` and `'dark'` and persists the result.",
    "solutionBlock": {
      "overview": "This exercise is about lifting theme state into a small global-ish store in Vue (a module-level `ref` + helpers) and wiring it to both the UI and the DOM. You store the current theme (`'light'` or `'dark'`) in a reactive `ref`, read an initial value from `localStorage` when the module is evaluated, and apply that value to the `<html>` element via a `data-theme` attribute. The root `App.vue` template shows a toggle in the top-right corner and delegates all theme changes to `toggleTheme()`. The provided CSS (`styles.css` + `App.css`) already listens to `data-theme` using `:root[data-theme='dark']` and `html[data-theme='dark'] .app-shell` rules, so you don't need to touch any styles.\n\n**Test cases**\n- First visit with empty localStorage → app starts in light mode and shows the light theme.\n- Click the toggle once → app switches to dark mode, the page background becomes dark, and the toggle shows dark mode.\n- Reload the page after switching to dark mode → app initializes in dark mode.\n- Toggle back to light → theme changes immediately and localStorage is updated.\n- The toggle label/icon always matches the active theme.",
      "approaches": [
        {
          "title": "Module-level theme store with `data-theme` on `<html>`",
          "prose": "Use a tiny theme store built directly in `<script setup>`.\n\n1. Define a `Theme` type alias (`'light' | 'dark'`) and a stable localStorage key.\n2. Create `const theme = ref<Theme>('light')` as the single source of truth.\n3. Add `applyTheme(theme)` that sets `document.documentElement.setAttribute('data-theme', theme)`.\n4. Run an `initTheme()` function at module evaluation time: it reads from localStorage, validates `'light'` / `'dark'`, falls back to `'light'`, assigns to `theme.value`, and calls `applyTheme`.\n5. Implement `setTheme(theme)` to update the ref, write to localStorage, and call `applyTheme`.\n6. Implement `toggleTheme()` to flip between `'light'` and `'dark'` using `setTheme`.\n7. Expose `const isDark = computed(() => theme.value === 'dark')` and an `onToggleClick()` handler that calls `toggleTheme()`.\n\nThe template stays very simple: it just binds the button to `onToggleClick` and shows `🌙 / ☀️` and `Dark / Light` labels based on `isDark`. All the persistence and DOM side-effects live in a few small helpers, keeping the component easy to reason about."
        }
      ],
      "notes": {
        "pitfalls": [
          "Reading from localStorage too late (e.g. only in a `mounted` hook) and causing a visible flash from light to dark.",
          "Forgetting to actually apply the theme to `<html>` and only updating a label in the UI.",
          "Using multiple sources of truth for the theme (for example, having separate `isDark` and `theme` refs that can drift apart).",
          "Not guarding access to `window` / `localStorage` when running in non-browser environments."
        ],
        "techniques": [
          "Using a module-level `ref` as a simple global store in Vue 3.",
          "Using `computed` to derive booleans (`isDark`) from core state.",
          "Encapsulating all side-effects (DOM + localStorage) in small helpers called from state-changing functions.",
          "Letting preconfigured CSS (`:root[data-theme='dark']` and `html[data-theme='dark'] .app-shell`) handle visual changes while the script only controls `data-theme`."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-theme-toggle.v2.json",
      "openFile": "/src/App.vue",
      "storageKey": "v2:ui:vue:vue-theme-toggle"
    },
    "companies": [],
    "solutionAsset": "assets/sb/vue/solution/vue-theme-toggle-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Implement a Vue Theme Toggle with localStorage Persistence",
      "description": "Build a global light dark mode toggle, persist theme preference in localStorage, and restore root-level theme state correctly after reload."
    }
  },
  {
    "id": "vue-multi-step-form",
    "title": "Multi-step Signup Form (3-step Wizard)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "vue",
      "forms",
      "validation",
      "wizard",
      "state-management",
      "composition-api"
    ],
    "description": {
      "summary": "Build a 3-step signup flow in Vue 3 that collects basic info, address info, and shows a summary with a final submit action. Each step should be validated before the user can proceed.",
      "specs": {
        "requirements": [
          "Render a 3-step signup form as a small wizard-style UI.",
          "Step 1: Basic info (name, email).",
          "Step 2: Address info (street, city, country, optional postal code).",
          "Step 3: Summary + Submit (show all collected data and allow submission).",
          "Provide a \"Next\" button to advance to the next step.",
          "\"Next\" must only be enabled when the current step is valid.",
          "Provide an optional \"Back\" button to navigate to the previous step (except on the first step).",
          "On the summary step, show a read-only overview of all data entered so far.",
          "On the last step, show a \"Submit\" button that submits the aggregated data."
        ],
        "expectedBehavior": [
          "Initial render shows Step 1 (Basic info) with empty fields.",
          "Typing in inputs updates the internal form state in real time.",
          "If required fields on the current step are invalid or empty, the \"Next\" button is disabled (or clicking it shows validation errors and does not advance).",
          "When the current step is valid, the \"Next\" button becomes enabled and moves to the next step when clicked.",
          "The \"Back\" button moves to the previous step and preserves already-entered values.",
          "The summary step reflects the latest values from the previous steps.",
          "Clicking \"Submit\" on the summary step validates all data and then performs a final action (e.g. logs the payload to the console)."
        ],
        "implementationNotes": [
          "Use Vue 3's Composition API in `<script setup>`.",
          "Store the entire form data (basic + address) in a single `reactive` object or equivalent structure.",
          "Use one `ref` for the current step index (e.g. `currentStep = ref(0)`).",
          "Use `computed` properties to derive booleans like `isFirstStep`, `isLastStep`, `canGoNext`, and `canSubmit` based on current step and validation rules.",
          "Implement simple per-step validation functions or computed objects (e.g. `basicErrors`, `addressErrors`) and drive both error messages and disabled states from them.",
          "Use `v-model` bindings for input elements so the form state stays in sync with user input.",
          "Use conditional rendering (`v-if` / `v-else-if` / `v-else`) to show the relevant step content based on `currentStep`."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `reactive`, `computed`)",
          "Multi-step form / wizard patterns",
          "Form validation + disabled states",
          "Centralized form state management",
          "Conditional rendering and navigation between steps"
        ]
      }
    },
    "starterCodeHint": "Use `<script setup>` with a `ref` for `currentStep` and a `reactive` object for the combined form state (basic + address). Derive `isFirstStep`, `isLastStep`, and `canGoNext` as `computed` properties based on simple validation rules. Drive `Next` button disabled state and error messages from these computed values.",
    "solutionBlock": {
      "overview": "Implement a 3-step signup wizard using Vue 3's Composition API. Keep all form state in a single `reactive` object with nested `basic` and `address` sections, and track the current step with a `ref`. Use `computed` properties to derive validation flags and control when the user can move forward or submit the form.\n\n**Key ideas**\n- Centralize all form fields inside one `reactive` object so you can easily show a summary view.\n- Track the current step with `currentStep = ref(0)` and use conditional rendering in the template to show the correct step content.\n- Implement per-step validation (e.g. `basicErrors`, `addressErrors`) as `computed` objects that inspect the reactive form fields.\n- Derive `canGoNext` and `canSubmit` from these validation results so buttons stay disabled until the current step is valid.\n- Preserve form values when navigating between steps, and have the summary step render directly from the same reactive data.",
      "approaches": [
        {
          "title": "Single `<App.vue>` wizard with reactive form state and computed validation",
          "prose": "Keep everything inside `App.vue` using `<script setup>`. Define a `reactive` `form` object to hold `basic` (name, email) and `address` (street, city, country, postalCode) data. Use a `ref` for `currentStep` and drive the view with `v-if`/`v-else-if` blocks for each step. For validation, create `computed` objects like `basicErrors` and `addressErrors` that return booleans based on whether fields are empty or invalid. Then derive `isBasicValid`, `isAddressValid`, `canGoNext`, and `canSubmit` as additional `computed` values. The `next()` handler should check `canGoNext` before incrementing `currentStep`, while `prev()` decrements it when possible. The summary step simply displays the same reactive `form` data, and the `submit()` handler validates everything one last time before logging or sending the payload."
        }
      ],
      "notes": {
        "pitfalls": [
          "Scattering form state across multiple refs instead of keeping it in a single structured `reactive` object, which makes the summary and submit step harder to implement.",
          "Implementing validation only in the click handlers and not deriving it from `computed` properties, which can lead to duplicated logic and inconsistent UI states.",
          "Allowing navigation to the next step even when required fields are empty, or forgetting to disable the \"Next\" button until the step is valid.",
          "Resetting or recreating the form object when changing steps, which causes entered values to be lost."
        ],
        "techniques": [
          "Using `reactive` for grouped form data (with nested objects) so all steps share the same source of truth.",
          "Using `computed` properties to derive validation flags and navigation booleans (`canGoNext`, `canSubmit`, `isFirstStep`, `isLastStep`).",
          "Driving button disabled states and inline error messages entirely from validation `computed`s.",
          "Using `v-model` for input fields so changes automatically update the underlying reactive form object."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-multi-step-form.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-multi-step-form"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-multi-step-form-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Multi-Step Signup Form in Vue 3 with Step Validation",
      "description": "Create a 3-step wizard that validates each section before moving forward and displays a final summary for confirmation before submit."
    }
  },
  {
    "id": "vue-shopping-cart",
    "title": "Vue Shopping Cart Mini",
    "type": "coding",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 2,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "arrays",
      "derived-state",
      "immutability",
      "ecommerce"
    ],
    "description": {
      "summary": "Build a small shopping cart UI in Vue 3. Show a list of products, let the user add them to the cart, adjust quantities, remove items, and display derived totals for item count and price. Vue focus: use reactive arrays and computed totals. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render a list of products with name, price, and an \"Add to cart\" button for each.",
          "Maintain a `cartItems` collection where each item has `id`, `name`, `price`, and `quantity`.",
          "In the cart, show each item's name, unit price, quantity, and line total (`price * quantity`).",
          "Provide controls to increase and decrease quantity for each cart item.",
          "Allow removing an item from the cart entirely.",
          "Display derived values: total item count and total cart price.",
          "Visually stack the cart card under the products card (single-column layout)."
        ],
        "expectedBehavior": [
          "Clicking \"Add to cart\" for a product that is not yet in the cart adds it with quantity `1`.",
          "Clicking \"Add to cart\" again for the same product increases its quantity by `1`.",
          "Clicking the \"+\" button in the cart increases that item's quantity by `1`.",
          "Clicking the \"−\" button decreases quantity by `1`. When quantity would drop below `1`, the item is removed from the cart.",
          "Clicking \"Remove\" immediately removes that item from the cart.",
          "Total item count and total price update correctly whenever the cart changes."
        ],
        "implementationNotes": [
          "Use Vue 3's Composition API with `ref` to hold `cartItems` as an array.",
          "Treat `cartItems` as immutable for updates: create new arrays with `map`, `filter`, and spreads instead of mutating in place.",
          "Derive `totalQty` and `totalPrice` from `cartItems` using `computed` + `Array.prototype.reduce`.",
          "Keep everything in a single `<App.vue>` component for this exercise; no Vuex or global store is required.",
          "Match the given UI: products card on top, cart card below, same styling as Angular/React versions."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Array-based state and immutable-style updates",
          "Derived state (total quantity, total price)",
          "List rendering with `v-for` and `:key`",
          "Click handlers for add / increase / decrease / remove"
        ]
      }
    },
    "starterCodeHint": "Store products in a constant array and `cartItems` in a `ref<CartItem[]>([])`. Use `computed` for `totalQty` and `totalPrice`, and update `cartItems.value` immutably with `map`, `filter`, and `[...prev, newItem]` when handling cart actions.",
    "solutionBlock": {
      "overview": "This exercise focuses on nested, array-based cart state and derived values in Vue 3. Keep `cartItems` in a single `ref` and update it immutably when adding, increasing, decreasing, or removing items. `totalQty` and `totalPrice` are derived via `computed` + `reduce`, so they always stay in sync with the cart.\n\nThe UI is a single column: a \"Products\" card on top and a \"Cart\" card below, with identical layout across Angular, React, and Vue.\n\n**Key ideas**\n- Use `ref` for the cart array and `computed` for totals.\n- Update cart items immutably with `map`/`filter`/spreads.\n- Derive totals instead of storing them separately.\n- Keep all logic inside a single `<App.vue>` using `<script setup>`.",
      "approaches": [
        {
          "title": "Single component with immutable cart array (Composition API)",
          "prose": "Define `PRODUCTS` as a constant array and keep `const cartItems = ref<CartItem[]>([])`. Use `const totalQty = computed(() => ...)` and `const totalPrice = computed(() => ...)` to derive totals from `cartItems.value`. For `addToCart`, `increaseQty`, `decreaseQty`, and `removeItem`, always create a new array rather than mutating the existing one. This keeps updates predictable and mirrors immutable patterns used in React while still playing nicely with Vue's reactivity."
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating `cartItems.value` in place (e.g. pushing or incrementing `item.quantity` directly) instead of replacing it with a new array.",
          "Computing `totalQty` and `totalPrice` in methods instead of `computed` properties, leading to duplicated logic.",
          "Using the loop index as `:key` instead of a stable `id`, which can cause odd re-render behavior.",
          "Letting items stay in the cart with `quantity` 0 instead of removing them."
        ],
        "techniques": [
          "Composition API with `<script setup>`.",
          "Immutable-style array updates with `map` and `filter` in Vue.",
          "Derived state with `computed` and `reduce`.",
          "Consistent UI parity across Angular, React, and Vue implementations."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-shopping-cart.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-shopping-cart"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-shopping-cart-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Vue 3 Shopping Cart with Quantity Controls and Totals",
      "description": "Implement add remove and quantity updates for cart items, then derive total item count and total price with reactive computed values."
    }
  },
  {
    "id": "vue-debounced-search",
    "title": "Vue Debounced Search with Fake API",
    "type": "coding",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 2,
    "tags": [
      "vue",
      "composition-api",
      "watch",
      "async",
      "debounce",
      "api-calls"
    ],
    "description": {
      "summary": "Implement a Vue 3 debounced search input that calls a fake API. Use a watcher with a timeout, cancel stale calls, and manage loading/error/empty states. This mirrors real-world search UX. Concepts: vue, composition-api, watch. Vue focus: debounce with watch + timeout cleanup and reactive loading state. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render a search input as the main UI.",
          "Hold the current query, loading flag, error message, and results list using Vue's Composition API.",
          "Trigger the search 500ms after the user stops typing (debounced).",
          "Call a provided fake API function that returns a filtered list of users.",
          "Show a loading message while the debounced request is in-flight.",
          "Show a friendly error message when the fake API rejects.",
          "Show result rows with user name and email on success.",
          "Show an empty state when there are no results for a non-empty query."
        ],
        "expectedBehavior": [
          "Typing in the input updates the query immediately.",
          "No API calls happen while the user is still typing quickly.",
          "500ms after the user stops typing, a search request is fired.",
          "While the debounced request is running, a loading state is visible.",
          "If the query is cleared, results are cleared and no request is fired.",
          "If the query is \"error\", the fake API rejects and an error message is displayed.",
          "On success, the list shows matching users by name or email.",
          "When there are no matches, an explicit 'no results' message is shown."
        ],
        "implementationNotes": [
          "Use Vue 3's Composition API (`ref`) to store `query`, `results`, `isLoading`, and `error`.",
          "Use `watch(query, ...)` with `setTimeout` and the `onInvalidate` cleanup callback to implement debouncing and cancel stale requests.",
          "Guard the empty-query case by clearing results and skipping the API call.",
          "Handle both success and error paths to keep loading and error state in sync."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `watch`)",
          "Effect-style logic with `watch` and cleanup",
          "Debounced async calls",
          "Error and loading state management"
        ]
      }
    },
    "starterCodeHint": "Use `ref('')` for `query`, `ref([])` for `results`, and a `watch(query, ...)` that starts a 500ms `setTimeout` and clears it in `onInvalidate`. Inside the timeout, call `fakeApiSearch(trimmedQuery)` and update loading, error, and results accordingly.",
    "solutionBlock": {
      "overview": "Keep all logic inside `<script setup>` in `App.vue`. Use `ref` for `query`, `results`, `isLoading`, and `error`. Implement a `watch(query, ...)` that debounces the search by 500ms using `setTimeout`. In the watcher:\n\n1. If the trimmed query is empty, immediately clear results and reset flags.\n2. Otherwise, set `isLoading` to `true`, clear `error`, and schedule a 500ms timeout.\n3. In the timeout callback, call `fakeApiSearch(trimmed)` and update `results` and `isLoading` on success or set `error` on failure.\n\nUse `onInvalidate` in the watcher to clear the timeout so older changes cannot trigger stale API calls.\n\n**Test cases**\n- Typing quickly does not fire a request until 500ms after typing stops.\n- Clearing the input clears results and stops loading.\n- Query `\"ali\"` returns users whose name or email contains that substring.\n- Query `\"error\"` triggers the fake API rejection and shows the error message.\n- With no matches, a 'no results' message is shown. Key concepts: vue, composition-api, watch.",
      "approaches": [
        {
          "title": "Single component with `watch` and debounced API call",
          "prose": "Use Composition API state (`ref`) inside `<script setup>`. Implement a `watch(query, ...)` that debounces the search.\n\n1. Declare `query`, `results`, `isLoading`, and `error` as refs.\n2. Inside `watch(query, (value, _old, onInvalidate) => { ... })`:\n   - Clear any previous timeout.\n   - If `value.trim()` is empty: reset results, `isLoading`, and `error`, then return.\n   - Otherwise, set `isLoading` and clear `error`, then start a 500ms timeout.\n   - In the timeout, call `fakeApiSearch(trimmed)` and update `results` / `error` / `isLoading`.\n3. Use `onInvalidate` to clear the timeout so that intermediate keystrokes don't leak timeouts and stale responses.\n\nThis mirrors how you might use `useEffect` + cleanup in React, but using Vue's `watch` API.",
          "codeJs": "<template>\n  <main class=\"main\">\n    <section class=\"card\">\n      <header class=\"header\">\n        <h1 class=\"title\">Debounced Search</h1>\n        <p class=\"subtitle\">\n          Type to search a fake user directory. Search runs 500ms after you stop typing.\n        </p>\n      </header>\n\n      <div class=\"field\">\n        <label class=\"label\" for=\"search-input\">Search</label>\n        <input\n          id=\"search-input\"\n          class=\"input\"\n          type=\"text\"\n          :value=\"query\"\n          @input=\"onInput\"\n          placeholder=\"Start typing a name or email...\"\n          autocomplete=\"off\"\n        />\n      </div>\n\n      <div class=\"status-row\">\n        <span v-if=\"isLoading\" class=\"status status--loading\">Searching…</span>\n        <span\n          v-else-if=\"!error && query\"\n          class=\"status\"\n        >\n          Showing {{ results.length }} result(s) for \"{{ query }}\"\n        </span>\n        <span\n          v-else-if=\"!error && !query\"\n          class=\"status status--muted\"\n        >\n          Start typing to search.\n        </span>\n        <span v-if=\"error\" class=\"status status--error\">{{ error }}</span>\n      </div>\n\n      <ul class=\"results\" v-if=\"results.length\">\n        <li class=\"result-row\" v-for=\"r in results\" :key=\"r.id\">\n          <div class=\"result-name\">{{ r.name }}</div>\n          <div class=\"result-email\">{{ r.email }}</div>\n        </li>\n      </ul>\n\n      <p\n        class=\"empty\"\n        v-if=\"!results.length && !isLoading && query && !error\"\n      >\n        No results found for \"{{ query }}\".\n      </p>\n    </section>\n  </main>\n</template>\n\n<script setup>\nimport { ref, watch } from 'vue';\n\nconst FAKE_DATA = [\n  { id: 1, name: 'Alice Johnson', email: 'alice@example.com' },\n  { id: 2, name: 'Bob Smith', email: 'bob@example.com' },\n  { id: 3, name: 'Charlie Kim', email: 'charlie@example.com' },\n  { id: 4, name: 'Diana Lopez', email: 'diana@example.com' },\n  { id: 5, name: 'Ethan Brown', email: 'ethan@example.com' },\n  { id: 6, name: 'Fiona Patel', email: 'fiona@example.com' }\n];\n\nfunction fakeApiSearch(term) {\n  const trimmed = term.trim().toLowerCase();\n  const delayMs = 600;\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (!trimmed) {\n        resolve([]);\n        return;\n      }\n\n      if (trimmed === 'error') {\n        reject(new Error('Fake API error'));\n        return;\n      }\n\n      const filtered = FAKE_DATA.filter((item) => {\n        const name = item.name.toLowerCase();\n        const email = item.email.toLowerCase();\n        return name.includes(trimmed) || email.includes(trimmed);\n      });\n\n      resolve(filtered);\n    }, delayMs);\n  });\n}\n\nconst query = ref('');\nconst results = ref([]);\nconst isLoading = ref(false);\nconst error = ref(null);\n\nlet timeoutId;\n\nwatch(\n  query,\n  (value, _oldValue, onInvalidate) => {\n    const trimmed = value.trim();\n\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n\n    if (!trimmed) {\n      results.value = [];\n      isLoading.value = false;\n      error.value = null;\n      return;\n    }\n\n    isLoading.value = true;\n    error.value = null;\n\n    timeoutId = setTimeout(() => {\n      fakeApiSearch(trimmed)\n        .then((data) => {\n          results.value = data;\n          isLoading.value = false;\n        })\n        .catch((err) => {\n          results.value = [];\n          isLoading.value = false;\n          error.value = err instanceof Error ? err.message : 'Something went wrong.';\n        });\n    }, 500);\n\n    onInvalidate(() => {\n      if (timeoutId != null) {\n        clearTimeout(timeoutId);\n        timeoutId = undefined;\n      }\n    });\n  }\n);\n\nconst onInput = (event) => {\n  query.value = event.target.value;\n};\n</script>\n\n<style scoped>\n/* same UI styles as React / Angular debounced search */\n</style>\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to clear the timeout in `onInvalidate`, causing multiple stale requests.",
          "Calling the API even when the query is empty, which creates confusing loading states.",
          "Not resetting `error` when a new search starts, leaving old error messages visible.",
          "Letting older responses overwrite newer ones if you don't cancel the timeout or ignore stale results."
        ],
        "techniques": [
          "Using `watch` for effect-style logic in Vue 3.",
          "Combining `setTimeout` with `onInvalidate` for debouncing.",
          "Managing loading, error, and results state together for a consistent UX.",
          "Deriving UI states (status text, empty message) from a small, well-structured state shape."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-debounced-search.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v2:ui:vue:vue-debounced-search"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-debounced-search-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Implement Debounced Search in Vue 3 with Watch and Cleanup",
      "description": "Use watch plus timeout cleanup to debounce API calls, cancel stale results, and manage loading error and empty states for better search UX."
    }
  },
  {
    "id": "vue-star-rating",
    "title": "Vue Star Rating Widget",
    "type": "coding",
    "technology": "vue",
    "difficulty": "easy",
    "importance": 3,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "event-handlers",
      "basics"
    ],
    "description": {
      "summary": "Create a reusable star rating widget in Vue 3 with a controlled rating value. Render stars from 1..max, update on click, and reflect the current rating visually. Keep the parent as the source of truth. Concepts: vue, components, reactivity. Vue focus: use props/emits for a controlled rating component. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render the star rating UI as the main component.",
          "Display a row of stars (e.g. 5 by default).",
          "Allow the user to select a rating by clicking a star.",
          "Visually fill all stars up to the selected rating.",
          "Display the current rating value below the stars (e.g. \"Current rating: 3 / 5\")."
        ],
        "expectedBehavior": [
          "Stars render from 1 up to the configured max (default 5).",
          "Clicking the 3rd star sets the rating to 3 and fills 3 stars.",
          "Clicking the 5th star sets the rating to 5 and fills 5 stars.",
          "Initial rating starts at 0 (no filled stars)."
        ],
        "implementationNotes": [
          "Use Vue 3's `<script setup>` syntax in `App.vue`.",
          "Store the current rating in a `ref` (e.g. `const rating = ref(0)`).",
          "Optionally store `max` in a `ref` and derive a stars list with `computed` or an inline array.",
          "Use class binding (e.g. `:class=\"{ filled: star <= rating }\"`) to style selected stars.",
          "Render a small text block under the stars to show the numeric rating."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Basic component structure with `<script setup>`",
          "Click event handlers",
          "Deriving UI from reactive state"
        ]
      }
    },
    "starterCodeHint": "Inside `<script setup>`, use a `ref(0)` for the current rating and a `computed` list of stars. Implement a `handleRate` function that updates the rating when a star is clicked.",
    "solutionBlock": {
      "overview": "Use Vue 3's Composition API with a `ref(0)` for `rating` and a `ref(5)` for `max`. Derive a list of star indices (1..max) via `computed`, render them with `v-for`, and apply a `filled` class when `star <= rating`. A `handleRate` function sets `rating.value` to the clicked star index.\n\n**Key ideas**\n- Keep all logic inside `<script setup>` in `App.vue`.\n- Represent the rating as a single `ref`.\n- Generate stars from data instead of hardcoding them.\n- Use class binding to toggle filled vs empty stars. Key concepts: vue, components, reactivity.",
      "approaches": [
        {
          "title": "Single component with reactive rating and computed stars",
          "prose": "Keep the star-rating logic in a single `App.vue` component. Use `const rating = ref(0)` to hold the value, and `const max = ref(5)` for the number of stars. A `computed` property `stars` returns an array `[1, 2, ..., max]` used in a `v-for` loop. Each star is a button that calls `handleRate(star)` on click. `handleRate` updates `rating.value` to the clicked index. The template binds a `filled` class when `star <= rating` and shows the numeric rating in a `<p>` below the stars."
        }
      ],
      "notes": {
        "pitfalls": [
          "Hardcoding stars in the template instead of generating them from data, which makes `max` harder to change.",
          "Forgetting to use `.value` when updating refs in `<script setup>`.",
          "Not visually differentiating selected vs unselected stars, making the rating unclear."
        ],
        "techniques": [
          "Using `ref` for reactive primitives.",
          "Using `computed` to derive arrays for `v-for`.",
          "Using class binding for visual state (`filled` vs default)."
        ]
      }
    },
    "companies": [
      "amazon"
    ],
    "sdk": {
      "asset": "assets/sb/vue/question/vue-star-rating.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-star-rating"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-star-rating-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Reusable Vue 3 Star Rating Component with Controlled Value",
      "description": "Create a star rating widget using props and emits, render 1..max stars, handle click selection, and keep parent state as the single source of truth."
    }
  },
  {
    "id": "vue-dynamic-table",
    "title": "Vue Dynamic Table (Rows × Columns)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "easy",
    "importance": 3,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "lists",
      "dynamic-ui",
      "basics"
    ],
    "description": {
      "summary": "Generate a dynamic table in Vue 3 from row/column inputs. Normalize inputs (clamp to 0/1), rebuild the grid on action, and render stable row/column labels so the UI stays predictable. Concepts: vue, components, reactivity. Vue focus: generate rows/cols with v-for and computed helpers. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render the dynamic table UI as the main component.",
          "Provide two numeric inputs: one for the number of rows and one for the number of columns.",
          "Provide a button (e.g. \"Generate table\") that rebuilds the table when clicked.",
          "Render an HTML table whose number of rows and columns matches the current input values.",
          "Each cell should display something simple and visible, such as its row/column indices (e.g. R1C1)."
        ],
        "expectedBehavior": [
          "Initially, it is fine to show an empty state or no table. After clicking the generate button, a table appears.",
          "Changing the row or column values and clicking the button updates the table dimensions.",
          "If the user enters non-positive values (0 or negative), the implementation may render no rows/columns or clamp the value to a minimum of 1, as long as the behavior is consistent."
        ],
        "implementationNotes": [
          "Use Vue 3's Composition API inside `<script setup>`.",
          "Use `ref` to store the numeric inputs and the `rows`/`cols` arrays that drive rendering.",
          "Implement a helper (e.g. `normalizeCount`) to clamp user input to a safe range (such as 0–20).",
          "Use `Array.from` or a similar approach to build arrays for `v-for` loops.",
          "Use a `computed` value for simple derived state like `hasGrid` (whether there is anything to render)."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Two-way binding with `v-model.number`",
          "Dynamic UI generation with `v-for`",
          "Basic input normalization and guarded rendering"
        ]
      }
    },
    "starterCodeHint": "Implement the logic inside `<script setup>`. Use `ref(3)` and `ref(4)` for the initial row/column inputs, keep `rows` and `cols` in refs that you rebuild in an `updateTable()` function, and drive the table with nested `v-for` loops over those arrays.",
    "solutionBlock": {
      "overview": "Use Vue 3's Composition API to keep four main reactive values: `rowInput`, `colInput`, `rows`, and `cols`. The numeric inputs use `v-model.number` to update `rowInput` and `colInput`. When the user clicks the \"Generate table\" button, `updateTable()` normalizes those values (e.g. clamp to 0–20) and rebuilds `rows` and `cols` with `Array.from`. The template uses nested `v-for` loops to render `<tr>` and `<td>` elements, and each cell displays its 1-based row and column index.\n\n**Key ideas**\n- Separate raw input state from the arrays you actually render.\n- Normalize user input before building the grid.\n- Use nested `v-for` loops for grid-like layouts. Key concepts: vue, components, reactivity.",
      "approaches": [
        {
          "title": "Single component with reactive inputs and `v-for`-driven grid",
          "prose": "Keep everything inside `<script setup>` in `App.vue`. Use `const rowInput = ref(3)` and `const colInput = ref(4)` for the initial inputs, and `rows` / `cols` as `ref<number[]>([])` to drive the table. Implement `normalizeCount` to clamp and sanitize user-provided numbers, then in `updateTable()` call it for both dimensions and build `rows.value` and `cols.value` with `Array.from({ length: n }, (_, i) => i)`. In the template, bind the inputs with `v-model.number` and use nested `v-for` loops over `rows` and `cols` to render `<tr>` and `<td>`, printing labels like `R{{ r + 1 }}C{{ c + 1 }}` inside each cell.",
          "notes": {}
        }
      ],
      "notes": {
        "pitfalls": [
          "Trying to iterate directly over a number in `v-for` instead of over an array.",
          "Not normalizing the input and letting negative, NaN, or very large values break the UI.",
          "Forgetting to use `.value` when reading and writing refs inside `<script setup>`."
        ],
        "techniques": [
          "Using `ref` for local state and rebuilding arrays reactively.",
          "Using `computed` to derive `hasGrid` so the empty state is handled cleanly.",
          "Using `Array.from({ length: n })` as a simple way to create ranges for `v-for`."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-dynamic-table.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-dynamic-table"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-dynamic-table-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Generate a Dynamic Row and Column Table in Vue 3",
      "description": "Build a table from row and column inputs, normalize values safely, regenerate grid data on demand, and render stable labels with v-for loops."
    }
  },
  {
    "id": "vue-nested-checkboxes",
    "title": "Vue Nested Checkbox Tree (Parent–Child Sync)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "event-handlers",
      "basics",
      "dom"
    ],
    "description": {
      "summary": "Build a small Vue 3 UI that renders a parent checkbox and multiple child checkboxes. The parent controls all children, and the children keep the parent in sync (checked, unchecked, or indeterminate). Vue focus: compute parent checked/indeterminate state via computed properties. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render a parent checkbox with a label, plus several child checkboxes listed under it.",
          "Checking the parent selects all children.",
          "Unchecking the parent clears all children.",
          "When children are toggled individually:",
          "- If all are checked → parent is checked.",
          "- If none are checked → parent is unchecked.",
          "- If some are checked → parent is indeterminate.",
          "Keep everything in a single <App.vue> component."
        ],
        "expectedBehavior": [
          "Each child checkbox toggles independently.",
          "The parent reflects the aggregate state of the children.",
          "The parent’s visual state shows indeterminate when selection is mixed.",
          "No external component libraries are required."
        ],
        "implementationNotes": [
          "Use Vue 3's Composition API in <script setup> with `ref` to store the children list.",
          "Derive the parent’s checked/indeterminate state from the children and apply `indeterminate` via a template ref.",
          "Use standard `@change` handlers to wire parent and child events."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `watch`)",
          "Derived state from a list of items",
          "Click/event handlers",
          "Working with DOM-only properties via `ref` (indeterminate)"
        ]
      }
    },
    "starterCodeHint": "Keep the children as an array of `{ id, label, checked }` in a `ref`. Use a template `ref` on the parent `<input>` so you can assign `el.indeterminate = true` when some but not all children are checked.",
    "solutionBlock": {
      "overview": "The core idea is to store the children as a reactive array and derive the parent state from it. The parent checkbox never has its own independent state; instead, a watcher looks at how many children are checked and sets `checked` and `indeterminate` on the DOM node via a template ref. Toggling the parent sets all children to the same value; toggling a child flips just that one and lets the watcher recompute the parent.",
      "approaches": [
        {
          "title": "Children in a `ref` + parent derived in a watcher",
          "prose": "Inside `<script setup>`, store the children in `const children = ref([...])`. Attach `ref=\"parentRef\"` to the parent checkbox and use `watch(children, ..., { deep: true, immediate: true })` to update `parentRef.value.checked` and `parentRef.value.indeterminate` whenever the list changes. The parent handler maps all children to the new checked value; the child handler toggles one element by id and reuses the same watcher logic."
        }
      ],
      "notes": {
        "pitfalls": [
          "Trying to bind `indeterminate` as a normal prop (e.g. `:indeterminate=\"...\"`) instead of assigning it on the DOM element via `ref`.",
          "Giving the parent its own `ref`-based boolean state instead of deriving from children, which risks desync.",
          "Forgetting to use `{ deep: true }` in the watcher, so changes inside the array objects are not observed."
        ],
        "techniques": [
          "Using `ref` for local reactive arrays.",
          "Using `watch` with `{ deep: true, immediate: true }` to derive and keep DOM state in sync.",
          "Keeping all state and handlers colocated in `<App.vue>` for a focused exercise."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-nested-checkboxes.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-nested-checkboxes"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-nested-checkboxes-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Create Nested Checkboxes in Vue with Indeterminate Parent State",
      "description": "Sync parent and child checkbox behavior so parent toggles all children while computed logic updates checked and indeterminate states correctly."
    }
  },
  {
    "id": "vue-autocomplete-search",
    "title": "Autocomplete Search (debounce + keyboard + outside click)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "medium",
    "importance": 1,
    "tags": [
      "vue",
      "composition-api",
      "reactivity",
      "events",
      "keyboard",
      "debounce",
      "accessibility",
      "components"
    ],
    "description": {
      "summary": "Build a Vue 3 autocomplete search input. It should debounce queries, show a dropdown with results, support keyboard navigation (↑/↓/Enter/Esc), and close on outside click. Keep the UI styles exactly as provided.",
      "specs": {
        "requirements": [
          "Render the autocomplete UI as the main component.",
          "Typing filters a fixed city list and shows results in a dropdown.",
          "Debounce input by ~300ms before searching.",
          "If query is empty (after trim): close dropdown and clear results.",
          "If query is non-empty: open dropdown and show results.",
          "Show up to 8 results.",
          "Keyboard support: ArrowUp/ArrowDown to move active option, Enter to select, Esc to close.",
          "Close dropdown on outside click.",
          "Highlight the matched substring using <mark> (escape HTML first).",
          "Show a 'Loading…' row while async search is pending (avoid flashing 'No results' during loading)."
        ],
        "expectedBehavior": [
          "Focus with non-empty query opens the dropdown.",
          "Typing updates results after debounce + simulated latency.",
          "Arrow keys cycle through visible options (wrap around).",
          "Enter selects the active option, sets input value, closes dropdown.",
          "Esc closes dropdown and clears active selection.",
          "Clicking an option selects it (mousedown to avoid blur issues).",
          "Clicking outside closes dropdown and clears active selection.",
          "When loading: dropdown can be open but shows 'Loading…' instead of 'No results'.",
          "When not loading and results are empty: show 'No results'."
        ],
        "implementationNotes": [
          "Use Vue 3 Composition API in <script setup>.",
          "Use refs for query/isOpen/activeIndex/results/isLoading.",
          "Use a debounced watcher on query to trigger async search.",
          "Use stale-result protection (sequence id or cancellation flag) so older searches don’t override newer ones.",
          "Use document mousedown listener for outside click."
        ],
        "techFocus": [
          "Vue 3 Composition API (ref, computed, watch, onMounted/onBeforeUnmount)",
          "Debounced async effects",
          "Keyboard navigation state",
          "Outside click handling",
          "Safe HTML escaping + highlight rendering"
        ]
      }
    },
    "starterCodeHint": "Implement the TODOs in <script setup>. Use a debounced watcher on `query` to call `search(q)` and update `results`. Track `isOpen`, `activeIndex`, `isLoading`. Close on outside click. Use `v-html` with escaped + highlighted markup.",
    "solutionBlock": {
      "overview": "Use `watch(query)` with a 300ms timeout to debounce. On non-empty query, open dropdown and set loading true, then call an async `search(q)` that simulates latency and returns up to 8 matches. Protect against stale updates using a sequence counter. Add keyboard handling to move `activeIndex` and select results. Use `document.addEventListener('mousedown', ...)` to close on outside click.\n\n**Key ideas**\n- Debounce + async search\n- Loading state to avoid 'No results' flicker\n- Active index wrap-around navigation\n- Escape HTML before inserting <mark>\n- Outside click close",
      "approaches": [
        {
          "title": "Single component (Composition API) with debounced watcher",
          "prose": "Keep everything in `App.vue`. Store state in refs: `query`, `isOpen`, `activeIndex`, `results`, `isLoading`. Debounce query changes with a timeout. When searching, bump a `seq` counter and only apply results if the sequence matches. Implement `onKeyDown` to wrap selection and select on Enter. Use a document mousedown handler to detect clicks outside the root element."
        }
      ],
      "notes": {
        "pitfalls": [
          "Showing 'No results' while a request is still in flight (fix with `isLoading`).",
          "Not trimming query, causing dropdown to open for whitespace.",
          "Letting stale async responses overwrite newer results (fix with seq/cancel).",
          "Using `click` instead of `mousedown` on options (blur can close dropdown before select).",
          "Injecting raw HTML into v-html without escaping (escape first)."
        ],
        "techniques": [
          "Debouncing with `setTimeout` inside `watch` and clearing on cleanup.",
          "Stale-result protection with a sequence ref.",
          "Wrap-around navigation using modular arithmetic."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-autocomplete-search.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v2:ui:vue:vue-autocomplete-search"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-autocomplete-search-solution.v1.json",
    "companies": [
      "apple"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 0,
      "passCritical": 0,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Vue 3 Autocomplete Search with Debounce and Keyboard Navigation",
      "description": "Implement debounced suggestions, up down Enter Escape interactions, and outside-click closing for accessible and responsive autocomplete UX."
    }
  },
  {
    "id": "vue-transfer-list",
    "title": "Transfer List (Move Selected Items Between Two Lists)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "medium",
    "importance": 5,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "derived-state",
      "event-handlers",
      "lists",
      "inputs"
    ],
    "description": {
      "summary": "This UI should keep item order stable, clear selection after transfer, and avoid no-op actions when nothing is selected. Concepts: vue, components, reactivity, derived state, event handlers, lists, inputs. Vue focus: manage selection with reactive arrays and computed helpers. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render two lists: Top and Bottom.",
          "Each row must have a checkbox to select the item.",
          "Provide two buttons between the lists: ↓ moves selected Top items to Bottom, ↑ moves selected Bottom items to Top.",
          "When moving items, append them to the end of the destination list.",
          "After moving, clear the selection of the moved-from list."
        ],
        "expectedBehavior": [
          "Top and Bottom lists render initial items.",
          "Selecting checkboxes enables the corresponding move button (↓ for Top, ↑ for Bottom).",
          "Clicking ↓ moves selected items from Top to Bottom and clears Top selection.",
          "Clicking ↑ moves selected items from Bottom to Top and clears Bottom selection.",
          "Selections are per-list (selecting in Top should not affect Bottom)."
        ],
        "implementationNotes": [
          "Use Vue 3 Composition API with `ref` for list state and selection state.",
          "Use `computed` properties for `canMoveDown` and `canMoveUp` (button enablement).",
          "When toggling selection, create a new `Set` to ensure reactivity updates properly.",
          "Keep everything in a single `<App.vue>` component for this exercise."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Immutable-ish updates with Set cloning",
          "Checkbox bindings and event handlers",
          "Moving items between lists"
        ]
      }
    },
    "starterCodeHint": "Store items in `ref<Item[]>` and selections in `ref<Set<string>>`. Use computed values to enable/disable arrows. When toggling selection, always replace with a new Set.",
    "solutionBlock": {
      "overview": "Transfer lists are common in admin tools. The key is to move only the selected items, preserve ordering, and reset selection so the UI doesn’t show stale checked states. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "Single component with per-list selection sets",
          "prose": "Track selections as Sets for quick lookup. When transferring, split the source list into moved and remaining, append moved to the destination, and then clear the selection set. Disable the transfer button when the selection set is empty to prevent no-op clicks. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating the same Set instance (Vue may not update UI as expected).",
          "Forgetting to clear selection after moving items.",
          "Removing items incorrectly (e.g., using wrong ids or mixing selections across lists)."
        ],
        "techniques": [
          "Using `computed` for enablement flags.",
          "Cloning Sets and arrays for predictable UI updates.",
          "Keeping state and handlers colocated in a single component."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-transfer-list.v2.json",
      "openFile": "/src/App.vue",
      "storageKey": "v2:ui:vue:vue-transfer-list"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-transfer-list-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Implement a Vue Transfer List with Multi-Select and Move Actions",
      "description": "Build dual lists with selection state, move selected items between panels, preserve item order, and clear selections after transfers."
    }
  },
  {
    "id": "vue-tictactoe",
    "title": "Tic-Tac-Toe (Reactivity + Winner Detection)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "easy",
    "importance": 5,
    "tags": [
      "vue",
      "composition-api",
      "reactivity",
      "event-handlers",
      "derived-state",
      "arrays",
      "control-flow"
    ],
    "description": {
      "summary": "Build a Tic-Tac-Toe game in Vue with alternating turns, win/draw detection, and a reset button. Prevent overwriting moves and show clear status messages for current player and outcome so the game is easy to follow. Concepts: vue, composition api, reactivity, event handlers, derived state, arrays, control flow. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render the Tic-Tac-Toe UI as the main component.",
          "Render a 3×3 board (9 cells).",
          "Alternate turns between 'X' and 'O'.",
          "Clicking an empty cell places the current player's mark (only if the game is not over).",
          "Detect a winner (3 in a row) and stop further moves.",
          "Detect a draw when the board is full and there is no winner.",
          "Show status text (next player / winner / draw).",
          "Include a 'Reset' button to restart the game."
        ],
        "expectedBehavior": [
          "Initial state shows an empty board and indicates 'Next: X'.",
          "Turns alternate X then O.",
          "Clicking a filled cell does nothing.",
          "After a win, status shows 'Winner: X' or 'Winner: O' and moves stop.",
          "After a draw, status shows 'Draw' and moves stop.",
          "Reset clears the board and sets next player to X."
        ],
        "implementationNotes": [
          "Model the board as an array of 9 values (`'X' | 'O' | null`).",
          "Use `ref` to store board and current player.",
          "Use `computed` for derived state: winner, draw, game-over, status.",
          "Use a helper that checks the 8 winning line combinations."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Event handlers",
          "Rendering lists",
          "Derived state",
          "Basic game logic"
        ]
      }
    },
    "starterCodeHint": "Implement `calculateWinner`, derive `isDraw`, `isGameOver`, and `status` via `computed`, then implement `play(i)` and `reset()` inside `<script setup>`.",
    "solutionBlock": {
      "overview": "Tic-Tac-Toe tests basic state management and derived UI. Track a 9-cell board and the current player, prevent overwriting moves, check for a winner after each move, and declare a draw when the board is full. Provide a reset for a clean restart. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "Single SFC with refs + computed derived state",
          "prose": "Use ref for the board array and current player. On cell click, guard against filled cells or game over, update the board, compute winner via the 8 combos, and toggle player if no winner. Render status text and a reset button so users always know the game state. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing overwriting a filled cell.",
          "Allowing moves after winner/draw.",
          "Missing diagonal win checks.",
          "Mutating without copying when you rely on immutable patterns (not required here, but be consistent)."
        ],
        "techniques": [
          "Use a fixed list of winning index triples.",
          "Use computed properties for status and game over logic.",
          "Keep UI handlers small and guarded."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-tictactoe.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-tictactoe"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-tictactoe-solution.v1.json",
    "companies": [
      "amazon"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build Tic Tac Toe in Vue with Winner Detection and Reset",
      "description": "Create a reactive Tic Tac Toe board with alternating turns, overwrite guards, win or draw status messages, and restart functionality."
    }
  },
  {
    "id": "vue-like-button",
    "title": "Vue Like Button (Toggle + Counter)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "easy",
    "importance": 3,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "event-handlers",
      "computed",
      "basics"
    ],
    "description": {
      "summary": "Create a Vue 3 Like button with a toggle state and visible counter. Clicking should increment on like, decrement on unlike, and never allow the count to drop below zero. The UI should immediately reflect the current state. Concepts: vue, components, reactivity. Include keyboard and ARIA considerations, edge cases like rapid clicks, and tests for optimistic UI or throttling. Vue focus: keep liked/count in refs and guard against negative values. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render a Like button and a like counter.",
          "Clicking toggles between 'Like' and 'Liked'.",
          "When toggling to liked: increment the counter by 1.",
          "When toggling to unliked: decrement the counter by 1.",
          "The counter must never go below 0.",
          "Update button styling based on liked state."
        ],
        "expectedBehavior": [
          "Initial state: not liked, counter shows an initial value (e.g., 120).",
          "Clicking toggles the label and active style.",
          "Counter updates by +1 / -1 depending on toggle direction.",
          "If the counter is 0, unliking should not make it negative."
        ],
        "implementationNotes": [
          "Use Vue 3 Composition API with `ref` for `liked` and `count`.",
          "Use `computed` for derived UI (label/classes) if you want.",
          "Implement `toggleLike()` with a guard (never below 0).",
          "Keep everything in a single `App.vue` for this exercise."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Event handlers",
          "Derived UI from state",
          "Guarded updates"
        ]
      }
    },
    "starterCodeHint": "Implement `toggleLike()` and update both `liked` and `count`. Ensure the count never drops below 0.",
    "solutionBlock": {
      "overview": "Use two reactive refs: `liked` (boolean) and `count` (number). The click handler flips `liked` and adjusts `count` by +1 or -1. Clamp the count to zero on unlike so the UI never goes negative. This is a simple but realistic state-sync exercise. Key concepts: vue, components, reactivity.",
      "approaches": [
        {
          "title": "Single component with guarded toggle",
          "prose": "In `<script setup>`, define `const liked = ref(false)` and `const count = ref(0)`. Implement `toggleLike()` that checks the current `liked.value` and updates `count.value` accordingly, using `Math.max(0, count.value - 1)` when unliking. Then flip `liked.value`. Bind the button text to `liked` and render the count next to it."
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing the count to go negative when unliking from 0.",
          "Forgetting `.value` when reading/writing refs in `<script setup>`.",
          "Deriving label/style separately and getting it out of sync with `liked`."
        ],
        "techniques": [
          "Use `ref` for local component state",
          "Clamp with `Math.max(0, count.value - 1)`",
          "Conditional classes from state"
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-like-button.v2.json",
      "openFile": "/src/App.vue",
      "storageKey": "v2:ui:vue:vue-like-button"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-like-button-solution.v2.json",
    "companies": [
      "amazon"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Vue 3 Like Button with Toggle State and Safe Counter",
      "description": "Implement a like button that toggles liked state, updates count up or down correctly, blocks negative totals, and keeps UI feedback instant on clicks."
    }
  },
  {
    "id": "vue-progress-bar-thresholds",
    "title": "Vue Progress Bar (0–100 with Threshold Colors)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "easy",
    "importance": 5,
    "tags": [
      "vue",
      "reactivity",
      "composition-api",
      "event-handlers",
      "state",
      "styling"
    ],
    "description": {
      "summary": "Build a Vue 3 progress bar for 0–100 with +10/−10 controls. Clamp values, display the percentage, and change the fill color by thresholds (red/orange/green) to communicate status clearly. Keep state in sync with UI at all times. Include accessibility notes (contrast, text labels), edge cases (clamping at 0/100), and tests for threshold boundaries and performance on rapid clicks. Vue focus: use computed classes and clamp values in reactive state. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render the progress bar UI as the main component.",
          "Display the current progress percentage (e.g., \"40%\").",
          "Provide \"+10%\" and \"−10%\" buttons to increase/decrease progress by 10.",
          "Clamp progress so it never goes below 0 or above 100.",
          "Change the bar color based on thresholds (red/orange/green)."
        ],
        "expectedBehavior": [
          "Initial progress starts at 0%.",
          "Clicking \"+10%\" increases progress by 10 up to 100.",
          "Clicking \"−10%\" decreases progress by 10 down to 0.",
          "Progress never renders below 0% or above 100%.",
          "Bar color changes by thresholds (example: <34 red, 34–66 orange, >66 green)."
        ],
        "implementationNotes": [
          "Use Vue 3 Composition API with `ref` for the progress state.",
          "Use a `computed` property to derive the threshold class (red/orange/green).",
          "Bind fill width with `:style` and the class with `:class`.",
          "UI must match the React version: title + subtitle + value + track/fill + two buttons + hint."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`, `computed`)",
          "Clamped state updates",
          "Derived UI state (threshold class)",
          "Template bindings and click handlers"
        ]
      }
    },
    "starterCodeHint": "Use `const progress = ref(0)`. Implement `inc/dec` with clamping. Compute `barClass` from progress (<34 red, 34–66 orange, >66 green). Bind `:style=\"{ width: progress + '%' }\"` on the fill.",
    "solutionBlock": {
      "overview": "A progress bar is a simple state-driven component: one numeric value controls width, label, and color. Clamp the value between 0 and 100, show the percentage, and compute a color class based on thresholds to communicate status clearly and consistently across updates. This keeps the UI declarative and predictable.",
      "approaches": [
        {
          "title": "Single component with clamped progress + computed threshold class",
          "prose": "Define progress = ref(0) and inc/dec handlers that clamp with Math.min/Math.max. Create a computed barClass for threshold colors and bind the fill width with a style binding. Render the numeric percentage so the UI remains transparent to the user, and keep all styling derived from state rather than manual DOM tweaks."
        }
      ],
      "notes": {
        "pitfalls": [
          "Not clamping (progress can exceed 100 or go below 0).",
          "Hardcoding class without using `computed` (threshold logic gets duplicated).",
          "Forgetting `.value` when reading/writing refs."
        ],
        "techniques": [
          "Use `computed` for derived UI state (threshold class).",
          "Use direct ref mutation for simple local state.",
          "Bind width and class to keep template declarative."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-progress-bar-thresholds.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-progress-bar-thresholds"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-progress-bar-thresholds-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Create a Vue Progress Bar with 0 to 100 Clamping and Color Thresholds",
      "description": "Build progress controls with safe value clamping, percentage display, and computed red orange green threshold styling for clear status communication."
    }
  },
  {
    "id": "vue-nested-comments",
    "title": "Vue Nested Comments (Infinite Replies, Single Active Reply Input)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "medium",
    "importance": 3,
    "tags": [
      "vue",
      "composition-api",
      "recursion",
      "tree",
      "event-handlers",
      "controlled-inputs"
    ],
    "description": {
      "summary": "Build a Vue 3 nested comments panel with infinite replies. Users can add top-level comments and reply to any comment, creating an infinitely deep tree. Clicking Reply should open an input ONLY under that comment (single active reply box). Render nested replies with indentation. Concepts: vue, composition api, recursion, tree, event handlers, controlled inputs. Vue focus: render recursive components and keep a single active reply id. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render a nested comments UI as the main screen.",
          "Allow adding top-level comments via a textarea + 'Add Comment' button.",
          "Each comment has a 'Reply' button.",
          "Clicking 'Reply' opens a reply input ONLY under that comment (single active reply at a time).",
          "Allow infinite depth replies (nested tree).",
          "Render replies hierarchically with indentation."
        ],
        "expectedBehavior": [
          "Top-level 'Add Comment' adds a new comment to the list.",
          "Clicking 'Reply' under a comment shows a reply input under that comment and hides any other open reply input.",
          "Posting a reply adds it as a child of the correct parent comment.",
          "Cancel closes the reply input without changes.",
          "Replies can be nested infinitely and indentation increases with depth."
        ],
        "implementationNotes": [
          "Use Vue 3 Composition API for state: `ref` for drafts and active id, and a `ref<CommentNode[]>` for the tree.",
          "Keep a single `activeReplyId` + `replyDraft` to ensure only one reply input exists.",
          "Use recursive rendering to display nested comments (a local recursive component is fine).",
          "IDs can be simple incrementing strings."
        ],
        "techFocus": [
          "Tree data structures in UI",
          "Recursive rendering in Vue",
          "Single active input state",
          "Controlled inputs (v-model) and event handlers"
        ]
      }
    },
    "starterCodeHint": "Keep `comments` as a `ref<CommentNode[]>`. Track `topDraft`, `activeReplyId`, and `replyDraft` with `ref`. Implement `findById` (DFS) and recursive rendering with a local component. Make sure text colors are explicitly set for dark UI readability.",
    "solutionBlock": {
      "overview": "Maintain a comment tree in state. Add top-level comments by unshifting a new node into the root array. For replies, track `activeReplyId` and `replyDraft` so only one reply input is visible. When submitting a reply, find the parent node by id (DFS) and push a new child into `children`. Render the tree recursively and indent each node by `depth * 16`.\n\nImportant: ensure text colors are explicitly set so headings and comment text are readable on the dark background. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "Single <App.vue> with Composition API + local recursive component",
          "prose": "1) Store comments in a `ref<CommentNode[]>`.\n2) Store `activeReplyId` + `replyDraft` as UI state.\n3) Implement `addTop`, `openReply`, `cancelReply`, `submitReply`.\n4) Implement `findById` DFS to locate a node.\n5) Create a local recursive component `Tree` (defineComponent) to render nodes and call itself for children.\n6) Apply consistent dark UI styles with explicit text colors. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Opening multiple reply inputs (keeping per-node reply state).",
          "Not resetting `replyDraft` when switching active comment.",
          "Forgetting to set readable text colors; default styles may render text too dark on dark backgrounds."
        ],
        "techniques": [
          "DFS search in a tree (`findById`).",
          "Single active reply input via `activeReplyId`.",
          "Local recursive component rendering in Vue."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-nested-comments.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-nested-comments"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-nested-comments-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build Nested Comments in Vue with Infinite Replies and Single Active Input",
      "description": "Create recursive comment threads with top-level and child replies, keep one active reply box at a time, and render deep hierarchies predictably."
    }
  },
  {
    "id": "vue-dynamic-counter-buttons",
    "title": "Vue Dynamic Counter Buttons (Grow-on-Click)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "medium",
    "importance": 3,
    "tags": [
      "vue",
      "components",
      "reactivity",
      "event-handlers",
      "lists"
    ],
    "description": {
      "summary": "In Vue 3, users should be able to add or remove step buttons dynamically, and each button should update the counter by its own step value. Concepts: vue, components, reactivity, event handlers, lists. Vue focus: store step buttons in reactive arrays and update with v-for. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
      "specs": {
        "requirements": [
          "Render the dynamic counter buttons UI as the main component.",
          "Initially render exactly 1 counter button with value 0.",
          "Clicking any button increments ONLY that button’s value by 1.",
          "After each click, append a NEW button at the bottom with value 0.",
          "All buttons keep their own values independently."
        ],
        "expectedBehavior": [
          "Initial UI: one button showing 0.",
          "Click first button once → first becomes 1, and a second button (0) appears below.",
          "Click second button twice → second becomes 2, and two more new buttons (0, 0) are appended over those clicks.",
          "Existing button values never reset when new buttons appear."
        ],
        "implementationNotes": [
          "Use Vue 3 Composition API with `ref<number[]>([0])` to store the counts array.",
          "Render buttons with `v-for` over the array.",
          "On click: increment the clicked index and `push(0)` to append a new button.",
          "Keep styling consistent with the dark UI theme (explicit readable text colors)."
        ],
        "techFocus": [
          "Vue 3 Composition API (`ref`)",
          "List rendering (`v-for`)",
          "Updating reactive arrays",
          "Click event handlers with indices"
        ]
      }
    },
    "starterCodeHint": "Use `const counts = ref<number[]>([0])`. Implement `onClick(i)` to increment `counts.value[i]` and then `counts.value.push(0)`.",
    "solutionBlock": {
      "overview": "This combines list state and counter state. Keep step values in a reactive array, render them with v-for, and update the count with a single click handler. The UI should reflect edits immediately. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "Single component with counts[] array",
          "prose": "Use a controlled input to add steps, update the array immutably, and render buttons from the list. On click, update count.value += step. Validate inputs (e.g., numeric only) to avoid NaN state. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Incrementing all buttons instead of only the clicked one.",
          "Replacing the entire array incorrectly (losing existing values).",
          "Forgetting explicit text colors on dark backgrounds (unreadable buttons)."
        ],
        "techniques": [
          "Reactive array updates with `ref`",
          "Index-based updates",
          "Stable keys in `v-for`"
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-dynamic-counter-buttons.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-dynamic-counter-buttons"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-dynamic-counter-buttons-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Implement Dynamic Counter Step Buttons in Vue 3",
      "description": "Let users add or remove step buttons dynamically and update one shared counter by each button value using reactive arrays and stable list rendering."
    }
  },
  {
    "id": "vue-chips-input-autocomplete",
    "title": "Invite Chips Input (Tags + Autocomplete)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "vue",
      "composition-api",
      "reactivity",
      "event-handlers",
      "autocomplete",
      "forms",
      "keyboard",
      "accessibility",
      "ui-components"
    ],
    "description": {
      "summary": "Build a Material-like invite field in Vue 3. As users type, show autocomplete suggestions, convert selections into removable chips, and support keyboard shortcuts (Enter/comma/backspace).",
      "specs": {
        "requirements": [
          "Render an input that creates chips below/inside the field.",
          "Show autocomplete suggestions filtered from a fixed users list.",
          "Exclude already-selected users from suggestions.",
          "Clicking a suggestion creates a chip and clears the input.",
          "Pressing Enter or comma creates/selects a chip.",
          "Backspace on empty input removes the last chip.",
          "Each chip has a remove button that updates state correctly.",
          "Support ArrowUp/ArrowDown + Enter keyboard navigation in the suggestion list."
        ],
        "expectedBehavior": [
          "Typing \"al\" surfaces matching user suggestions (name or email).",
          "Selecting \"Alice\" adds one chip and it no longer appears in suggestions.",
          "Typing custom text and pressing comma adds a custom chip.",
          "Pressing Enter with an active suggestion selects that suggestion.",
          "Pressing Enter/comma with no active suggestion adds a custom chip.",
          "Pressing backspace on empty input removes the most recently added chip."
        ],
        "implementationNotes": [
          "Use Vue 3 Composition API in <script setup> with refs/computed/watch.",
          "Model selected chips as an array of `{ id, label, value }`.",
          "Use a normalized id for custom chips (for example `custom-<slug>`).",
          "Prevent duplicates by id or case-insensitive value match.",
          "Use `@mousedown` for suggestion selection to avoid blur race conditions.",
          "Keep combobox/listbox/option roles and active-descendant wiring for accessibility."
        ],
        "techFocus": [
          "Vue 3 Composition API (ref/computed/watch)",
          "Keyboard interaction state",
          "Derived suggestion filtering",
          "Accessible combobox patterns"
        ]
      }
    },
    "starterCodeHint": "Implement TODOs in <script setup>: derive suggestions, wire keyboard behavior (arrow/enter/comma/backspace), prevent duplicates, and support suggestion selection + custom chips.",
    "solutionBlock": {
      "overview": "Keep `chips`, `query`, `isOpen`, and `activeIndex` in refs. Derive suggestions from query + selected chips. Handle Enter/comma for add/select, Arrow keys for navigation, Backspace for last-chip delete, and outside click for dropdown close.",
      "approaches": [
        {
          "title": "Single Vue component with derived suggestions and keyboard UX",
          "prose": "Use a computed value to filter a static dataset by query while excluding already selected chips. Add a helper that inserts chips only when unique. In `onKeyDown`, map ArrowUp/ArrowDown to active option movement, Enter/comma to select/create, and Backspace (when input empty) to remove the last chip. Use a root ref + document mousedown listener to close the dropdown on outside clicks."
        }
      ],
      "notes": {
        "pitfalls": [
          "Using `@click` instead of `@mousedown` on suggestions can lose selection because blur runs first.",
          "Not normalizing text for duplicate checks leads to repeated chips with casing differences.",
          "Not resetting `activeIndex` when query changes causes stale keyboard focus."
        ],
        "techniques": [
          "Derived data with `computed` for suggestions.",
          "Stable keyboard interaction with `activeIndex` state.",
          "Case-insensitive de-duplication by id/value."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-chips-input-autocomplete.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-chips-input-autocomplete"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-chips-input-autocomplete-solution.v1.json",
    "companies": [
      "amazon",
      "airbnb"
    ],
    "access": "premium",
    "updatedAt": "2026-02-09",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 1,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Vue Chips Input with Autocomplete and Keyboard Shortcuts",
      "description": "Implement an invite field that filters suggestions, converts selections into removable chips, and supports Enter comma backspace interactions accessibly."
    }
  },
  {
    "id": "vue-chessboard-click-highlight",
    "title": "Vue Chessboard Click/Highlight (N×N Board)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "vue",
      "composition-api",
      "reactivity",
      "event-handlers",
      "grid",
      "dom",
      "accessibility"
    ],
    "description": {
      "summary": "Build an interactive N×N chessboard in Vue 3. Clicking a cell should highlight it and clear the previous selection. Add a size control so users can change board dimensions.",
      "specs": {
        "requirements": [
          "Render an N×N chessboard with alternating light/dark squares.",
          "Add a numeric size input and clamp size between 2 and 20.",
          "Clicking a cell highlights it and removes highlight from the previously selected cell.",
          "Show selected cell coordinates (row/column) in a status region.",
          "Keep keyboard focus visibility and proper grid semantics."
        ],
        "expectedBehavior": [
          "Initial board renders at size 8×8.",
          "Changing board size updates the grid and clears previous selection.",
          "Clicking one cell activates only that cell.",
          "Status text updates to the selected row/column.",
          "If nothing is selected, status shows no selection."
        ],
        "implementationNotes": [
          "Use Vue 3 Composition API with refs/computed for `size` and `selectedKey`.",
          "Compute rows/columns from current size.",
          "Use class binding for dark/light and active styles.",
          "Keep logic deterministic and avoid external libraries."
        ],
        "techFocus": [
          "Vue 3 Composition API (ref/computed)",
          "Event handling and local state",
          "Grid rendering with nested v-for",
          "Accessible interaction patterns"
        ]
      }
    },
    "starterCodeHint": "Implement TODOs in <script setup>: clamp size input (2..20), reset selection when size changes, and activate only the clicked cell.",
    "solutionBlock": {
      "overview": "Track `size` and `selectedKey` in refs. On size change, parse and clamp the input, then clear selection. On cell click, derive a stable key from row/col and store it. Use class bindings to render checkerboard colors and active state.",
      "approaches": [
        {
          "title": "Single Vue component with derived grid and selected-key state",
          "prose": "Store `size` and `selectedKey` in refs. Build rows with `Array.from({ length: size.value })`, render nested loops, and map each cell to a unique key like `row-col`. On click, assign the clicked key; on size input, clamp within bounds and reset selection so state is always valid."
        }
      ],
      "notes": {
        "pitfalls": [
          "Not clamping board size can break layout and state assumptions.",
          "Tracking selection by array index alone becomes brittle after size changes.",
          "Forgetting to clear selection on resize can leave stale coordinates."
        ],
        "techniques": [
          "Derived arrays for grid rendering",
          "Stable key modeling for selected cell",
          "Simple ARIA roles for grid and gridcell semantics"
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-chessboard-click-highlight.v1.json",
      "openFile": "/src/App.vue",
      "storageKey": "v1:ui:vue:vue-chessboard-click-highlight"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-chessboard-click-highlight-solution.v1.json",
    "companies": [
      "amazon",
      "microsoft"
    ],
    "access": "premium",
    "updatedAt": "2026-02-09",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 1,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Create an Interactive N x N Chessboard in Vue with Click Highlight",
      "description": "Build a clickable grid board that highlights one selected cell at a time and updates layout dynamically when board size changes."
    }
  },
  {
    "id": "vue-snake-game",
    "title": "Vue Snake Game (Grid + Food + Collision)",
    "type": "coding",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 3,
    "tags": [
      "vue",
      "composition-api",
      "reactivity",
      "event-handlers",
      "grid",
      "dom",
      "accessibility"
    ],
    "description": {
      "summary": "Build a Snake game in Vue 3 using a grid board. Support keyboard controls, food spawning, score updates, and game-over handling for wall/body collisions.",
      "specs": {
        "requirements": [
          "Render a fixed-size board (for example 14×14) with snake body and food cells.",
          "Move the snake using Arrow keys (optionally WASD).",
          "Run game ticks on an interval while the game is running.",
          "Eating food should grow the snake and increment score.",
          "Colliding with walls or snake body should end the game.",
          "Provide Start/Pause and Reset controls.",
          "Expose score and current snake length in the UI.",
          "Keep keyboard interactions stable (no reverse-direction bug)."
        ],
        "expectedBehavior": [
          "Initial state shows a short snake, one food cell, and score 0.",
          "Press Start to begin movement; snake advances one cell per tick.",
          "When head reaches food, score increases and snake length grows by 1.",
          "Pressing opposite direction immediately should be ignored for safety.",
          "Hitting boundary or own body stops the game and shows game-over state.",
          "Reset returns to initial state with a new food position."
        ],
        "implementationNotes": [
          "Store snake as ordered coordinates, with index 0 as the head.",
          "Track both current direction and pending direction to avoid race conditions.",
          "Use Set/string keys for fast cell occupancy checks.",
          "Generate food only on free cells that are not occupied by snake.",
          "Clear interval correctly on pause, game over, and unmount."
        ],
        "techFocus": [
          "Vue 3 Composition API (ref/computed)",
          "Interval lifecycle management",
          "Keyboard event handling",
          "Deterministic state updates for moving/growing arrays"
        ]
      }
    },
    "starterCodeHint": "Implement TODOs in <script setup>: keyboard direction updates, game loop movement, collision checks, food growth, and reset flow.",
    "solutionBlock": {
      "overview": "Keep snake coordinates, direction, pendingDirection, food, score, and run state in refs. Tick with setInterval, prepend next head, and pop tail unless food is eaten. End the game on wall/body collision.",
      "approaches": [
        {
          "title": "Single Vue component with deterministic game-loop state",
          "prose": "On each tick, compute the next head from current direction. Validate collisions before mutating state. If food is eaten, keep the tail (grow) and spawn new food on a free cell. Otherwise remove tail for standard movement. Use key mapping and block immediate opposite-direction turns."
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing immediate reverse direction can cause instant self-collision artifacts.",
          "Forgetting interval cleanup leads to duplicate timers and speed glitches.",
          "Spawning food without excluding snake cells can make unreachable food."
        ],
        "techniques": [
          "Occupancy keys like `x,y` for constant-time lookups.",
          "Pending direction buffer to avoid same-tick race conditions.",
          "Deterministic tick flow with explicit collision branches."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/vue/question/vue-snake-game.v2.json",
      "openFile": "/src/App.vue",
      "storageKey": "v3:ui:vue:vue-snake-game"
    },
    "solutionAsset": "assets/sb/vue/solution/vue-snake-game-solution.v2.json",
    "companies": [
      "amazon",
      "microsoft"
    ],
    "access": "premium",
    "updatedAt": "2026-02-09",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 1,
      "crossCompany": 1,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Build a Vue Snake Game with Grid Movement, Food, and Collision Rules",
      "description": "Implement keyboard-controlled snake movement on a grid, timed game ticks, random food spawning, score updates, and game-over handling for wall or self collisions."
    }
  }
]
