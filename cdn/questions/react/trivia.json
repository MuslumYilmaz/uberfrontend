[
  {
    "id": "react-core-problem-and-non-goals",
    "title": "What core problem does React solve, and what does it deliberately NOT solve?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "React solves predictable UI rendering from state with a component model and reconciliation. It does not provide routing, data fetching, or state management out of the box. This clarity guides architecture decisions; the trade-off is adding routing or state libraries and testing their integration.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React solves one main problem: <em>reliably keeping the UI in sync with changing data</em> (state/props/context) without manually mutating the DOM. It gives you a component model + a declarative rendering system so you describe <em>what the UI should look like</em>, and React figures out <em>how to update</em> the DOM efficiently."
        },
        {
          "type": "list",
          "columns": [
            "Problem in UI apps",
            "What React provides",
            "Why it matters"
          ],
          "rows": [
            [
              "Manual DOM updates become complex and bug-prone",
              "Declarative rendering (re-render components from current inputs)",
              "Reduces “UI out of sync” bugs"
            ],
            [
              "Hard to structure large UIs",
              "Components (composition + reuse + isolation)",
              "Scales UI development and ownership"
            ],
            [
              "Frequent updates can be expensive",
              "Reconciliation + efficient commits",
              "Avoids unnecessary DOM work"
            ],
            [
              "State changes need predictable flow",
              "Unidirectional data flow (props down, events up)",
              "Makes changes easier to trace/debug"
            ]
          ],
          "caption": "What React is built to solve"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  // No manual DOM updates.\n  // UI is a pure result of current state.\n  return (\n    <button onClick={() => setCount((c) => c + 1)}>\n      Count: {count}\n    </button>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>What React deliberately does NOT solve</strong><br><br>React is intentionally a <em>UI library</em>, not a full framework. It avoids forcing a single “one true way” for the rest of the app (routing, data, architecture), so teams can choose what fits their needs."
        },
        {
          "type": "list",
          "columns": [
            "Concern",
            "React's stance",
            "What you typically add"
          ],
          "rows": [
            [
              "Routing",
              "Not included",
              "A router (client-side or framework routing)"
            ],
            [
              "Data fetching / server state",
              "Not included (useEffect exists, but no fetching strategy)",
              "A data-fetching/cache approach (query library or framework)"
            ],
            [
              "Global state architecture",
              "Not prescribed (Context exists, but not a full store pattern)",
              "Store pattern/library (or colocated state + lifting)"
            ],
            [
              "Forms and validation",
              "Not included",
              "Form library or custom form architecture"
            ],
            [
              "Styling approach",
              "Not included",
              "CSS Modules / CSS-in-JS / utility CSS / design system"
            ],
            [
              "Build tooling / bundling / SSR",
              "Not included",
              "A build tool or a React framework (for SSR/SSG, routing, etc.)"
            ]
          ],
          "caption": "React’s non-goals (by design)"
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say it like this: React owns <em>rendering</em> and <em>component composition</em>. Everything else is a product decision: choose a stack around React (router, data strategy, state strategy, build/SSR). The trade-off is flexibility vs having to assemble your own opinionated architecture."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React solves: <em>predictable UI updates from state</em> using declarative components + reconciliation. React does NOT solve: routing, data fetching strategy, global state architecture, forms, styling, or build/SSR tooling — those are intentionally left to the ecosystem."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Building a dashboard, React handles UI state and rendering while you choose routing and data-fetching libraries for navigation and cache.<br><br><strong>Common pitfalls</strong><br><ul><li>Expecting React to provide routing or global state out of the box.</li><li>Mixing view state with server-cache concerns.</li><li>Ignoring performance and testing needs for large component trees.</li></ul><strong>Trade-off or test tip</strong><br>The lean core is flexible but requires architecture decisions. Test by listing missing pieces (routing, data fetching, auth) before you build.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "core",
      "components",
      "state",
      "ecosystem"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "What problem does React solve and what does it not solve?",
      "description": "React solves state-driven UI rendering and reconciliation, but it does not include built-in routing, data fetching, or global state by default."
    }
  },
  {
    "id": "react-pure-function-of-props-and-state",
    "title": "Why are React components expected to be pure functions of props and state?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Explain why React expects rendering to be a pure computation (UI = f(props, state, context)) and why side effects must be moved to effects/event handlers. Connect it to render vs commit, Concurrent Rendering, StrictMode double-invocation, memoization, and predictable reconciliation. Pure rendering improves predictability and testing, but side effects must live in effects/hooks. Test with StrictMode and rerenders.",
    "seo": {
      "title": "Why should React components be pure functions of props and state?",
      "description": "React components should be pure because the same props and state must produce the same UI output without side effects during render."
    },
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React wants rendering to be a deterministic computation: given the same <code>props</code> + <code>state</code> (+ <code>context</code>), the component should return the same UI description. That purity lets React freely re-run renders, pause/abort work, and diff trees safely without causing “real-world” side effects."
        },
        {
          "type": "list",
          "columns": [
            "Why purity matters",
            "What it enables in React",
            "What breaks if you add side effects in render"
          ],
          "rows": [
            [
              "Render can run multiple times",
              "Retry / discard renders safely (especially in Concurrent Rendering)",
              "Duplicate API calls, duplicate subscriptions, duplicated logs, inconsistent state"
            ],
            [
              "Render can be paused / resumed / interleaved",
              "Scheduling + prioritization without committing to the DOM",
              "Effects happen at the wrong time, race conditions, tearing-like bugs"
            ],
            [
              "React uses diffing + memoization",
              "Predictable reconciliation, <code>React.memo</code>, caching, dev tooling",
              "Non-deterministic output makes “same inputs => same UI” false"
            ],
            [
              "StrictMode intentionally stress-tests",
              "Double-invocation in dev helps catch unsafe patterns",
              "Impure render causes “works in prod, weird in dev” behavior"
            ]
          ],
          "caption": "Purity is what makes React’s rendering model safe and optimizable"
        },
        {
          "type": "text",
          "text": "<strong>Render vs side effects</strong><br><br><em>Render phase</em> should only compute the next UI tree. <em>Side effects</em> belong in event handlers (user actions) or effects (<code>useEffect</code>/<code>useLayoutEffect</code>) which run after React commits changes."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ Impure render: side effects inside render\nlet renders = 0;\n\nfunction Profile({ user }) {\n  renders++; // side effect: mutating external state\n\n  // side effect: mutating props object\n  user.lastSeenAt = Date.now();\n\n  // side effect: starting async work during render\n  fetch('/api/track?u=' + user.id);\n\n  return <div>Renders: {renders} — {user.name}</div>;\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Side effect in render",
            "Why it’s bad",
            "Where it should go instead"
          ],
          "rows": [
            [
              "Mutating props/state/external variables",
              "Repeated renders produce cumulative mutations and hard-to-debug bugs",
              "Compute derived values immutably; update state via setters"
            ],
            [
              "Network calls / subscriptions / timers",
              "Render may be retried/aborted → duplicated work and leaks",
              "useEffect cleanup; subscribe/unsubscribe there"
            ],
            [
              "Reading time/randomness (Date.now, Math.random)",
              "Same inputs can yield different UI (non-deterministic)",
              "Initialize once with lazy state init, or store in state"
            ],
            [
              "DOM reads/writes",
              "DOM may not match the tree until commit; causes layout issues",
              "useLayoutEffect (reads/writes after commit) or refs"
            ]
          ],
          "caption": "Common impurities React wants you to avoid"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ✅ Pure render + side effects moved out\nfunction Profile({ user }) {\n  // Pure: derived UI only\n  return <div>{user.name}</div>;\n}\n\nfunction ProfileWithTracking({ user }) {\n  React.useEffect(() => {\n    let cancelled = false;\n\n    (async () => {\n      try {\n        await fetch('/api/track?u=' + user.id);\n      } finally {\n        // optional: handle completion\n      }\n    })();\n\n    return () => {\n      cancelled = true; // example cleanup flag\n    };\n  }, [user.id]);\n\n  return <Profile user={user} />;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>If running the component body twice would cause anything “real” to happen twice (API call, subscription, mutation, analytics), it’s not pure. Keep render as a calculation; do real work in effects and event handlers."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React expects components to be pure so it can re-run rendering freely (including retries/aborts), apply concurrent scheduling, and reconcile efficiently. Side effects in render break determinism and lead to duplicated work and inconsistent UI; move them to effects/event handlers where React guarantees timing relative to commits."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A product card renders purely from props and local state, while data fetching happens in effects.<br><br><strong>Common pitfalls</strong><br><ul><li>Triggering side effects during render.</li><li>Deriving state incorrectly from props.</li><li>Relying on mutable props.</li></ul><strong>Trade-off or test tip</strong><br>Pure renders are predictable but require disciplined effects. Test with StrictMode and snapshot behavior.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "state",
      "props",
      "rendering",
      "basics"
    ],
    "updatedAt": "2026-01-30"
  },
  {
    "id": "react-functional-vs-class-components",
    "title": "Functional vs class components in React: what actually differs?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Functional components are plain functions with hooks for state and lifecycle. Class components use this.state and lifecycle methods. Modern React favors function components with hooks. Trade-offs matter: hooks simplify composition, but legacy code still uses classes, so test lifecycle and performance behavior.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Both function and class components can render the same UI. The difference is <em>how</em> they express state, side effects, and reuse.<br><br><strong>Function components</strong> use Hooks (<code>useState</code>, <code>useEffect</code>, etc.). <strong>Class components</strong> use instance state (<code>this.state</code>) and lifecycle methods (<code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>)."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Functional (Hooks)",
            "Class"
          ],
          "rows": [
            [
              "Definition",
              "A function that returns a ReactNode (JSX, string/number, fragment, null, etc.)",
              "An ES6 class extending <code>React.Component</code> with a <code>render()</code> method"
            ],
            [
              "State",
              "<code>useState</code> / <code>useReducer</code>",
              "<code>this.state</code> + <code>this.setState()</code>"
            ],
            [
              "Side effects / lifecycle",
              "<code>useEffect</code> / <code>useLayoutEffect</code> (+ cleanup)",
              "Lifecycle methods (<code>componentDidMount/Update/WillUnmount</code>)"
            ],
            [
              "Code reuse",
              "Custom Hooks (share stateful logic without wrappers)",
              "HOCs / render props / mixins (older patterns)"
            ],
            [
              "Mental model",
              "Render is a pure calculation; hooks add state/effects tied to render order",
              "Instance methods + <code>this</code>, lifecycle phases"
            ],
            [
              "Interop",
              "Can’t use class lifecycles; but can wrap classes / call into legacy libs via effects/refs",
              "Can’t use Hooks inside classes"
            ],
            [
              "Modern React direction",
              "Primary model; new patterns and ecosystem examples are hook-first",
              "Supported but mostly for legacy codebases"
            ]
          ],
          "caption": "High-level differences that matter in real code"
        },
        {
          "type": "text",
          "text": "<strong>Lifecycle mapping (common interview ask)</strong><br><br>Hooks are not “magic faster”. They’re a different API that can express the same lifecycle behaviors with explicit dependencies + cleanup."
        },
        {
          "type": "list",
          "columns": [
            "Goal",
            "Hooks",
            "Class lifecycle"
          ],
          "rows": [
            [
              "Run once on mount",
              "<code>useEffect(() => { ... }, [])</code>",
              "<code>componentDidMount()</code>"
            ],
            [
              "Run on specific changes",
              "<code>useEffect(() => { ... }, [a, b])</code>",
              "<code>componentDidUpdate(prevProps, prevState)</code> + comparisons"
            ],
            [
              "Cleanup on unmount",
              "<code>return () => cleanup()</code> inside effect",
              "<code>componentWillUnmount()</code>"
            ],
            [
              "Sync DOM measurements before paint",
              "<code>useLayoutEffect</code>",
              "<code>componentDidMount/Update</code> (but timing differs; layout effect is the closer analogue)"
            ]
          ],
          "caption": "How to translate between the two styles"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Functional component (Hooks)\nimport React from 'react';\n\nexport function Counter() {\n  const [count, setCount] = React.useState(0);\n\n  // effect: run after commit; cleanup on unmount\n  React.useEffect(() => {\n    document.title = `Count: ${count}`;\n\n    const id = setInterval(() => {\n      // functional update avoids stale reads\n      setCount((c) => c + 1);\n    }, 1000);\n\n    return () => clearInterval(id);\n  }, []);\n\n  return (\n    <button onClick={() => setCount((c) => c + 1)}>\n      Count: {count}\n    </button>\n  );\n}\n\n// Class component equivalent\nexport class CounterClass extends React.Component {\n  state = { count: 0 };\n  _id = null;\n\n  componentDidMount() {\n    document.title = `Count: ${this.state.count}`;\n    this._id = setInterval(() => {\n      this.setState((s) => ({ count: s.count + 1 }));\n    }, 1000);\n  }\n\n  componentDidUpdate() {\n    document.title = `Count: ${this.state.count}`;\n  }\n\n  componentWillUnmount() {\n    clearInterval(this._id);\n  }\n\n  render() {\n    return (\n      <button onClick={() => this.setState((s) => ({ count: s.count + 1 }))}>\n        Count: {this.state.count}\n      </button>\n    );\n  }\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Important nuance (don’t claim “functional is faster”)</strong><br><br>There’s no inherent “function components are faster” rule. Performance depends on update patterns, memoization boundaries, and avoiding unnecessary work. Functions are preferred because Hooks give a simpler composition model for stateful logic and align with modern React features and patterns."
        },
        {
          "type": "list",
          "columns": [
            "When to pick",
            "Functional (recommended)",
            "Class (still valid)"
          ],
          "rows": [
            [
              "New code",
              "Default choice",
              "Avoid unless you have a specific reason"
            ],
            [
              "Legacy codebase",
              "Incremental migration is common (mixing is fine)",
              "Keep existing classes; rewrite opportunistically"
            ],
            [
              "Reusable stateful logic",
              "Custom hooks are the standard approach",
              "Older patterns (HOC/render props) still exist but are heavier"
            ],
            [
              "Very old React (< 16.8)",
              "Hooks unavailable",
              "Classes required"
            ]
          ],
          "caption": "Practical selection guidance"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Function components are the modern default: state and lifecycle behavior are expressed with Hooks (especially <code>useState</code>/<code>useEffect</code>) and logic reuse is done via custom hooks. Class components express the same ideas via <code>this</code>, <code>this.state</code>/<code>setState</code>, and lifecycle methods. React still supports classes, but new React code is typically hook-first."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>You migrate a class-based form to hooks to share validation logic across components.<br><br><strong>Common pitfalls</strong><br><ul><li>Trying to use <code>this</code> or lifecycle methods directly in a function component.</li><li>Missing <code>useEffect</code> dependencies, causing stale state.</li><li>Overusing hooks in complex components without refactoring.</li></ul><strong>Trade-off or test tip</strong><br>Hooks are flexible but rely on rules. Test lifecycle behavior and add lint rules for hooks.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "components",
      "hooks",
      "classes",
      "lifecycle"
    ],
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ],
    "seo": {
      "title": "Functional vs class components in React: what is the difference?",
      "description": "Functional components use hooks and are the modern default, while class components use lifecycle methods and class syntax."
    }
  },
  {
    "id": "react-jsx-transform-and-why-not-required",
    "title": "How does JSX get transformed, and why doesn’t React require it?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 2,
    "description": "Explain what JSX actually is (syntax sugar), how a compiler (Babel/TypeScript) transforms it into plain JavaScript calls, and why React can work without JSX (you can call the element factory directly). Mention the two JSX runtimes (classic createElement vs automatic react/jsx-runtime) and the practical implications (React import, tooling, and why JSX isn’t HTML). Modern JSX transform removes the explicit React import, but tooling must be configured. Test build output and lint rules.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>JSX is <em>not</em> something React executes. JSX is syntax that your build tool (Babel or TypeScript) compiles into plain JavaScript function calls that create React elements. React doesn’t require JSX because React only needs the <em>result</em>: a React element tree (plain JS objects) — and you can create those objects without JSX."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "What happens",
            "Who does it"
          ],
          "rows": [
            [
              "1) Parse JSX",
              "JSX is parsed into an AST (like any JS syntax).",
              "Babel / TypeScript compiler"
            ],
            [
              "2) Transform",
              "JSX nodes become function calls (classic or automatic runtime).",
              "Babel plugin / TS JSX transform"
            ],
            [
              "3) Run",
              "Those function calls return React elements (JS objects).",
              "React runtime"
            ],
            [
              "4) Render",
              "React reconciles elements and updates the DOM.",
              "React + ReactDOM"
            ]
          ],
          "caption": "JSX is a compile-time feature, not a React runtime feature"
        },
        {
          "type": "text",
          "text": "<strong>Two JSX runtimes you’ll see</strong><br><br>There are two common outputs for JSX transforms: <em>classic</em> (calls <code>React.createElement</code>) and <em>automatic</em> (calls <code>jsx/jsxs</code> from <code>react/jsx-runtime</code>). Both produce the same kind of React elements."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Input (JSX)\nfunction App({ user }) {\n  return (\n    <main className=\"page\">\n      <h1>Hello, {user.name}</h1>\n      <button onClick={() => alert('hi')}>Click</button>\n    </main>\n  );\n}\n"
        },
        {
          "type": "code",
          "language": "js",
          "code": "// Output (classic runtime - conceptual)\nfunction App({ user }) {\n  return React.createElement(\n    'main',\n    { className: 'page' },\n    React.createElement('h1', null, 'Hello, ', user.name),\n    React.createElement('button', { onClick: () => alert('hi') }, 'Click')\n  );\n}\n"
        },
        {
          "type": "code",
          "language": "js",
          "code": "// Output (automatic runtime - conceptual)\nimport { jsx, jsxs } from 'react/jsx-runtime';\n\nfunction App({ user }) {\n  return jsxs('main', {\n    className: 'page',\n    children: [\n      jsxs('h1', { children: ['Hello, ', user.name] }),\n      jsx('button', { onClick: () => alert('hi'), children: 'Click' })\n    ]\n  });\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Detail",
            "What it means in practice"
          ],
          "rows": [
            [
              "Automatic runtime often removes the need to import React just for JSX",
              "You might not see <code>import React from 'react'</code> anymore, but the runtime still imports helpers (from <code>react/jsx-runtime</code>)."
            ],
            [
              "JSX becomes props + children",
              "Attributes become a props object; nested content becomes <code>children</code>."
            ],
            [
              "JSX is JavaScript expressions",
              "{...} is an expression slot, not “template interpolation” like HTML."
            ],
            [
              "Lowercase vs Uppercase matters",
              "<code>&lt;div /&gt;</code> becomes a string tag; <code>&lt;MyComp /&gt;</code> becomes a variable reference (a component function/class)."
            ]
          ],
          "caption": "Important mental model differences"
        },
        {
          "type": "text",
          "text": "<strong>Why React doesn’t require JSX</strong><br><br>React only needs you to produce React elements. JSX is just a nicer way to write those element factory calls. You can skip JSX entirely and write <code>createElement</code> (or <code>jsx</code>) calls yourself — it’s just more verbose."
        },
        {
          "type": "code",
          "language": "js",
          "code": "// React without JSX\nimport React from 'react';\n\nexport function App() {\n  return React.createElement('h1', null, 'No JSX here');\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say: “JSX is syntax sugar compiled by Babel/TS into element-creation calls (classic <code>createElement</code> or automatic <code>jsx/jsxs</code>). React doesn’t require JSX because it only consumes React elements — JSX never reaches React as JSX.”"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>You upgrade to React 17+ and remove <code>import React</code> from files using JSX.<br><br><strong>Common pitfalls</strong><br><ul><li>Tooling not configured for the new JSX transform.</li><li>Babel/TS settings inconsistent across packages.</li><li>Lint rules still expecting React in scope.</li></ul><strong>Trade-off or test tip</strong><br>New transform reduces boilerplate but needs config. Test build output and update linters.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "jsx",
      "tooling",
      "build",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "How is JSX transformed in React and do you need it?",
      "description": "JSX compiles to JavaScript function calls, and React does not require JSX because you can write elements with plain JavaScript APIs."
    }
  },
  {
    "id": "react-function-treated-as-component-rules",
    "title": "What rules must a function follow to be treated as a React component?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Explain what makes React treat a function as a component (element type), the JSX naming rule (Uppercase vs lowercase), what it must return, and the practical rules around calling it (don’t call directly if it uses Hooks). Include common runtime errors and gotchas. Uppercase naming and hook rules are common edge cases, so add tests for warnings and invalid returns.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React treats a function as a <em>component</em> when you use it as an <em>element type</em>: <code>&lt;MyComp /&gt;</code> (or <code>React.createElement(MyComp)</code>). Then React calls it during rendering and interprets its return value as UI."
        },
        {
          "type": "list",
          "columns": [
            "Rule",
            "What it means",
            "Why it matters"
          ],
          "rows": [
            [
              "Use it as an element type",
              "Render it as <code>&lt;MyComp /&gt;</code> (or <code>createElement(MyComp)</code>)",
              "If you just call <code>MyComp()</code>, React isn’t in control (Hooks/state model breaks)."
            ],
            [
              "Uppercase name in JSX",
              "<code>&lt;MyComp /&gt;</code> must start with a capital letter",
              "Lowercase tags are treated as DOM elements (<code>'div'</code>, <code>'span'</code>), not components."
            ],
            [
              "Return a valid React node",
              "Return JSX, string/number, fragment, array of nodes, <code>null</code>",
              "Returning an invalid type (like a plain object or Promise) crashes at runtime."
            ],
            [
              "Be render-safe (no side effects in render)",
              "Component body should compute UI; side effects go to effects/handlers",
              "Render can run multiple times (StrictMode / concurrent scheduling)."
            ]
          ],
          "caption": "The practical rules React relies on"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ✅ Component: uppercase usage\nfunction Hello({ name }) {\n  return <h1>Hello {name}</h1>;\n}\n\nexport default function App() {\n  return <Hello name=\"Ada\" />;\n}\n\n// ❌ Not a component in JSX: lowercase means DOM tag\nfunction hello() {\n  return <h1>hi</h1>;\n}\n\nexport function Broken() {\n  return <hello />; // React treats this as <\"hello\"> DOM element, not your function.\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Return value",
            "Allowed?",
            "Notes"
          ],
          "rows": [
            [
              "JSX element",
              "✅",
              "Most common: <code>&lt;div /&gt;</code>, <code>&lt;MyComp /&gt;</code>"
            ],
            [
              "string / number",
              "✅",
              "Renders a text node"
            ],
            [
              "<code>null</code> / <code>false</code>",
              "✅",
              "Renders nothing (intentional gating)"
            ],
            [
              "Array of nodes",
              "✅",
              "Use keys for stable lists"
            ],
            [
              "Plain object",
              "❌",
              "Error: <code>Objects are not valid as a React child</code>"
            ],
            [
              "Promise (async function)",
              "❌ (client)",
              "Async component returns a Promise; not a valid React node in client rendering"
            ]
          ],
          "caption": "What a function component is allowed to return"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ Invalid return\nfunction Bad() {\n  return { ok: true }; // runtime error\n}\n\n// ✅ Valid: render nothing\nfunction Gate({ enabled }) {\n  if (!enabled) return null;\n  return <div>Enabled</div>;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Hooks-specific rule</strong><br><br>If the function uses Hooks, it must be treated as a real component: call it only via React render (<code>&lt;Comp /&gt;</code>), and follow the Rules of Hooks (call hooks at the top level, not inside conditions/loops). Calling a Hook-using component like <code>Comp()</code> is a common mistake."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Counter() {\n  const [n, setN] = React.useState(0);\n  return <button onClick={() => setN((x) => x + 1)}>{n}</button>;\n}\n\n// ❌ Don’t do this\nfunction Wrong() {\n  const el = Counter(); // breaks Hooks model\n  return <div>{el}</div>;\n}\n\n// ✅ Do this\nfunction Right() {\n  return <Counter />;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>A function is treated as a React component when React sees it as the element type (<code>&lt;MyComp /&gt;</code> / <code>createElement(MyComp)</code>), it’s capitalized in JSX, and it returns a valid React node. If it uses Hooks, it must only be invoked by React’s render pipeline (not called directly)."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>You create a reusable <code>UserCard</code> component and render it in a list with JSX.<br><br><strong>Common pitfalls</strong><br><ul><li>Using a lowercase name so React treats it as a DOM tag.</li><li>Calling the function directly instead of using JSX, breaking hook rules.</li><li>Returning invalid values or fragments without a wrapper.</li></ul><strong>Trade-off or test tip</strong><br>Component naming and hook rules are strict but predictable. Test for warnings in dev and add lint rules.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "components",
      "naming",
      "jsx",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "What makes a function a React component?",
      "description": "A function is treated as a React component when used as a JSX tag, follows component naming conventions, and returns renderable React output."
    }
  },
  {
    "id": "react-rerender-decision-and-render",
    "title": "How does React decide when to re-render a component, and what role does render() play in that process?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what triggers a React component to re-render, what a “render” actually means (vs updating the DOM), and what role the class render() method (or function component body) plays in the render + commit pipeline.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React re-renders a component when it thinks that component’s <em>inputs</em> might have changed (state/props/context). A re-render means: “run the component again to produce a new element tree.” It does <em>not</em> necessarily mean the browser DOM will change."
        },
        {
          "type": "list",
          "columns": [
            "Trigger",
            "What changed?",
            "What React does",
            "Notes / common gotcha"
          ],
          "rows": [
            [
              "State update",
              "<code>setState</code> / <code>setX</code> / <code>dispatch</code>",
              "Schedules a render for that component",
              "<code>useState</code> bails out if the new state is <code>Object.is</code>-equal to the old state; new object/array references always count as “changed”."
            ],
            [
              "New props",
              "Parent renders and passes props down",
              "Child is rendered by default",
              "Even if props are “equal by value”, React still re-renders unless the child is memoized (<code>React.memo</code>/<code>PureComponent</code>)."
            ],
            [
              "Context update",
              "A <code>Context.Provider</code> value changes",
              "All consuming components re-render",
              "Context is identity-based: <code>{...}</code> created inline will change every render unless memoized."
            ],
            [
              "Force update",
              "<code>forceUpdate()</code> (class) or “dummy state”",
              "Forces a render",
              "Usually a code smell; prefer state/props-driven rendering."
            ]
          ],
          "caption": "The main reasons React decides to re-render a component"
        },
        {
          "type": "text",
          "text": "<strong>What happens during a re-render</strong><br><br>React runs the component (function body or class <code>render()</code>) to build a new React element tree. Then it <em>reconciles</em> (diffs) it against the previous tree. Only the differences are committed to the DOM."
        },
        {
          "type": "list",
          "columns": [
            "Phase",
            "What runs here",
            "What must be true"
          ],
          "rows": [
            [
              "Render phase",
              "Component function body / class <code>render()</code>",
              "Must be pure: no side effects (no data fetching, subscriptions, DOM writes)."
            ],
            [
              "Commit phase",
              "DOM mutations + layout effects",
              "Safe place for effects: <code>useEffect</code>, <code>useLayoutEffect</code>, lifecycle methods."
            ]
          ],
          "caption": "Render vs commit (why render() must be pure)"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Counter() {\n  const [count, setCount] = React.useState(0);\n\n  // This function body is the “render” for function components.\n  // It runs again when state/props/context changes.\n  return (\n    <button onClick={() => setCount((c) => c + 1)}>\n      Count: {count}\n    </button>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>So what is <code>render()</code> doing?</strong><br><br><code>render()</code> does not “trigger” updates. It’s the function React calls <em>after</em> an update is scheduled, to compute the next UI description. For function components, the component function itself plays the same role as <code>render()</code>."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "class Profile extends React.Component {\n  render() {\n    // Called during the render phase to compute UI.\n    return <h1>{this.props.name}</h1>;\n  }\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Skipping re-renders (bailouts)</strong><br><br>By default, parent re-renders propagate to children. To skip work, React needs an explicit bailout rule."
        },
        {
          "type": "list",
          "columns": [
            "Technique",
            "How it skips work",
            "When to use"
          ],
          "rows": [
            [
              "<code>React.memo(Component)</code>",
              "Shallow-compares props; if equal, skips re-render",
              "Pure presentational children with stable props"
            ],
            [
              "<code>PureComponent</code> / <code>shouldComponentUpdate</code>",
              "Controls whether class component re-renders",
              "Legacy/class codebases"
            ],
            [
              "Stable references",
              "Avoid changing prop identity unnecessarily",
              "Use <code>useCallback</code>/<code>useMemo</code> only when it prevents real re-renders"
            ]
          ],
          "caption": "Common ways to prevent unnecessary re-renders"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React re-renders when state/props/context might have changed. A “render” means recomputing the next React element tree, not necessarily updating the DOM. The class <code>render()</code> method (or function component body) is the pure computation React runs during the render phase; DOM updates happen later in the commit phase."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "rendering",
      "state",
      "props",
      "performance"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "How does React know when to re-render a component?",
      "description": "React re-renders a component when its state, props, or consumed context changes, then render computes the next UI tree."
    }
  },
  {
    "id": "react-render-nothing-return-value",
    "title": "Why does a React component sometimes render nothing, and how does React interpret its return value?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 2,
    "description": "React renders nothing when a component returns null, false, or an empty fragment. This is useful for conditional UI without extra wrapper nodes. Covers: react, rendering, null, conditional, components. Return null/false for no UI, and keep layout stable. This affects conditional rendering, accessibility, and testing of empty states.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>A React component is basically a function that returns a <code>ReactNode</code> (what React should render). If the returned value is “empty” (<code>null</code> / <code>false</code>) React mounts nothing for that component. If you accidentally return <code>undefined</code> (often due to a missing <code>return</code>), React throws an error like: <code>Nothing was returned from render</code>."
        },
        {
          "type": "list",
          "columns": [
            "Return value",
            "How React treats it"
          ],
          "rows": [
            [
              "JSX element (e.g., <code>&lt;div /&gt;</code>)",
              "Renders that element."
            ],
            [
              "<code>string</code> / <code>number</code>",
              "Renders a text node."
            ],
            [
              "<code>null</code>",
              "Renders nothing (intentional “no UI”)."
            ],
            [
              "<code>false</code> / <code>true</code>",
              "Booleans are not rendered (treated like “nothing”)."
            ],
            [
              "Array / iterable of nodes",
              "Renders multiple siblings (keys required for stable lists)."
            ],
            [
              "Fragment (<code>&lt;&gt;...&lt;/&gt;</code>)",
              "Renders children without an extra DOM wrapper."
            ],
            [
              "Portal",
              "Renders into a different DOM container, still part of the React tree."
            ],
            [
              "<code>undefined</code>",
              "❌ Error (usually means you forgot to return)."
            ],
            [
              "Plain object (not a React element)",
              "❌ Error (<code>Objects are not valid as a React child</code>)."
            ]
          ],
          "caption": "How React interprets common component return values"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function LoadingGate({ isLoading, children }) {\n  if (isLoading) return null; // ✅ intentionally render nothing\n  return <>{children}</>; // ✅ render children\n}\n\nfunction TextOnly() {\n  return 'Hello'; // ✅ renders a text node\n}\n\nfunction Multi() {\n  return [\n    <span key=\"a\">A</span>,\n    <span key=\"b\">B</span>\n  ]; // ✅ multiple siblings\n}"
        },
        {
          "type": "text",
          "text": "<strong>Why it “renders nothing” in real life</strong><br><br>Sometimes this is intentional (feature flags, loading gates, access control). Other times it’s a bug where the component returns <code>undefined</code> or produces “empty” output via short-circuit expressions."
        },
        {
          "type": "list",
          "columns": [
            "Cause",
            "What happens",
            "Fix"
          ],
          "rows": [
            [
              "Missing <code>return</code> in a component",
              "Component returns <code>undefined</code> → React error / nothing displayed.",
              "Use explicit <code>return</code> or implicit return with parentheses."
            ],
            [
              "Arrow function with <code>{}</code> but no <code>return</code>",
              "Same: returns <code>undefined</code>.",
              "Change to <code>() =&gt; (&lt;div /&gt;)</code> or add <code>return</code>."
            ],
            [
              "Conditional early return",
              "<code>return null</code> hides UI until condition passes.",
              "Make sure the condition eventually becomes true; add fallback UI if needed."
            ],
            [
              "<code>condition &amp;&amp; &lt;X /&gt;</code> patterns",
              "If condition is <code>false</code>, result is <code>false</code> → nothing renders.",
              "Use ternary when you want an explicit else: <code>cond ? &lt;X /&gt; : null</code>."
            ],
            [
              "Forgetting <code>return</code> inside <code>map</code>",
              "Each item becomes <code>undefined</code> → list items render as “nothing”.",
              "Use implicit return or add <code>return</code> inside the callback."
            ]
          ],
          "caption": "Common reasons a component ends up rendering nothing"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ BUG: braces without return\nconst Bad = () => {\n  <div>Hi</div>;\n};\n\n// ✅ FIX 1: explicit return\nconst Good1 = () => {\n  return <div>Hi</div>;\n};\n\n// ✅ FIX 2: implicit return\nconst Good2 = () => (<div>Hi</div>);\n\n// ⚠️ Gotcha: && with numbers\n// If count is 0, this renders 0 (because 0 is rendered as text)\nfunction Badge({ count }) {\n  return <div>{count && <span>{count}</span>}</div>;\n}\n\n// ✅ Safer\nfunction BadgeSafe({ count }) {\n  return <div>{count > 0 ? <span>{count}</span> : null}</div>;\n}\n\n// ❌ BUG: missing return in map\nitems.map((x) => {\n  <li key={x.id}>{x.name}</li>;\n});\n\n// ✅ FIX: implicit return\nitems.map((x) => (\n  <li key={x.id}>{x.name}</li>\n));"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React renders whatever your component returns as a <code>ReactNode</code>. Returning <code>null</code>/<code>false</code> is a valid way to render nothing. The most common accidental “renders nothing” bug is returning <code>undefined</code> (missing <code>return</code>), especially with arrow functions and <code>map()</code> callbacks."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Practical notes</strong>\n\nWatch for edge case behavior, common pitfalls, and trade-offs between clarity and performance. Mention accessibility and testing considerations when the concept affects UI output or event timing."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>You conditionally hide an empty recommendations section when there are no items.<br><br><strong>Common pitfalls</strong><br><ul><li>Returning <code>undefined</code> or an empty object instead of <code>null</code>.</li><li>Using empty strings and still leaving layout gaps.</li><li>Forgetting accessibility announcements when content disappears.</li></ul><strong>Trade-off or test tip</strong><br>Prefer <code>null</code> for no render. Test that DOM nodes are absent and screen readers don’t announce hidden content.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "rendering",
      "null",
      "conditional",
      "components"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "What happens when a React component returns null?",
      "description": "Returning null or false tells React to render nothing for that component, while fragments render children without adding extra DOM nodes."
    }
  },
  {
    "id": "react-one-way-data-flow",
    "title": "Why does React enforce one-way data flow?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain why React is designed around unidirectional data flow (state/props go down, events go up). Connect it to predictability, debugging, avoiding multiple-writers problems, and React’s rendering/reconciliation model (including concurrency-friendly rendering).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React’s UI model is: <em>UI = f(state, props, context)</em>. One-way data flow means the “source of truth” lives in one place (usually the nearest common parent), and children can’t directly mutate that data. Data goes <em>down</em> via props; changes go <em>up</em> via callbacks/events. This keeps updates predictable and traceable."
        },
        {
          "type": "list",
          "columns": [
            "Reason",
            "What React gets from it",
            "Why it matters"
          ],
          "rows": [
            [
              "Single writer per piece of state",
              "Avoids competing updates from multiple places",
              "Prevents “who overwrote my value?” bugs"
            ],
            [
              "Changes are explicit (events/actions)",
              "Clear update path: handler → state update → re-render",
              "Debugging becomes follow-the-event instead of hunting side effects"
            ],
            [
              "Rendering stays a pure computation",
              "React can re-run/abort renders safely",
              "Works well with concurrent rendering and scheduling"
            ],
            [
              "Stable component boundaries",
              "Props are inputs; components are reusable",
              "Encourages composition and testability"
            ],
            [
              "Reconciliation assumptions hold",
              "React diffs trees based on inputs changing",
              "Mutations that bypass state updates cause stale UI / missed updates"
            ]
          ],
          "caption": "Why unidirectional flow is a feature, not a limitation"
        },
        {
          "type": "text",
          "text": "<strong>What “enforce” means</strong><br><br>React doesn’t magically block you from mutating an object passed as a prop. But the API nudges you hard: props are treated as read-only, and state updates are expected to go through setters/dispatch. If you mutate data outside that flow, you break React’s mental model and optimization assumptions."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\nfunction Child({ value, onChange }) {\n  return (\n    <label>\n      Value:\n      <input value={value} onChange={(e) => onChange(e.target.value)} />\n    </label>\n  );\n}\n\nexport default function Parent() {\n  const [value, setValue] = React.useState('');\n\n  // Data down: value\n  // Events up: onChange -> setValue\n  return <Child value={value} onChange={setValue} />;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>What goes wrong with “two-way” style patterns</strong><br><br>Two-way binding often means multiple places can write to the same piece of data (child + parent, or UI + model). That creates implicit coupling and hidden update loops. In React, it typically shows up as mutating props or sharing mutable objects across components."
        },
        {
          "type": "list",
          "columns": [
            "Anti-pattern",
            "Failure mode",
            "Fix"
          ],
          "rows": [
            [
              "Child mutates a prop object",
              "Parent doesn’t re-render (or re-renders unpredictably); UI becomes inconsistent",
              "Treat props as immutable; update via callbacks and immutable copies"
            ],
            [
              "Shared mutable module-level state",
              "Updates bypass React scheduling; hard-to-trace rerenders",
              "Move into React state/store; update via setState/dispatch"
            ],
            [
              "Child “owns” state but parent also derives from it",
              "Double sources of truth; stale derived UI",
              "Lift state up to the common owner (single source of truth)"
            ]
          ],
          "caption": "The real problem is multiple writers and hidden coupling"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ BAD: mutating a prop object (breaks one-way assumptions)\nfunction Child({ user }) {\n  function rename() {\n    user.name = 'New Name'; // mutation\n  }\n\n  return (\n    <>\n      <div>{user.name}</div>\n      <button onClick={rename}>Rename</button>\n    </>\n  );\n}\n\n// ✅ GOOD: parent owns state; child requests changes\nfunction ChildGood({ user, onRename }) {\n  return (\n    <>\n      <div>{user.name}</div>\n      <button onClick={() => onRename('New Name')}>Rename</button>\n    </>\n  );\n}\n\nfunction ParentGood() {\n  const [user, setUser] = React.useState({ id: 1, name: 'Ada' });\n\n  return (\n    <ChildGood\n      user={user}\n      onRename={(name) => setUser((u) => ({ ...u, name }))}\n    />\n  );\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>React is optimized for predictable updates: inputs flow down, updates happen through explicit events, and renders stay pure. One-way flow prevents multiple sources of truth and makes state changes easy to trace (especially important as React can re-render/retry work in modern rendering)."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React prefers one-way data flow because it gives a single source of truth, explicit update paths, and render safety. That unlocks simpler reasoning, easier debugging, and rendering optimizations (including concurrency-friendly scheduling) that fall apart when components can “push” state into each other implicitly."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "state",
      "props",
      "architecture",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Why does React use one-way data flow?",
      "description": "React uses one-way data flow to keep updates predictable: data moves down through props and updates move up through events or callbacks."
    }
  },
  {
    "id": "react-why-props-immutable",
    "title": "Why are props immutable in React, and what breaks if they aren’t?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain why React treats props as read-only inputs (UI = f(props, state, context)). Connect this to predictable rendering, parent ownership, referential equality optimizations (PureComponent/React.memo), and why mutating props can cause missed updates, shared-state bugs, and inconsistent UI—especially under concurrent rendering and StrictMode.",
    "seo": {
      "title": "Why are props immutable in React?",
      "description": "Props are immutable in React because parent components own them, and mutating them in children breaks predictable updates and memoization."
    },
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Props are <em>inputs</em> owned by the parent. React’s mental model is: <code>UI = f(props, state, context)</code>. If a child can mutate its inputs, rendering stops being a pure computation and you get hidden side effects and shared mutable state across components."
        },
        {
          "type": "list",
          "columns": [
            "Why props are read-only",
            "What React assumes",
            "What you gain"
          ],
          "rows": [
            [
              "Parent owns the data",
              "Only the parent decides when/why props change",
              "Clear ownership + easier reasoning"
            ],
            [
              "Render should be pure",
              "Same inputs => same output",
              "Safe re-renders, retries, and dev StrictMode stress tests"
            ],
            [
              "Optimizations rely on identity",
              "Shallow comparisons (memo/PureComponent) are meaningful",
              "Skipping work becomes correct and predictable"
            ]
          ],
          "caption": "Immutability is a contract that keeps rendering deterministic and debuggable"
        },
        {
          "type": "text",
          "text": "<strong>What breaks if you mutate props</strong><br><br>JavaScript won’t stop you from mutating objects/arrays passed via props, but React will still treat props as if they were immutable. That mismatch causes bugs."
        },
        {
          "type": "list",
          "columns": [
            "Breakage",
            "What it looks like",
            "Why it happens"
          ],
          "rows": [
            [
              "Missed re-renders / stale UI",
              "You change a field, but UI doesn’t update (or updates inconsistently)",
              "Parent didn’t produce a new reference; memo/shallow compare thinks “nothing changed”"
            ],
            [
              "Shared mutable state bugs",
              "One child “mysteriously” affects another sibling",
              "They both reference the same mutated object/array"
            ],
            [
              "Invalid assumptions in concurrent rendering",
              "Weird flickers, order-dependent bugs, “it depends on timing”",
              "React may render, pause, retry; mutations during render leak across attempts"
            ],
            [
              "Debugging becomes painful",
              "You can’t trace where the data changed",
              "Mutation hides the real source of change (no single writer)"
            ]
          ],
          "caption": "Mutating props breaks the parent->child contract and React’s optimization model"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\nconst UserCard = React.memo(function UserCard({ user }) {\n  // ❌ Mutating a prop object\n  user.lastSeenAt = Date.now();\n\n  return (\n    <div>\n      <div>{user.name}</div>\n      <div>lastSeenAt: {user.lastSeenAt}</div>\n    </div>\n  );\n});\n\nexport default function App() {\n  const [user, setUser] = React.useState({ id: 1, name: 'Ada', lastSeenAt: 0 });\n\n  // Parent does NOT create a new object unless setUser is called.\n  // UserCard is memoized; shallow compare sees same `user` reference and may skip re-render.\n  return (\n    <>\n      <UserCard user={user} />\n      <button onClick={() => setUser((u) => ({ ...u, name: u.name + '!' }))}>\n        Update name (new object)\n      </button>\n    </>\n  );\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Another classic footgun: mutating arrays</strong><br><br>Sorting, pushing, splicing, or reversing a prop array mutates in-place and can corrupt parent/sibling views."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function List({ items }) {\n  // ❌ Mutates parent-owned array in-place\n  items.sort((a, b) => a.label.localeCompare(b.label));\n\n  return <ul>{items.map((x) => <li key={x.id}>{x.label}</li>)}</ul>;\n}\n\n// ✅ Make a copy\nfunction ListSafe({ items }) {\n  const sorted = [...items].sort((a, b) => a.label.localeCompare(b.label));\n  return <ul>{sorted.map((x) => <li key={x.id}>{x.label}</li>)}</ul>;\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "If you need to “change props”…",
            "Do this instead"
          ],
          "rows": [
            [
              "Child needs to request an update",
              "Pass a callback prop (events up), parent updates state and passes new props down"
            ],
            [
              "Need derived data",
              "Compute immutably (copy + transform) inside render or memoize with useMemo if expensive"
            ],
            [
              "Need local editable state",
              "Initialize local state from props carefully (and handle updates explicitly)"
            ]
          ],
          "caption": "Props are inputs; changes flow via state updates and callbacks"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Props are immutable because React’s rendering model assumes components are pure functions of their inputs, and because performance optimizations depend on stable identity + parent ownership. If you mutate props, you introduce hidden side effects: missed updates, cross-component contamination, and timing-sensitive bugs—especially with memoization and concurrent rendering."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "props",
      "immutability",
      "data-flow",
      "basics"
    ],
    "updatedAt": "2026-01-30"
  },
  {
    "id": "react-usestate-purpose",
    "title": "Why useState() exists in React (and what it actually guarantees)",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Explain what useState() is for (local component state), what it returns, how updates trigger re-renders, and the key mental models interviewers expect: initial state (including lazy init), functional updates, batching, Object.is bailout, and why you must treat state as immutable.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>useState()</code> gives a function component <em>persistent local state</em> across renders. When you call its setter, React schedules a re-render of that component so the UI can be recalculated from the new state. The key model is: <code>UI = f(props, state)</code> — you don’t manually update the DOM."
        },
        {
          "type": "list",
          "columns": [
            "What you get",
            "What it means",
            "Why it matters"
          ],
          "rows": [
            [
              "A state value",
              "The current snapshot for this render",
              "Rendering reads state; it does not mutate it"
            ],
            [
              "A setter function",
              "Schedules an update (it does not instantly change the variable)",
              "React decides when to render/commit; avoids inconsistent UI"
            ],
            [
              "State is tied to position in the tree",
              "State is preserved across renders while the component stays mounted",
              "Unmount/remount (or key changes) resets state"
            ]
          ],
          "caption": "What useState actually provides"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = React.useState(0);\n\n  return (\n    <button onClick={() => setCount((c) => c + 1)}>\n      Count: {count}\n    </button>\n  );\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Why the functional update form matters</strong><br><br>If the next state depends on the previous state, use <code>setX(prev =&gt; next)</code>. This avoids stale reads when multiple updates happen close together or are batched."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Bad() {\n  const [n, setN] = React.useState(0);\n\n  // ❌ can be stale if called multiple times in one tick\n  const incTwice = () => {\n    setN(n + 1);\n    setN(n + 1);\n  };\n\n  return <button onClick={incTwice}>{n}</button>;\n}\n\nfunction Good() {\n  const [n, setN] = React.useState(0);\n\n  // ✅ each update reads the latest queued value\n  const incTwice = () => {\n    setN((x) => x + 1);\n    setN((x) => x + 1);\n  };\n\n  return <button onClick={incTwice}>{n}</button>;\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Interview-level detail",
            "Correct statement",
            "Practical takeaway"
          ],
          "rows": [
            [
              "Initial state",
              "<code>useState(initial)</code> uses the initial value only on the first mount",
              "If you need expensive computation, use lazy init: <code>useState(() =&gt; compute())</code>"
            ],
            [
              "Bailout",
              "If the new state is <code>Object.is</code>-equal to the old state, React can skip re-rendering",
              "Don’t create new objects/arrays unless something actually changed"
            ],
            [
              "Batching",
              "React may batch multiple state updates into one render",
              "Don’t rely on “immediate” state after calling the setter"
            ],
            [
              "Immutability",
              "Mutating state in place breaks React’s change detection assumptions",
              "Always create new references when updating objects/arrays"
            ]
          ],
          "caption": "The key guarantees and caveats around useState"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function TodoApp() {\n  // ✅ Lazy init (runs only once on mount)\n  const [todos, setTodos] = React.useState(() => {\n    const raw = localStorage.getItem('todos');\n    return raw ? JSON.parse(raw) : [];\n  });\n\n  // ✅ Immutable update (new array)\n  function addTodo(text) {\n    setTodos((prev) => [...prev, { id: crypto.randomUUID(), text }]);\n  }\n\n  // ❌ Bad: mutating state\n  function badAdd(text) {\n    todos.push({ id: 'x', text });\n    setTodos(todos); // same reference -> may not re-render\n  }\n\n  return (\n    <div>\n      <button onClick={() => addTodo('Learn useState')}>Add</button>\n      <ul>{todos.map((t) => <li key={t.id}>{t.text}</li>)}</ul>\n    </div>\n  );\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>When useState is the wrong tool</strong><br><br><code>useState</code> is for <em>local UI state</em> (toggles, inputs, selected tabs). If updates become complex (many transitions, derived actions), <code>useReducer</code> often reads better. If the state is global/shared across many branches, you typically lift it up, use Context carefully, or use a store."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>useState()</code> adds persistent local state to function components. It returns <em>[state, setState]</em>; calling the setter schedules a re-render so React can recompute the UI. Use functional updates when the next state depends on the previous state, update objects/arrays immutably, and remember that React may batch updates and can bail out when the new state is <code>Object.is</code>-equal to the old state."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "hooks",
      "state",
      "basics",
      "components"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "What does useState do in React?",
      "description": "useState lets function components store local state and trigger re-renders by calling the state setter."
    }
  },
  {
    "id": "react-why-event-delegation",
    "title": "Why does React use event delegation instead of native listeners?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Explain how React’s event system works (SyntheticEvent + root-level listeners) and why delegation is used: fewer listeners, easier updates for dynamic trees, consistent cross-browser behavior, and better integration with React’s scheduling/batching. Mention the React 17+ change (listeners attached to the root container instead of document) and common trade-offs (native vs synthetic, non-bubbling events).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React usually doesn’t attach a native DOM listener to every element that has <code>onClick</code>/<code>onChange</code>, etc. Instead, it attaches a small set of listeners at the <em>root container</em> and uses <em>event delegation</em>: when the browser event bubbles up, React catches it once and dispatches it to the correct component handler via its internal tree."
        },
        {
          "type": "list",
          "columns": [
            "Why delegation",
            "What it buys React",
            "What breaks with per-node native listeners"
          ],
          "rows": [
            [
              "Fewer listeners (memory + setup cost)",
              "One listener can cover thousands of nodes",
              "Big trees would create many listeners and slow mounts/updates"
            ],
            [
              "Works with dynamic UIs",
              "No attach/detach churn as elements appear/disappear during reconciliation",
              "You’d constantly add/remove listeners on every commit"
            ],
            [
              "Consistent behavior (SyntheticEvent)",
              "Normalizes event quirks across browsers + consistent API",
              "Different native event edge cases leak into app logic"
            ],
            [
              "Tight integration with React scheduling",
              "React can assign event priority (discrete/continuous) and coordinate updates",
              "Harder to keep consistent ordering/priority if every node owns native listeners"
            ],
            [
              "Portals + component tree semantics",
              "Dispatch follows React’s tree (including across portals) rather than only DOM structure",
              "Handlers become harder to reason about when UI spans multiple DOM subtrees"
            ]
          ],
          "caption": "Delegation is about scale + correctness, not just micro-performance"
        },
        {
          "type": "text",
          "text": "<strong>How it works (mental model)</strong><br><br>1) Browser fires a native event on a target node.<br>2) The event bubbles up to the root container.<br>3) React’s root listener runs once, finds the closest React component instance for the target, then runs the matching handler(s) in the right order (capture/bubble)."
        },
        {
          "type": "code",
          "language": "js",
          "code": "// Native DOM event delegation (concept)\nconst root = document.getElementById('root');\n\nroot.addEventListener('click', (e) => {\n  const btn = e.target.closest('button[data-id]');\n  if (!btn) return;\n\n  console.log('Clicked id:', btn.dataset.id);\n});\n\n// React does something similar internally:\n// - one (or few) listeners at the root\n// - map DOM target -> React fiber/component\n// - call the matching onClick handler\n"
        },
        {
          "type": "text",
          "text": "<strong>React 17+ note</strong><br><br>React attaches event listeners to the <em>root container</em> instead of the global <code>document</code>. This avoids interference when multiple React versions/roots coexist and keeps event handling scoped to a root."
        },
        {
          "type": "list",
          "columns": [
            "Trade-off / gotcha",
            "What you’ll notice",
            "What to do"
          ],
          "rows": [
            [
              "Native vs React events",
              "<code>e</code> is a SyntheticEvent wrapper; native event is at <code>e.nativeEvent</code>",
              "Use React handlers for UI updates; use native listeners in <code>useEffect</code> only when needed"
            ],
            [
              "Non-bubbling events",
              "Some events don’t bubble in the DOM (React may emulate via capture or special handling)",
              "Know when to use capture props (e.g., <code>onFocusCapture</code>) or native listeners"
            ],
            [
              "Propagation expectations",
              "React propagation follows React’s tree semantics (including portals), not only DOM nesting",
              "When debugging, think in “React tree”, not just “DOM tree”"
            ]
          ],
          "caption": "Delegation is great, but understand the boundary with native DOM"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React uses event delegation so it can handle events with a small number of root listeners, keep behavior consistent, avoid listener churn as the UI tree changes, and integrate event handling with React’s scheduling and update model. If it attached native listeners per element, large trees would pay heavy setup/teardown costs and React would lose control over consistent dispatch + prioritization."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "events",
      "event-handling",
      "performance",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Why does React use event delegation?",
      "description": "React uses event delegation by attaching a small set of root listeners and dispatching events to components through its event system."
    }
  },
  {
    "id": "react-keys-in-lists",
    "title": "What is the significance of keys in lists in React?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Keys in React help identify which list items have changed, been added, or been removed. They make the reconciliation process efficient by allowing React to re-render only the modified elements instead of rebuilding the entire list.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>When rendering lists in React using <code>map()</code>, each item should have a unique <code>key</code> prop. Keys help React track elements between renders, improving performance and preventing bugs during dynamic updates or reordering."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function TodoList({ items }) {\n  return (\n    <ul>\n      {items.map((item) => (\n        <li key={item.id}>{item.text}</li>\n      ))}\n    </ul>\n  );\n}"
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Explanation"
          ],
          "rows": [
            [
              "Uniqueness",
              "Each key must be unique among siblings (but not globally)."
            ],
            [
              "Identity Tracking",
              "Helps React distinguish between elements when data changes."
            ],
            [
              "Reconciliation",
              "Keys optimize the virtual DOM diffing process by mapping elements efficiently."
            ],
            [
              "Dynamic Updates",
              "Prevents unnecessary re-renders or lost input focus when items reorder."
            ]
          ],
          "caption": "How keys influence React's rendering behavior"
        },
        {
          "type": "text",
          "text": "<strong>Example: Without Keys</strong><br>When keys are missing, React may reuse components incorrectly, leading to bugs like mismatched states or input fields swapping values."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "{items.map((item, index) => (\n  <li key={index}>{item.text}</li>\n))}"
        },
        {
          "type": "text",
          "text": "Using array indices as keys works for static lists but can cause issues in lists that reorder or update dynamically."
        },
        {
          "type": "text",
          "text": "<strong>Best Practices</strong><br><ul><li>Use stable and unique identifiers like database IDs for keys.</li><li>Avoid using array indices if the list can change order or length.</li><li>Do not use random or non-deterministic values as keys — React relies on key consistency across renders.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Performance Insight</strong><br>Keys allow React’s diffing algorithm (reconciliation) to skip unchanged elements and efficiently patch only modified nodes, improving render speed and stability."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of keys like labels on moving boxes — without them, React wouldn’t know which box belongs where after reordering."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Keys uniquely identify list items during rendering.</li><li>They improve performance and prevent re-rendering bugs.</li><li>Use stable, unique values like IDs — avoid indices when possible.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "lists",
      "keys",
      "rendering",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Why are keys important in React lists?",
      "description": "Keys give list items stable identity so React can correctly match, move, and preserve state during reconciliation."
    }
  },
  {
    "id": "react-controlled-vs-uncontrolled",
    "title": "What is the difference between controlled and uncontrolled components?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Controlled components in React are those whose form data is managed by React state, while uncontrolled components manage their own state internally through the DOM. Controlled components offer more predictable, testable, and synchronized data flow, whereas uncontrolled components are simpler but less flexible. Controlled inputs enable validation and state sync but can be verbose; uncontrolled inputs are simpler but harder to test. Test with form reset and validation.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>React provides two ways to handle form inputs: <em>controlled</em> and <em>uncontrolled</em> components. Controlled components rely on React state as the single source of truth, while uncontrolled components use the DOM’s internal state via <code>ref</code> to manage data."
        },
        {
          "type": "list",
          "columns": [
            "Type",
            "Description",
            "Data Source"
          ],
          "rows": [
            [
              "Controlled Component",
              "React state controls the input value. Each keystroke triggers a state update.",
              "React state"
            ],
            [
              "Uncontrolled Component",
              "Input value is handled by the DOM itself and accessed via <code>ref</code> when needed.",
              "DOM element"
            ]
          ],
          "caption": "Key differences between controlled and uncontrolled components"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Controlled Component\nfunction ControlledInput() {\n  const [value, setValue] = useState('');\n  return (\n    <input value={value} onChange={(e) => setValue(e.target.value)} />\n  );\n}\n\n// Uncontrolled Component\nfunction UncontrolledInput() {\n  const inputRef = useRef(null);\n  const handleSubmit = () => alert(inputRef.current.value);\n  return (\n    <>\n      <input ref={inputRef} />\n      <button onClick={handleSubmit}>Submit</button>\n    </>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>When to Use Each</strong><br><ul><li><strong>Controlled Components:</strong> When you need form validation, dynamic behavior, or real-time updates (e.g., search inputs, login forms).</li><li><strong>Uncontrolled Components:</strong> When simple or legacy forms are needed, and performance or quick prototyping is prioritized.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Pros and Cons</strong><br><ul><li><strong>Controlled:</strong> Predictable, easier to debug, suitable for complex interactions.</li><li><strong>Uncontrolled:</strong> Simpler, faster for basic use cases, but harder to validate and synchronize with app state.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Controlled components put React in charge of the form state — think of it as React 'holding the pen' while you type."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Controlled components store input values in React state.</li><li>Uncontrolled components rely on DOM references.</li><li>Controlled inputs are ideal for validation, while uncontrolled are simpler but less powerful.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A login form needs validation and error messages, so inputs are controlled by React state.<br><br><strong>Common pitfalls</strong><br><ul><li>Mixing controlled and uncontrolled inputs in the same field.</li><li>Forgetting defaultValue when using uncontrolled inputs.</li><li>Causing re-render lag on large forms.</li></ul><strong>Trade-off or test tip</strong><br>Controlled inputs are testable but verbose. Test form reset and validation flows.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "forms",
      "state",
      "inputs",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Controlled vs uncontrolled inputs in React: what's the difference?",
      "description": "Controlled inputs store value in React state, while uncontrolled inputs keep state in the DOM and are usually accessed with refs."
    }
  },
  {
    "id": "react-default-vs-named-exports-runtime-break",
    "title": "How can incorrect default vs named exports break a React application at runtime?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 2,
    "description": "Incorrectly mixing default exports and named exports can cause React to import the wrong thing (often undefined). The app may compile, but crash at runtime when React tries to render a component that isn’t actually a component. This often shows up as a runtime crash, so testing and lint rules are critical.",
    "seo": {
      "title": "Default vs named exports in React: why do import errors happen?",
      "description": "Mixing up default and named imports resolves the component to undefined and can cause runtime errors like invalid element type."
    },
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React doesn’t render “imports” — it renders the <em>value</em> you pass as a component. If you import the wrong symbol, you often end up with <code>undefined</code> (or a plain object). React then throws at runtime when it tries to treat that value like a component."
        },
        {
          "type": "list",
          "columns": [
            "Export style",
            "Import style",
            "Typical runtime result",
            "Fix"
          ],
          "rows": [
            [
              "Default export: <code>export default Button</code>",
              "Wrong: <code>import { Button } from './Button'</code>",
              "Button becomes <code>undefined</code> → React error: <code>Element type is invalid...</code>",
              "Use <code>import Button from './Button'</code>"
            ],
            [
              "Named export: <code>export const Button = ...</code>",
              "Wrong: <code>import Button from './Button'</code>",
              "Button becomes <code>undefined</code> (or a module wrapper) → runtime crash",
              "Use <code>import { Button } from './Button'</code>"
            ],
            [
              "Barrel re-export mistake",
              "Import from <code>index.ts</code> expecting a symbol that isn’t exported",
              "Import resolves but value is missing → <code>undefined</code> at render time",
              "Fix barrel: export the symbol correctly"
            ],
            [
              "Default export renamed during re-export",
              "<code>export { default } from './Button'</code> but you import <code>{ Button }</code>",
              "Named import is missing → <code>undefined</code>",
              "Re-export with a name: <code>export { default as Button } ...</code>"
            ]
          ],
          "caption": "Common export/import mismatches that cause runtime crashes"
        },
        {
          "type": "text",
          "text": "<strong>The classic crash</strong><br><br>When React tries to render <code>undefined</code> as a component, you commonly see:<br><code>Element type is invalid: expected a string (for built-in components) or a class/function but got: undefined</code>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Button.jsx\nexport default function Button() {\n  return <button>OK</button>;\n}\n\n// App.jsx (WRONG)\nimport { Button } from './Button';\n\nexport default function App() {\n  return <Button />; // Button === undefined -> runtime crash\n}\n\n// App.jsx (RIGHT)\nimport Button from './Button';\n"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Button.jsx\nexport function Button() {\n  return <button>OK</button>;\n}\n\n// App.jsx (WRONG)\nimport Button from './Button';\n\nexport default function App() {\n  return <Button />; // Button is not the named export -> undefined -> crash\n}\n\n// App.jsx (RIGHT)\nimport { Button } from './Button';\n"
        },
        {
          "type": "text",
          "text": "<strong>Why it can slip past “build success”</strong><br><br>Depending on tooling (JS vs TS strictness, Babel settings, path aliases, barrel files), the import might not error at compile time. But at runtime, the imported value is still wrong (often <code>undefined</code>), and React only discovers it when rendering."
        },
        {
          "type": "list",
          "columns": [
            "Quick debug step",
            "What you’re checking",
            "What it usually reveals"
          ],
          "rows": [
            [
              "Log the import",
              "<code>console.log(Button)</code> right before rendering",
              "If you see <code>undefined</code> or an object, you imported wrong"
            ],
            [
              "Open the module file",
              "Check the exact export statements",
              "Whether it’s <code>export default</code> or <code>export const</code>"
            ],
            [
              "Check barrel/index files",
              "Is the symbol re-exported correctly?",
              "Missing or incorrectly named re-exports are common"
            ],
            [
              "Search for duplicate files/paths",
              "Same component name in multiple locations",
              "You might be importing a different file than you think"
            ]
          ],
          "caption": "Fast runtime triage checklist"
        },
        {
          "type": "text",
          "text": "<strong>Best practice</strong><br><br>Pick a team convention and enforce it with lint rules. Many teams prefer <em>named exports</em> for components (easier refactors + consistent imports), and reserve <em>default exports</em> for special cases (single main export modules). Consistency reduces these runtime failures."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>You import a component from a shared UI library and see \"Element type is invalid\" at runtime due to export mismatch.<br><br><strong>Common pitfalls</strong><br><ul><li>Mixing default and named exports in barrel files.</li><li>Refactoring exports without updating all imports.</li><li>Circular imports hiding the real error.</li></ul><strong>Trade-off or test tip</strong><br>Named exports improve clarity but require consistent usage. Test with type checks and component render tests.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "modules",
      "exports",
      "imports",
      "basics"
    ],
    "updatedAt": "2026-01-30"
  },
  {
    "id": "react-conditional-rendering",
    "title": "Conditional rendering in React: patterns, trade-offs, and gotchas",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Conditional rendering in React means showing different UI based on state or props. Common patterns include && for simple toggles, ternaries for two branches, and early returns for guards. This keeps rendering logic explicit and makes components easier to read. Conditional UI affects accessibility and layout stability. Test empty states, transitions, and focus behavior.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Conditional rendering in React is just JavaScript: your component returns different <code>ReactNode</code> values depending on conditions (state/props/context). React renders whatever you return. Returning <code>null</code> (or <code>false</code>) means “render nothing”."
        },
        {
          "type": "list",
          "columns": [
            "Pattern",
            "What you write",
            "Best when"
          ],
          "rows": [
            [
              "Guard clause (early return)",
              "<code>if (cond) return A; return B;</code>",
              "One branch is a clear gate (loading/auth/empty/error)"
            ],
            [
              "Inline ternary",
              "<code>{cond ? A : B}</code>",
              "Two short alternatives in JSX"
            ],
            [
              "Render-only-when-true (&&)",
              "<code>{cond && A}</code>",
              "You only need the “true” branch (else = nothing)"
            ],
            [
              "Switch / mapping",
              "<code>views[state] ?? fallback</code>",
              "Multiple states (idle/loading/error/success)"
            ],
            [
              "Extract to variable/function",
              "<code>const content = ...</code>",
              "JSX gets messy; want readability + testability"
            ]
          ],
          "caption": "Common conditional rendering patterns"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// 1) Guard clause (early return)\nfunction UserView({ user, isLoading, error }) {\n  if (isLoading) return <Spinner />;\n  if (error) return <ErrorBanner message={error.message} />;\n  if (!user) return null; // render nothing\n\n  return <Profile user={user} />;\n}\n"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// 2) Inline ternary\nfunction Greeting({ isLoggedIn }) {\n  return (\n    <h1>\n      {isLoggedIn ? 'Welcome back!' : 'Please sign in.'}\n    </h1>\n  );\n}\n"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// 3) Logical AND (render only when true)\nfunction Notifications({ messages }) {\n  const count = messages.length;\n\n  return (\n    <>\n      {count > 0 && <p>You have {count} new messages.</p>}\n    </>\n  );\n}\n"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// 4) Switch / mapping (multiple UI states)\nfunction Page({ status }) {\n  const views = {\n    idle: <p>Ready</p>,\n    loading: <Spinner />,\n    error: <ErrorBanner message=\"Something failed\" />,\n    success: <DataView />\n  };\n\n  return views[status] ?? <p>Unknown status</p>;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Common gotchas</strong><br><br>Most bugs come from (1) non-boolean values with <code>&&</code>, (2) returning <code>undefined</code> by accident, or (3) unreadable nested conditions."
        },
        {
          "type": "list",
          "columns": [
            "Gotcha",
            "What happens",
            "Fix"
          ],
          "rows": [
            [
              "<code>{count && <Badge />}</code> with <code>count = 0</code>",
              "Renders <code>0</code> as text (because 0 is renderable)",
              "Use <code>count > 0 ? <Badge /> : null</code>"
            ],
            [
              "Arrow function with braces but no return",
              "Component returns <code>undefined</code> → “Nothing was returned from render”",
              "Use <code>() => ( ... )</code> or add <code>return</code>"
            ],
            [
              "Nested ternaries",
              "Hard to read/debug; easy to mis-handle edge cases",
              "Extract to variable/function or use a mapping"
            ],
            [
              "Inline objects/functions used as conditions/props",
              "Identity changes can cause extra renders, not a rendering bug but a perf trap",
              "Stabilize only where it matters (<code>memo</code> boundaries)"
            ]
          ],
          "caption": "Typical conditional rendering pitfalls"
        },
        {
          "type": "text",
          "text": "<strong>Mounting matters: preserve vs reset component state</strong><br><br>Conditional rendering often means <em>mount/unmount</em>. Unmounting resets local state. If you need to preserve internal state, keep the component mounted and hide it instead."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Unmounts when closed (state resets on reopen)\nfunction App({ open }) {\n  return open ? <Modal /> : null;\n}\n\n// Keeps mounted (state preserved), just hidden\nfunction AppPreserve({ open }) {\n  return <Modal style={{ display: open ? 'block' : 'none' }} />;\n}\n"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Forcing a reset on purpose: change the key\nfunction ProfileEditor({ userId }) {\n  return <Editor key={userId} userId={userId} />;\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Rule of thumb",
            "Why"
          ],
          "rows": [
            [
              "Use guard clauses for gating (loading/error/auth/empty)",
              "Keeps JSX clean and makes branches obvious"
            ],
            [
              "Use ternary when you truly have two alternatives",
              "Makes the “else” explicit (vs implicit nothing)"
            ],
            [
              "Use <code>&&</code> only with boolean conditions",
              "Avoid rendering <code>0</code> / empty strings accidentally"
            ],
            [
              "For 3+ states, use a mapping/switch",
              "Scales better than nested ternaries"
            ],
            [
              "Be intentional about mount/unmount",
              "Unmount resets local state; hiding preserves it"
            ]
          ],
          "caption": "Best practices that interviewers expect"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Conditional rendering is simply returning different <code>ReactNode</code> outputs based on conditions. Choose a pattern by complexity: guard clauses for gating, ternaries for two options, and mappings/switches for multiple states. Be careful with <code>&&</code> when the condition might be a non-boolean (especially <code>0</code>). Finally, remember that mount/unmount controls whether local component state is preserved or reset (and <code>key</code> can force a reset when needed)."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Show a loading spinner until data arrives, then replace it with content.<br><br><strong>Common pitfalls</strong><br><ul><li>Layout jump when components mount/unmount.</li><li>Focus loss when elements are removed.</li><li>Rendering heavy components unnecessarily.</li></ul><strong>Trade-off or test tip</strong><br>Conditional render is simple but can cause UX shifts. Test loading transitions and focus retention.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "conditional-rendering",
      "patterns",
      "jsx",
      "best-practices"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "How do you do conditional rendering in React?",
      "description": "React conditional rendering uses if statements, ternaries, or && to show different UI based on state and props."
    }
  },
  {
    "id": "react-useeffect-purpose",
    "title": "useEffect() in React: syncing with the outside world (timing, dependencies, cleanup)",
    "technology": "react",
    "companies": [
      "bytedance"
    ],
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what useEffect is actually for (synchronizing with external systems), when it runs (after commit), how dependencies control re-running, and how cleanup prevents leaks. Cover common patterns (fetching, subscriptions, timers) and common pitfalls (stale closures, infinite loops, derived state in effects).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>useEffect()</code> is React’s API for <em>side effects</em>: code that must run <em>outside</em> rendering to keep your component synchronized with something external (network, subscriptions, browser APIs, timers, logging/analytics).<br><br>Key mental model: <strong>render computes UI</strong> (pure), then React <strong>commits</strong> DOM changes, then <code>useEffect</code> runs to “sync with the world.”"
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "What it means",
            "Why it matters"
          ],
          "rows": [
            [
              "Runs after commit",
              "Effects run after React has committed updates to the DOM (they don’t run during render).",
              "You avoid doing real-world work in render (render may run multiple times)."
            ],
            [
              "Cleanup is part of the contract",
              "An effect can return a cleanup function.",
              "React runs cleanup before re-running the effect and on unmount (prevents leaks)."
            ],
            [
              "Dependencies define when to re-sync",
              "The dependency array tells React when your effect’s inputs changed.",
              "Correct deps prevent stale values and accidental infinite loops."
            ]
          ],
          "caption": "What useEffect is for (interview-grade mental model)"
        },
        {
          "type": "text",
          "text": "<strong>Dependency array rules (what actually happens)</strong><br><br>React decides whether to re-run an effect by comparing dependency values with <code>Object.is</code>."
        },
        {
          "type": "list",
          "columns": [
            "Dependency form",
            "When it runs",
            "Typical usage"
          ],
          "rows": [
            [
              "<code>[]</code>",
              "Runs on mount; cleanup runs on unmount.",
              "Set up/tear down a subscription, event listener, timer."
            ],
            [
              "<code>[a, b]</code>",
              "Runs on mount and whenever <code>a</code> or <code>b</code> changes; cleanup runs before each re-run.",
              "Re-sync when specific inputs change (e.g., <code>userId</code>, <code>query</code>, <code>enabled</code>)."
            ],
            [
              "No array",
              "Runs after every commit; cleanup runs before each re-run.",
              "Rare; usually a smell (often missing deps)."
            ]
          ],
          "caption": "How dependencies control re-running + cleanup timing"
        },
        {
          "type": "text",
          "text": "<strong>Edge cases: objects, arrays, and refs in deps</strong><br><br>React compares deps with <code>Object.is</code>. If you create a new object/array/function in render, it is a new identity each render, so the effect re-runs every time. Fix by memoizing (<code>useMemo</code>/<code>useCallback</code>) or moving the value outside render. Refs are different: the <code>ref</code> object from <code>useRef</code> is stable, so adding <code>ref</code> to deps usually does nothing. Changes to <code>ref.current</code> do not trigger re-renders, so do not expect deps to react to it; use state or a callback ref when you need to respond to DOM changes."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\nexport default function DocumentTitle({ count }) {\n  // Sync with a browser API (document title)\n  React.useEffect(() => {\n    document.title = `Count: ${count}`;\n  }, [count]);\n\n  return <div>Count: {count}</div>;\n}\n"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\nexport function ResizeLogger() {\n  React.useEffect(() => {\n    const onResize = () => console.log('width:', window.innerWidth);\n    window.addEventListener('resize', onResize);\n\n    // Cleanup prevents leaks + duplicate listeners\n    return () => window.removeEventListener('resize', onResize);\n  }, []);\n\n  return <div>Resize the window</div>;\n}\n"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\nexport function IntervalCounter() {\n  const [n, setN] = React.useState(0);\n\n  React.useEffect(() => {\n    const id = setInterval(() => {\n      // Use functional update to avoid stale state\n      setN((x) => x + 1);\n    }, 1000);\n\n    return () => clearInterval(id);\n  }, []);\n\n  return <div>{n}</div>;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Data fetching pattern (avoid stale results)</strong><br><br>Fetching is a side effect. The common issue is: the component re-renders with a new <code>userId</code> while an older request is still in flight. You need a cancellation/ignore strategy."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\nexport function UserProfile({ userId }) {\n  const [user, setUser] = React.useState(null);\n  const [error, setError] = React.useState(null);\n\n  React.useEffect(() => {\n    const controller = new AbortController();\n\n    (async () => {\n      try {\n        setError(null);\n        const res = await fetch(`/api/users/${userId}`, { signal: controller.signal });\n        if (!res.ok) throw new Error('Request failed');\n        const data = await res.json();\n        setUser(data);\n      } catch (e) {\n        if (controller.signal.aborted) return; // ignore abort\n        setError(e);\n      }\n    })();\n\n    return () => controller.abort();\n  }, [userId]);\n\n  if (error) return <div>Failed</div>;\n  if (!user) return <div>Loading...</div>;\n  return <div>{user.name}</div>;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Common pitfalls (what interviewers watch for)</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Pitfall",
            "What goes wrong",
            "Fix"
          ],
          "rows": [
            [
              "Missing dependencies",
              "Effect reads stale values/props because it captured an old closure.",
              "Include every value used inside the effect in the dependency list, or restructure (move logic into effect, use refs for mutable non-render state)."
            ],
            [
              "Infinite loop",
              "Effect sets state that changes a dependency, which re-runs the effect forever.",
              "Don’t use effects to derive state from state; compute derived values during render or use memoization."
            ],
            [
              "Async effect function directly",
              "Writing <code>useEffect(async () =&gt; { ... })</code> returns a Promise instead of cleanup.",
              "Wrap async work inside the effect and return a real cleanup function."
            ],
            [
              "Using useEffect for pure derivations",
              "Extra renders + harder logic (state duplication).",
              "If it can be computed from props/state, compute it in render (or <code>useMemo</code> if expensive)."
            ]
          ],
          "caption": "Most real-world bugs come from deps, stale closures, or using effects as “state sync”"
        },
        {
          "type": "text",
          "text": "<strong>useEffect vs useLayoutEffect</strong><br><br><code>useEffect</code> is the default. Use <code>useLayoutEffect</code> only when you must read layout or synchronously write to the DOM before the browser paints (measurement, scroll positioning). Overusing <code>useLayoutEffect</code> can hurt performance because it can block paint."
        },
        {
          "type": "text",
          "text": "<strong>StrictMode note (dev)</strong><br><br>In development with <code>&lt;React.StrictMode&gt;</code>, React may run an effect’s setup + cleanup twice on mount to surface unsafe side effects. This is why effects must be idempotent and clean up correctly."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li><code>useEffect</code> is for <em>synchronizing</em> a component with external systems (network, subscriptions, timers, browser APIs) after React commits UI.</li><li>The dependency array defines <em>when</em> React should re-run the effect; cleanup runs before re-run and on unmount.</li><li>Common bugs: missing deps (stale closures), effect-driven derived state (loops), and forgetting cleanup (leaks).</li><li>Default to <code>useEffect</code>; use <code>useLayoutEffect</code> only for layout-sensitive DOM work.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "hooks",
      "effects",
      "lifecycle",
      "basics"
    ],
    "updatedAt": "2026-01-31",
    "seo": {
      "title": "What is useEffect used for in React?",
      "description": "useEffect is used to run side effects after render, such as subscriptions, data fetching, timers, or syncing with external systems."
    }
  },
  {
    "id": "react-fragments-dom-and-reconciliation",
    "title": "How do fragments affect the rendered DOM and reconciliation?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Explain what React fragments change in the real DOM (no extra wrapper node) and what they still represent in React’s tree (a Fragment fiber). Connect this to reconciliation: identity/type matching, keys (especially keyed fragments in lists), and common remount/state-loss gotchas when adding/removing a fragment wrapper.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>A fragment (<code>&lt;&gt;...&lt;/&gt;</code> / <code>React.Fragment</code>) is <em>invisible in the browser DOM</em> (no extra element node), but it is <em>still a node in React’s internal tree</em>. That means it affects reconciliation (how React matches old vs new children), even though it doesn’t produce a DOM wrapper."
        },
        {
          "type": "list",
          "columns": [
            "Topic",
            "What happens",
            "Why it matters"
          ],
          "rows": [
            [
              "Rendered DOM",
              "Fragment adds <em>no</em> extra DOM element; only its children are inserted",
              "No accidental wrappers that break CSS layout, semantics (<code>&lt;tr&gt;</code>, <code>&lt;li&gt;</code>), or accessibility structure"
            ],
            [
              "React tree",
              "React still creates a Fragment “fiber” that groups children",
              "Reconciliation can treat “Fragment vs not Fragment” as a type change (can remount)"
            ],
            [
              "Props/attributes",
              "Fragments don’t create a DOM node, so you can’t attach DOM attributes/events/layout hooks to “the fragment itself”",
              "If you need a className, ref to a DOM element, or an event boundary, you need a real element wrapper"
            ]
          ],
          "caption": "Fragments: invisible in DOM, visible to React"
        },
        {
          "type": "text",
          "text": "<strong>How reconciliation sees fragments</strong><br><br>Reconciliation matches elements by <em>type + key + position</em>. A fragment has a distinct element type (<code>Fragment</code>). So introducing/removing a fragment wrapper can change the element type at that position, and React may tear down and recreate that subtree."
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "What React compares",
            "Typical result"
          ],
          "rows": [
            [
              "Same fragment, children change",
              "Fragment type stays; React diffs children inside it",
              "Child components can preserve state if their own identity is stable"
            ],
            [
              "Fragment ↔ element wrapper swap (<code>&lt;&gt;</code> vs <code>&lt;div&gt;</code>)",
              "Type changes at that position",
              "Subtree often remounts (state reset) because old fiber is replaced"
            ],
            [
              "Fragment present ↔ fragment removed (wrapping/unwrapping)",
              "Type at the position changes (Fragment vs Child)",
              "Can remount the child even if it “looks like the same UI”"
            ],
            [
              "Fragments in lists with keys",
              "Keyed Fragment gives identity to a <em>group</em> of siblings",
              "Prevents incorrect reuse when returning multiple siblings per list item"
            ]
          ],
          "caption": "What fragments change in reconciliation"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ✅ DOM stays clean (no wrapper)\nfunction Header() {\n  return (\n    <>\n      <h1>Title</h1>\n      <p>Subtitle</p>\n    </>\n  );\n}\n\n// DOM output is roughly:\n// <h1>Title</h1>\n// <p>Subtitle</p>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ✅ Keyed Fragment in a list (group multiple siblings per item)\nfunction DefinitionList({ items }) {\n  return (\n    <dl>\n      {items.map((x) => (\n        <React.Fragment key={x.id}>\n          <dt>{x.term}</dt>\n          <dd>{x.desc}</dd>\n        </React.Fragment>\n      ))}\n    </dl>\n  );\n}\n\n// Without a keyed Fragment, you'd need a wrapper element (often invalid inside <dl>)."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ⚠️ Gotcha: wrapping/unwrapping can remount (state loss)\nfunction Counter() {\n  const [n, setN] = React.useState(0);\n  return <button onClick={() => setN((x) => x + 1)}>{n}</button>;\n}\n\nfunction App({ wrap }) {\n  // If `wrap` toggles, React may replace the subtree because\n  // the element type at this position changes (Fragment vs Counter).\n  return wrap ? (\n    <>\n      <Counter />\n    </>\n  ) : (\n    <Counter />\n  );\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Gotcha",
            "What you see",
            "Fix / rule of thumb"
          ],
          "rows": [
            [
              "Using fragment when you needed a layout hook",
              "You can’t style/measure “the fragment” (no DOM node)",
              "Use a real element when you need className/ref/layout boundary"
            ],
            [
              "Swapping wrappers (Fragment vs <div>)",
              "Unexpected remount / lost local state / lost focus",
              "Keep wrapper type stable; don’t toggle between structurally different roots"
            ],
            [
              "Returning multiple siblings per list item without a keyed Fragment",
              "React warns about keys or reuses siblings incorrectly on reorder",
              "Put the <code>key</code> on <code>React.Fragment</code> (shorthand can’t take a key)"
            ]
          ],
          "caption": "Common fragment pitfalls"
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>“Fragments don’t create DOM nodes, so they keep markup/semantics clean. But they still exist in React’s tree, so they participate in reconciliation: type + key + position. Keyed fragments are mainly for lists where one item returns multiple siblings. Be careful: adding/removing/swapping the fragment wrapper can change element identity and cause remounts.”"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Fragments affect the <em>DOM</em> by removing unnecessary wrapper elements. They affect <em>reconciliation</em> because Fragment is still an element type in React’s tree: it can change identity matching (and therefore state preservation), and keyed fragments give stable identity to grouped siblings in lists."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "fragments",
      "dom",
      "rendering",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "What do React fragments do and when should you use them?",
      "description": "React fragments group children without adding extra DOM nodes, helping keep markup clean while preserving component structure."
    }
  },
  {
    "id": "react-virtual-dom",
    "title": "What is the Virtual DOM in React, and how does it relate to reconciliation?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Explain what people mean by “Virtual DOM” in React (React element tree in memory), how React re-renders to produce a new tree, how reconciliation (diffing + heuristics + keys) computes changes, and how the commit phase applies DOM mutations. Emphasize: re-render ≠ DOM update.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>In React, “Virtual DOM” usually means: <em>an in-memory tree representation of your UI</em> (React elements / fibers), not the browser DOM itself. On each update, React re-runs components to produce a <em>new</em> tree, then <strong>reconciles</strong> it with the previous tree to decide what must change. Only after that, React <strong>commits</strong> the necessary changes to the real DOM."
        },
        {
          "type": "list",
          "columns": [
            "Claim",
            "Accurate?",
            "Better wording / why it matters"
          ],
          "rows": [
            [
              "“VDOM is a copy of the real DOM.”",
              "⚠️ half-true",
              "It’s a JS representation of the UI (<code>type</code>, <code>props</code>, <code>children</code>). It models what the DOM <em>should</em> look like, not a full DOM clone."
            ],
            [
              "“React updates the minimal set of DOM changes.”",
              "⚠️ usually",
              "React uses reconciliation heuristics. With stable keys/types, it’s very efficient, but it’s not a perfect minimal-edit solver."
            ],
            [
              "“Re-render means the DOM changed.”",
              "❌",
              "Re-render means React re-ran components to compute a new UI tree. DOM mutations only happen in the commit phase if something actually differs."
            ],
            [
              "“VDOM makes React fast.”",
              "⚠️ incomplete",
              "The win is: predictable re-rendering + efficient diffing + batching. Many perf issues are still JS work, reconciliation work, or browser layout/paint."
            ]
          ],
          "caption": "Common Virtual DOM misconceptions (and the interview-correct framing)"
        },
        {
          "type": "text",
          "text": "<strong>What happens on an update</strong><br><br>When state/props/context change, React schedules work, re-runs the affected components, builds a new tree, then reconciles it against the previous one. If it detects differences, it commits DOM mutations for only those differences."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = React.useState(0);\n\n  // When you click:\n  // 1) React re-runs Counter() to compute a new element tree\n  // 2) Reconciliation compares old vs new children\n  // 3) Commit applies the minimal DOM changes (often just the text node)\n  return (\n    <button onClick={() => setCount((c) => c + 1)}>\n      Count: {count}\n    </button>\n  );\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Phase",
            "What React does",
            "Rules / why it matters"
          ],
          "rows": [
            [
              "Render phase",
              "Runs components to compute the next UI tree",
              "Should be pure (no subscriptions, network calls, DOM writes). React may re-run renders (especially in dev/StrictMode)."
            ],
            [
              "Reconciliation",
              "Matches old vs new elements (type + key + position) and decides what to keep, move, mount, unmount",
              "Keys are crucial for stable identity in lists; changing element type at a position can cause remount/state loss."
            ],
            [
              "Commit phase",
              "Mutates the real DOM + runs effects/lifecycles",
              "This is where DOM changes actually happen; effects run after commit."
            ]
          ],
          "caption": "Virtual DOM is the input to reconciliation; reconciliation decides the DOM commit"
        },
        {
          "type": "text",
          "text": "<strong>Keys are a big part of “VDOM performance”</strong><br><br>Reconciliation is fast when React can match previous children to next children reliably. In lists, stable <code>key</code> values give identity; bad keys (like index in reordering lists) can cause unnecessary remounts, DOM churn, and state bugs."
        },
        {
          "type": "list",
          "columns": [
            "Why React uses this model",
            "Practical benefit"
          ],
          "rows": [
            [
              "Declarative UI (UI as a function of data)",
              "You describe <em>what</em> the UI should be; React computes <em>how</em> to update it."
            ],
            [
              "Batching + scheduling",
              "Multiple state updates can be grouped; React can prioritize urgent updates."
            ],
            [
              "Efficient updates for dynamic trees",
              "As the UI shape changes, React can mount/unmount/move nodes without manual DOM bookkeeping."
            ],
            [
              "Tooling + predictability",
              "The same inputs produce the same tree (when render is pure), which makes behavior easier to reason about and debug."
            ]
          ],
          "caption": "What the “Virtual DOM + reconciliation” architecture buys you"
        },
        {
          "type": "text",
          "text": "<strong>Interview-quality summary</strong><br><br>In React, “Virtual DOM” refers to the in-memory UI tree (React elements/fibers). On updates, React re-renders to produce a new tree, then runs reconciliation (diffing + keys + heuristics) to compute what changed, and finally commits only the necessary DOM mutations. A re-render is just recomputing UI — it does not automatically mean the browser DOM changed."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "virtual-dom",
      "rendering",
      "performance",
      "basics"
    ],
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ],
    "seo": {
      "title": "What is the Virtual DOM in React?",
      "description": "The Virtual DOM is React's in-memory UI representation used to compare renders and apply minimal real DOM updates during reconciliation."
    }
  },
  {
    "id": "react-component-rerendering",
    "title": "When does React re-render a component, and when does it actually update the DOM?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain React’s update pipeline: what a “re-render” really is (re-running component functions to produce a new element tree), what triggers it (state/props/context/parent renders), how reconciliation decides what changed, and why a re-render often results in zero DOM mutations. Include bailouts (Object.is state equality, React.memo/PureComponent), identity pitfalls (inline objects/functions, Context value identity), StrictMode dev behavior, and keys/remount gotchas.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>In React, a <strong>re-render</strong> means: React runs your component again to compute the next <em>React element tree</em> (the in-memory UI description).<br><br><strong>Re-render ≠ DOM update</strong>. After rendering, React <strong>reconciles</strong> (matches old vs new trees) and only then <strong>commits</strong> the minimal DOM mutations <em>if anything actually changed</em>."
        },
        {
          "type": "list",
          "columns": [
            "Trigger",
            "What happens",
            "Important nuance"
          ],
          "rows": [
            [
              "State update (useState/useReducer)",
              "Schedules a render for that component",
              "If the new state is <code>Object.is</code>-equal to the old state, React can bail out (no re-render). New object/array references are always “different”."
            ],
            [
              "Parent re-renders",
              "Children are rendered by default",
              "Even if props “look the same”, React will call the child again unless you use <code>React.memo</code>/<code>PureComponent</code> (or a custom comparison)."
            ],
            [
              "Prop identity changes",
              "Child re-renders",
              "Inline objects/functions create new references every render → looks like “props changed” to memo/shallow compare."
            ],
            [
              "Context Provider value changes",
              "All consumers may re-render",
              "Context is identity-based too. <code>value={{...}}</code> created inline changes every render unless memoized."
            ],
            [
              "Key / type changes at a position",
              "React remounts the subtree",
              "This is bigger than a re-render: local state resets because React treats it as a different component."
            ]
          ],
          "caption": "What typically causes re-renders (and the gotchas)"
        },
        {
          "type": "list",
          "columns": [
            "Phase",
            "What React does",
            "Rule of thumb"
          ],
          "rows": [
            [
              "Render phase",
              "Runs component functions / class <code>render()</code> to compute the next tree",
              "Must be pure (no subscriptions, network calls, DOM writes). React may run it more than once in dev/StrictMode."
            ],
            [
              "Reconciliation",
              "Compares old vs new elements (type + key + position) and decides what to keep/move/mount/unmount",
              "Stable keys/types preserve state and reduce work; unstable identity causes extra work and bugs."
            ],
            [
              "Commit phase",
              "Applies DOM mutations and runs effects/lifecycles",
              "This is when the browser DOM can actually change; effects run after commit."
            ]
          ],
          "caption": "Render vs reconcile vs commit (the mental model interviewers want)"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\nconst Child = React.memo(function Child({ onInc, config }) {\n  console.log('Child rendered');\n  return <button onClick={onInc}>Inc</button>;\n});\n\nexport default function Parent() {\n  const [count, setCount] = React.useState(0);\n\n  // ❌ NEW function/object every render -> Child sees \"new props\" -> re-renders\n  // const onInc = () => setCount(count + 1);\n  // const config = { step: 1 };\n\n  // ✅ Stable identities -> Child can skip renders via React.memo\n  const onInc = React.useCallback(() => setCount((c) => c + 1), []);\n  const config = React.useMemo(() => ({ step: 1 }), []);\n\n  console.log('Parent rendered');\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <Child onInc={onInc} config={config} />\n    </div>\n  );\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>What this example proves</strong><br><br>1) Updating <code>count</code> re-renders <code>Parent</code>.<br>2) By default, children render too.<br>3) <code>React.memo</code> lets a child <em>bail out</em> if props are shallow-equal, but only if you keep prop identities stable (callbacks/objects)."
        },
        {
          "type": "list",
          "columns": [
            "Common misconception",
            "Correct framing"
          ],
          "rows": [
            [
              "“React re-renders the whole app.”",
              "React schedules work for the affected part of the tree. But parent renders do propagate unless you add bailout boundaries (memo) and keep identities stable."
            ],
            [
              "“Virtual DOM diff always computes the minimal edit.”",
              "Reconciliation is heuristic and optimized for common UI patterns. With good keys/types, it’s very efficient; with bad keys/identity churn, it can do extra work."
            ],
            [
              "“If a component re-rendered, the DOM changed.”",
              "Not necessarily. If the computed output is the same (or the changed parts don’t affect the DOM), commit can be a no-op."
            ],
            [
              "“useCallback/useMemo always improves performance.”",
              "They help only when they prevent real work (rerenders of expensive children, expensive computations). Overuse adds complexity and overhead."
            ]
          ],
          "caption": "Interview-grade corrections to typical statements"
        },
        {
          "type": "list",
          "columns": [
            "Optimization lever",
            "What it actually reduces",
            "Best use"
          ],
          "rows": [
            [
              "Colocate state (move it down)",
              "The number of components affected by updates",
              "Keep state as close as possible to where it’s used, so fewer parents re-render."
            ],
            [
              "Split components",
              "The size of the rerendered subtree",
              "Separate “fast-changing” parts from “mostly-static” parts."
            ],
            [
              "React.memo / PureComponent",
              "Re-rendering of child components",
              "Pure/presentational children with stable props."
            ],
            [
              "Stable prop identities",
              "False-positive “prop changed” signals",
              "Avoid inline objects/functions when they’re passed to memoized children."
            ],
            [
              "Memoize Context value",
              "Broad consumer rerenders",
              "Wrap provider value creation in <code>useMemo</code> to avoid rerendering all consumers."
            ]
          ],
          "caption": "Practical ways to reduce unnecessary re-renders (in the order that usually matters most)"
        },
        {
          "type": "text",
          "text": "<strong>Two important gotchas</strong><br><br>• <strong>StrictMode (dev)</strong>: React may intentionally run render logic more than once to surface unsafe side effects. Don’t treat “double logs” in dev as production behavior.<br>• <strong>Keys/type changes</strong>: Changing a component’s key or swapping wrappers (e.g., Fragment ↔ div) can cause a remount (state reset), not just a re-render."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React re-renders when state/props/context might have changed. A re-render is “recompute the next UI tree”, not “mutate the DOM”. React then reconciles and commits only necessary DOM changes. Unnecessary re-renders usually come from unclear state ownership, unstable prop identities (inline objects/functions), broad context updates, or bad keys."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "rendering",
      "state",
      "props",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "When does React re-render and update the DOM?",
      "description": "React re-renders when state, props, or context change, but the DOM updates only if reconciliation finds actual output differences."
    }
  },
  {
    "id": "react-mixing-state-and-props-responsibilities",
    "title": "What bugs appear when state and props responsibilities are mixed?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Explain what typically breaks when a component treats the same piece of data as both “props-owned” and “state-owned” (multiple sources of truth). Cover common symptoms (stale UI, input jumps, infinite loops, memo bugs) and the correct patterns (single source of truth, controlled vs uncontrolled, derived state). Confusing state vs props leads to bugs and re-render issues. Test with prop changes and derived state updates.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Props are <em>inputs</em> owned by the parent. State is <em>local memory</em> owned by the component. When the same value is “owned” by both (prop + local state trying to represent the same truth), you create <em>two sources of truth</em>. React can only re-render correctly if ownership is clear: one writer, one authoritative value."
        },
        {
          "type": "list",
          "columns": [
            "Bug class",
            "What you see",
            "Why it happens"
          ],
          "rows": [
            [
              "Stale UI / missed updates",
              "Parent updates prop, child UI still shows old value",
              "Child copied prop into state once (or with a wrong sync) so it stops reflecting prop changes"
            ],
            [
              "Input “jumps” / cursor issues",
              "User types, then text resets or cursor jumps",
              "Both parent and child write to the input value; updates race and overwrite each other"
            ],
            [
              "Infinite update loops",
              "“Maximum update depth exceeded” or render thrashing",
              "Effect syncs prop → state, state change triggers parent callback, parent changes prop again"
            ],
            [
              "Controlled/uncontrolled warnings",
              "React warning about switching controlled ↔ uncontrolled",
              "Sometimes you pass value, sometimes you don’t; or you mix value + defaultValue"
            ],
            [
              "Memo / shallow-compare lies",
              "React.memo/PureComponent skips re-render when it shouldn’t (or vice versa)",
              "Mutations or identity mismatches: prop reference stays same while internal state changes (or you mutate a prop object)"
            ],
            [
              "Hard-to-debug coupling",
              "“Works sometimes”, order/timing dependent behavior",
              "Two writers + async scheduling = last write wins, but it’s not obvious who wrote last"
            ]
          ],
          "caption": "Typical failures when prop + state compete for the same responsibility"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ Classic bug: copying props to state (stale after parent updates)\nfunction ProfileEditor({ user }) {\n  const [name, setName] = React.useState(user.name); // copied once\n\n  // Later: parent changes user.name (e.g., refetch) but input stays stale\n  return <input value={name} onChange={(e) => setName(e.target.value)} />;\n}\n\n// This component now has two truths:\n// - parent truth: user.name\n// - child truth: name\n"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ Sync effect + callback can create loops / jitter\nfunction Child({ value, onChange }) {\n  const [local, setLocal] = React.useState(value);\n\n  // tries to \"keep in sync\" with prop\n  React.useEffect(() => {\n    setLocal(value);\n  }, [value]);\n\n  // tries to \"keep parent in sync\" with local\n  React.useEffect(() => {\n    onChange(local);\n  }, [local, onChange]);\n\n  return <input value={local} onChange={(e) => setLocal(e.target.value)} />;\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Correct pattern",
            "When to use",
            "How it prevents bugs"
          ],
          "rows": [
            [
              "Single source of truth (controlled)",
              "Parent owns the value; child just renders + emits events",
              "One writer (parent). No local copy, no drift"
            ],
            [
              "Uncontrolled input + ref",
              "You don’t need every keystroke in React state",
              "DOM owns value; React reads it only when needed (submit, blur)"
            ],
            [
              "Derived data (no state)",
              "Value can be computed from props/state",
              "No syncing needed: compute during render (optionally memoize)"
            ],
            [
              "Intentional “draft state” with explicit reset",
              "You need editable local draft that can be reset by parent",
              "You define a reset rule (key change / reset token) instead of ambiguous syncing"
            ]
          ],
          "caption": "Fix = make ownership explicit (pick one owner per piece of data)"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ✅ Controlled: parent owns value (single source of truth)\nfunction Child({ value, onChange }) {\n  return <input value={value} onChange={(e) => onChange(e.target.value)} />;\n}\n\nfunction Parent() {\n  const [value, setValue] = React.useState('');\n  return <Child value={value} onChange={setValue} />;\n}\n\n// ✅ Uncontrolled: DOM owns value\nfunction UncontrolledForm() {\n  const ref = React.useRef(null);\n  return (\n    <form\n      onSubmit={(e) => {\n        e.preventDefault();\n        alert(ref.current.value);\n      }}\n    >\n      <input ref={ref} defaultValue=\"\" />\n      <button>Submit</button>\n    </form>\n  );\n}\n\n// ✅ Intentional draft with explicit reset signal\nfunction Editor({ initialName, resetKey }) {\n  const [draft, setDraft] = React.useState(initialName);\n\n  // explicit reset (not \"sync every time\")\n  React.useEffect(() => {\n    setDraft(initialName);\n  }, [resetKey]);\n\n  return <input value={draft} onChange={(e) => setDraft(e.target.value)} />;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>If two different places can write the “same” value, you will eventually get drift, overwrites, loops, or UI jumps. Decide who owns it (parent via props, or child via local state/DOM), then design the API around that ownership."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A child component both receives user data as props and stores local edits, creating conflicts.<br><br><strong>Common pitfalls</strong><br><ul><li>Duplicating source of truth in props and state.</li><li>Out-of-sync updates when props change.</li><li>Unnecessary re-renders from derived state.</li></ul><strong>Trade-off or test tip</strong><br>Keep a single source of truth. Test by changing props and verifying UI updates correctly.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "state",
      "props",
      "architecture",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "What happens when state and props responsibilities are mixed?",
      "description": "Mixing state and props ownership creates multiple sources of truth, which leads to stale UI, reset bugs, and harder debugging."
    }
  },
  {
    "id": "react-lifting-state-up",
    "title": "How can you lift state up in React?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Lifting state up means moving shared state to the closest common ancestor and passing it down via props. This keeps siblings in sync and avoids duplicated state. The trade-off is prop drilling vs shared state, so test updates from each child and consider performance and memoization.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In React, when two or more components need to share the same state, it’s best to 'lift the state up' — move it to their nearest common parent. The parent holds the state, and passes it down to children via <code>props</code>. This ensures data consistency and centralized control."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example: Lifting state up\nfunction Parent() {\n  const [value, setValue] = useState('');\n\n  return (\n    <div>\n      <Input value={value} onChange={setValue} />\n      <Display value={value} />\n    </div>\n  );\n}\n\nfunction Input({ value, onChange }) {\n  return <input value={value} onChange={(e) => onChange(e.target.value)} />;\n}\n\nfunction Display({ value }) {\n  return <p>Typed text: {value}</p>;\n}"
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Explanation"
          ],
          "rows": [
            [
              "Centralized State",
              "The parent manages state instead of each child maintaining its own."
            ],
            [
              "Data Flow",
              "State is passed down via props; updates flow upward via callback functions."
            ],
            [
              "Synchronization",
              "Ensures that multiple components always display the same data."
            ]
          ],
          "caption": "Core principles of lifting state up in React"
        },
        {
          "type": "text",
          "text": "<strong>Why Lift State</strong><br><ul><li>To share data between sibling components.</li><li>To prevent duplication of logic or inconsistent state.</li><li>To manage user input that affects multiple components.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Best Practices</strong><br><ul><li>Keep state as high as necessary, but as low as possible — avoid globalizing everything.</li><li>Use callbacks to propagate changes from children to parents.</li><li>Consider using Context API or state management libraries for complex shared state.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of lifting state up as giving one parent the responsibility of tracking data, while children simply read or update it."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Lifting state up moves shared data to a common ancestor.</li><li>Children communicate changes via callbacks.</li><li>It promotes consistency and unidirectional data flow in React.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Two sibling components need to stay in sync (e.g., a slider and a numeric input), so you move shared state to their parent.<br><br><strong>Common pitfalls</strong><br><ul><li>Excessive prop drilling as the tree grows.</li><li>Duplicating derived state in multiple places, causing inconsistencies.</li><li>Triggering unnecessary re-renders for unrelated children.</li></ul><strong>Trade-off or test tip</strong><br>Lifting state improves consistency but can increase coupling. Test by updating each child and verifying the other reflects changes immediately."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "state",
      "props",
      "lifting-state",
      "data-flow"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "How do you lift state up in React?",
      "description": "Lift state up by moving shared state to the nearest common parent and passing values and update handlers down as props."
    }
  },
  {
    "id": "react-higher-order-components",
    "title": "Higher-order components (HOCs) in React: what are they and when should you use them?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 2,
    "description": "Higher-Order Components (HOCs) are a React pattern for reusing cross-cutting component logic by wrapping a component. An HOC is a function that takes a component and returns a new component with added behavior (e.g., injecting props, guarding access, subscriptions). They’re common in older/legacy React and some libraries (e.g., Redux connect), even though hooks are the modern default for new code. HOCs enable reuse but can complicate debugging and typing. Test prop collisions and display names.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>A <strong>higher-order component (HOC)</strong> is a <strong>function</strong> with the shape <code>(Component) =&gt; Component</code>. It wraps a “base” component and returns a new component that adds behavior around it (inject props, gate rendering, subscribe/unsubscribe, etc.).<br><br>Key rule: an HOC should be <strong>pure</strong> with respect to its input component (don’t mutate the wrapped component; compose by wrapping)."
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "What it means",
            "Why it matters"
          ],
          "rows": [
            [
              "Input",
              "A component (\"WrappedComponent\")",
              "The HOC enhances behavior around the same UI contract"
            ],
            [
              "Output",
              "A new component (\"Enhanced\")",
              "You get reuse without copy-pasting logic"
            ],
            [
              "How it works",
              "Wrapper renders <code>&lt;WrappedComponent {...props} /&gt;</code>",
              "Pass-through preserves flexibility and testability"
            ],
            [
              "Composition",
              "<code>withA(withB(Component))</code>",
              "Order matters; wrappers layer behavior"
            ]
          ],
          "caption": "What a HOC is (and how to reason about it)"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Minimal HOC: adds logging without changing WrappedComponent\nfunction withLogger(WrappedComponent) {\n  function WithLogger(props) {\n    console.log('Rendering', WrappedComponent.displayName || WrappedComponent.name || 'Component');\n    return <WrappedComponent {...props} />;\n  }\n\n  WithLogger.displayName = `withLogger(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return WithLogger;\n}\n\nfunction Hello({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}\n\nexport const HelloWithLogger = withLogger(Hello);\n"
        },
        {
          "type": "text",
          "text": "<strong>Common use cases (where HOCs still show up)</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Use case",
            "What the HOC does",
            "Typical examples"
          ],
          "rows": [
            [
              "Inject props",
              "Adds derived/global props to the wrapped component",
              "<code>connect()</code> (Redux), feature flags, theme injection (older patterns)"
            ],
            [
              "Access control",
              "Blocks/redirects/returns fallback UI when unauthorized",
              "withAuth / withRoleGuard"
            ],
            [
              "Side-effect wiring",
              "Subscribes and cleans up (events, websockets) around the wrapped component",
              "withSubscription / withWindowListener"
            ],
            [
              "Error boundaries",
              "Wraps with an error boundary component",
              "withErrorBoundary (common in codebases without global boundaries)"
            ]
          ],
          "caption": "Real-world places HOCs are used"
        },
        {
          "type": "text",
          "text": "<strong>Hard parts / interview-level gotchas</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Gotcha",
            "What can go wrong",
            "Fix / best practice"
          ],
          "rows": [
            [
              "Ref forwarding",
              "Refs don’t automatically pass through wrappers",
              "Use <code>React.forwardRef</code> and pass <code>ref</code> down"
            ],
            [
              "Static methods lost",
              "Statics on the wrapped component (e.g., <code>someStatic</code>) aren’t present on the wrapper",
              "Hoist statics (e.g., <code>hoist-non-react-statics</code>) when needed"
            ],
            [
              "Prop clobbering",
              "HOC injects a prop name that collides with caller props",
              "Namespace injected props or document the contract clearly"
            ],
            [
              "Wrapper noise",
              "DevTools shows extra wrapper layers (“wrapper hell”)",
              "Set <code>displayName</code>; prefer hooks for new code"
            ],
            [
              "Order sensitivity",
              "<code>withA(withB(X))</code> vs <code>withB(withA(X))</code> can change behavior",
              "Be intentional; document composition order"
            ],
            [
              "Creating HOCs in render",
              "New component type each render → remounts/state loss/perf issues",
              "Create HOCs once (module scope) or memoize carefully"
            ]
          ],
          "caption": "The parts that make HOCs “hard” in practice"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\n// HOC that forwards refs + sets displayName\nfunction withFocusRing(WrappedComponent) {\n  const WithFocusRing = React.forwardRef(function WithFocusRing(props, ref) {\n    return (\n      <div data-focus-ring>\n        <WrappedComponent ref={ref} {...props} />\n      </div>\n    );\n  });\n\n  WithFocusRing.displayName = `withFocusRing(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return WithFocusRing;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Modern guidance</strong><br><br>In modern React, <strong>custom hooks</strong> are usually the first choice for reusing stateful logic because they avoid wrapper nesting and compose more cleanly. HOCs still matter for <strong>legacy code</strong>, <strong>class components</strong>, and <strong>library APIs</strong> built around wrapping (e.g., Redux <code>connect</code> in older setups)."
        },
        {
          "type": "list",
          "columns": [
            "Summary"
          ],
          "rows": [
            [
              "An HOC is a function: <code>(WrappedComponent) =&gt; EnhancedComponent</code>."
            ],
            [
              "Prefer custom hooks for new logic reuse; HOCs mostly show up in legacy code and library APIs (e.g., older Redux <code>connect</code>)."
            ],
            [
              "Key gotchas: prop collisions, ref forwarding (<code>forwardRef</code>), hoisting statics, and wrapper nesting (\"wrapper hell\")."
            ]
          ],
          "caption": "Summary"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Wrap components with an auth HOC that injects user info and guards rendering.<br><br><strong>Common pitfalls</strong><br><ul><li>Prop name collisions between HOC and wrapped component.</li><li>Losing static methods or display names.</li><li>Over-nesting HOCs and reducing readability.</li></ul><strong>Trade-off or test tip</strong><br>HOCs are powerful but add indirection. Test prop passing and component names in DevTools.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "patterns",
      "hoc",
      "composition",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "What is a higher-order component in React?",
      "description": "A higher-order component is a function that takes a component and returns an enhanced component with added behavior."
    }
  },
  {
    "id": "react-usememo-vs-usecallback",
    "title": "What is the difference between useMemo() and useCallback()?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "useMemo memoizes a computed value; useCallback memoizes a function reference. Use them to avoid expensive recalculations or re-renders, but only when it actually helps.",
    "seo": {
      "title": "useMemo vs useCallback in React: what is the difference?",
      "description": "useMemo memoizes a computed value, while useCallback memoizes a function reference between renders."
    },
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>useMemo()</code> and <code>useCallback()</code> help improve performance by caching results or function references between re-renders. React components re-render when their props or state change, and these hooks prevent expensive re-computations or re-creations that could slow the app down."
        },
        {
          "type": "list",
          "columns": [
            "Hook",
            "Purpose",
            "Returns",
            "Use Case"
          ],
          "rows": [
            [
              "useMemo()",
              "Memoizes a computed value to avoid recalculating it every render.",
              "A cached value.",
              "When you have an expensive calculation that depends on specific values."
            ],
            [
              "useCallback()",
              "Memoizes a function so it retains the same reference between renders.",
              "A memoized function.",
              "When passing callback props to child components to prevent unnecessary re-renders."
            ]
          ],
          "caption": "Key differences between useMemo() and useCallback()"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// useMemo example\nconst total = useMemo(() => {\n  console.log('Calculating total...');\n  return items.reduce((sum, item) => sum + item.price, 0);\n}, [items]);\n\n// useCallback example\nconst handleClick = useCallback(() => {\n  console.log('Button clicked');\n}, []);"
        },
        {
          "type": "text",
          "text": "<strong>Detailed Explanation</strong><br><ul><li><strong>useMemo()</strong> recalculates a value only when dependencies change. It’s ideal for optimizing expensive computations like filtering large datasets or formatting lists.</li><li><strong>useCallback()</strong> returns the same function reference between renders unless its dependencies change. It’s most useful when passing callbacks to memoized child components.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Performance Tip</strong><br>Both hooks should be used selectively. Overusing them can make code complex without significant performance gain. They are primarily helpful in preventing unnecessary renders and optimizing heavy computations."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Combined example\nfunction ProductList({ products }) {\n  const [query, setQuery] = useState('');\n\n  const filteredProducts = useMemo(() => {\n    return products.filter((p) => p.name.toLowerCase().includes(query.toLowerCase()));\n  }, [products, query]);\n\n  const handleChange = useCallback((e) => {\n    setQuery(e.target.value);\n  }, []);\n\n  return (\n    <div>\n      <input value={query} onChange={handleChange} placeholder='Search products' />\n      <ul>{filteredProducts.map((p) => <li key={p.id}>{p.name}</li>)}</ul>\n    </div>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Analogy</strong><br><em>useMemo()</em> is like remembering the result of a long math calculation so you don’t recalculate it unless the inputs change. <em>useCallback()</em> is like remembering the function you used to do the calculation so you don’t create it again each time."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <code>useMemo()</code> optimizes values, <code>useCallback()</code> optimizes functions — both help React skip unnecessary work and maintain stable references."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li><code>useMemo()</code> caches computed values.</li><li><code>useCallback()</code> caches function definitions.</li><li>Both improve performance by avoiding redundant work and reducing re-renders.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "memoization",
      "callbacks",
      "performance",
      "hooks"
    ],
    "updatedAt": "2026-01-30"
  },
  {
    "id": "react-prevent-unnecessary-rerenders",
    "title": "How can you prevent unnecessary re-renders in React?",
    "technology": "react",
    "companies": [
      "netflix"
    ],
    "difficulty": "hard",
    "importance": 5,
    "description": "Preventing unnecessary re-renders in React is crucial for maintaining optimal performance. Re-renders occur when a component's state, props, or context changes, but React provides several techniques and patterns to minimize them — including memoization, pure components, stable references, and smart state management.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>React re-renders components whenever their <code>state</code>, <code>props</code>, or <code>context</code> change. While this ensures UI consistency, unnecessary re-renders can slow down large applications. To optimize performance, React provides techniques like <code>React.memo()</code>, <code>useMemo()</code>, <code>useCallback()</code>, and state hoisting strategies that reduce redundant rendering cycles."
        },
        {
          "type": "list",
          "columns": [
            "Technique",
            "Description",
            "Use Case"
          ],
          "rows": [
            [
              "React.memo()",
              "Prevents re-rendering of a functional component unless its props change.",
              "When a child component receives the same props repeatedly."
            ],
            [
              "useMemo()",
              "Memoizes a computed value and reuses it until its dependencies change.",
              "When performing expensive calculations in render."
            ],
            [
              "useCallback()",
              "Memoizes a function definition so that it doesn’t re-trigger re-renders in memoized children.",
              "When passing callbacks as props."
            ],
            [
              "PureComponent / shallow comparison",
              "Automatically skips re-renders when prop and state values have not changed.",
              "When using class-based components."
            ],
            [
              "Splitting state",
              "Store state closer to the component that actually needs it to avoid global updates.",
              "When managing complex UI with multiple interactive areas."
            ]
          ],
          "caption": "Common strategies to prevent unnecessary re-renders in React"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example using React.memo and useCallback\nconst Button = React.memo(({ onClick, label }) => {\n  console.log('Button rendered');\n  return <button onClick={onClick}>{label}</button>;\n});\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() => {\n    setCount((prev) => prev + 1);\n  }, []);\n\n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <Button onClick={handleClick} label='Increment' />\n    </div>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Detailed Explanation</strong><br><ul><li><strong>Memoization:</strong> By caching values and functions, React avoids re-creating them during re-renders.</li><li><strong>Pure Components:</strong> Class-based components that implement shallow comparison for props and state, ensuring only changed data triggers updates.</li><li><strong>Restructuring State:</strong> Large shared state causes global re-renders; move state down to relevant child components when possible.</li><li><strong>Context Optimization:</strong> Context triggers re-renders in all consumers; use memoized context values or split contexts by responsibility.</li></ul>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example: Context optimization with useMemo\nconst ThemeContext = React.createContext();\n\nfunction App() {\n  const [theme, setTheme] = useState('light');\n  const value = useMemo(() => ({ theme, setTheme }), [theme]);\n\n  return (\n    <ThemeContext.Provider value={value}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Other Optimization Techniques</strong><br><ul><li>Use <code>key</code> attributes wisely — avoid changing keys unnecessarily.</li><li>Batch multiple state updates using <code>ReactDOM.flushSync()</code> or rely on React's automatic batching (React 18+).</li><li>Defer complex calculations or animations using <code>useTransition()</code> or <code>useDeferredValue()</code>.</li><li>Profile performance using React DevTools Profiler to locate render bottlenecks.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Efficient React apps don’t avoid re-renders entirely — they control when and where they happen. The goal is to ensure only components affected by data changes re-render."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>React re-renders components on state, props, or context changes.</li><li>Prevent redundant re-renders with memoization, stable callbacks, and scoped state.</li><li>Proper optimization ensures smooth UI updates without unnecessary computation.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "performance",
      "memoization",
      "rendering",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "How do you prevent unnecessary re-renders in React?",
      "description": "Prevent unnecessary React re-renders by stabilizing props, splitting state, and using memoization tools like React.memo, useMemo, and useCallback."
    }
  },
  {
    "id": "react-strictmode-purpose",
    "title": "What is the purpose of the React.StrictMode component?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "React.StrictMode runs extra checks in development to surface unsafe lifecycles, deprecated APIs, and side-effect bugs. It does not affect production output. StrictMode catches unsafe patterns by double-invoking in dev; ensure effects are idempotent and tested.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>React.StrictMode</code> is a wrapper component provided by React to help developers identify unsafe or deprecated code patterns. It activates additional development checks and warnings to ensure components adhere to modern React practices and will behave correctly in concurrent rendering scenarios."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nReactDOM.createRoot(document.getElementById('root')).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);"
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Behavior"
          ],
          "rows": [
            [
              "Detects Unsafe Lifecycles",
              "Warns when using outdated lifecycle methods like <code>componentWillMount</code> or <code>componentWillReceiveProps</code>."
            ],
            [
              "Detects Side-Effect Issues",
              "Runs certain functions twice (like useEffect callbacks) to ensure side effects are idempotent."
            ],
            [
              "Highlights Deprecated APIs",
              "Warns about legacy string refs, findDOMNode, and legacy context usage."
            ],
            [
              "Identifies Unexpected Behavior",
              "Detects potential issues in asynchronous rendering with React concurrent features."
            ]
          ],
          "caption": "Key development checks enabled by React.StrictMode"
        },
        {
          "type": "text",
          "text": "<strong>Why It Matters</strong><br><ul><li>Encourages developers to write cleaner, future-proof React code.</li><li>Ensures that effects and updates behave consistently in upcoming React features.</li><li>Improves debugging and helps migrate older codebases to modern React hooks and concurrent rendering.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Important Notes</strong><br><ul><li>Only active in development mode; it has no effect in production builds.</li><li>May cause duplicate console logs or API calls in development due to intentional double-invocation of certain functions.</li><li>Does not render any UI or change component behavior; it’s purely diagnostic.</li></ul>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example of StrictMode highlighting a side-effect\nfunction Example() {\n  useEffect(() => {\n    console.log('Effect triggered');\n    return () => console.log('Cleanup');\n  }, []);\n\n  return <p>Hello World</p>;\n}\n\n// The effect above runs twice in development to test cleanup behavior."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>React.StrictMode</code> as React’s 'training mode' — it helps you find potential bugs early, making your app stronger and more resilient in production."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>StrictMode helps detect side effects, deprecated APIs, and unsafe lifecycles.</li><li>It runs additional checks in development without affecting production.</li><li>Useful for ensuring your React app is ready for future updates and concurrent rendering.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>In development, you notice effects running twice; StrictMode is intentionally exposing unsafe side effects.\n<br><br><strong>Common pitfalls</strong><br><ul><li>Assuming double-invocation happens in production (it does not).</li><li>Writing non-idempotent effects that break when re-run.</li><li>Doing side effects directly in render.</li></ul><strong>Trade-off or test tip</strong><br>StrictMode makes dev noisier but catches bugs early. Test by making effects idempotent and verifying cleanup works."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "strictmode",
      "devtools",
      "warnings",
      "hooks"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "What is React.StrictMode used for?",
      "description": "React.StrictMode enables extra development checks to surface unsafe patterns and side effects before production."
    }
  },
  {
    "id": "react-reconciliation",
    "title": "What is React reconciliation and how does it work?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Reconciliation is the process React uses to compare the current Virtual DOM with the previous one and determine the minimal set of changes needed to update the real DOM. It ensures React applications stay fast and efficient even when rendering complex UI trees.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Reconciliation is the core mechanism that makes React performant. Whenever the state or props of a component change, React generates a new Virtual DOM tree. It then compares this new tree with the previous one to detect differences. This comparison process is called <em>reconciliation</em>, and the optimized algorithm React uses to perform it is known as the <em>diffing algorithm</em>."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "Description"
          ],
          "rows": [
            [
              "Render Phase",
              "React creates a new Virtual DOM representation of the UI based on the latest component state and props."
            ],
            [
              "Diffing Phase",
              "React compares the new Virtual DOM with the old one to detect what has changed."
            ],
            [
              "Commit Phase",
              "React updates only the changed elements in the real DOM, leaving the rest untouched."
            ]
          ],
          "caption": "Main phases of React’s reconciliation process"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example: Reconciliation in action\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <h2>Count: {count}</h2>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// Only <h2> changes when count updates; React reuses <div> and <button>."
        },
        {
          "type": "text",
          "text": "<strong>Why It Matters</strong><br>Direct manipulation of the DOM is expensive. React’s reconciliation process ensures that only necessary updates happen, minimizing reflows and improving performance. This approach makes React declarative — you describe the UI, and React efficiently figures out how to update it."
        },
        {
          "type": "text",
          "text": "<strong>Rules of Reconciliation</strong><br><ul><li>Elements of the same type are compared recursively.</li><li>If an element type changes (e.g., <code>&lt;div&gt;</code> → <code>&lt;span&gt;</code>), React destroys and rebuilds that node.</li><li>Keys help React identify elements across renders, especially in lists, ensuring stable updates instead of re-creating entire subtrees.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Reconciliation and Keys</strong><br><ul><li>Keys allow React to match old and new elements efficiently.</li><li>When keys are missing or inconsistent, React may re-render entire lists instead of updating only changed items.</li><li>Stable, unique keys (like IDs) help React maintain state between renders.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Example</strong><br>If you render a list and change one item’s position, React uses the <code>key</code> attribute to identify which element moved instead of destroying and re-creating all items."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "{items.map(item => (\n  <li key={item.id}>{item.name}</li>\n))}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Reconciliation is React’s secret engine — it ensures your UI stays fast by updating only what’s necessary, not everything that changed."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Reconciliation is React’s process for updating the DOM efficiently.</li><li>It compares old and new Virtual DOM trees using the diffing algorithm.</li><li>Only changed parts of the real DOM are updated, ensuring optimal performance.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "rendering",
      "reconciliation",
      "diffing",
      "basics"
    ],
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ],
    "seo": {
      "title": "What is reconciliation in React?",
      "description": "Reconciliation is React's process of comparing previous and next element trees to decide the minimal UI updates."
    }
  },
  {
    "id": "react-diffing-algorithm",
    "title": "Explain how React’s diffing algorithm determines which parts of the DOM to update.",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "React’s diffing algorithm efficiently compares two Virtual DOM trees to find the minimal number of operations needed to synchronize the real DOM with the new state. It uses intelligent heuristics that make the process nearly O(n) instead of O(n³).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>The diffing algorithm is the heart of React’s Virtual DOM system. Whenever a component’s state or props change, React constructs a new Virtual DOM and compares it to the previous one. Instead of checking every possible change (which would be computationally expensive), React uses smart assumptions to identify the minimal changes required."
        },
        {
          "type": "list",
          "columns": [
            "Rule",
            "Explanation"
          ],
          "rows": [
            [
              "1. Element Type Comparison",
              "If two elements have the same type (e.g., both are <code>&lt;div&gt;</code>), React assumes their structure is similar and performs a deep comparison of their attributes and children."
            ],
            [
              "2. Replacement on Type Change",
              "If the element type differs (e.g., <code>&lt;div&gt;</code> → <code>&lt;span&gt;</code>), React removes the old node and creates a new one."
            ],
            [
              "3. Key-Based List Comparison",
              "When diffing lists, React uses keys to track which items changed, were added, or removed. Keys ensure minimal reordering and preserve component state."
            ]
          ],
          "caption": "Simplified rules of React’s diffing algorithm"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example: Efficient list diffing using keys\nconst fruits = ['Apple', 'Banana', 'Cherry'];\n\n// When re-rendered with a new list:\nconst updatedFruits = ['Banana', 'Cherry', 'Apple'];\n\n// React uses 'key' to determine what moved instead of re-rendering everything.\n{updatedFruits.map(fruit => (\n  <li key={fruit}>{fruit}</li>\n))}"
        },
        {
          "type": "text",
          "text": "<strong>How the Algorithm Works</strong><br><ul><li><strong>Step 1:</strong> React starts from the root of the tree and compares each Virtual DOM node with its previous version.</li><li><strong>Step 2:</strong> If nodes are identical, React skips them.</li><li><strong>Step 3:</strong> If attributes differ (e.g., <code>className</code>), React updates only those attributes in the real DOM.</li><li><strong>Step 4:</strong> When lists change, React uses keys to identify additions, deletions, and reorderings efficiently.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Example of Attribute Update</strong><br>React updates only what changes — not the entire node."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Old Virtual DOM\n<div className='red'>Hello</div>\n\n// New Virtual DOM\n<div className='blue'>Hello</div>\n\n// React result:\n// Only updates the className from 'red' to 'blue', not the entire <div>."
        },
        {
          "type": "text",
          "text": "<strong>Performance Advantage</strong><br>The traditional approach to comparing trees is O(n³), but React’s diffing algorithm achieves near O(n) by making these assumptions:<ul><li>Different element types produce different trees.</li><li>Stable keys indicate the same components across renders.</li></ul>This efficiency makes React suitable for large-scale dynamic UIs."
        },
        {
          "type": "text",
          "text": "<strong>When Keys Are Misused</strong><br>Incorrect or missing keys can cause React to discard and re-create DOM nodes unnecessarily, resulting in performance issues and lost component state. Always use unique and stable keys (like database IDs)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> The diffing algorithm is React’s performance superpower — it ensures your UI updates surgically instead of rebuilding the whole DOM every time something changes."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>React’s diffing algorithm compares Virtual DOM trees efficiently.</li><li>It updates only changed attributes or elements using heuristic assumptions.</li><li>Keys play a critical role in optimizing list updates and preserving state.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "rendering",
      "diffing",
      "performance",
      "basics"
    ],
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ],
    "seo": {
      "title": "How does React's diffing algorithm work?",
      "description": "React diffing compares old and new trees with heuristics based on element type and keys to update only changed nodes."
    }
  },
  {
    "id": "react-render-props-vs-hocs",
    "title": "What are render props and how do they differ from HOCs?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 2,
    "description": "Render props and higher-order components (HOCs) are both React patterns used for code reuse. Render props use a function passed as a prop to control what to render, while HOCs wrap components to inject additional logic or data.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In React, both <em>Render Props</em> and <em>Higher-Order Components (HOCs)</em> aim to share logic between components. However, they differ in implementation: HOCs wrap components and return enhanced ones, whereas Render Props use a function as a prop to dynamically render UI with shared functionality."
        },
        {
          "type": "text",
          "text": "<strong>Render Props Pattern</strong><br>Render props is a pattern where a component receives a function as a prop and uses it to determine what to render. This function receives shared data or behavior as arguments, enabling reusable and flexible composition."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example of Render Props\nfunction DataProvider({ render }) {\n  const [data, setData] = useState('Hello Render Props!');\n  return render(data);\n}\n\nfunction App() {\n  return (\n    <DataProvider render={(data) => <h1>{data}</h1>} />\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Higher-Order Components (HOCs)</strong><br>HOCs are functions that take a component as input and return an enhanced version of it. They are often used to inject props or logic into wrapped components, such as authentication, logging, or global data handling."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example of HOC\nfunction withLogger(WrappedComponent) {\n  return function EnhancedComponent(props) {\n    console.log('Rendering', WrappedComponent.name);\n    return <WrappedComponent {...props} />;\n  };\n}\n\nconst Hello = (props) => <h2>Hello, {props.name}</h2>;\nconst HelloWithLogger = withLogger(Hello);"
        },
        {
          "type": "list",
          "columns": [
            "Pattern",
            "Implementation",
            "Rendering Control",
            "Common Use Cases"
          ],
          "rows": [
            [
              "Render Props",
              "Passes a function prop to control rendering.",
              "Parent component controls rendering output.",
              "Reusable behavior without inheritance or wrapping."
            ],
            [
              "HOC",
              "Wraps a component and returns an enhanced version.",
              "Wrapped component renders normally.",
              "Injecting data or functionality (e.g., Redux connect)."
            ]
          ],
          "caption": "Key differences between Render Props and HOCs"
        },
        {
          "type": "text",
          "text": "<strong>When to Use Each</strong><br><ul><li><strong>Render Props:</strong> When you want full control over rendering and flexible composition.</li><li><strong>HOCs:</strong> When you want to extend or modify components’ behavior in a reusable, declarative way.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Best Practices</strong><br><ul><li>Avoid using both patterns simultaneously in the same component — it increases complexity.</li><li>Prefer hooks in modern React for sharing logic (e.g., <code>useCustomHook()</code>).</li><li>Render props are more explicit and composable, whereas HOCs abstract logic more deeply.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of render props as 'passing a render recipe' and HOCs as 'wrapping an object with a new layer of behavior.' Both achieve reusability, but through different philosophies."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Render Props share logic through function props.</li><li>HOCs wrap and enhance components.</li><li>Modern React often replaces both patterns with custom hooks for cleaner and simpler reusability.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "patterns",
      "render-props",
      "hoc",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Render props vs HOCs in React: what is the difference?",
      "description": "Render props share logic through a function prop, while HOCs share logic by wrapping a component and injecting behavior."
    }
  },
  {
    "id": "react-portals",
    "title": "What are React portals and when would you use them?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Portals render children into a DOM node outside the parent hierarchy, useful for modals, tooltips, and overlays while preserving React event bubbling. Portals help overlays but require focus management and accessibility checks; test event bubbling and scroll lock.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>By default, components in React render into a specific section of the DOM tree — typically inside a root element. However, there are cases where you need to render an element outside of this hierarchy (like a modal that overlays the entire page). React Portals make this possible while preserving the component’s state and event bubbling behavior."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example: Creating a Portal\nimport { createPortal } from 'react-dom';\n\nfunction Modal({ children }) {\n  const modalRoot = document.getElementById('modal-root');\n  return createPortal(\n    <div className='modal-overlay'>\n      <div className='modal-content'>{children}</div>\n    </div>,\n    modalRoot\n  );\n}\n\n// Usage\nfunction App() {\n  return (\n    <>\n      <h1>Main App</h1>\n      <Modal>\n        <p>This modal is rendered outside the main DOM hierarchy!</p>\n      </Modal>\n    </>\n  );\n}"
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Description"
          ],
          "rows": [
            [
              "DOM Separation",
              "Renders children into a different part of the DOM while still being part of the same React component tree."
            ],
            [
              "Event Propagation",
              "Events (like clicks) still bubble up through the React tree even if rendered elsewhere."
            ],
            [
              "Reusability",
              "Useful for rendering overlays, tooltips, dropdowns, and notifications without CSS positioning issues."
            ]
          ],
          "caption": "Key characteristics of React Portals"
        },
        {
          "type": "text",
          "text": "<strong>When to Use React Portals</strong><br><ul><li><strong>Modals and Dialogs:</strong> To overlay content on top of the entire app while avoiding nested CSS stacking contexts.</li><li><strong>Tooltips and Popovers:</strong> To position elements outside of overflow or clipping containers.</li><li><strong>Floating UI Elements:</strong> For global notifications, menus, or context-sensitive actions.</li></ul>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Typical setup in index.html -->\n<body>\n  <div id='root'></div>\n  <div id='modal-root'></div>\n</body>"
        },
        {
          "type": "text",
          "text": "<strong>How It Works Internally</strong><br>React’s <code>createPortal()</code> function takes two arguments: a React child (JSX element) and a DOM node. It attaches the child to the specified DOM node, but keeps it part of the React component hierarchy — meaning it still shares state, context, and event propagation with its parent."
        },
        {
          "type": "text",
          "text": "<strong>Advantages of Using Portals</strong><br><ul><li>Solves z-index and overflow issues by detaching UI from parent containers.</li><li>Keeps React’s declarative structure intact.</li><li>Maintains event propagation and context links even when rendered outside the normal DOM flow.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Portals act like ‘wormholes’ in React — they render elements somewhere else in the DOM while keeping them connected to their original logic and context."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>React Portals render children outside the parent DOM hierarchy.</li><li>Used for modals, overlays, and tooltips to avoid CSS stacking issues.</li><li>They preserve React context and event bubbling despite DOM separation.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A modal and tooltip must render above the app shell, so you render them into a portal root outside the main DOM tree.<br><br><strong>Common pitfalls</strong><br><ul><li>Missing focus management and keyboard trapping.</li><li>Assuming event bubbling changes (it still bubbles through React tree).</li><li>Forgetting to lock background scroll.</li></ul><strong>Trade-off or test tip</strong><br>Portals solve layering but add accessibility work. Test with keyboard navigation and focus return.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "portals",
      "modals",
      "overlays",
      "dom"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "What are React portals and when should you use them?",
      "description": "React portals render children into a different DOM node while keeping them in the same React tree for events and context."
    }
  },
  {
    "id": "react-concurrent-rendering",
    "title": "How does React’s concurrent rendering improve performance?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Concurrent rendering is a feature introduced in React 18 that allows React to prepare multiple versions of the UI simultaneously, improving responsiveness and user experience. It makes rendering interruptible, enabling React to prioritize urgent updates and avoid UI blocking during heavy computations.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Traditional rendering in React was synchronous — once React started rendering a component tree, it had to finish before handling new updates. Concurrent rendering changes that behavior. It allows React to work on multiple UI updates at the same time, pause work when necessary, and prioritize more important updates (like user interactions) over less critical ones."
        },
        {
          "type": "text",
          "text": "<strong>Key Concept</strong><br><em>Concurrent rendering</em> doesn’t mean React renders components in parallel; rather, it can interrupt and resume work intelligently. This leads to smoother UIs, especially in complex applications where large updates could otherwise block input or animations."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Explanation"
          ],
          "rows": [
            [
              "Interruptible Rendering",
              "React can pause an ongoing render to handle higher-priority tasks, like responding to a user click."
            ],
            [
              "Prioritized Updates",
              "Updates are assigned priorities — urgent ones (like typing) are handled first, while non-urgent ones (like data loading) can be delayed."
            ],
            [
              "Concurrent Preparation",
              "React can prepare multiple versions of the UI in memory and commit the best one when ready."
            ],
            [
              "Non-blocking Rendering",
              "Rendering no longer freezes the main thread, keeping the app responsive even under heavy load."
            ]
          ],
          "caption": "Core principles of concurrent rendering"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example using useTransition\nimport { useState, useTransition } from 'react';\n\nfunction SearchList({ items }) {\n  const [query, setQuery] = useState('');\n  const [filtered, setFiltered] = useState(items);\n  const [isPending, startTransition] = useTransition();\n\n  const handleChange = (e) => {\n    const value = e.target.value;\n    setQuery(value);\n    startTransition(() => {\n      const results = items.filter(item => item.includes(value));\n      setFiltered(results);\n    });\n  };\n\n  return (\n    <div>\n      <input value={query} onChange={handleChange} placeholder='Search...' />\n      {isPending && <p>Loading...</p>}\n      <ul>{filtered.map((item, i) => <li key={i}>{item}</li>)}</ul>\n    </div>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>How This Improves Performance</strong><br><ul><li>By marking some updates as ‘transitions’, React knows they are not urgent and can delay them to keep the UI responsive.</li><li>React can interrupt rendering mid-way to handle urgent updates first, then continue rendering where it left off.</li><li>This prevents input lag and stuttering during large data updates or re-renders.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Key APIs Enabling Concurrent Rendering</strong><br><ul><li><code>useTransition()</code>: Defers expensive updates to improve responsiveness.</li><li><code>useDeferredValue()</code>: Allows a value to ‘lag behind’ to avoid blocking fast updates.</li><li><code>startTransition()</code>: Marks non-urgent updates to be scheduled with lower priority.</li><li><code>Suspense</code>: Works with concurrent rendering to pause UI updates until asynchronous data is ready.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Under the Hood</strong><br><br>React’s concurrent renderer is built on a new architecture called the <em>Fiber Reconciler</em>. Each component update is split into small units of work (called fibers). This lets React work on these pieces incrementally and yield control back to the browser between frames, ensuring smooth rendering without blocking the main thread."
        },
        {
          "type": "text",
          "text": "<strong>Example of Prioritization</strong><br>Imagine typing into a search box that filters a large list. With concurrent rendering:<ul><li>Your keystrokes (high priority) update the input immediately.</li><li>The filtering logic (low priority) runs in the background without freezing the input field.</li></ul>This creates a seamless, lag-free user experience."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Concurrent rendering isn’t about parallelism — it’s about <em>cooperative scheduling</em>. React breaks large tasks into smaller chunks and works on them over time, making your app feel faster without actually increasing raw performance."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Concurrent rendering lets React pause, resume, and prioritize rendering tasks.</li><li>It improves responsiveness by keeping the UI interactive during long updates.</li><li>Enabled through APIs like <code>useTransition</code>, <code>useDeferredValue</code>, and the Fiber architecture.</li><li>Especially useful for search filtering, data fetching, and large list rendering scenarios.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "concurrent",
      "rendering",
      "performance",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "What is concurrent rendering in React?",
      "description": "Concurrent rendering lets React interrupt and prioritize rendering work so urgent updates stay responsive during expensive UI updates."
    }
  },
  {
    "id": "react-why-hooks-have-rules",
    "title": "Why do Hooks have rules? What breaks if you call Hooks conditionally?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain why React Hooks must be called unconditionally and in the same order, how React internally matches Hook calls to state slots, and what breaks when that order changes. Hooks rely on call order, so violations cause subtle bugs. Test with lint rules and ensure stable hook order.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Short answer</strong><br><br>Hooks have rules because React does <em>not</em> identify Hooks by name. It identifies them by <em>call order</em>. If you call Hooks conditionally, the order changes between renders, and React starts attaching the wrong state/effect/memo to the wrong Hook call."
        },
        {
          "type": "text",
          "text": "<strong>The mental model</strong><br><br>Internally, React stores Hooks for a component in something like an <em>array</em> and uses a pointer while rendering:<br><br><code>useState → slot 0</code><br><code>useEffect → slot 1</code><br><code>useMemo → slot 2</code><br><br>On every render, React assumes: <em>\"The first Hook call is the same Hook as last time. The second Hook call is the same Hook as last time.\"</em><br><br>So the only thing that matters is: <strong>the order of Hook calls must be identical on every render.</strong>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Example({ showExtra }) {\n  const [count, setCount] = useState(0);     // Hook slot 0\n\n  if (showExtra) {\n    const [flag, setFlag] = useState(false); // Hook slot 1 (sometimes!)\n  }\n\n  const [name, setName] = useState('Alice'); // Hook slot 1 or 2 🤯\n}"
        },
        {
          "type": "text",
          "text": "<strong>What breaks here?</strong><br><br>When <code>showExtra</code> is <code>false</code>, the second <code>useState</code> is skipped. That means the <code>name</code> state now occupies <em>slot 1</em> instead of <em>slot 2</em>.<br><br>On the next render when <code>showExtra</code> becomes <code>true</code>, React thinks:<br>• slot 1 = <code>flag</code> state<br>• slot 2 = <code>name</code> state<br><br>But previously:<br>• slot 1 was actually <code>name</code> state 😬<br><br>So now React mixes up states. Values jump between variables. Effects attach to the wrong logic. Everything becomes <em>silently wrong</em>."
        },
        {
          "type": "list",
          "columns": [
            "Rule",
            "Why it exists",
            "What breaks if you violate it"
          ],
          "rows": [
            [
              "Only call Hooks at the top level",
              "Guarantees stable call order",
              "State/effects shift between variables"
            ],
            [
              "Never call Hooks conditionally",
              "Ensures same Hooks run every render",
              "Hooks get mismatched to wrong slots"
            ],
            [
              "Only call Hooks from components or custom Hooks",
              "Ensures React controls render lifecycle",
              "React cannot track Hook state correctly"
            ]
          ],
          "caption": "The real reasons behind the Rules of Hooks"
        },
        {
          "type": "text",
          "text": "<strong>Important insight</strong><br><br>This is not a \"style rule\". This is a <em>fundamental constraint of how Hooks are implemented</em>. React could have designed a more complex system using keys or IDs, but that would make Hooks slower, more complex, and harder to optimize."
        },
        {
          "type": "text",
          "text": "<strong>How you should write conditional logic instead</strong><br><br>Call Hooks <em>unconditionally</em>, and put the condition <em>inside</em> the Hook logic:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Example({ showExtra }) {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n  const [name, setName] = useState('Alice');\n\n  useEffect(() => {\n    if (!showExtra) return;\n    // conditional behavior goes here\n  }, [showExtra]);\n}"
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say it like this:<br><em>\"React tracks Hooks by call order, not by name. If you call Hooks conditionally, the order changes between renders, so React attaches state and effects to the wrong Hook. The Rules of Hooks exist to guarantee stable ordering.\"</em>"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Hooks must be called in the same order on every render. React relies on call order to map Hook calls to internal state slots. Conditional Hooks break this mapping, causing state and effects to shift between variables and produce unpredictable bugs."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A hook is called inside a conditional and breaks state order across renders.<br><br><strong>Common pitfalls</strong><br><ul><li>Calling hooks inside loops or conditionals.</li><li>Using hooks in non-component functions.</li><li>Suppressing lint rules and masking bugs.</li></ul><strong>Trade-off or test tip</strong><br>Rules enforce consistency. Test with eslint-plugin-react-hooks and avoid conditional calls.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "hooks",
      "state",
      "best-practices",
      "control-flow"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Why do React Hooks have rules?",
      "description": "Hooks have rules because React maps hook state by call order, so conditional or reordered calls break state and effect matching."
    }
  },
  {
    "id": "react-stale-state-closures",
    "title": "Why does React sometimes show stale state in closures? How do you fix it?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain how JavaScript closures capture values from a specific render, why React renders create new closures, and how this leads to stale state bugs in effects, timeouts, and event handlers — and how to fix them.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Short answer</strong><br><br>Because <em>each render creates new variables and new functions</em>, and JavaScript closures capture the values from <em>the render they were created in</em>. If an async callback or effect runs later, it may still see <em>old state</em> from an earlier render."
        },
        {
          "type": "text",
          "text": "<strong>The mental model</strong><br><br>React components are not long-lived objects. They are more like:<br><em>\"Functions that React calls again and again to produce UI.\"</em><br><br>Every render creates a <strong>new snapshot</strong> of props, state, and functions. Closures created in that render <em>freeze</em> those values."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      console.log(count); // ❌ Might log stale value\n    }, 1000);\n\n    return () => clearInterval(id);\n  }, []); // empty deps\n\n  return <button onClick={() => setCount(c => c + 1)}>+</button>;\n}"
        },
        {
          "type": "text",
          "text": "<strong>Why this logs stale state</strong><br><br>This effect runs only once. The closure inside <code>setInterval</code> captures <code>count</code> from the <em>first render</em> (which is 0).<br><br>Even if state updates later, this callback still sees <code>count = 0</code> forever. Not a React bug. Just JavaScript closures + React render model."
        },
        {
          "type": "list",
          "columns": [
            "Cause",
            "What’s actually happening",
            "Symptom"
          ],
          "rows": [
            [
              "Closure captures old render values",
              "Callback keeps references to old variables",
              "State appears \"stuck\" or outdated"
            ],
            [
              "Effect deps are missing",
              "Effect never re-runs with new state",
              "Logic uses old props/state"
            ],
            [
              "Async logic (timeout, interval, promise)",
              "Runs after render that created it",
              "Reads stale snapshot"
            ]
          ],
          "caption": "Why stale state bugs happen"
        },
        {
          "type": "text",
          "text": "<strong>Fix #1: Add correct dependencies</strong><br><br>Tell React to recreate the closure when state changes:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "useEffect(() => {\n  const id = setInterval(() => {\n    console.log(count);\n  }, 1000);\n\n  return () => clearInterval(id);\n}, [count]); // ✅ now closure updates when count changes"
        },
        {
          "type": "text",
          "text": "<strong>Fix #2: Use functional updates (most common fix)</strong><br><br>If you are <em>updating state based on previous state</em>, don’t read from the closure at all:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "setCount(c => c + 1); // ✅ always uses latest state"
        },
        {
          "type": "text",
          "text": "<strong>Fix #3: Use useRef for mutable latest value</strong><br><br>If you need to read the <em>latest</em> value from long-lived async callbacks:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "const countRef = useRef(count);\nuseEffect(() => {\n  countRef.current = count;\n}, [count]);\n\nuseEffect(() => {\n  const id = setInterval(() => {\n    console.log(countRef.current); // ✅ always latest\n  }, 1000);\n  return () => clearInterval(id);\n}, []);"
        },
        {
          "type": "text",
          "text": "<strong>Important insight</strong><br><br>This is not a React quirk. This is how <em>JavaScript closures</em> work combined with React’s <em>\"each render is a snapshot\"</em> model."
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say it like this:<br><em>\"Each render creates a new closure with its own state snapshot. Async callbacks keep the snapshot from the render they were created in. Stale state happens when effects or callbacks don’t re-run with new dependencies. You fix it with correct deps, functional updates, or refs.\"</em>"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Stale state happens because closures capture values from a specific render. React re-renders create new snapshots, but old async callbacks keep old ones. Fix it by using correct dependencies, functional state updates, or a ref for reading the latest value."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "hooks",
      "closure",
      "state",
      "effects",
      "callbacks"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Why does stale state happen in React closures?",
      "description": "Stale state happens because closures capture values from the render when they were created, not the latest state after future renders."
    }
  },
  {
    "id": "react-useref-vs-usestate",
    "title": "What’s the difference between useRef and useState? When should each be used?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Explain how useState triggers re-renders and is used for UI state, while useRef holds a mutable value that persists across renders without re-rendering — and when each is the correct tool (DOM refs, timers, previous values, avoiding stale closures, and render-driving state).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Short answer</strong><br><br><code>useState</code> is for data that should <strong>drive what you render</strong> (changing it re-renders). <code>useRef</code> is for data you want to <strong>persist across renders</strong> but changing it should <strong>not</strong> trigger a re-render (a mutable container)."
        },
        {
          "type": "list",
          "columns": [
            "Hook",
            "What it stores",
            "What happens when it changes"
          ],
          "rows": [
            [
              "useState",
              "A render-driving value (UI state)",
              "✅ Triggers a re-render"
            ],
            [
              "useRef",
              "A mutable container: { current: ... }",
              "❌ Does NOT trigger a re-render"
            ]
          ],
          "caption": "The core difference"
        },
        {
          "type": "text",
          "text": "<strong>First-principles mental model</strong><br><br>React re-renders when you want the UI to reflect new data. So ask yourself one question:<br><br><em>\"Should changing this value update what the user sees right now?\"</em><br><br>If yes → <strong>useState</strong>.<br>If no (but you still need the value to persist) → <strong>useRef</strong>."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Example() {\n  const [count, setCount] = useState(0);  // UI should update when this changes\n  const clicksRef = useRef(0);           // internal bookkeeping; UI doesn't need it\n\n  const onClick = () => {\n    clicksRef.current += 1;              // won't re-render\n    setCount((c) => c + 1);              // will re-render\n  };\n\n  return (\n    <button onClick={onClick}>\n      Count: {count}\n    </button>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Common useState use cases</strong><br><br>Use <code>useState</code> when the value affects rendering: text, visibility, selection, form inputs, loading state, errors, filters, toggles, etc."
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "Correct tool",
            "Why"
          ],
          "rows": [
            [
              "Show/hide a modal",
              "useState",
              "UI must update immediately"
            ],
            [
              "Form input value",
              "useState",
              "Render depends on current value"
            ],
            [
              "Loading / error / fetched data",
              "useState",
              "UI should reflect async results"
            ],
            [
              "Selected tab / filter",
              "useState",
              "Directly affects what is shown"
            ]
          ],
          "caption": "When useState is the right choice"
        },
        {
          "type": "text",
          "text": "<strong>Common useRef use cases</strong><br><br>Use <code>useRef</code> when you need a value to persist, but you don’t want a render every time it changes."
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "Why useRef fits",
            "Example"
          ],
          "rows": [
            [
              "DOM element access",
              "Imperative access to a node",
              "focus(), scrollIntoView()"
            ],
            [
              "Timer / interval IDs",
              "Store mutable IDs across renders",
              "setTimeout / setInterval cleanup"
            ],
            [
              "Latest value for async callbacks",
              "Avoid stale closures without rerendering",
              "read latest state in an interval"
            ],
            [
              "Previous value tracking",
              "Persist last render's value",
              "prevCount.current"
            ]
          ],
          "caption": "When useRef is the right choice"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Search() {\n  const inputRef = useRef(null);\n\n  return (\n    <div>\n      <input ref={inputRef} />\n      <button onClick={() => inputRef.current?.focus()}>\n        Focus input\n      </button>\n    </div>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>The big trap: using useRef as \"state\"</strong><br><br>People do this to avoid re-renders, but it’s usually a bug factory. If the UI depends on it and you store it in a ref, the UI won’t update and you’ll get out-of-sync screens."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Bad() {\n  const valueRef = useRef('');\n\n  return (\n    <div>\n      <input onChange={(e) => (valueRef.current = e.target.value)} />\n      <p>Typed: {valueRef.current}</p> {/* ❌ UI won't update reliably */}\n    </div>\n  );\n}\n\nfunction Good() {\n  const [value, setValue] = useState('');\n\n  return (\n    <div>\n      <input value={value} onChange={(e) => setValue(e.target.value)} />\n      <p>Typed: {value}</p> {/* ✅ UI updates */}\n    </div>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb that wins interviews</strong><br><br><strong>useState</strong> = \"React should re-render when this changes.\"<br><strong>useRef</strong> = \"I need to remember something between renders, but it’s not part of the UI.\""
        },
        {
          "type": "text",
          "text": "<strong>Bonus: combining both (best of both worlds)</strong><br><br>Sometimes you want <em>rendering</em> plus a <em>latest value for async callbacks</em> (avoiding stale closures). Keep the UI in state and mirror it into a ref:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Example() {\n  const [count, setCount] = useState(0);\n  const countRef = useRef(count);\n\n  useEffect(() => {\n    countRef.current = count;\n  }, [count]);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      console.log('latest:', countRef.current);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  return <button onClick={() => setCount((c) => c + 1)}>Count: {count}</button>;\n}"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>useState</code> holds render-driving state and triggers re-renders. <code>useRef</code> holds a mutable value that persists across renders but does not trigger re-renders. Use state for anything that affects UI, and refs for DOM access, timers, latest values in async callbacks, and other non-visual bookkeeping."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "hooks",
      "state",
      "dom"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "useRef vs useState in React: what is the difference?",
      "description": "useState stores reactive values that trigger re-renders, while useRef stores mutable values that persist across renders without re-rendering."
    }
  },
  {
    "id": "react-why-batching-state-updates",
    "title": "Why does React batch state updates? When does it not batch?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Explain why React batches multiple state updates into a single render for performance, how automatic batching works (especially in React 18), and in which situations batching does not apply or can be disabled.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Short answer</strong><br><br>React batches state updates to <strong>avoid unnecessary re-renders</strong>. If multiple state updates happen during the same logical event, React groups them and performs <em>one</em> render instead of many."
        },
        {
          "type": "text",
          "text": "<strong>The first-principles reason</strong><br><br>Rendering is expensive. Reconciliation + DOM updates cost time. If React re-rendered after <em>every</em> <code>setState</code>, a single click handler could trigger 3–5 renders in a row.<br><br>Batching turns this:<br><em>\"Render → update → render → update → render\"</em><br>into this:<br><em>\"Update → update → update → render once\"</em>."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Counter() {\n  const [a, setA] = useState(0);\n  const [b, setB] = useState(0);\n\n  const onClick = () => {\n    setA(a + 1);\n    setB(b + 1);\n    // ✅ React batches these into ONE render\n  };\n\n  console.log('render');\n\n  return <button onClick={onClick}>Click</button>;\n}"
        },
        {
          "type": "text",
          "text": "<strong>What batching guarantees</strong><br><br>Within the same event or task, React waits until your logic finishes, then renders <em>once</em> using the final state."
        },
        {
          "type": "list",
          "columns": [
            "Without batching",
            "With batching",
            "Why it matters"
          ],
          "rows": [
            [
              "Multiple renders per event",
              "Single render per event",
              "Much better performance"
            ],
            [
              "Wasted reconciliation work",
              "Minimal reconciliation",
              "Scales better in large apps"
            ],
            [
              "More layout/paint work",
              "Fewer DOM commits",
              "Smoother UI"
            ]
          ],
          "caption": "Why batching exists"
        },
        {
          "type": "text",
          "text": "<strong>React 18: Automatic batching</strong><br><br>Before React 18, batching only happened in <em>React event handlers</em>. In React 18+, batching happens <strong>almost everywhere</strong>:<br>• timeouts<br>• promises<br>• native event handlers<br>• async callbacks"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "setTimeout(() => {\n  setA(a + 1);\n  setB(b + 1);\n  // ✅ React 18 batches these too\n}, 1000);"
        },
        {
          "type": "text",
          "text": "<strong>But when does React NOT batch?</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Case",
            "Does it batch?",
            "Why"
          ],
          "rows": [
            [
              "Different ticks / separate tasks",
              "❌ No",
              "They are not part of the same batch window"
            ],
            [
              "Using flushSync",
              "❌ No (forces sync render)",
              "You explicitly tell React to render immediately"
            ],
            [
              "Legacy React (<18) async callbacks",
              "❌ No",
              "Batching only existed in React events"
            ]
          ],
          "caption": "When batching does not apply"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import { flushSync } from 'react-dom';\n\nflushSync(() => {\n  setA(1);\n});\n// 👆 Forces immediate render here\n\nsetB(2);\n// 👆 Causes another render"
        },
        {
          "type": "text",
          "text": "<strong>Important pitfall: stale state with non-functional updates</strong><br><br>Because updates are batched, this is WRONG:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "setCount(count + 1);\nsetCount(count + 1); // ❌ still only +1"
        },
        {
          "type": "text",
          "text": "Because both updates read the <em>same snapshot</em>. The correct version is:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "setCount(c => c + 1);\nsetCount(c => c + 1); // ✅ +2"
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say it like this:<br><em>\"React batches state updates to minimize renders and improve performance. In React 18, batching is automatic across events, promises, and timeouts. It only stops batching when you cross async boundaries or explicitly force sync rendering with flushSync.\"</em>"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React batches state updates to reduce unnecessary renders and DOM work. In React 18, batching is automatic in most async and sync contexts. It does not batch across separate tasks or when you explicitly force synchronous rendering with flushSync. Because of batching, functional state updates are often required to avoid stale values."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "state",
      "performance",
      "state-management"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Why does React batch state updates?",
      "description": "React batches state updates to reduce extra renders and apply related updates together for more consistent UI."
    }
  },
  {
    "id": "react-derived-state-anti-pattern",
    "title": "Why is derived state considered an anti-pattern? When is it OK?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Explain why storing data in state that can be computed from props/state creates duplication and sync bugs, the concept of single source of truth, and when derived state is acceptable (initialization, controlled/uncontrolled transitions, memoized expensive computations, and snapshotting external values).",
    "seo": {
      "title": "Why is derived state an anti-pattern in React?",
      "description": "Derived state is often an anti-pattern because duplicated sources of truth drift out of sync and create stale or conflicting UI."
    },
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Short answer</strong><br><br>Derived state is considered an anti-pattern because it <strong>duplicates source data</strong>. When you store something in state that can be calculated from props or other state, you now have <em>two sources of truth</em> — and they eventually drift out of sync."
        },
        {
          "type": "text",
          "text": "<strong>First-principles mental model</strong><br><br>React is best when your UI is a pure function of inputs:<br><br><em>UI = f(props, state)</em><br><br>If a value can be computed from existing inputs, storing it as state means you must keep it manually synced. That’s extra complexity + extra failure modes."
        },
        {
          "type": "list",
          "columns": [
            "What derived state is",
            "Why it’s tempting",
            "Why it bites later"
          ],
          "rows": [
            [
              "State that can be computed from props/other state",
              "Feels convenient (\"I’ll store it once\")",
              "Creates duplication and sync bugs"
            ],
            [
              "Copying props into state",
              "Lets you “edit” a prop locally",
              "Prop changes can get ignored"
            ],
            [
              "Storing computed values",
              "Avoid recomputation",
              "Stale values when inputs change"
            ]
          ],
          "caption": "Why derived state is risky"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Bad({ items }) {\n  const [count, setCount] = useState(items.length); // ❌ derived from props\n\n  // Now you must remember to keep it in sync...\n  // What if items changes? count becomes wrong.\n\n  return <div>Count: {count}</div>;\n}"
        },
        {
          "type": "text",
          "text": "<strong>Why this breaks in real life</strong><br><br>If <code>items</code> changes (refetch, filtering, websocket update), <code>count</code> won’t automatically update because React does not “re-run” <code>useState</code> initializers. Your UI becomes inconsistent: it shows old computed values from a previous render."
        },
        {
          "type": "text",
          "text": "<strong>Preferred approach: derive during render</strong><br><br>If it’s cheap to compute, just compute it from the real source of truth:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Good({ items }) {\n  const count = items.length; // ✅ derived during render\n  return <div>Count: {count}</div>;\n}"
        },
        {
          "type": "text",
          "text": "<strong>If it’s expensive: memoize, don’t store</strong><br><br>If computing derived data is heavy (sorting, filtering huge lists), use <code>useMemo</code> so you still have a single source of truth:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Good({ items, query }) {\n  const filtered = useMemo(() => {\n    return items.filter(i => i.name.toLowerCase().includes(query.toLowerCase()));\n  }, [items, query]);\n\n  return <List items={filtered} />;\n}"
        },
        {
          "type": "text",
          "text": "<strong>When derived state is OK</strong><br><br>It’s acceptable when you intentionally want a <strong>snapshot</strong> or a <strong>locally editable copy</strong> that should not always follow the source automatically."
        },
        {
          "type": "list",
          "columns": [
            "OK scenario",
            "What you’re doing",
            "Example"
          ],
          "rows": [
            [
              "Initial value only (one-time initialization)",
              "Use prop once to seed local state",
              "Initial form value from server"
            ],
            [
              "Locally editable draft",
              "User edits a copy, then saves/cancels",
              "Edit profile modal: draftName"
            ],
            [
              "State machines / UI modes",
              "Derived info becomes an independent UI state",
              "step index, expanded rows"
            ],
            [
              "Snapshot external values",
              "Capture a value at a moment in time",
              "store initial scroll position"
            ]
          ],
          "caption": "Acceptable uses of derived state"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function EditProfile({ user }) {\n  // ✅ OK: draft state is intentionally independent\n  const [draftName, setDraftName] = useState(user.name);\n\n  const save = () => {\n    // submit draftName\n  };\n\n  return (\n    <div>\n      <input value={draftName} onChange={(e) => setDraftName(e.target.value)} />\n      <button onClick={save}>Save</button>\n    </div>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>But… what if the prop can change while editing?</strong><br><br>This is where teams accidentally reintroduce the anti-pattern. If <code>user</code> can change (switching profiles, refetch), you must decide behavior:<br><br>• If you want to <em>reset</em> draft on user change → set draft when the identity changes (not every render).<br>• If you want to <em>preserve</em> unsaved edits → don’t overwrite draft."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function EditProfile({ user }) {\n  const [draftName, setDraftName] = useState(user.name);\n\n  // ✅ reset draft only when user identity changes\n  useEffect(() => {\n    setDraftName(user.name);\n  }, [user.id]);\n\n  return <input value={draftName} onChange={(e) => setDraftName(e.target.value)} />;\n}"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>If you ever write <code>useEffect(() => setX(deriveFromY), [y])</code>, pause and ask:<br><br><em>\"Why do I need X at all? Can I compute it during render or memoize it?\"</em><br><br>Most of the time: compute/memoize is simpler and safer."
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say it like this:<br><em>\"Derived state duplicates data and creates two sources of truth, leading to sync bugs. Prefer computing derived values during render or with useMemo. It’s only OK when you intentionally need a snapshot or an editable draft that should not always track the source.\"</em>"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Derived state is an anti-pattern because it duplicates information that can be derived from props/state, causing drift and stale UI. Prefer deriving during render or memoizing expensive computations. It’s OK when you intentionally need independent local state (drafts, snapshots, UI modes) and you define clear rules for when (or if) it should resync."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "state",
      "derived-state",
      "state-management",
      "best-practices"
    ],
    "updatedAt": "2026-01-30"
  },
  {
    "id": "react-context-performance-issues",
    "title": "Why does Context cause performance issues? How do you fix them?",
    "technology": "react",
    "difficulty": "hard",
    "importance": 4,
    "description": "Explain why Context updates can trigger re-renders across many consumers (especially when the Provider value identity changes), common pitfalls (inline objects/functions), and practical fixes: memoizing Provider values, splitting contexts, narrowing provider scope, memoizing consumers, and using selector-based patterns when needed.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Short answer</strong><br><br>Context can cause performance issues because when a Provider’s <code>value</code> changes, React notifies <strong>all consumers</strong> under that Provider. If the value is an object/function created inline, its identity changes on every render — causing a fan-out of re-renders even when the “real data” didn’t change."
        },
        {
          "type": "text",
          "text": "<strong>Core mechanism</strong><br><br>Context is not a \"subscription by field\" system. React tracks context updates by comparing the Provider’s <code>value</code> <em>by reference</em> (identity), not by deep equality. So this is a common footgun:<br><br><em>\"Provider rerenders → new object → consumers rerender\"</em>."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "const AppContext = createContext(null);\n\nfunction AppProvider({ children }) {\n  const [user, setUser] = useState(null);\n\n  // ❌ Bad: new object every render (new identity)\n  const value = { user, setUser };\n\n  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;\n}\n\nfunction Profile() {\n  const { user } = useContext(AppContext);\n  return <div>{user?.name}</div>;\n}"
        },
        {
          "type": "text",
          "text": "<strong>Why this hurts</strong><br><br>Every time <code>AppProvider</code> re-renders, <code>value</code> becomes a brand-new object. React treats that as a context change and re-renders every component using <code>useContext(AppContext)</code> — even if the piece they care about didn’t change."
        },
        {
          "type": "list",
          "columns": [
            "Common cause",
            "What happens",
            "Symptom"
          ],
          "rows": [
            [
              "Provider value is an inline object",
              "Identity changes each render",
              "All consumers re-render too often"
            ],
            [
              "Provider value contains inline functions",
              "Functions get new identity",
              "Memoized consumers still re-render"
            ],
            [
              "Context holds “everything” (mega context)",
              "Any change invalidates all consumers",
              "Small updates cause big UI work"
            ],
            [
              "Provider wraps the whole app",
              "Update fan-out is huge",
              "Scrolling / typing feels laggy"
            ]
          ],
          "caption": "Why Context can become a perf trap"
        },
        {
          "type": "text",
          "text": "<strong>Fix #1: Memoize the Provider value</strong><br><br>Stabilize the <code>value</code> identity so consumers only re-render when the actual data changes:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function AppProvider({ children }) {\n  const [user, setUser] = useState(null);\n\n  const value = useMemo(() => ({ user, setUser }), [user]);\n  // ✅ stable object identity unless user changes\n\n  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;\n}"
        },
        {
          "type": "text",
          "text": "<strong>Fix #2: Split contexts by change rate</strong><br><br>Don’t put fast-changing values (like <code>theme</code>, <code>locale</code>, <code>isOnline</code>, <code>mousePosition</code>) in the same context as rarely-changing values (like <code>user</code>). Split them so updates don’t cascade unnecessarily."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "const UserContext = createContext(null);\nconst ThemeContext = createContext('light');\n\n// ✅ user updates won't re-render theme consumers and vice versa"
        },
        {
          "type": "text",
          "text": "<strong>Fix #3: Narrow the Provider scope</strong><br><br>Wrap only the subtree that needs the context. If you wrap the entire app, every update has a huge blast radius."
        },
        {
          "type": "list",
          "columns": [
            "Strategy",
            "How it helps",
            "When to use"
          ],
          "rows": [
            [
              "Move Provider lower in the tree",
              "Fewer consumers get notified",
              "Large apps, frequently updated context"
            ],
            [
              "Create feature-level providers",
              "Localizes re-renders",
              "Dashboard pages, complex layouts"
            ],
            [
              "Avoid putting transient UI state in context",
              "Prevents high-frequency fan-out",
              "Typing, hover, scroll, drag state"
            ]
          ],
          "caption": "Reducing the blast radius of context updates"
        },
        {
          "type": "text",
          "text": "<strong>Fix #4: Memoize consumers (sometimes helps)</strong><br><br><code>React.memo</code> does <em>not</em> stop a component from re-rendering due to context changes. But it can still help reduce work inside subtrees if you restructure so only small components read context."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "const UserName = React.memo(function UserName() {\n  const { user } = useContext(AppContext);\n  return <span>{user?.name}</span>;\n});\n\n// ✅ Keep context reads in small leaf components"
        },
        {
          "type": "text",
          "text": "<strong>Fix #5: Selector-based patterns for big stores</strong><br><br>If you’re using Context like a global store with lots of fields, you may want a selector-based approach so consumers re-render only when the selected slice changes (instead of any change). This is where store libraries or selector patterns shine."
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br><strong>Context is great for:</strong> low-frequency global values (theme, locale, auth user, feature flags).<br><strong>Context is risky for:</strong> high-frequency state or “everything store” objects (typing, forms, rapidly updating dashboards)."
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say it like this:<br><em>\"Context updates are based on Provider value identity. If the value changes, all consumers re-render. Fix it by memoizing the Provider value, splitting contexts by change rate, narrowing provider scope, and avoiding mega-context stores. For large state, use selector-based patterns or a store.\"</em>"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Context can hurt performance because Provider value identity changes can trigger re-renders across many consumers. Stabilize the Provider value with useMemo, split contexts, reduce provider scope, keep context reads small, and prefer selector/store patterns when you need fine-grained updates."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "context",
      "performance",
      "memoization",
      "state-management"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Why can React Context cause performance issues?",
      "description": "React Context can cause performance issues because all consumers re-render when provider value identity changes."
    }
  },
  {
    "id": "react-error-boundaries-what-they-solve",
    "title": "What problem do Error Boundaries solve? What don’t they catch?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Explain how React Error Boundaries prevent a whole app from crashing due to rendering errors by showing a fallback UI, what they catch (render/lifecycle/constructor errors in descendants), and what they do NOT catch (event handlers, async code, SSR, and errors inside the boundary itself).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Short answer</strong><br><br>Error Boundaries solve the problem of <strong>UI tree crashes</strong>. If a component throws during rendering, React can replace that broken subtree with a <strong>fallback UI</strong> instead of unmounting the entire app (or leaving a blank screen)."
        },
        {
          "type": "text",
          "text": "<strong>What they are (mental model)</strong><br><br>An Error Boundary is like a <em>seatbelt for a part of your component tree</em>.<br><br>Without it: one render error can crash the whole render path.<br>With it: React catches the error and renders a fallback for that subtree."
        },
        {
          "type": "list",
          "columns": [
            "What Error Boundaries catch",
            "Where the error happens",
            "Why it matters"
          ],
          "rows": [
            [
              "Errors during rendering",
              "While React is computing the UI output",
              "Prevents blank screens / app crashes"
            ],
            [
              "Errors in lifecycle methods (class components)",
              "componentDidMount / componentDidUpdate, etc.",
              "Lets you recover with fallback UI"
            ],
            [
              "Errors in constructors (class components)",
              "During component creation",
              "Stops faulty subtree from taking down the app"
            ]
          ],
          "caption": "What Error Boundaries are designed to catch"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, info) {\n    // log to monitoring (Sentry, etc.)\n    console.error(error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <div>Something went wrong.</div>;\n    }\n    return this.props.children;\n  }\n}\n\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <BuggyWidget />\n    </ErrorBoundary>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Key limitation</strong><br><br>Error Boundaries only catch errors that happen while React is rendering/committing the UI tree for <em>descendants</em>.<br><br>They are <strong>not</strong> a general-purpose try/catch for everything in your app."
        },
        {
          "type": "list",
          "columns": [
            "What they do NOT catch",
            "Example",
            "How to handle instead"
          ],
          "rows": [
            [
              "Event handler errors",
              "onClick / onSubmit throws",
              "Use try/catch in the handler + report/log"
            ],
            [
              "Async errors",
              "setTimeout / promise / async/await throws",
              "Catch with .catch / try/catch and set error state"
            ],
            [
              "Errors in the Error Boundary itself",
              "Fallback UI throws",
              "Wrap higher or fix boundary; keep fallback simple"
            ],
            [
              "Errors outside React tree",
              "Global scripts, non-React code",
              "window.onerror / monitoring integration"
            ],
            [
              "SSR rendering errors (server-side)",
              "Server render throws before client loads",
              "Handle on server/framework level + return error page"
            ]
          ],
          "caption": "What Error Boundaries don’t catch"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Button() {\n  const onClick = () => {\n    // ❌ Error Boundaries do NOT catch this\n    throw new Error('Boom in event handler');\n  };\n\n  return <button onClick={onClick}>Click me</button>;\n}\n\nfunction SaferButton() {\n  const onClick = () => {\n    try {\n      throw new Error('Boom');\n    } catch (e) {\n      // ✅ handle + report\n      console.error(e);\n    }\n  };\n\n  return <button onClick={onClick}>Click me</button>;\n}"
        },
        {
          "type": "text",
          "text": "<strong>Where to place Error Boundaries (practical)</strong><br><br>Don’t wrap the entire app with one giant boundary only. Use a few strategically placed boundaries so failure is isolated:<br><br>• Page-level boundary (keeps navbar/layout alive)<br>• Widget/card boundary (dashboard tiles don’t nuke the whole page)<br>• Route boundary (one route fails, rest of app still usable)"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>Use Error Boundaries to protect the UI tree from render-time crashes. Use normal error handling for user interactions and async work."
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say it like this:<br><em>\"Error Boundaries catch errors during rendering and lifecycle/constructor of descendants, letting React show a fallback UI instead of crashing the whole tree. They do not catch errors in event handlers, async callbacks, SSR, or errors inside the boundary itself — those need explicit try/catch or promise handling.\"</em>"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Error Boundaries prevent render-time exceptions in a subtree from crashing the entire UI by rendering a fallback and optionally reporting the error. They catch render/commit-time errors in descendants but not event handler errors, async errors, SSR errors, or errors in the boundary itself."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "error-handling",
      "components",
      "best-practices"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "What do React Error Boundaries catch?",
      "description": "Error Boundaries catch render, lifecycle, and constructor errors in trees and show fallback UI. They do not catch event-handler, async, or SSR errors."
    }
  },
  {
    "id": "react-strictmode-double-invoke-effects",
    "title": "Why does StrictMode double-invoke effects in dev? What bugs does it expose?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain why React StrictMode intentionally double-invokes certain lifecycles and effects in development, how this simulates mount–unmount–remount, and what kinds of side-effect and cleanup bugs it is designed to reveal.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Short answer</strong><br><br>React StrictMode double-invokes effects in development to <strong>stress-test your side effects</strong>. It intentionally simulates <em>mount → unmount → mount</em> to expose bugs where effects are not <strong>idempotent</strong> or don’t clean up properly."
        },
        {
          "type": "text",
          "text": "<strong>Important: this only happens in development</strong><br><br>StrictMode checks run <strong>only in dev</strong>. Production builds do not double-invoke effects. This is a <em>diagnostic tool</em>, not a performance feature."
        },
        {
          "type": "text",
          "text": "<strong>The mental model</strong><br><br>React is preparing for a future where it can <em>pause, discard, and restart renders</em> (concurrent rendering). To make sure your code is safe for that world, StrictMode asks a brutal question:<br><br><em>\"If I mount this component, tear it down, and mount it again immediately… does anything break?\"</em>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Example() {\n  useEffect(() => {\n    console.log('effect run');\n    return () => {\n      console.log('cleanup');\n    };\n  }, []);\n\n  return <div>Hello</div>;\n}\n\n// In StrictMode (dev), you'll see:\n// effect run\n// cleanup\n// effect run"
        },
        {
          "type": "text",
          "text": "<strong>What exactly gets double-invoked?</strong><br><br>In React 18 StrictMode (dev):<br>• Component render functions<br>• useEffect / useLayoutEffect setup + cleanup<br>• Certain initializers<br><br>React mounts, cleans up, and mounts again immediately."
        },
        {
          "type": "list",
          "columns": [
            "What React is testing",
            "Bad pattern",
            "Bug it exposes"
          ],
          "rows": [
            [
              "Missing cleanup",
              "Subscribing but never unsubscribing",
              "Memory leaks, duplicate listeners"
            ],
            [
              "Non-idempotent side effects",
              "Sending analytics / POST request on mount",
              "Duplicate network calls or double charges"
            ],
            [
              "Mutating external state",
              "Pushing into global arrays, singletons",
              "Duplicated or corrupted global state"
            ],
            [
              "Assuming effects run only once",
              "“This runs once on mount” logic",
              "Breaks under remounts / transitions"
            ]
          ],
          "caption": "The kinds of bugs StrictMode is hunting"
        },
        {
          "type": "text",
          "text": "<strong>Classic bug example: missing cleanup</strong>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "useEffect(() => {\n  window.addEventListener('resize', onResize);\n  // ❌ No cleanup\n}, []);\n\n// In StrictMode dev, this registers the listener twice 😬"
        },
        {
          "type": "text",
          "text": "Correct version:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "useEffect(() => {\n  window.addEventListener('resize', onResize);\n  return () => {\n    window.removeEventListener('resize', onResize);\n  };\n}, []);\n\n// ✅ Safe under mount → unmount → mount"
        },
        {
          "type": "text",
          "text": "<strong>Another classic: non-idempotent side effects</strong>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "useEffect(() => {\n  analytics.track('page_view'); // ❌ will fire twice in dev StrictMode\n}, []);"
        },
        {
          "type": "text",
          "text": "Better patterns:<br><br>• Move it to a router-level boundary<br>• Or make it idempotent<br>• Or dedupe on the analytics side"
        },
        {
          "type": "text",
          "text": "<strong>Why React does this (the real reason)</strong><br><br>Concurrent React may mount, pause, throw away, and restart trees. If your effects are not resilient to being started and stopped multiple times, you’ll get production-only bugs. StrictMode forces you to see them early."
        },
        {
          "type": "text",
          "text": "<strong>What this is NOT</strong><br><br>• Not a bug<br>• Not React being slow<br>• Not something to “work around”<br><br>It’s a correctness check."
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>Write effects as if React can run them, clean them up, and run them again at any time. If that is safe, your code is future-proof."
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say it like this:<br><em>\"StrictMode double-invokes effects in dev to simulate mount–unmount–remount and catch unsafe side effects. It exposes missing cleanups, non-idempotent logic, and code that assumes effects run only once. This is to prepare apps for concurrent rendering and only runs in development.\"</em>"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>StrictMode intentionally double-invokes effects in development to detect unsafe side effects and missing cleanup. It helps catch memory leaks, duplicated subscriptions, non-idempotent logic, and code that assumes a single mount. This behavior is dev-only and exists to make apps safe for concurrent rendering."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "effects",
      "best-practices"
    ],
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Why does useEffect run twice in React StrictMode?",
      "description": "In StrictMode development, React intentionally runs effect setup-cleanup-setup to expose missing cleanup and non-idempotent side effects."
    }
  },
  {
    "id": "react-useeffect-vs-uselayouteffect",
    "title": "What’s the difference between useEffect and useLayoutEffect? When does it matter?",
    "technology": "react",
    "companies": [
      "bytedance"
    ],
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Explain the timing difference between useEffect and useLayoutEffect in the render/commit/paint pipeline, why useLayoutEffect blocks painting, and when it is required (DOM measurements, preventing visual flicker) versus when useEffect is preferred.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Short answer</strong><br><br><code>useEffect</code> runs <strong>after the browser paints</strong>. <code>useLayoutEffect</code> runs <strong>synchronously after DOM mutations but before the browser paints</strong>. The difference matters when you need to <em>read or write layout</em> and avoid visual flicker."
        },
        {
          "type": "text",
          "text": "<strong>The render pipeline (mental model)</strong><br><br>Roughly, React does this:<br><br>1) Render (compute virtual tree)<br>2) Commit (apply DOM changes)<br>3) <strong>useLayoutEffect runs here (before paint)</strong><br>4) Browser paints to screen<br>5) <strong>useEffect runs here (after paint)</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Hook",
            "When it runs",
            "Does it block paint?"
          ],
          "rows": [
            [
              "useLayoutEffect",
              "After DOM updates, before paint",
              "✅ Yes (blocks paint)"
            ],
            [
              "useEffect",
              "After paint",
              "❌ No (non-blocking)"
            ]
          ],
          "caption": "The critical timing difference"
        },
        {
          "type": "text",
          "text": "<strong>Why this difference exists</strong><br><br><code>useLayoutEffect</code> exists for code that must <em>synchronously</em> read or modify the DOM <strong>before the user sees anything</strong>. <code>useEffect</code> is for everything else (data fetching, subscriptions, logging, timers, etc.)."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Example() {\n  const ref = useRef(null);\n\n  useLayoutEffect(() => {\n    const rect = ref.current.getBoundingClientRect();\n    // Measure and synchronously adjust layout\n  }, []);\n\n  return <div ref={ref}>Hello</div>;\n}"
        },
        {
          "type": "text",
          "text": "<strong>What happens if you use useEffect for layout work?</strong><br><br>The browser will:<br>• Paint the UI once<br>• Then your effect runs<br>• Then you update layout/state<br>• Then it paints again<br><br>The user sees a <strong>visual flicker / jump</strong>."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Tooltip({ text }) {\n  const ref = useRef(null);\n  const [top, setTop] = useState(0);\n\n  // ❌ This can cause visible jump\n  useEffect(() => {\n    const rect = ref.current.getBoundingClientRect();\n    setTop(rect.top - 10);\n  }, []);\n\n  return (\n    <div ref={ref} style={{ position: 'absolute', top }}>\n      {text}\n    </div>\n  );\n}"
        },
        {
          "type": "text",
          "text": "Correct version:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "useLayoutEffect(() => {\n  const rect = ref.current.getBoundingClientRect();\n  setTop(rect.top - 10);\n}, []);\n// ✅ User never sees the wrong position"
        },
        {
          "type": "text",
          "text": "<strong>When you should use useLayoutEffect</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "Why",
            "Examples"
          ],
          "rows": [
            [
              "Measuring DOM size/position",
              "Must read layout before paint",
              "getBoundingClientRect, offsetWidth"
            ],
            [
              "Synchronously adjusting layout",
              "Prevent visible jumps",
              "Tooltips, popovers, modals"
            ],
            [
              "Scroll position corrections",
              "Avoid one-frame wrong scroll",
              "Scroll restoration, anchored lists"
            ],
            [
              "Imperative animations setup",
              "Need correct initial layout",
              "FLIP animations, measurement-based motion"
            ]
          ],
          "caption": "Legitimate use cases for useLayoutEffect"
        },
        {
          "type": "text",
          "text": "<strong>When you should use useEffect (almost always)</strong><br><br>• Data fetching<br>• Subscriptions / event listeners<br>• Logging / analytics<br>• Timers<br>• Syncing with external systems<br><br>These do not need to block paint and should not slow down rendering."
        },
        {
          "type": "text",
          "text": "<strong>Why you should avoid overusing useLayoutEffect</strong><br><br>Because it <strong>blocks the browser from painting</strong>. Too many or heavy <code>useLayoutEffect</code> calls = slow first paint and janky UI."
        },
        {
          "type": "text",
          "text": "<strong>SSR warning</strong><br><br><code>useLayoutEffect</code> does nothing on the server and causes warnings in SSR environments. Many frameworks alias it to <code>useEffect</code> on the server. Another reason to only use it when truly necessary."
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>Start with <code>useEffect</code>. Only switch to <code>useLayoutEffect</code> if you see a visual flicker, layout jump, or need to measure/mutate layout before paint."
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say it like this:<br><em>\"useLayoutEffect runs synchronously after DOM mutations but before paint and blocks rendering, so it’s for layout measurement and visual correctness. useEffect runs after paint and is non-blocking, so it’s for side effects like data fetching and subscriptions. You should prefer useEffect unless you need to prevent visual flicker.\"</em>"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>useLayoutEffect</code> runs before the browser paints and blocks rendering, making it suitable for DOM measurements and layout corrections. <code>useEffect</code> runs after paint and should be used for most side effects. Overusing <code>useLayoutEffect</code> hurts performance, so only use it when visual correctness requires it."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "hooks",
      "effects",
      "performance",
      "dom"
    ],
    "updatedAt": "2026-01-31",
    "seo": {
      "title": "useEffect vs useLayoutEffect: what is the difference?",
      "description": "useLayoutEffect runs synchronously after DOM mutations but before paint, while useEffect runs after paint for non-blocking side effects."
    }
  },
  {
    "id": "react-hooks-youve-used",
    "title": "Which React Hooks have you used, and when would you choose each?",
    "technology": "react",
    "companies": [
      "bytedance",
      "apple"
    ],
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Interviewers want to see that you can choose Hooks intentionally: state, effects, refs, memoization, context, reducers, and concurrent features. Explain what each Hook is for, when you reach for it, and the trade-offs.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nA strong answer shows you pick Hooks based on the job: local state, side effects, stable references, global state, or performance. Group Hooks by purpose and give one concrete example for each."
        },
        {
          "type": "list",
          "columns": [
            "Hook",
            "When I use it",
            "Example"
          ],
          "rows": [
            [
              "useState",
              "Local UI state",
              "Form inputs, toggles, tabs"
            ],
            [
              "useEffect",
              "Sync with external systems after render",
              "Fetch data, subscriptions, timers"
            ],
            [
              "useRef",
              "Hold mutable values or DOM refs without re-rendering",
              "Focus an input, store interval id"
            ],
            [
              "useMemo / useCallback",
              "Avoid expensive recomputation or unstable handlers",
              "Memoize filtered lists or event callbacks"
            ],
            [
              "useContext",
              "Read global values shared across the tree",
              "Theme, locale, auth user"
            ],
            [
              "useReducer",
              "Complex state transitions",
              "Multi-step forms, undo/redo"
            ],
            [
              "useLayoutEffect",
              "Read or write layout before paint",
              "Measure DOM, prevent flicker"
            ],
            [
              "useTransition / useDeferredValue",
              "Keep UI responsive during heavy updates",
              "Search filtering on large lists"
            ],
            [
              "useId",
              "Stable ids for accessibility",
              "label/input linking"
            ]
          ],
          "caption": "Common Hooks and how to talk about them"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Custom hooks</strong>\n\nMention any custom hooks you have built (for data fetching, form logic, analytics, etc.). This shows you can extract reusable stateful logic and keep components clean."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Rules of Hooks (must mention)</strong>\n\n- Call hooks at the top level (no loops or conditionals).\n- Only call hooks from components or other hooks.\n\nThese rules exist because React matches hook state by call order."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nPick hooks based on intent: state, side effects, refs, memoization, or shared state. Explain trade-offs, and show you know the rules and when to use custom hooks."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "hooks",
      "state",
      "effects",
      "context",
      "performance"
    ],
    "updatedAt": "2026-01-31",
    "seo": {
      "title": "Which React Hooks should you use and when?",
      "description": "Choose hooks by purpose: useState/useReducer for state, useEffect for side effects, useRef for mutable values, and useMemo/useCallback for memoization."
    }
  },
  {
    "id": "react-18-whats-new",
    "title": "What's new in React 18?",
    "technology": "react",
    "companies": [
      "bytedance"
    ],
    "difficulty": "intermediate",
    "importance": 3,
    "description": "React 18 introduced the concurrent rendering foundation plus new APIs like createRoot, automatic batching, transitions, and new hooks. Explain the key changes and why they matter to users and developers.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nReact 18 is about a new rendering foundation (concurrency) plus APIs that make apps feel more responsive without changing every component. It also adds new hooks and stricter dev checks to surface unsafe effects."
        },
        {
          "type": "list",
          "columns": [
            "Change",
            "Why it matters",
            "Example"
          ],
          "rows": [
            [
              "New root API",
              "Enables concurrent features and improved scheduling",
              "<code>createRoot(...)</code>"
            ],
            [
              "Automatic batching",
              "Fewer renders across async boundaries",
              "Multiple state updates in timeouts/promises"
            ],
            [
              "Transitions",
              "Keep urgent input responsive during heavy updates",
              "<code>startTransition</code>, <code>useTransition</code>"
            ],
            [
              "Deferred values",
              "Let expensive UI lag slightly behind fast input",
              "<code>useDeferredValue</code>"
            ],
            [
              "Suspense + streaming SSR",
              "Faster time-to-first-byte and incremental rendering",
              "Stream HTML and hydrate as data arrives"
            ],
            [
              "New hooks for ids and external stores",
              "Stable ids for a11y and safer subscriptions",
              "<code>useId</code>, <code>useSyncExternalStore</code>"
            ]
          ],
          "caption": "Key React 18 additions interviewers expect"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Migration notes</strong>\n\nMove to <code>createRoot</code> to opt into React 18 behavior, and audit effects for StrictMode double-invocation in dev. Use transitions for non-urgent updates and keep effects idempotent."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nReact 18 adds concurrent rendering foundations, automatic batching, transitions/deferred values for responsiveness, stronger Suspense/streaming capabilities, and new hooks like <code>useId</code>. The goal is smoother UI without blocking urgent updates."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "react",
      "concurrency",
      "rendering",
      "transition",
      "performance",
      "hooks"
    ],
    "updatedAt": "2026-01-31",
    "seo": {
      "title": "What is new in React 18?",
      "description": "React 18 introduced createRoot, automatic batching, transitions, and concurrent rendering features that improve responsiveness and update scheduling."
    }
  }
]
