[
  {
    "id": "js-number-clamp",
    "title": "Clamp",
    "type": "coding",
    "technology": "javascript",
    "importance": 1,
    "difficulty": "easy",
    "tags": [
      "numbers",
      "math",
      "boundaries"
    ],
    "description": {
      "summary": "Implement a function `clamp(value, lower, upper)` that keeps `value` between `lower` and `upper` (inclusive). Assume `lower <= upper`. This is often used for sliders, percentages, animations, and other bounded values.",
      "arguments": [
        {
          "name": "value",
          "type": "number",
          "desc": "The number to clamp."
        },
        {
          "name": "lower",
          "type": "number",
          "desc": "The lower bound."
        },
        {
          "name": "upper",
          "type": "number",
          "desc": "The upper bound."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The clamped number."
      },
      "examples": [
        "// Basic examples\nclamp(3, 0, 5) // => 3\nclamp(-10, -3, 5) // => -3\nclamp(10, -5, 5) // => 5\n\n// On the bounds (inclusive)\nclamp(0, 0, 5) // => 0\nclamp(5, 0, 5) // => 5"
      ]
    },
    "starterCode": "export default function clamp(value, lower, upper) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: keep a number inside an inclusive range. If it falls below `lower`, return `lower`. If it goes above `upper`, return `upper`. Otherwise, return `value` as-is. This shows up in sliders, percentages, animations, and input validation.",
      "approaches": [
        {
          "title": "Approach 1: Branching (readable baseline)",
          "prose": "Idea: compare `value` to each bound and return the appropriate number.\n\nHow it works:\n1. If `value < lower`, return `lower`.\n2. Else if `value > upper`, return `upper`.\n3. Otherwise, return `value` as-is.\n\nWhy use it: very explicit and easy to debug or extend (for example, add logging around each branch).",
          "codeJs": "export default function clamp(value, lower, upper) {\n  if (value < lower) return lower;\n  if (value > upper) return upper;\n  return value;\n}\n",
          "codeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  if (value < lower) return lower;\n  if (value > upper) return upper;\n  return value;\n}\n"
        },
        {
          "title": "Approach 2: Math chaining (compact)",
          "prose": "Idea: clamp in a single expression — first push `value` up to the lower bound, then cap it at the upper bound.\n\nWe can write: `Math.min(Math.max(value, lower), upper)`.\n\nRead it as: *at least `lower`, at most `upper`.*\n\nWhy use it: short, idiomatic, and easy to scan once you're used to it.",
          "codeJs": "export default function clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\n",
          "codeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  return Math.min(Math.max(value, lower), upper);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "`lower` should be `<= upper`. If not guaranteed by caller, normalize or assert.",
          "`NaN` inputs propagate through `Math.min/max` → result becomes `NaN`. Decide whether to coerce or throw.",
          "Non-number inputs (strings, null) will be coerced if you use Math.*; prefer validating types for clarity."
        ],
        "edgeCases": [
          "value exactly equals `lower` or `upper` → return that bound.",
          "Very large magnitudes: works, but be mindful of ±Infinity if it can appear.",
          "Swapped bounds: if it can happen, you can fix with `[lower, upper] = lower <= upper ? [lower, upper] : [upper, lower]`."
        ],
        "techniques": [
          "Guard + early return for clarity (Approach 1).",
          "Common clamping pattern with `Math.min(Math.max(...))` (Approach 2)."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels",
        "js-arrays-equal"
      ],
      "resources": [
        {
          "title": "MDN – Math.max()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max"
        },
        {
          "title": "MDN – Math.min()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min"
        }
      ]
    },
    "tests": "import clamp from './clamp';\n\ndescribe('clamp', () => {\n  test('within range', () => expect(clamp(3, 0, 5)).toBe(3));\n  test('below lower', () => expect(clamp(-10, -3, 5)).toBe(-3));\n  test('above upper', () => expect(clamp(10, -5, 5)).toBe(5));\n  test('on bounds (inclusive)', () => {\n    expect(clamp(0, 0, 5)).toBe(0);\n    expect(clamp(5, 0, 5)).toBe(5);\n  });\n});\n",
    "testsTs": "import clamp from './clamp';\n\ndescribe('clamp (TypeScript)', () => {\n  it('returns the same value when within range', () => {\n    expect(clamp(3, 0, 5)).toBe(3);\n  });\n  it('clamps to lower bound when below range', () => {\n    expect(clamp(-10, -3, 5)).toBe(-3);\n  });\n  it('clamps to upper bound when above range', () => {\n    expect(clamp(10, -5, 5)).toBe(5);\n  });\n  it('returns bounds when value is exactly on them', () => {\n    expect(clamp(0, 0, 5)).toBe(0);\n    expect(clamp(5, 0, 5)).toBe(5);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-reverse-string",
    "title": "Reverse a String",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "string"
    ],
    "description": {
      "summary": "Implement a function `reverseString(str)` that returns the reversed version of the input string without using built-in methods like `.reverse()`.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to be reversed."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "The reversed string."
      },
      "examples": [
        "// Basic example\nreverseString('abc') // => 'cba'",
        "// Palindrome\nreverseString('racecar') // => 'racecar'",
        "// With spaces and punctuation\nreverseString('A man, a plan') // => 'nalp a ,nam A'"
      ]
    },
    "starterCode": "export default function reverseString(str) {\n  // TODO: Implement without using Array.prototype.reverse()\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function reverseString(str: string): string {\n  // TODO: Implement without using Array.prototype.reverse()\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: reverse the characters of a string from end to start without calling `Array.prototype.reverse()` in your main solution. This tests string traversal and the fact that strings are immutable.",
      "approaches": [
        {
          "title": "Approach 1: Manual loop (explicit and clear)",
          "prose": "Idea: traverse the string backwards and build a new string character by character.\n\nHow it works:\n1. Initialize `out = ''`.\n2. Loop from the last index (`str.length - 1`) down to `0`.\n3. On each iteration, append `str[i]` to `out`.\n4. After the loop, return `out`.\n\nWhy use it: very clear and easy to understand for beginners. It also shows that strings are immutable — each concatenation creates a new string.",
          "codeJs": "export default function reverseString(str) {\n  let out = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    out += str[i];\n  }\n  return out;\n}\n",
          "codeTs": "export default function reverseString(str: string): string {\n  let out = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    out += str[i];\n  }\n  return out;\n}\n"
        },
        {
          "title": "Approach 2: Using array methods (follow-up, compact)",
          "prose": "Idea: convert the string into an array, reverse it, and join it back into a string.\n\nWe can write: `str.split('').reverse().join('')`.\n\nRead it as: *split → reverse → join*.\n\nWhy use it: concise and idiomatic once you know the APIs. In this problem, treat it as an alternate or follow-up solution, because the main requirement is to avoid calling `Array.prototype.reverse()` in your core implementation.",
          "codeJs": "export default function reverseString(str) {\n  return str.split('').reverse().join('');\n}\n",
          "codeTs": "export default function reverseString(str: string): string {\n  return str.split('').reverse().join('');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Strings are immutable — you cannot modify characters in place.",
          "Avoid relying on `.reverse()` in your primary solution if the problem forbids it.",
          "For Unicode characters like emoji, this naive approach may split surrogate pairs incorrectly."
        ],
        "edgeCases": [
          "Empty string → returns `''`.",
          "Single character → unchanged.",
          "Palindrome → returns itself."
        ],
        "techniques": [
          "Iterating in reverse order over a string.",
          "Using concatenation or array methods to reconstruct a string."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels",
        "js-capitalize-words"
      ],
      "resources": [
        {
          "title": "MDN – String.prototype.split()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split"
        },
        {
          "title": "MDN – String.prototype.concat()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat"
        }
      ]
    },
    "tests": "import reverseString from './reverseString';\n\ndescribe('reverseString', () => {\n  test('reverses simple strings (abc)', () => {\n    expect(reverseString('abc')).toBe('cba');\n  });\n\n  test('reverses simple strings (hello)', () => {\n    expect(reverseString('hello')).toBe('olleh');\n  });\n\n  test('handles palindromes', () => {\n    expect(reverseString('racecar')).toBe('racecar');\n  });\n\n  test('reverses with spaces and punctuation', () => {\n    expect(reverseString('A man, a plan')).toBe('nalp a ,nam A');\n  });\n\n  test('handles empty string', () => {\n    expect(reverseString('')).toBe('');\n  });\n\n  test('handles single character', () => {\n    expect(reverseString('x')).toBe('x');\n  });\n});\n",
    "testsTs": "import reverseString from './reverseString';\n\ndescribe('reverseString (TypeScript)', () => {\n  it('reverses simple strings (abc)', () => {\n    expect(reverseString('abc')).toBe('cba');\n  });\n\n  it('reverses simple strings (hello)', () => {\n    expect(reverseString('hello')).toBe('olleh');\n  });\n\n  it('handles palindromes', () => {\n    expect(reverseString('racecar')).toBe('racecar');\n  });\n\n  it('reverses with spaces and punctuation', () => {\n    expect(reverseString('A man, a plan')).toBe('nalp a ,nam A');\n  });\n\n  it('handles empty string', () => {\n    expect(reverseString('')).toBe('');\n  });\n\n  it('handles single character', () => {\n    expect(reverseString('x')).toBe('x');\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-count-vowels",
    "title": "Count Vowels",
    "type": "coding",
    "importance": 2,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "string"
    ],
    "description": {
      "summary": "Implement a function `countVowels(str)` that returns how many vowels (`a, e, i, o, u`) exist in a given string, regardless of case.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to analyze."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The number of vowels found in the string."
      },
      "examples": [
        "// Basic examples\ncountVowels('hello') // => 2",
        "countVowels('rhythm') // => 0",
        "countVowels('AEIOU') // => 5",
        "// Mixed case and spaces\ncountVowels('A quick brown fox') // => 5"
      ]
    },
    "starterCode": "export default function countVowels(str) {\n  // TODO: Return how many vowels (a, e, i, o, u) are in the string\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function countVowels(str: string): number {\n  // TODO: Return how many vowels (a, e, i, o, u) are in the string\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: count how many vowels (`a, e, i, o, u`) appear in a given string, ignoring case. This tests string traversal and simple conditional logic.",
      "approaches": [
        {
          "title": "Approach 1: Iterative counting (explicit and clear)",
          "prose": "Idea: iterate through each character, normalize to lowercase, and count it if it's one of `aeiou`.\n\nHow it works:\n1. Define a string of vowels: `const vowels = 'aeiou'`.\n2. Initialize `count = 0`.\n3. Loop through each character `ch` in `str.toLowerCase()`.\n4. If `vowels.includes(ch)`, increment `count`.\n5. Return `count`.\n\nWhy use it: clear, O(n), and works for any casing. Great for learning iteration and conditionals.",
          "codeJs": "export default function countVowels(str) {\n  const vowels = 'aeiou';\n  let count = 0;\n  for (const ch of str.toLowerCase()) {\n    if (vowels.includes(ch)) count++;\n  }\n  return count;\n}\n",
          "codeTs": "export default function countVowels(str: string): number {\n  const vowels = 'aeiou';\n  let count = 0;\n  for (const ch of str.toLowerCase()) {\n    if (vowels.includes(ch)) count++;\n  }\n  return count;\n}\n"
        },
        {
          "title": "Approach 2: Regular expression (concise alternative)",
          "prose": "Idea: use a regular expression to directly match all vowels.\n\nWe can write: `(str.match(/[aeiou]/gi) || []).length`.\n\nRead it as: *find all vowels (case-insensitive) and count them*. The `/g` flag finds all matches, and `/i` makes it case-insensitive.\n\nWhy use it: shorter and declarative, though less explicit than manual iteration. Good as a follow-up solution when you're comfortable with regex.",
          "codeJs": "export default function countVowels(str) {\n  return (str.match(/[aeiou]/gi) || []).length;\n}\n",
          "codeTs": "export default function countVowels(str: string): number {\n  return (str.match(/[aeiou]/gi) || []).length;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Empty strings should return `0`.",
          "Regex approach may be less intuitive for beginners.",
          "Non-letter characters (spaces, punctuation) are simply skipped.",
          "`y` is not treated as a vowel here."
        ],
        "edgeCases": [
          "No vowels → returns `0`.",
          "Mixed case → handled by `toLowerCase()` or the `/i` flag.",
          "Accented vowels (é, ü) → not counted unless explicitly included in the vowel set or regex."
        ],
        "techniques": [
          "String traversal and membership checking.",
          "Regex matching and counting via array length."
        ]
      },
      "followUpQuestions": [
        "js-reverse-string",
        "js-capitalize-words"
      ],
      "resources": [
        {
          "title": "MDN – String.prototype.includes()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes"
        },
        {
          "title": "MDN – String.prototype.match()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match"
        }
      ]
    },
    "tests": "import countVowels from './countVowels';\n\ndescribe('countVowels', () => {\n  test('counts lowercase vowels', () => {\n    expect(countVowels('hello')).toBe(2);\n    expect(countVowels('rhythm')).toBe(0);\n  });\n\n  test('counts uppercase vowels', () => {\n    expect(countVowels('AEIOU')).toBe(5);\n  });\n\n  test('counts vowels in mixed case and spaces', () => {\n    expect(countVowels('A quick brown fox')).toBe(5);\n  });\n\n  test('handles empty string', () => {\n    expect(countVowels('')).toBe(0);\n  });\n});\n",
    "testsTs": "import countVowels from './countVowels';\n\ndescribe('countVowels (TypeScript)', () => {\n  it('counts lowercase vowels', () => {\n    expect(countVowels('hello')).toBe(2);\n    expect(countVowels('rhythm')).toBe(0);\n  });\n\n  it('counts uppercase vowels', () => {\n    expect(countVowels('AEIOU')).toBe(5);\n  });\n\n  it('counts vowels in mixed case and spaces', () => {\n    expect(countVowels('A quick brown fox')).toBe(5);\n  });\n\n  it('handles empty string', () => {\n    expect(countVowels('')).toBe(0);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-flatten-once",
    "title": "Flatten One Level",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrays"
    ],
    "description": {
      "summary": "Implement a function `flattenOnce(arr)` that shallow-flattens a nested array by **one level only**. Only arrays that are direct elements of `arr` are unpacked; deeper arrays stay nested and non-array elements are copied as-is.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "The input array which may contain nested arrays."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array shallow-flattened by one level."
      },
      "examples": [
        "// Basic example\nflattenOnce([1, [2, 3], [4, [5]]]) // => [1, 2, 3, 4, [5]]",
        "// Already flat\nflattenOnce([1, 2, 3]) // => [1, 2, 3]",
        "// Mixed values\nflattenOnce([[1], 2, [3, [4]], 5]) // => [1, 2, 3, [4], 5]"
      ]
    },
    "starterCode": "export default function flattenOnce(arr) {\n  // TODO: Flatten one level deep\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function flattenOnce(arr: any[]): any[] {\n  // TODO: Flatten one level deep\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: unpack only the **first layer** of nested arrays (shallow flatten). Deeper arrays remain nested. This tests understanding of array iteration and type checking.",
      "approaches": [
        {
          "title": "Approach 1: Iterative spread (explicit and clear)",
          "prose": "Idea: build a new array and check each element. If it's an array, spread its contents into the result; otherwise, add it directly.\n\nHow it works:\n1. Initialize `const result = []`.\n2. Loop through every element `el` in `arr`.\n3. If `Array.isArray(el)`, push `...el` into `result` (this adds all items from `el`).\n4. Otherwise, push `el` directly.\n5. Return `result`.\n\nWhy use it: straightforward, readable, and O(n). Great for understanding how shallow flattening works without recursion.",
          "codeJs": "export default function flattenOnce(arr) {\n  const result = [];\n  for (const el of arr) {\n    if (Array.isArray(el)) {\n      result.push(...el);\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flattenOnce(arr: any[]): any[] {\n  const result: any[] = [];\n  for (const el of arr) {\n    if (Array.isArray(el)) {\n      result.push(...el);\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using built-in `.flat(1)` (alternate, compact syntax)",
          "prose": "Idea: use the modern `Array.prototype.flat()` method with depth `1`.\n\nWe can write: `arr.flat(1)`.\n\nRead it as: *flatten one layer deep and leave inner arrays untouched*.\n\nWhy use it: concise, modern, and likely optimized. In this question, treat it as an alternate or follow-up solution — the manual approach helps you understand how shallow flattening works internally.",
          "codeJs": "export default function flattenOnce(arr) {\n  return arr.flat(1);\n}\n",
          "codeTs": "export default function flattenOnce(arr: any[]): any[] {\n  return arr.flat(1);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Flattening too deeply defeats the 'one-level' requirement — avoid recursion or `.flat(Infinity)`.",
          "Mutating the original array is not allowed — always return a new one.",
          "Non-array values should remain untouched."
        ],
        "edgeCases": [
          "Empty array → returns `[]`.",
          "Already flat array → identical output.",
          "Mixed values like `[1, [2], 3]` → flattens only first-level arrays."
        ],
        "techniques": [
          "Using `Array.isArray()` for type checking.",
          "Using spread syntax (`...`) for shallow unpacking.",
          "Understanding `.flat(depth)` as a concise modern alternative."
        ]
      },
      "followUpQuestions": [
        "js-flatten-depth"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.flat()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat"
        },
        {
          "title": "MDN – Array.isArray()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
        }
      ]
    },
    "tests": "import flattenOnce from './flattenOnce';\n\ndescribe('flattenOnce', () => {\n  test('flattens a simple nested array', () => {\n    expect(flattenOnce([1, [2, 3], [4, [5]]])).toEqual([1, 2, 3, 4, [5]]);\n  });\n\n  test('returns same array when already flat', () => {\n    expect(flattenOnce([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n\n  test('handles mixed array contents', () => {\n    expect(flattenOnce([[1], 2, [3, [4]], 5])).toEqual([1, 2, 3, [4], 5]);\n  });\n\n  test('returns empty array for empty input', () => {\n    expect(flattenOnce([])).toEqual([]);\n  });\n});\n",
    "testsTs": "import flattenOnce from './flattenOnce';\n\ndescribe('flattenOnce (TypeScript)', () => {\n  it('flattens a simple nested array', () => {\n    expect(flattenOnce([1, [2, 3], [4, [5]]])).toEqual([1, 2, 3, 4, [5]]);\n  });\n\n  it('returns same array when already flat', () => {\n    expect(flattenOnce([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n\n  it('handles mixed array contents', () => {\n    expect(flattenOnce([[1], 2, [3, [4]], 5])).toEqual([1, 2, 3, [4], 5]);\n  });\n\n  it('returns empty array for empty input', () => {\n    expect(flattenOnce([])).toEqual([]);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-unique-array",
    "title": "Remove Duplicates",
    "type": "coding",
    "importance": 4,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrays"
    ],
    "description": {
      "summary": "Implement a function `unique(arr)` that returns a new array with duplicate values removed. The **original order** of elements must be preserved.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array of items that may contain duplicates."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array with only unique elements, preserving their first occurrence order."
      },
      "examples": [
        "// Basic example\nunique([1, 2, 2, 3, 1]) // => [1, 2, 3]",
        "// Works with strings\nunique(['a', 'b', 'a', 'c', 'b']) // => ['a', 'b', 'c']",
        "// Mixed types\nunique([1, '1', 1]) // => [1, '1']"
      ]
    },
    "starterCode": "export default function unique(arr) {\n  // TODO: Return new array with duplicates removed\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function unique<T>(arr: T[]): T[] {\n  // TODO: Return new array with duplicates removed\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: return a new array that contains each value only once — keeping the first occurrence and preserving order. This teaches efficient use of `Set` for deduplication.",
      "approaches": [
        {
          "title": "Approach 1: Using a Set to track seen values (explicit control)",
          "prose": "Idea: use a `Set` to record which elements have been encountered. Iterate through `arr` and only push values you haven't seen yet.\n\nHow it works:\n1. Initialize an empty `Set`: `const seen = new Set()`.\n2. Initialize `const result = []`.\n3. Loop through every element `item` in `arr`.\n4. If `!seen.has(item)`, add it to both `seen` and `result`.\n5. Return `result`.\n\nWhy use it: this method is efficient (O(n)) and preserves original order, since elements are added in the order they first appear.",
          "codeJs": "export default function unique(arr) {\n  const seen = new Set();\n  const result = [];\n  for (const item of arr) {\n    if (!seen.has(item)) {\n      seen.add(item);\n      result.push(item);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  const seen = new Set<T>();\n  const result: T[] = [];\n  for (const item of arr) {\n    if (!seen.has(item)) {\n      seen.add(item);\n      result.push(item);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using `new Set()` directly (compact form)",
          "prose": "Idea: leverage the fact that a `Set` automatically removes duplicates.\n\nUse `[...new Set(arr)]` to instantly produce a deduplicated array.\n\nRead it as: *wrap the array in a Set to drop duplicates, then spread it back into a new array*.\n\nWhy use it: clean and elegant one-liner, ideal when order preservation and the default value equality semantics are acceptable.",
          "codeJs": "export default function unique(arr) {\n  return [...new Set(arr)];\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  return [...new Set(arr)];\n}\n"
        },
        {
          "title": "Approach 3: Using `filter()` and `indexOf()` (less efficient)",
          "prose": "Idea: only keep items where their first occurrence index matches the current index.\n\nUse `arr.filter((item, idx) => arr.indexOf(item) === idx)`.\n\nWhy use it: clear for learning, but less efficient (O(n²)) since each `indexOf` scan starts from the beginning.",
          "codeJs": "export default function unique(arr) {\n  return arr.filter((item, idx) => arr.indexOf(item) === idx);\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  return arr.filter((item, idx) => arr.indexOf(item) === idx);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Comparisons are done using strict equality (`===`), so `1` and `'1'` are treated differently.",
          "Objects and arrays are compared by reference, not structure.",
          "Avoid using `filter + indexOf` for very large arrays due to quadratic performance."
        ],
        "edgeCases": [
          "Empty array → returns `[]`.",
          "Already unique array → unchanged.",
          "All duplicates → only first kept."
        ],
        "techniques": [
          "Using `Set` for uniqueness tracking.",
          "Maintaining insertion order manually.",
          "Using spread syntax (`...`) for conversion."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN – Set",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"
        },
        {
          "title": "MDN – Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        }
      ]
    },
    "tests": "import unique from './unique';\n\ndescribe('unique', () => {\n  test('removes duplicates from numbers', () => {\n    expect(unique([1, 2, 2, 3, 1])).toEqual([1, 2, 3]);\n  });\n\n  test('works with strings', () => {\n    expect(unique(['a', 'b', 'a', 'c', 'b'])).toEqual(['a', 'b', 'c']);\n  });\n\n  test('handles mixed types', () => {\n    expect(unique([1, '1', 1])).toEqual([1, '1']);\n  });\n\n  test('returns empty array when input is empty', () => {\n    expect(unique([])).toEqual([]);\n  });\n\n  test('returns identical array when all unique', () => {\n    expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "import unique from './unique';\n\ndescribe('unique (TypeScript)', () => {\n  it('removes duplicates from numbers', () => {\n    expect(unique([1, 2, 2, 3, 1])).toEqual([1, 2, 3]);\n  });\n\n  it('works with strings', () => {\n    expect(unique(['a', 'b', 'a', 'c', 'b'])).toEqual(['a', 'b', 'c']);\n  });\n\n  it('handles mixed types', () => {\n    expect(unique([1, '1', 1])).toEqual([1, '1']);\n  });\n\n  it('returns empty array when input is empty', () => {\n    expect(unique([])).toEqual([]);\n  });\n\n  it('returns identical array when all unique', () => {\n    expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-max-char",
    "title": "Find Maximum Occurring Character",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "string"
    ],
    "description": {
      "summary": "Implement a function `maxChar(str)` that returns the character that appears most frequently in a string. All characters (letters, digits, spaces, punctuation) are considered. For an empty string, return `''`.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to analyze."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "The single character with the highest frequency of occurrence. Returns `''` for an empty string."
      },
      "examples": [
        "// Basic examples\nmaxChar('hello') // => 'l'\nmaxChar('aabbbcc') // => 'b'\nmaxChar('abcccccccd') // => 'c'\n\n// When multiple characters tie, return the first one found\nmaxChar('aabb') // => 'a'\n\n// Empty string\nmaxChar('') // => ''"
      ]
    },
    "starterCode": "export default function maxChar(str) {\n  // TODO: Return the most frequent character in the string\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function maxChar(str: string): string {\n  // TODO: Return the most frequent character in the string\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: find the most frequently occurring character in a string using a character frequency map. If the input is empty, return `''`. This introduces hash-map-style counting, a common pattern in many string and array problems.",
      "approaches": [
        {
          "title": "Approach 1: Frequency map with a loop (efficient and clear)",
          "prose": "Idea: use an object as a frequency counter. Traverse the string once, count occurrences, and track the character with the highest frequency.\n\nHow it works:\n1. If `str` is falsy (e.g. empty string), return `''` immediately.\n2. Initialize an empty object `charCount = {}`.\n3. Initialize `max = 0` and `maxChar = ''`.\n4. Loop through each character `ch` in the string.\n   - Increment `charCount[ch] = (charCount[ch] || 0) + 1`.\n   - If `charCount[ch] > max`, update `max` and `maxChar`.\n5. After the loop, return `maxChar`.\n\nWhy use it: runs in O(n) time, uses O(k) space (k = number of unique chars), and the `>` comparison ensures ties return the first character that reached the maximum count.",
          "codeJs": "export default function maxChar(str) {\n  if (!str) return '';\n  const charCount = {};\n  let max = 0;\n  let maxChar = '';\n\n  for (const ch of str) {\n    charCount[ch] = (charCount[ch] || 0) + 1;\n    if (charCount[ch] > max) {\n      max = charCount[ch];\n      maxChar = ch;\n    }\n  }\n\n  return maxChar;\n}\n",
          "codeTs": "export default function maxChar(str: string): string {\n  if (!str) return '';\n  const charCount: Record<string, number> = {};\n  let max = 0;\n  let maxChar = '';\n\n  for (const ch of str) {\n    charCount[ch] = (charCount[ch] || 0) + 1;\n    if (charCount[ch] > max) {\n      max = charCount[ch];\n      maxChar = ch;\n    }\n  }\n\n  return maxChar;\n}\n"
        },
        {
          "title": "Approach 2: Using `reduce()` for a functional style",
          "prose": "Idea: first build a frequency map with `Array.prototype.reduce()`, then scan that map to find the character with the highest count.\n\nHow it works:\n1. If `str` is empty, return `''` immediately.\n2. Use `reduce` over the characters of `str` to build an object `freq` where keys are characters and values are counts.\n3. Initialize `maxChar = ''` and `max = 0`.\n4. Loop over `Object.entries(freq)` and update `max` / `maxChar` whenever you see a larger count.\n5. Return `maxChar`.\n\nWhy use it: keeps the counting logic in a single expression and can feel more declarative, but is slightly less direct than the plain loop for beginners.",
          "codeJs": "export default function maxChar(str) {\n  if (!str) return '';\n  const freq = [...str].reduce((acc, ch) => {\n    acc[ch] = (acc[ch] || 0) + 1;\n    return acc;\n  }, {});\n\n  let maxChar = '';\n  let max = 0;\n  for (const [ch, count] of Object.entries(freq)) {\n    if (count > max) {\n      max = count;\n      maxChar = ch;\n    }\n  }\n  return maxChar;\n}\n",
          "codeTs": "export default function maxChar(str: string): string {\n  if (!str) return '';\n  const freq = Array.from(str).reduce<Record<string, number>>((acc, ch) => {\n    acc[ch] = (acc[ch] || 0) + 1;\n    return acc;\n  }, {});\n\n  let maxChar = '';\n  let max = 0;\n  for (const [ch, count] of Object.entries(freq)) {\n    if (count > max) {\n      max = count;\n      maxChar = ch;\n    }\n  }\n  return maxChar;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Do not forget to handle the empty string case — return `''`.",
          "Comparisons are case-sensitive (`'A'` and `'a'` are counted separately).",
          "Ties are resolved by returning the first character that reaches the maximum count (due to the `>` comparison)."
        ],
        "edgeCases": [
          "Empty string → returns `''`.",
          "All unique characters → returns the first character.",
          "Multiple max chars → returns the earliest one by position in the string."
        ],
        "techniques": [
          "Using frequency maps (hash tables) to count occurrences.",
          "Tracking the current maximum value during iteration instead of doing a second pass.",
          "Reasoning about O(n) time and O(k) extra space where k is the number of unique characters."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels"
      ],
      "resources": [
        {
          "title": "MDN – Object.entries()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"
        },
        {
          "title": "MDN – for...of statement",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"
        }
      ]
    },
    "tests": "import maxChar from './maxChar';\n\ndescribe('maxChar', () => {\n  test('finds the most common letter', () => {\n    expect(maxChar('hello')).toBe('l');\n  });\n\n  test('works with multiple repetitions', () => {\n    expect(maxChar('aabbbcc')).toBe('b');\n    expect(maxChar('abcccccccd')).toBe('c');\n  });\n\n  test('returns first character when tie', () => {\n    expect(maxChar('aabb')).toBe('a');\n  });\n\n  test('returns empty string when input is empty', () => {\n    expect(maxChar('')).toBe('');\n  });\n});\n",
    "testsTs": "import maxChar from './maxChar';\n\ndescribe('maxChar (TypeScript)', () => {\n  it('finds the most common letter', () => {\n    expect(maxChar('hello')).toBe('l');\n  });\n\n  it('works with multiple repetitions', () => {\n    expect(maxChar('aabbbcc')).toBe('b');\n    expect(maxChar('abcccccccd')).toBe('c');\n  });\n\n  it('returns first character when tie', () => {\n    expect(maxChar('aabb')).toBe('a');\n  });\n\n  it('returns empty string when input is empty', () => {\n    expect(maxChar('')).toBe('');\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-capitalize-words",
    "title": "Capitalize Words",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "string"
    ],
    "description": {
      "summary": "Implement a function `capitalizeWords(sentence)` that returns the same string but with the first letter of each word capitalized, preserving all spaces. For an empty string, return `''`.",
      "arguments": [
        {
          "name": "sentence",
          "type": "string",
          "desc": "A sentence consisting of one or more words separated by spaces. May contain leading, trailing, or multiple spaces between words."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "A new string where each word starts with an uppercase letter and the rest of the word is lowercase. Returns `''` for an empty string."
      },
      "examples": [
        "// Basic examples",
        "capitalizeWords('hello world') // => 'Hello World'",
        "capitalizeWords('javascript is fun') // => 'Javascript Is Fun'",
        "// Handles extra spaces",
        "capitalizeWords('  welcome   to  earth  ') // => '  Welcome   To  Earth  '",
        "// Empty string",
        "capitalizeWords('') // => ''"
      ]
    },
    "starterCode": "export default function capitalizeWords(sentence) {\n  // TODO: Capitalize first letter of each word\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function capitalizeWords(sentence: string): string {\n  // TODO: Capitalize first letter of each word\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure each word in a sentence starts with an uppercase letter while preserving spacing and keeping the rest of the letters lowercase. If the input is empty, return `''`. This builds practical mastery over string splitting, mapping, joining, and basic character processing.",
      "approaches": [
        {
          "title": "Approach 1: Split–Map–Join (clean and readable)",
          "prose": "Idea: split the sentence into parts by spaces, capitalize the first letter of each non-empty part, and then join them back together.\n\nHow it works:\n1. If `sentence` is falsy (for example, an empty string), return `''`.\n2. Use `.split(' ')` to break the sentence into an array of substrings separated by single spaces.\n3. For each element `word` in the array, if `word` is an empty string (extra space), leave it as is; otherwise build `word[0].toUpperCase() + word.slice(1).toLowerCase()`.\n4. Join the transformed array back into a string with `' '` as the separator.\n5. Return the final joined string.\n\nWhy use it: clear logic, preserves multiple spaces exactly as they are, and doesn’t require regex — a straightforward approach for readability and maintainability.",
          "codeJs": "export default function capitalizeWords(sentence) {\n  if (!sentence) return '';\n  return sentence\n    .split(' ')\n    .map(word => {\n      if (!word) return word;\n      return word[0].toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ');\n}\n",
          "codeTs": "export default function capitalizeWords(sentence: string): string {\n  if (!sentence) return '';\n  return sentence\n    .split(' ')\n    .map(word => {\n      if (!word) return word;\n      return word[0].toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ');\n}\n"
        },
        {
          "title": "Approach 2: Character iteration (manual traversal)",
          "prose": "Idea: iterate through each character and capitalize when the previous character was a space.\n\nHow it works:\n1. If `sentence` is falsy, return `''`.\n2. Initialize an empty string `result = ''` and a boolean flag `capitalizeNext = true`.\n3. For each character `ch` in `sentence`, if `ch === ' '`, append it to `result` and set `capitalizeNext = true`; otherwise, if `capitalizeNext` is true, append `ch.toUpperCase()` and set `capitalizeNext = false`, and if it is false, append `ch.toLowerCase()`.\n4. After processing all characters, return `result`.\n\nWhy use it: avoids splitting and joining, and gives fine-grained control over character-by-character behavior. Efficient for long strings and useful when you want to extend the logic (for example, treat other delimiters as word boundaries).",
          "codeJs": "export default function capitalizeWords(sentence) {\n  if (!sentence) return '';\n  let result = '';\n  let capitalizeNext = true;\n\n  for (const ch of sentence) {\n    if (ch === ' ') {\n      result += ch;\n      capitalizeNext = true;\n    } else if (capitalizeNext) {\n      result += ch.toUpperCase();\n      capitalizeNext = false;\n    } else {\n      result += ch.toLowerCase();\n    }\n  }\n\n  return result;\n}\n",
          "codeTs": "export default function capitalizeWords(sentence: string): string {\n  if (!sentence) return '';\n  let result = '';\n  let capitalizeNext = true;\n\n  for (const ch of sentence) {\n    if (ch === ' ') {\n      result += ch;\n      capitalizeNext = true;\n    } else if (capitalizeNext) {\n      result += ch.toUpperCase();\n      capitalizeNext = false;\n    } else {\n      result += ch.toLowerCase();\n    }\n  }\n\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid trimming spaces — leading, trailing, and repeated spaces must be preserved.",
          "Punctuation and digits are treated as part of a word; only the first character after a space is uppercased.",
          "Always lowercase the rest of each word to normalize mixed casing."
        ],
        "edgeCases": [
          "Empty string → `''`.",
          "Extra spaces between words → preserved exactly.",
          "Already title-cased input → unchanged.",
          "Mixed casing → normalized to Title Case (e.g. `jaVaScript IS fUn` → `Javascript Is Fun`)."
        ],
        "techniques": [
          "Using `.split()`, `.map()`, and `.join()` for immutable string transformations.",
          "String iteration and character-based logic.",
          "Applying capitalization rules based on simple word boundaries (spaces)."
        ]
      },
      "followUpQuestions": [
        "js-reverse-string"
      ],
      "resources": [
        {
          "title": "MDN – String.prototype.split()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split"
        },
        {
          "title": "MDN – String.prototype.toUpperCase()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase"
        }
      ]
    },
    "tests": "import capitalizeWords from './capitalizeWords';\n\ndescribe('capitalizeWords', () => {\n  test('capitalizes each word in a simple sentence', () => {\n    expect(capitalizeWords('hello world')).toBe('Hello World');\n  });\n\n  test('handles mixed casing', () => {\n    expect(capitalizeWords('jaVaScript IS fUn')).toBe('Javascript Is Fun');\n  });\n\n  test('preserves multiple spaces', () => {\n    expect(capitalizeWords('  welcome   to  earth  ')).toBe('  Welcome   To  Earth  ');\n  });\n\n  test('returns empty string for empty input', () => {\n    expect(capitalizeWords('')).toBe('');\n  });\n});\n",
    "testsTs": "import capitalizeWords from './capitalizeWords';\n\ndescribe('capitalizeWords (TypeScript)', () => {\n  it('capitalizes each word in a simple sentence', () => {\n    expect(capitalizeWords('hello world')).toBe('Hello World');\n  });\n\n  it('handles mixed casing', () => {\n    expect(capitalizeWords('jaVaScript IS fUn')).toBe('Javascript Is Fun');\n  });\n\n  it('preserves multiple spaces', () => {\n    expect(capitalizeWords('  welcome   to  earth  ')).toBe('  Welcome   To  Earth  ');\n  });\n\n  it('returns empty string for empty input', () => {\n    expect(capitalizeWords('')).toBe('');\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-sum-numbers",
    "title": "Sum of Numbers in an Array",
    "type": "coding",
    "importance": 2,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrays"
    ],
    "description": {
      "summary": "Implement a function `sum(arr)` that returns the total of all numeric elements in the array, ignoring non-numeric values (including numeric strings). For an empty array, return `0`.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array containing numbers and possibly other types (e.g., strings, booleans, nulls). Only actual numbers should be summed."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The sum of all numeric (non-NaN) elements in the array. Returns `0` if there are no numeric entries."
      },
      "examples": [
        "// Basic examples",
        "sum([1, 2, 3]) // => 6",
        "// '20' is a string → ignored",
        "sum([10, '20', 30]) // => 40",
        "// Ignores non-numbers",
        "sum(['a', 5, true, 7]) // => 12",
        "// Handles empty array",
        "sum([]) // => 0"
      ]
    },
    "starterCode": "export default function sum(arr) {\n  // TODO: Return the sum of all numeric elements, ignoring non-numbers\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function sum(arr: any[]): number {\n  // TODO: Return the sum of all numeric elements, ignoring non-numbers\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: calculate the total sum of numeric values in an array, safely ignoring any non-numeric entries (including numeric strings) and `NaN`. This reinforces type checking, iteration, and accumulator patterns — fundamentals for array manipulation.",
      "approaches": [
        {
          "title": "Approach 1: Imperative loop (explicit and safe)",
          "prose": "Idea: iterate through each element and only add valid numbers to a running total.\n\nHow it works:\n1. Initialize `let total = 0`.\n2. Loop through each `el` in `arr`.\n3. If `typeof el === 'number' && !Number.isNaN(el)`, add `el` to `total`.\n4. After the loop, return `total`.\n\nWhy use it: simple, readable, and avoids hidden coercions. Runs in O(n) time with O(1) extra space.",
          "codeJs": "export default function sum(arr) {\n  let total = 0;\n  for (const el of arr) {\n    if (typeof el === 'number' && !Number.isNaN(el)) {\n      total += el;\n    }\n  }\n  return total;\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  let total = 0;\n  for (const el of arr) {\n    if (typeof el === 'number' && !Number.isNaN(el)) {\n      total += el;\n    }\n  }\n  return total;\n}\n"
        },
        {
          "title": "Approach 2: Filter + Reduce (functional style)",
          "prose": "Idea: first filter the array to only include valid numbers, then sum them using `reduce()`.\n\nHow it works:\n1. Use `filter()` to keep only elements where `typeof el === 'number' && !Number.isNaN(el)`.\n2. Use `reduce()` with an accumulator starting from `0` to sum the filtered values.\n\nWhy use it: concise and expressive, and the TypeScript version benefits from a type guard.",
          "codeJs": "export default function sum(arr) {\n  return arr\n    .filter(el => typeof el === 'number' && !Number.isNaN(el))\n    .reduce((total, el) => total + el, 0);\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  return arr\n    .filter((el): el is number => typeof el === 'number' && !Number.isNaN(el))\n    .reduce((total, el) => total + el, 0);\n}\n"
        },
        {
          "title": "Approach 3: Reduce-only with inline check",
          "prose": "Idea: combine filtering and summing into a single `reduce()` call.\n\nHow it works:\n1. Start with `total = 0`.\n2. For each `el` in `arr`, check if it is a valid number.\n3. If so, add it to `total`.\n4. Return the final `total`.\n\nWhy use it: avoids creating an intermediate array, which can be more efficient for large inputs.",
          "codeJs": "export default function sum(arr) {\n  return arr.reduce((total, el) => {\n    if (typeof el === 'number' && !Number.isNaN(el)) {\n      total += el;\n    }\n    return total;\n  }, 0);\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  return arr.reduce((total, el) => {\n    if (typeof el === 'number' && !Number.isNaN(el)) {\n      total += el;\n    }\n    return total;\n  }, 0);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid coercing numeric strings — `'20'` should not be counted unless you explicitly convert it.",
          "Skip `NaN` to prevent polluting the final sum.",
          "Ensure non-numeric falsy values like `false`, `null`, or `undefined` are not counted."
        ],
        "edgeCases": [
          "Empty array → returns `0`.",
          "All non-numeric → returns `0`.",
          "Includes `NaN` → ignored.",
          "Mixed types → only valid numbers contribute to the total."
        ],
        "techniques": [
          "Type checking with `typeof` and `Number.isNaN`.",
          "Using loops vs. functional array methods (`filter`, `reduce`).",
          "Accumulator logic for numeric aggregation."
        ]
      },
      "followUpQuestions": [
        "js-flatten-once"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        },
        {
          "title": "MDN – Number.isNaN()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"
        }
      ]
    },
    "tests": "import sum from './sum';\n\ndescribe('sum', () => {\n  test('sums numbers in a simple array', () => {\n    expect(sum([1, 2, 3])).toBe(6);\n  });\n\n  test('ignores non-numeric values', () => {\n    expect(sum(['a', 5, true, 7])).toBe(12);\n  });\n\n  test('ignores numeric strings', () => {\n    expect(sum([10, '20', 30])).toBe(40);\n  });\n\n  test('returns 0 for empty or all-non-numeric arrays', () => {\n    expect(sum([])).toBe(0);\n    expect(sum(['x', false, null])).toBe(0);\n  });\n});\n",
    "testsTs": "import sum from './sum';\n\ndescribe('sum (TypeScript)', () => {\n  it('sums numbers in a simple array', () => {\n    expect(sum([1, 2, 3])).toBe(6);\n  });\n\n  it('ignores non-numeric values', () => {\n    expect(sum(['a', 5, true, 7])).toBe(12);\n  });\n\n  it('ignores numeric strings', () => {\n    expect(sum([10, '20', 30])).toBe(40);\n  });\n\n  it('returns 0 for empty or all-non-numeric arrays', () => {\n    expect(sum([])).toBe(0);\n    expect(sum(['x', false, null])).toBe(0);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-compact",
    "title": "Falsy Bouncer",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrays"
    ],
    "description": {
      "summary": "Implement a function `compact(arr)` that removes all falsy values (`false`, `0`, `''`, `null`, `undefined`, `NaN`) from an array.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array containing any types of elements, including falsy values."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array with all falsy values removed."
      },
      "examples": [
        "// Basic examples\ncompact([0, 1, false, 2, '', 3]) // => [1, 2, 3]",
        "// Works with only truthy values\ncompact(['a', true, 42]) // => ['a', true, 42]",
        "// Handles null and undefined\ncompact([null, undefined, 'x']) // => ['x']",
        "// Handles NaN\ncompact([NaN, 1, 2]) // => [1, 2]"
      ]
    },
    "starterCode": "export default function compact(arr) {\n  // TODO: Remove all falsy values from the array\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function compact(arr: any[]): any[] {\n  // TODO: Remove all falsy values from the array\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: remove all falsy values (`false`, `0`, `''`, `null`, `undefined`, `NaN`) from an array while preserving order. This task reinforces truthy/falsy coercion and the use of functional array methods like `filter()`.",
      "approaches": [
        {
          "title": "Approach 1: Using filter(Boolean) (concise and expressive)",
          "prose": "Idea: rely on JavaScript's truthy/falsy evaluation — falsy values convert to `false` in boolean contexts, so `filter(Boolean)` automatically removes them.\n\nHow it works:\n1. Call `arr.filter(Boolean)` (equivalent to `arr.filter(value => Boolean(value))`).\n2. The `Boolean` function converts each value to a boolean: truthy values become `true`, falsy values become `false`.\n3. `filter` keeps only the values for which the callback returns `true`, so all falsy values are dropped and the remaining truthy values keep their original order.\n\nWhy use it: clean, idiomatic, and short. Runs in O(n) time and uses O(n) space for the new array while preserving order.",
          "codeJs": "export default function compact(arr) {\n  return arr.filter(Boolean);\n}\n",
          "codeTs": "export default function compact(arr: any[]): any[] {\n  return arr.filter(Boolean);\n}\n"
        },
        {
          "title": "Approach 2: Manual filtering with explicit check",
          "prose": "Idea: explicitly iterate and push only truthy elements to a new array. Slightly longer but very clear for beginners.\n\nHow it works:\n1. Initialize an empty array `result = []`.\n2. Loop over each element `el` in `arr` and check if it is truthy using `if (el)`.\n3. If the condition is true, push `el` into `result`.\n4. After the loop finishes, return `result`.\n\nWhy use it: makes the truthy/falsy check very explicit and shows how `filter` works under the hood. Also runs in O(n) time and uses O(n) space.",
          "codeJs": "export default function compact(arr) {\n  const result = [];\n  for (const el of arr) {\n    if (el) result.push(el);\n  }\n  return result;\n}\n",
          "codeTs": "export default function compact(arr: any[]): any[] {\n  const result: any[] = [];\n  for (const el of arr) {\n    if (el) result.push(el);\n  }\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid this pattern if you need to keep values like `0` or `''` — this function removes all falsy values by design.",
          "Be aware that `NaN` is also falsy and will be removed."
        ],
        "edgeCases": [
          "Empty array → returns `[]`.",
          "Array with all falsy values → returns `[]`.",
          "Mixed types → only truthy ones remain."
        ],
        "techniques": [
          "Using Boolean coercion in array filtering.",
          "Understanding truthy/falsy evaluation in JavaScript.",
          "Preserving array order during filtering."
        ]
      },
      "followUpQuestions": [
        "js-unique-array"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        },
        {
          "title": "MDN – Boolean() constructor",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"
        }
      ]
    },
    "tests": "import compact from './compact';\n\ndescribe('compact', () => {\n  test('removes falsy values', () => {\n    expect(compact([0, 1, false, 2, '', 3])).toEqual([1, 2, 3]);\n  });\n\n  test('returns same array when all truthy', () => {\n    expect(compact(['a', true, 42])).toEqual(['a', true, 42]);\n  });\n\n  test('removes null and undefined', () => {\n    expect(compact([null, undefined, 'x'])).toEqual(['x']);\n  });\n\n  test('removes NaN', () => {\n    expect(compact([NaN, 1, 2])).toEqual([1, 2]);\n  });\n\n  test('handles empty array', () => {\n    expect(compact([])).toEqual([]);\n  });\n});\n",
    "testsTs": "import compact from './compact';\n\ndescribe('compact (TypeScript)', () => {\n  it('removes falsy values', () => {\n    expect(compact([0, 1, false, 2, '', 3])).toEqual([1, 2, 3]);\n  });\n\n  it('returns same array when all truthy', () => {\n    expect(compact(['a', true, 42])).toEqual(['a', true, 42]);\n  });\n\n  it('removes null and undefined', () => {\n    expect(compact([null, undefined, 'x'])).toEqual(['x']);\n  });\n\n  it('removes NaN', () => {\n    expect(compact([NaN, 1, 2])).toEqual([1, 2]);\n  });\n\n  it('handles empty array', () => {\n    expect(compact([])).toEqual([]);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-arrays-equal",
    "title": "Check if Two Arrays Are Equal",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrays"
    ],
    "description": {
      "summary": "Implement a function `arraysEqual(a, b)` that returns `true` if both arrays contain the same elements in the same order.",
      "arguments": [
        {
          "name": "a",
          "type": "any[]",
          "desc": "The first array to compare."
        },
        {
          "name": "b",
          "type": "any[]",
          "desc": "The second array to compare."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if both arrays are identical in length and elements (in the same order), otherwise `false`."
      },
      "examples": [
        "// Basic examples\narraysEqual([1, 2, 3], [1, 2, 3]) // => true",
        "arraysEqual([1, 2, 3], [3, 2, 1]) // => false",
        "// Different lengths\narraysEqual([1, 2], [1, 2, 3]) // => false",
        "// Works with strings\narraysEqual(['a', 'b'], ['a', 'b']) // => true",
        "// Works with mixed types\narraysEqual([1, '2', 3], [1, 2, 3]) // => false"
      ]
    },
    "starterCode": "export default function arraysEqual(a, b) {\n  // TODO: Return true if both arrays contain the same elements in the same order\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  // TODO: Return true if both arrays contain the same elements in the same order\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: verify if two arrays are identical in both length and element order using strict equality. This exercise focuses on iteration, index-based comparison, and understanding shallow equality for arrays of primitive values.",
      "approaches": [
        {
          "title": "Approach 1: Loop-based comparison (explicit and efficient)",
          "prose": "Idea: iterate through both arrays, comparing elements at each index.\n\nHow it works:\n1. If `a.length !== b.length`, return `false` immediately.\n2. Loop over all indices with a `for` loop.\n3. For each index `i`, compare `a[i]` and `b[i]` using strict equality (`===`). If any pair differs, return `false`.\n4. If the loop completes without mismatches, return `true`.\n\nWhy use it: runs in O(n) time, uses O(1) extra space, and is very straightforward to debug.",
          "codeJs": "export default function arraysEqual(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n"
        },
        {
          "title": "Approach 2: Using every() (declarative style)",
          "prose": "Idea: use `Array.prototype.every()` to ensure that every element in `a` matches the element at the same index in `b`.\n\nHow it works:\n1. If `a.length !== b.length`, return `false`.\n2. Otherwise, return `a.every((el, i) => el === b[i])`.\n\nWhy use it: more declarative and concise than a manual loop, while still running in O(n) time and short-circuiting on the first mismatch.",
          "codeJs": "export default function arraysEqual(a, b) {\n  return a.length === b.length && a.every((el, i) => el === b[i]);\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  return a.length === b.length && a.every((el, i) => el === b[i]);\n}\n"
        },
        {
          "title": "Approach 3: JSON.stringify shortcut (not recommended for complex data)",
          "prose": "Idea: serialize both arrays to JSON strings and compare the resulting strings.\n\nHow it works:\n1. Compute `JSON.stringify(a)` and `JSON.stringify(b)`.\n2. Compare the two strings with `===` and return the result.\n\nWhy use it: very compact and can work for simple arrays of primitives, but it has important caveats — it does not handle `undefined`, functions, or differences in object key order reliably, so it is not suitable for robust deep equality checks.",
          "codeJs": "export default function arraysEqual(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Strict equality (`===`) does not perform deep comparison for objects or nested arrays; it compares references.",
          "Avoid relying on `JSON.stringify` for nested structures, objects with varying key order, or values like `undefined`, functions, or symbols.",
          "Be aware that `['1']` and `[1]` are not considered equal due to type differences."
        ],
        "edgeCases": [
          "Empty arrays → `true`.",
          "Different lengths → `false`.",
          "Different order → `false`.",
          "Mixed types → `false` when any pair differs by value or type.",
          "Nested arrays or objects → compared by reference in Approaches 1 and 2; not reliably by structure in Approach 3."
        ],
        "techniques": [
          "Using index-based loops for element-wise comparison.",
          "Using `every()` for a declarative comparison with early exit.",
          "Understanding reference vs. value equality in JavaScript."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.every()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every"
        },
        {
          "title": "MDN – Equality comparisons and sameness",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness"
        }
      ]
    },
    "tests": "import arraysEqual from './arraysEqual';\n\ndescribe('arraysEqual', () => {\n  test('returns true for identical arrays', () => {\n    expect(arraysEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  });\n\n  test('returns false for different element order', () => {\n    expect(arraysEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  test('returns false for different lengths', () => {\n    expect(arraysEqual([1, 2], [1, 2, 3])).toBe(false);\n  });\n\n  test('works with string arrays', () => {\n    expect(arraysEqual(['a', 'b'], ['a', 'b'])).toBe(true);\n  });\n\n  test('returns false for mixed type differences', () => {\n    expect(arraysEqual([1, '2', 3], [1, 2, 3])).toBe(false);\n  });\n\n  test('handles empty arrays', () => {\n    expect(arraysEqual([], [])).toBe(true);\n  });\n});\n",
    "testsTs": "import arraysEqual from './arraysEqual';\n\ndescribe('arraysEqual (TypeScript)', () => {\n  it('returns true for identical arrays', () => {\n    expect(arraysEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  });\n\n  it('returns false for different element order', () => {\n    expect(arraysEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  it('returns false for different lengths', () => {\n    expect(arraysEqual([1, 2], [1, 2, 3])).toBe(false);\n  });\n\n  it('works with string arrays', () => {\n    expect(arraysEqual(['a', 'b'], ['a', 'b'])).toBe(true);\n  });\n\n  it('returns false for mixed type differences', () => {\n    expect(arraysEqual([1, '2', 3], [1, 2, 3])).toBe(false);\n  });\n\n  it('handles empty arrays', () => {\n    expect(arraysEqual([], [])).toBe(true);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-debounce",
    "title": "Debounce Function",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "companies": [
      "google",
      "netflix"
    ],
    "difficulty": "intermediate",
    "tags": [
      "async",
      "functions",
      "timing"
    ],
    "description": {
      "summary": "Implement a function `debounce(fn, delay)` that delays the execution of `fn` until a specified time (`delay` ms) has passed since the last invocation.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The function to be executed after the delay."
        },
        {
          "name": "delay",
          "type": "number",
          "desc": "The number of milliseconds to wait before executing the function."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A debounced version of the original function that delays execution until the delay period has elapsed."
      },
      "examples": [
        "// Basic examples\ndebounce(() => console.log('Hello!'), 300)",
        "// Multiple rapid calls — only last one runs\nconst log = debounce(() => console.log('Run!'), 500)\nlog()\nlog()\nlog() // Only this one executes after 500ms",
        "// With arguments\nconst greet = debounce(name => console.log(`Hi ${name}`), 400)\ngreet('Alice')\ngreet('Bob') // Only 'Hi Bob' logs after 400ms"
      ]
    },
    "starterCode": "export default function debounce(fn, delay) {\n  // TODO: Return a debounced function that delays execution until delay ms have passed\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): F {\n  // TODO: Return a debounced function that delays execution until delay ms have passed\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure `fn` runs only after calls have stopped for `delay` ms (trailing-edge debounce by default). This is common for search inputs, resize/scroll handlers, and deduping rapid UI events. Approaches 2 and 3 show common extensions used in real-world libraries.",
      "approaches": [
        {
          "title": "Approach 1: Timeout-based debounce (canonical)",
          "prose": "Idea: store a `timeoutId`. Each call clears the previous timeout and schedules a new one. When the last timer completes, invoke `fn` with the latest args and `this`.\n\nHow it works:\n1. Keep `let timeoutId` in the closure.\n2. On each call, clear any existing timer with `clearTimeout(timeoutId)`.\n3. Start a new timer: `timeoutId = setTimeout(() => fn.apply(this, args), delay)`.\n4. Return the debounced wrapper function.\n\nThis is the classic trailing-edge debounce: only the last call in a burst actually runs.",
          "codeJs": "export default function debounce(fn, delay) {\n  let timeoutId;\n  return function (...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n",
          "codeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): F {\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  return function (this: any, ...args: Parameters<F>) {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  } as F;\n}\n"
        },
        {
          "title": "Approach 2: Debounce with cancel + flush helpers (extended API)",
          "prose": "Idea: extend the basic debounced function with `.cancel()` and `.flush()` helpers so callers can cancel a pending call or force it to run immediately.\n\nHow it works:\n1. Wrap the debounced function and keep `timeoutId`, `lastArgs`, and `lastThis` in the closure.\n2. On each call, store the latest args/context, clear the previous timer, and start a new one.\n3. `.cancel()` just clears the timer.\n4. `.flush()` clears the timer and immediately invokes `fn` with the last stored args and context.\n\nThis pattern mirrors popular utility libraries (like Lodash) and is an extension beyond the minimal `debounce(fn, delay)` contract.",
          "codeJs": "export default function debounce(fn, delay) {\n  let timeoutId, lastArgs, lastThis;\n  function debounced(...args) {\n    lastArgs = args;\n    lastThis = this;\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }, delay);\n  }\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n  debounced.flush = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }\n  };\n  return debounced;\n}\n",
          "codeTs": "type Debounced<F extends (...a: any[]) => void> = F & { cancel: () => void; flush: () => void };\n\nexport default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): Debounced<F> {\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  let lastArgs: Parameters<F>;\n  let lastThis: any;\n\n  const debounced = function (this: any, ...args: Parameters<F>) {\n    lastArgs = args;\n    lastThis = this;\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }, delay);\n  } as Debounced<F>;\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  debounced.flush = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }\n  };\n\n  return debounced;\n}\n"
        },
        {
          "title": "Approach 3: Leading-edge option (extended signature)",
          "prose": "Idea: add an options object to support `leading` mode. With `leading: true`, call `fn` immediately on the first trigger in a burst and then suppress further calls until the delay elapses. With `leading: false` (default), fall back to classic trailing-only debounce.\n\nHow it works:\n1. Track `timeoutId`, plus the last arguments and `this`.\n2. On each call, compute `shouldCallNow = leading && !timeoutId` to know whether this should be an immediate (leading) call.\n3. Clear any existing timer and start a new one. In trailing mode (`leading === false`), the timer will call `fn` after `delay` with the last arguments. In leading mode, the timer simply resets `timeoutId` after `delay` so that a new burst can trigger another leading call.\n4. If `shouldCallNow` is true, invoke `fn` immediately with the current arguments.\n\nThis is an API extension: the base exercise only requires `debounce(fn, delay)`, but this shows how to evolve it to support configurable leading behavior.",
          "codeJs": "export default function debounce(fn, delay, { leading = false } = {}) {\n  let timeoutId, lastArgs, lastThis;\n  return function (...args) {\n    lastArgs = args;\n    lastThis = this;\n    const shouldCallNow = leading && !timeoutId;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      if (!leading) {\n        fn.apply(lastThis, lastArgs);\n      }\n    }, delay);\n\n    if (shouldCallNow) {\n      fn.apply(lastThis, lastArgs);\n    }\n  };\n}\n",
          "codeTs": "export default function debounce<F extends (...a: any[]) => void>(\n  fn: F,\n  delay: number,\n  opts: { leading?: boolean } = {}\n): F {\n  const { leading = false } = opts;\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  let lastArgs: Parameters<F>;\n  let lastThis: any;\n\n  const debounced = function (this: any, ...args: Parameters<F>) {\n    lastArgs = args;\n    lastThis = this;\n    const shouldCallNow = leading && !timeoutId;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      if (!leading) {\n        fn.apply(lastThis, lastArgs);\n      }\n    }, delay);\n\n    if (shouldCallNow) {\n      fn.apply(lastThis, lastArgs);\n    }\n  } as F;\n\n  return debounced;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Return value is usually lost; debounced wrappers typically return `void`. If you need a result, consider callbacks or promises.",
          "Be careful with `this` — use `fn.apply(this, args)` (or `fn.call`) so methods still see the correct context.",
          "Timers differ between environments (Node vs browser), but `setTimeout/clearTimeout` work in both."
        ],
        "edgeCases": [
          "delay = 0 → effectively batches multiple calls into one at the end of the event loop.",
          "Rapid continuous calls → only the last invocation executes after inactivity in trailing mode.",
          "In long-lived components, remember to cancel timers (e.g. via `.cancel()`) on unmount to avoid stray executions."
        ],
        "techniques": [
          "Using closures to store timer and last-arguments state.",
          "Clearing and resetting timeouts to restart the debounce window.",
          "Extending the basic pattern with cancel/flush helpers and leading-edge options."
        ]
      },
      "followUpQuestions": [
        "js-throttle"
      ],
      "resources": [
        {
          "title": "MDN – setTimeout()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        },
        {
          "title": "MDN – Function.prototype.apply()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
        }
      ]
    },
    "tests": "import debounce from './debounce';\n\nconst wait = (ms) => new Promise((r) => setTimeout(r, ms));\n\ndescribe('debounce', () => {\n  test('calls function after delay', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 120);\n\n    debounced();\n    expect(calls).toBe(0);\n\n    await wait(140);\n    expect(calls).toBe(1);\n  });\n\n  test('resets timer on rapid calls (only last executes)', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 100);\n\n    debounced();\n    await wait(50);\n    debounced();\n    await wait(50);\n    debounced();\n\n    await wait(90);\n    expect(calls).toBe(0);\n\n    await wait(20);\n    expect(calls).toBe(1);\n  });\n\n  test('passes arguments (and preserves this via apply)', async () => {\n    let last = '';\n    const debounced = debounce(function (name) {\n      last = `Hi ${name}`;\n    }, 80);\n\n    debounced.call({ tag: 'ctx' }, 'Alice');\n    await wait(100);\n    expect(last).toBe('Hi Alice');\n  });\n});\n",
    "testsTs": "import debounce from './debounce';\n\nconst wait = (ms: number) => new Promise<void>((r) => setTimeout(r, ms));\n\ndescribe('debounce (TypeScript)', () => {\n  it('delays function execution', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 120);\n\n    debounced();\n    expect(calls).toBe(0);\n\n    await wait(140);\n    expect(calls).toBe(1);\n  });\n\n  it('restarts timer on multiple calls', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 100);\n\n    debounced();\n    await wait(50);\n    debounced();\n    await wait(50);\n    debounced();\n\n    await wait(90);\n    expect(calls).toBe(0);\n\n    await wait(20);\n    expect(calls).toBe(1);\n  });\n\n  it('forwards parameters correctly', async () => {\n    let captured = '';\n    const debounced = debounce((msg: string) => { captured = msg; }, 80);\n\n    debounced('Hello');\n    await wait(100);\n    expect(captured).toBe('Hello');\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-throttle",
    "title": "Throttle Function",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "companies": [
      "google",
      "netflix"
    ],
    "difficulty": "intermediate",
    "tags": [
      "async",
      "functions",
      "timing"
    ],
    "description": {
      "summary": "Implement a function `throttle(fn, interval)` that ensures `fn` is executed at most once during every `interval` milliseconds, no matter how many times it's triggered. In this exercise we use a leading-only throttle: the first call in each interval runs immediately; subsequent calls within that window are ignored.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The function to be throttled."
        },
        {
          "name": "interval",
          "type": "number",
          "desc": "The time window (in milliseconds) within which subsequent calls are ignored."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A throttled version of the original function that executes at most once per interval (leading-edge behavior)."
      },
      "examples": [
        "// Basic examples\nthrottle(() => console.log('Clicked!'), 1000)",
        "// Multiple rapid calls — only the first one executes within the interval\nconst log = throttle(() => console.log('Run!'), 500)\nlog()\nlog()\nlog() // Only the first logs immediately; later calls within 500ms are ignored",
        "// With arguments (leading-only)\nconst greet = throttle(name => console.log(`Hi ${name}`), 800)\ngreet('Alice')\ngreet('Bob') // 'Hi Alice' logs immediately; 'Hi Bob' is ignored because it's inside the 800ms window\n// A call after 800ms (e.g. greet('Charlie')) would run again"
      ]
    },
    "starterCode": "export default function throttle(fn, interval) {\n  // TODO: Execute fn at most once per interval (leading-only)\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  // TODO: Execute fn at most once per interval (leading-only)\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure a function executes at most once within a defined period — controlling execution frequency for performance-critical events (scroll, resize, input). The implementations shown here are **leading-only throttles**: the first call in an interval runs immediately; subsequent calls in the same interval are ignored. In real projects you might extend this to combined leading + trailing behavior (like Lodash's `throttle`).",
      "approaches": [
        {
          "title": "Approach 1: Timestamp-based throttle (simple and effective)",
          "prose": "Idea: record the last time the function was called, and skip execution until enough time passes.\n\nHow it works:\n1. Initialize `let lastTime = 0` to remember the last execution time.\n2. On each call, compute `const now = Date.now()` and check `now - lastTime >= interval`.\n3. If the check passes, call `fn` with the current `this` and arguments, then set `lastTime = now`.\n\nWhy use it: straightforward, minimal overhead, and gives consistently spaced executions when calls are frequent.",
          "codeJs": "export default function throttle(fn, interval) {\n  let lastTime = 0;\n  return function (...args) {\n    const now = Date.now();\n    if (now - lastTime >= interval) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  };\n}\n",
          "codeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  let lastTime = 0;\n  return function (this: any, ...args: Parameters<F>) {\n    const now = Date.now();\n    if (now - lastTime >= interval) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  } as F;\n}\n"
        },
        {
          "title": "Approach 2: Timer-based throttle (cooldown flag)",
          "prose": "Idea: run the first call immediately, then use a timer as a cooldown. While the timer is active, additional calls are ignored.\n\nHow it works:\n1. Keep a boolean `waiting = false` in the closure to represent the cooldown.\n2. On each call:\n   - If `waiting` is `true`, ignore the call.\n   - If `waiting` is `false`, invoke `fn` with the current `this` and arguments, set `waiting = true`, and start a `setTimeout` that flips `waiting` back to `false` after `interval` ms.\n\nThis guarantees that once `fn` runs, it cannot run again until at least `interval` ms have passed.\n\nWhy use it: uses timers instead of timestamps, which can feel more intuitive when you already rely heavily on `setTimeout` in your code.",
          "codeJs": "export default function throttle(fn, interval) {\n  let waiting = false;\n  return function (...args) {\n    if (!waiting) {\n      fn.apply(this, args);\n      waiting = true;\n      setTimeout(() => {\n        waiting = false;\n      }, interval);\n    }\n  };\n}\n",
          "codeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  let waiting = false;\n  return function (this: any, ...args: Parameters<F>) {\n    if (!waiting) {\n      fn.apply(this, args);\n      waiting = true;\n      setTimeout(() => {\n        waiting = false;\n      }, interval);\n    }\n  } as F;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "These simple implementations are leading-only: the final event in a burst may be ignored. For guaranteed trailing execution, use a combined leading + trailing throttle (not shown here) or a utility like Lodash.",
          "Avoid mixing throttle and debounce on the same handler unless the expected behavior is very clear.",
          "Ensure consistent `this` context by using `fn.apply(this, args)` (or `fn.call`)."
        ],
        "edgeCases": [
          "interval = 0 → throttling effectively disappears; `fn` runs on every call.",
          "The first call in each interval always executes immediately.",
          "Successive calls within the active interval window are ignored."
        ],
        "techniques": [
          "Controlling execution rate with timestamps or timers.",
          "Tracking `lastTime` or a cooldown flag in a closure.",
          "Preserving caller context with `apply()`."
        ]
      },
      "followUpQuestions": [
        "js-debounce"
      ],
      "resources": [
        {
          "title": "MDN – setTimeout()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        },
        {
          "title": "Lodash – throttle",
          "url": "https://lodash.com/docs/#throttle"
        }
      ]
    },
    "tests": "import throttle from './throttle';\n\nconst wait = (ms) => new Promise((r) => setTimeout(r, ms));\n\ndescribe('throttle', () => {\n  test('executes immediately and ignores rapid calls', async () => {\n    let calls = 0;\n    const throttled = throttle(() => { calls += 1; }, 200);\n\n    throttled(); // should run immediately\n    throttled(); // ignored\n    throttled(); // ignored\n\n    expect(calls).toBe(1);\n\n    await wait(220);\n    throttled(); // should run after interval\n    expect(calls).toBe(2);\n  });\n\n  test('maintains correct interval spacing', async () => {\n    let timestamps = [];\n    const throttled = throttle(() => { timestamps.push(Date.now()); }, 100);\n\n    throttled();\n    await wait(30);\n    throttled();\n    await wait(80);\n    throttled(); // should run after ~110ms total\n\n    await wait(120);\n    throttled(); // another valid call\n\n    expect(timestamps.length).toBe(3);\n  });\n\n  test('passes arguments correctly', async () => {\n    let last = '';\n    const throttled = throttle((msg) => { last = msg; }, 150);\n\n    throttled('Hello');\n    throttled('World'); // ignored\n\n    await wait(160);\n    throttled('Again');\n\n    expect(last).toBe('Again');\n  });\n});\n",
    "testsTs": "import throttle from './throttle';\n\nconst wait = (ms: number) => new Promise<void>((r) => setTimeout(r, ms));\n\ndescribe('throttle (TypeScript)', () => {\n  it('executes immediately and ignores rapid calls', async () => {\n    let calls = 0;\n    const throttled = throttle(() => { calls += 1; }, 200);\n\n    throttled();\n    throttled();\n    throttled();\n\n    expect(calls).toBe(1);\n\n    await wait(220);\n    throttled();\n    expect(calls).toBe(2);\n  });\n\n  it('maintains proper intervals', async () => {\n    let times: number[] = [];\n    const throttled = throttle(() => { times.push(Date.now()); }, 100);\n\n    throttled();\n    await wait(30);\n    throttled();\n    await wait(80);\n    throttled();\n\n    await wait(120);\n    throttled();\n\n    expect(times.length).toBe(3);\n  });\n\n  it('passes arguments correctly', async () => {\n    let last = '';\n    const throttled = throttle((msg: string) => { last = msg; }, 150);\n\n    throttled('Hi');\n    throttled('Ignore');\n\n    await wait(160);\n    throttled('Final');\n\n    expect(last).toBe('Final');\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-deep-clone",
    "title": "Deep Clone",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "difficulty": "hard",
    "tags": [
      "clone",
      "deep-copy",
      "objects",
      "recursion"
    ],
    "description": {
      "summary": "Implement a function `deepClone(value)` that creates a deep copy of the provided value, including nested objects, arrays, Dates, and RegExps.",
      "arguments": [
        {
          "name": "value",
          "type": "any",
          "desc": "The value to deeply clone. Can be an object, array, Date, RegExp, or primitive."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "A deep copy of the input value where all nested structures are duplicated rather than referenced."
      },
      "examples": [
        "// Basic examples",
        "deepClone({ a: 1, b: { c: 2 } }) // => { a: 1, b: { c: 2 } }",
        "// Arrays and nested objects",
        "const arr = [1, { x: 10 }, [2, 3]]",
        "const copy = deepClone(arr)",
        "copy[1].x = 99",
        "// arr stays unchanged",
        "// Dates and RegExps",
        "const obj = { d: new Date('2020-01-01'), r: /abc/i }",
        "const clone = deepClone(obj)",
        "clone.d.setFullYear(2024)",
        "// obj.d still points to 2020"
      ]
    },
    "starterCode": "export default function deepClone(value) {\n  // TODO: Return a deep-cloned copy of the input value\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function deepClone<T>(value: T): T {\n  // TODO: Return a deep-cloned copy of the input value\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: create a fully independent copy of the input value — primitives, plain objects, arrays, Dates, or RegExps — so that later mutations do **not** affect the original. The base approach handles typical data structures (no circular references); the advanced version extends it to support circular graphs using a `WeakMap`.",
      "approaches": [
        {
          "title": "Approach 1: Recursive type-aware cloning (base version, no circular refs)",
          "prose": "Idea: detect the type of the input and handle each case appropriately — primitive, array, plain object, or special object type (Date / RegExp).\n\n### Steps\n1. If `value` is not an object (including `null`, numbers, strings, booleans, bigints, symbols), return it directly.\n2. If `value` is a `Date`, create a new `Date` with the same timestamp.\n3. If `value` is a `RegExp`, create a new `RegExp` with the same pattern, flags, and `lastIndex`.\n4. If `value` is an array, create a new array and recursively clone each element.\n5. Otherwise treat it as a plain object: create `{}`, iterate its own enumerable keys, and recursively clone each property.\n\nThis ensures deeply nested structures are copied without sharing references (as long as there are no circular references).",
          "codeJs": "export default function deepClone(value) {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (value instanceof Date) return new Date(value.getTime());\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClone(item));\n  }\n\n  const clonedObj = {};\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clonedObj[key] = deepClone(value[key]);\n    }\n  }\n  return clonedObj;\n}\n",
          "codeTs": "export default function deepClone<T>(value: T): T {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (value instanceof Date) return new Date(value.getTime()) as any;\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re as any;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClone(item)) as any;\n  }\n\n  const clonedObj: any = {};\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clonedObj[key] = deepClone((value as any)[key]);\n    }\n  }\n  return clonedObj;\n}\n"
        },
        {
          "title": "Approach 2: Handling circular references with WeakMap (advanced extension)",
          "prose": "Idea: build on the recursive approach but track already-cloned objects in a `WeakMap`. When you encounter the same object again, return the stored clone instead of recursing, which prevents infinite loops on cyclic graphs.\n\n### Steps\n1. Pass a `seen = new WeakMap()` through recursive calls.\n2. If `value` is primitive / `null`, return it directly (same as before).\n3. Before cloning an object/array, check `seen.has(value)` — if yes, return `seen.get(value)`.\n4. Otherwise, create the appropriate empty container (`[]` or `{}`), store it in `seen.set(value, clone)`, then recursively fill its properties.\n5. Keep the same Date/RegExp handling as in the base approach.\n\nThis version behaves like the base version on normal inputs, but also safely supports circular structures (objects that reference themselves or each other).",
          "codeJs": "export default function deepClone(value, seen = new WeakMap()) {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (seen.has(value)) return seen.get(value);\n\n  if (value instanceof Date) return new Date(value.getTime());\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re;\n  }\n\n  const clone = Array.isArray(value) ? [] : {};\n  seen.set(value, clone);\n\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clone[key] = deepClone(value[key], seen);\n    }\n  }\n  return clone;\n}\n",
          "codeTs": "export default function deepClone<T>(value: T, seen: WeakMap<any, any> = new WeakMap()): T {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (seen.has(value)) return seen.get(value);\n\n  if (value instanceof Date) return new Date(value.getTime()) as any;\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re as any;\n  }\n\n  const clone: any = Array.isArray(value) ? [] : {};\n  seen.set(value, clone);\n\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clone[key] = deepClone((value as any)[key], seen);\n    }\n  }\n  return clone;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Shallow copy methods like spread (`{ ...obj }`) or `Object.assign` only copy one level deep — nested objects will still share references.",
          "The base recursive version (Approach 1) will recurse forever on circular structures; use the WeakMap-based extension when cycles are possible.",
          "Functions, DOM nodes, Maps/Sets, and custom class instances are **not** truly cloned here — their references and/or plain enumerable properties are copied, but prototypes and special internal state are not preserved."
        ],
        "edgeCases": [
          "null or primitive → returned directly.",
          "Date → returns new Date with identical timestamp.",
          "RegExp → returns new RegExp with identical source, flags, and `lastIndex`.",
          "Array → deep-cloned recursively.",
          "Plain object → deep-cloned recursively by own enumerable properties."
        ],
        "techniques": [
          "Recursion for nested structures.",
          "Type detection using `instanceof` and `Array.isArray`.",
          "Reference tracking using WeakMap for circular safety.",
          "Differentiating deep vs shallow copying."
        ]
      },
      "followUpQuestions": [
        "js-flatten-depth"
      ],
      "resources": [
        {
          "title": "MDN – Object cloning basics",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy"
        },
        {
          "title": "JavaScript.info – Deep cloning",
          "url": "https://javascript.info/object-copy#structuredclone"
        }
      ]
    },
    "tests": "import deepClone from './deepClone';\n\ndescribe('deepClone', () => {\n  test('clones nested objects', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const clone = deepClone(obj);\n    expect(clone).toEqual(obj);\n    clone.b.c = 5;\n    expect(obj.b.c).toBe(2);\n  });\n\n  test('clones arrays correctly', () => {\n    const arr = [1, { x: 2 }, [3, 4]];\n    const clone = deepClone(arr);\n    expect(clone).toEqual(arr);\n    clone[1].x = 99;\n    expect(arr[1].x).toBe(2);\n  });\n\n  test('clones Date and RegExp instances', () => {\n    const obj = { d: new Date('2020-01-01T00:00:00Z'), r: /abc/i };\n    const clone = deepClone(obj);\n\n    expect(clone.d instanceof Date).toBe(true);\n    expect(clone.d === obj.d).toBe(false);\n    expect(clone.d.getTime()).toBe(obj.d.getTime());\n\n    const sameRegExp = (\n      clone.r instanceof RegExp &&\n      clone.r !== obj.r &&\n      clone.r.source === obj.r.source &&\n      (('flags' in clone.r && 'flags' in obj.r)\n        ? clone.r.flags === obj.r.flags\n        : String(clone.r) === String(obj.r)) &&\n      clone.r.lastIndex === obj.r.lastIndex\n    );\n    expect(sameRegExp).toBe(true);\n  });\n\n  test('returns primitives as-is', () => {\n    expect(deepClone(5)).toBe(5);\n    expect(deepClone('test')).toBe('test');\n    expect(deepClone(null)).toBe(null);\n  });\n});\n",
    "testsTs": "import deepClone from './deepClone';\n\ndescribe('deepClone (TypeScript)', () => {\n  it('deeply clones nested objects', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const clone = deepClone(obj);\n    expect(clone).toEqual(obj);\n    clone.b.c = 99;\n    expect(obj.b.c).toBe(2);\n  });\n\n  it('clones arrays correctly', () => {\n    const arr = [1, { x: 10 }, [2, 3]];\n    const clone = deepClone(arr);\n    expect(clone).toEqual(arr);\n    clone[1].x = 50;\n    expect(arr[1].x).toBe(10);\n  });\n\n  it('handles Dates and RegExps robustly', () => {\n    const obj = { d: new Date('2020-01-01T00:00:00Z'), r: /test/g };\n    const clone = deepClone(obj);\n\n    expect(clone.d instanceof Date).toBe(true);\n    expect(clone.d === obj.d).toBe(false);\n    expect(clone.d.getTime()).toBe(obj.d.getTime());\n\n    const sameRegExp = (\n      clone.r instanceof RegExp &&\n      clone.r !== obj.r &&\n      clone.r.source === obj.r.source &&\n      (('flags' in clone.r && 'flags' in obj.r)\n        ? clone.r.flags === obj.r.flags\n        : String(clone.r) === String(obj.r)) &&\n      clone.r.lastIndex === obj.r.lastIndex\n    );\n    expect(sameRegExp).toBe(true);\n  });\n\n  it('returns primitives unchanged', () => {\n    expect(deepClone('abc')).toBe('abc');\n    expect(deepClone(123)).toBe(123);\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-deep-equal",
    "title": "Deep Equal",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "comparison",
      "equality",
      "objects",
      "recursion"
    ],
    "description": {
      "summary": "Implement a function `deepEqual(a, b)` that returns `true` when two values are deeply equal — primitives by value and objects/arrays by recursively comparing their properties. Handle Dates, RegExps, and `NaN`.",
      "arguments": [
        {
          "name": "a",
          "type": "any",
          "desc": "First value to compare."
        },
        {
          "name": "b",
          "type": "any",
          "desc": "Second value to compare."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if both inputs are deeply equal; otherwise `false`."
      },
      "examples": [
        "// Basic examples",
        "deepEqual(1, 1) // => true",
        "deepEqual(1, '1') // => false",
        "// Nested objects",
        "deepEqual({ a: 1, b: { c: 2 } }, { a: 1, b: { c: 2 } }) // => true",
        "// Arrays (order matters)",
        "deepEqual([1, 2, 3], [1, 2, 3]) // => true",
        "deepEqual([1, 2, 3], [3, 2, 1]) // => false",
        "// Dates and RegExp",
        "deepEqual(new Date('2020-01-01'), new Date('2020-01-01')) // => true",
        "deepEqual(/ab/i, new RegExp('ab', 'i')) // => true",
        "// Special values",
        "deepEqual(NaN, NaN) // => true",
        "deepEqual(null, undefined) // => false"
      ]
    },
    "starterCode": "export default function deepEqual(a, b) {\n  // TODO: Compare two values for deep equality\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function deepEqual<T = any>(a: T, b: T): boolean {\n  // TODO: Compare two values for deep equality\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: return `true` only when two inputs are the same **by value** (for primitives) or **by structure** (for arrays/objects). Must treat `NaN` as equal to `NaN`, compare `Date` by timestamp, and `RegExp` by pattern/flags/lastIndex. Approach 1 is the canonical solution that satisfies these requirements; Approach 2 shows a common shortcut that only works for plain JSON-like data and is not suitable for the full spec.",
      "approaches": [
        {
          "title": "Approach 1: Direct recursion (baseline, easiest to follow)",
          "prose": "Idea: handle the common cases with clear early exits, then recurse for arrays and plain objects.\n\n### Steps\n1. If `a === b`, return `true` (covers identical references and most primitives).\n2. If both are numbers and both are `NaN`, return `true`.\n3. If types differ or either is `null`, return `false`.\n4. Handle `Date` and `RegExp` specially.\n5. If either value is an array, both must be arrays; compare length, then pairwise recurse.\n6. Otherwise, treat as plain objects: compare own keys length, ensure the same keys exist, then recurse per key.\n\nWhy use it: readable flow with tight, predictable checks that pass typical interview test suites.",
          "codeJs": "export default function deepEqual(a, b) {\n  if (a === b) return true;\n  if (typeof a === 'number' && typeof b === 'number' && Number.isNaN(a) && Number.isNaN(b)) return true;\n  if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') return false;\n\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    const same = a.source === b.source && a.flags === b.flags;\n    return same && a.lastIndex === b.lastIndex;\n  }\n\n  const aIsArr = Array.isArray(a);\n  const bIsArr = Array.isArray(b);\n  if (aIsArr || bIsArr) {\n    if (!(aIsArr && bIsArr)) return false;\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const k of aKeys) {\n    if (!Object.prototype.hasOwnProperty.call(b, k)) return false;\n    if (!deepEqual(a[k], b[k])) return false;\n  }\n  return true;\n}\n",
          "codeTs": "export default function deepEqual<T = any>(a: T, b: T): boolean {\n  if (a === b) return true;\n  if (typeof a === 'number' && typeof b === 'number' && Number.isNaN(a as any) && Number.isNaN(b as any)) return true;\n  if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') return false;\n\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    const same = a.source === b.source && a.flags === b.flags;\n    return same && a.lastIndex === b.lastIndex;\n  }\n\n  const aIsArr = Array.isArray(a);\n  const bIsArr = Array.isArray(b);\n  if (aIsArr || bIsArr) {\n    if (!(aIsArr && bIsArr)) return false;\n    const aa = a as unknown as any[];\n    const bb = b as unknown as any[];\n    if (aa.length !== bb.length) return false;\n    for (let i = 0; i < aa.length; i++) {\n      if (!deepEqual(aa[i], bb[i])) return false;\n    }\n    return true;\n  }\n\n  const aObj = a as Record<string, unknown>;\n  const bObj = b as Record<string, unknown>;\n  const aKeys = Object.keys(aObj);\n  const bKeys = Object.keys(bObj);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const k of aKeys) {\n    if (!Object.prototype.hasOwnProperty.call(bObj, k)) return false;\n    if (!deepEqual((aObj as any)[k], (bObj as any)[k])) return false;\n  }\n  return true;\n}\n"
        },
        {
          "title": "Approach 2: JSON stringify (quick but limited)",
          "prose": "Idea: `JSON.stringify(a) === JSON.stringify(b)` as a one-liner for **plain** data (no functions, symbols, or `undefined` in objects; key order stable).\n\nThis does **not** correctly handle Dates, RegExps, `NaN`, or cyclic structures, so it cannot be used as the main solution for this exercise — it is only a shortcut for simple, JSON-serializable payloads.\n\nWhy use it: handy sanity check or pre-filter for simple objects; not reliable for general-purpose deep equality.",
          "codeJs": "export default function deepEqual(a, b) {\n  try {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } catch {\n    // cyclic structures throw errors\n    return false;\n  }\n}\n",
          "codeTs": "export default function deepEqual<T>(a: T, b: T): boolean {\n  try {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } catch {\n    return false;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Treat `NaN` as equal to `NaN` — `NaN === NaN` is false by default.",
          "Don’t rely on `JSON.stringify` for general deep equality (Dates/RegExps/NaN/undefined/functions differ).",
          "Only compare **own** enumerable string keys; symbol keys, non-enumerable properties, and prototypes are out of scope for this exercise."
        ],
        "edgeCases": [
          "Different types → immediately false.",
          "Arrays: order matters; lengths must match.",
          "RegExp: compare `source`, `flags`, and optionally `lastIndex`.",
          "Date: compare `getTime()`.",
          "Null vs undefined → false."
        ],
        "techniques": [
          "Short-circuit checks before recursion.",
          "Type-specific comparisons for Date/RegExp.",
          "Key set + recursive property comparison."
        ]
      },
      "followUpQuestions": [
        "js-deep-clone",
        "js-arrays-equal"
      ],
      "resources": [
        {
          "title": "MDN – Object.keys()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"
        },
        {
          "title": "MDN – Date",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"
        },
        {
          "title": "MDN – RegExp",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp"
        }
      ]
    },
    "tests": "import deepEqual from './deepEqual';\n\ndescribe('deepEqual', () => {\n  test('compares primitives', () => {\n    expect(deepEqual(1, 1)).toBe(true);\n    expect(deepEqual(1, '1')).toBe(false);\n    expect(deepEqual(NaN, NaN)).toBe(true);\n  });\n\n  test('compares nested objects', () => {\n    const a = { x: 1, y: { z: 2 } };\n    const b = { x: 1, y: { z: 2 } };\n    expect(deepEqual(a, b)).toBe(true);\n    const c = { x: 1, y: { z: 3 } };\n    expect(deepEqual(a, c)).toBe(false);\n  });\n\n  test('compares arrays (order matters)', () => {\n    expect(deepEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n    expect(deepEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  test('handles Date and RegExp', () => {\n    const d1 = new Date('2020-01-01T00:00:00Z');\n    const d2 = new Date('2020-01-01T00:00:00Z');\n    expect(deepEqual(d1, d2)).toBe(true);\n\n    const r1 = /ab/i;\n    const r2 = new RegExp('ab', 'i');\n    expect(deepEqual(r1, r2)).toBe(true);\n  });\n\n  test('null vs undefined', () => {\n    expect(deepEqual(null, undefined)).toBe(false);\n  });\n});\n",
    "testsTs": "import deepEqual from './deepEqual';\n\ndescribe('deepEqual (TypeScript)', () => {\n  it('compares primitives', () => {\n    expect(deepEqual(1, 1)).toBe(true);\n    expect(deepEqual(1 as any, '1' as any)).toBe(false);\n    expect(deepEqual(NaN, NaN)).toBe(true);\n  });\n\n  it('compares nested objects', () => {\n    const a = { x: 1, y: { z: 2 } };\n    const b = { x: 1, y: { z: 2 } };\n    expect(deepEqual(a, b)).toBe(true);\n    const c = { x: 1, y: { z: 3 } };\n    expect(deepEqual(a, c)).toBe(false);\n  });\n\n  it('compares arrays (order matters)', () => {\n    expect(deepEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n    expect(deepEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  it('handles Date and RegExp', () => {\n    const d1 = new Date('2020-01-01T00:00:00Z');\n    const d2 = new Date('2020-01-01T00:00:00Z');\n    expect(deepEqual(d1, d2)).toBe(true);\n\n    const r1 = /ab/i;\n    const r2 = new RegExp('ab', 'i');\n    expect(deepEqual(r1, r2)).toBe(true);\n  });\n\n  it('null vs undefined', () => {\n    expect(deepEqual(null as any, undefined as any)).toBe(false);\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-flatten-depth",
    "title": "Flatten with Depth",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "arrays",
      "depth",
      "flatten",
      "recursion"
    ],
    "description": {
      "summary": "Implement `flatten(arr, depth)` that flattens a nested array up to a given depth.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "Nested array to flatten."
        },
        {
          "name": "depth",
          "type": "number",
          "desc": "Number of levels to flatten (default 1). If depth ≤ 0, return a shallow copy; if depth exceeds the nesting level, flatten completely."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array flattened up to the given depth."
      },
      "examples": [
        "// Basic examples\nflatten([1, [2, [3, [4]]]], 1) // => [1, 2, [3, [4]]]",
        "flatten([1, [2, [3, [4]]]], 2) // => [1, 2, 3, [4]]",
        "flatten([1, [2, [3, [4]]]], 3) // => [1, 2, 3, 4]",
        "// Handles empty and non-nested arrays\nflatten([1, 2, 3], 2) // => [1, 2, 3]"
      ]
    },
    "starterCode": "export default function flatten(arr, depth = 1) {\n  // TODO: Flatten array up to given depth\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  // TODO: Flatten array up to given depth\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: reduce nested arrays by one or more levels depending on `depth`. Each recursive or iterative step removes one layer of nesting until `depth` reaches 0 (at which point you return a shallow copy).",
      "approaches": [
        {
          "title": "Approach 1: Recursive flattening (baseline, easiest to read)",
          "prose": "Idea: for each element, check if it’s an array. If yes, flatten it one level deeper (reducing `depth`), otherwise push directly.\n\nHow it works:\n1. Base case: if `depth === 0`, return a shallow copy of the array (`arr.slice()`).\n2. Loop through the elements of `arr`.\n3. For nested arrays and `depth > 0`, recurse with `flatten(el, depth - 1)` and spread the result into `result`.\n4. For non-array elements (or when `depth` is 0), push them directly into `result`.\n\nWhy use it: very readable, mirrors how you might reason about the problem on paper, and makes the `depth` behavior explicit.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  const result = [];\n  for (const el of arr) {\n    if (Array.isArray(el) && depth > 0) {\n      result.push(...flatten(el, depth - 1));\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  const result: any[] = [];\n  for (const el of arr) {\n    if (Array.isArray(el) && depth > 0) {\n      result.push(...flatten(el, depth - 1));\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using reduce (compact, functional style)",
          "prose": "Idea: use `Array.prototype.reduce` to build the flattened array recursively with accumulation.\n\nHow it works:\n1. If `depth === 0`, return a shallow copy of `arr`.\n2. Call `reduce` with an empty array accumulator.\n3. For each element, either concatenate a recursively flattened version (when it’s an array and depth > 0) or concatenate the element itself.\n\nThis mirrors Approach 1 but in a more functional, chain-friendly style.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  return arr.reduce((acc, el) => {\n    return acc.concat(Array.isArray(el) ? flatten(el, depth - 1) : el);\n  }, []);\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  return arr.reduce((acc: any[], el) => {\n    return acc.concat(Array.isArray(el) ? flatten(el, depth - 1) : el);\n  }, []);\n}\n"
        },
        {
          "title": "Approach 3: Using stack (iterative, avoids recursion)",
          "prose": "Idea: simulate recursion using a stack so we can flatten arrays iteratively. This approach is great for deeply nested arrays since it avoids call-stack overflows.\n\n### 🔍 How it works\n1. Seed a stack with each top-level element and the starting `depth` value, pushing them right-to-left.\n2. Pop elements from the stack one by one.\n3. If the element is an array and `depth > 0`, push its children **in reverse order**, each with `depth - 1`.\n4. If it’s not an array or `depth === 0`, append it to the result array.\n\n### 💡 Why reverse order?\nBecause the stack is LIFO — we want elements to be processed left-to-right. By seeding the stack in reverse and pushing children in reverse, the final order matches the original array.\n\n### ⚙️ When to use\n- When arrays are extremely deep and recursion may hit a call-stack limit.\n- When you need explicit control over traversal.\n\n### ✅ Complexity\nO(n) time and O(n) space — similar to the recursive approach, but stack-safe.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  const result = [];\n  const stack = [];\n  // Seed stack right-to-left so popping processes left-to-right\n  for (let i = arr.length - 1; i >= 0; i--) {\n    stack.push([arr[i], depth]);\n  }\n  while (stack.length) {\n    const [curr, d] = stack.pop();\n    if (Array.isArray(curr) && d > 0) {\n      for (let i = curr.length - 1; i >= 0; i--) {\n        stack.push([curr[i], d - 1]);\n      }\n    } else {\n      result.push(curr);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  const result: any[] = [];\n  const stack: Array<[any, number]> = [];\n  // Seed stack right-to-left so popping processes left-to-right\n  for (let i = arr.length - 1; i >= 0; i--) {\n    stack.push([arr[i], depth]);\n  }\n  while (stack.length) {\n    const [curr, d] = stack.pop() as [any, number];\n    if (Array.isArray(curr) && d > 0) {\n      for (let i = curr.length - 1; i >= 0; i--) {\n        stack.push([curr[i], d - 1]);\n      }\n    } else {\n      result.push(curr);\n    }\n  }\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Don’t mutate the input array — always return a new array.",
          "If `depth === 0`, return a shallow copy, not the original reference.",
          "`Array.flat()` is off-limits here (we’re reimplementing it)."
        ],
        "edgeCases": [
          "Empty arrays → return empty array.",
          "Depth larger than nesting → fully flatten.",
          "Depth 0 or below → return shallow copy."
        ],
        "techniques": [
          "Recursion and base case handling.",
          "Using spread / concat to merge flattened pieces.",
          "Iterative stack-based traversal to avoid recursion limits."
        ]
      },
      "followUpQuestions": [
        "js-flatten-once",
        "js-deep-clone"
      ]
    },
    "tests": "import flatten from './flatten';\n\ndescribe('flatten', () => {\n  test('flattens one level deep', () => {\n    expect(flatten([1, [2, [3, [4]]]], 1)).toEqual([1, 2, [3, [4]]]);\n  });\n\n  test('flattens two levels deep', () => {\n    expect(flatten([1, [2, [3, [4]]]], 2)).toEqual([1, 2, 3, [4]]);\n  });\n\n  test('flattens completely when depth is high', () => {\n    expect(flatten([1, [2, [3, [4]]]], 10)).toEqual([1, 2, 3, 4]);\n  });\n\n  test('handles empty and non-nested arrays', () => {\n    expect(flatten([], 2)).toEqual([]);\n    expect(flatten([1, 2, 3], 2)).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "import flatten from './flatten';\n\ndescribe('flatten (TypeScript)', () => {\n  it('flattens one level', () => {\n    expect(flatten([1, [2, [3, [4]]]], 1)).toEqual([1, 2, [3, [4]]]);\n  });\n\n  it('flattens up to given depth', () => {\n    expect(flatten([1, [2, [3, [4]]]], 2)).toEqual([1, 2, 3, [4]]);\n  });\n\n  it('fully flattens if depth is large', () => {\n    expect(flatten([1, [2, [3, [4]]]], 10)).toEqual([1, 2, 3, 4]);\n  });\n\n  it('returns array unchanged when already flat', () => {\n    expect(flatten([1, 2, 3], 2)).toEqual([1, 2, 3]);\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-curry-function",
    "title": "Curry Function",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "closure",
      "currying",
      "functions",
      "higher-order"
    ],
    "description": {
      "summary": "Implement a function `curry(fn)` that transforms a multi-argument function into a function that can be called in a chain, supplying arguments one or more at a time.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "A function that accepts multiple arguments."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A curried version of the input function that collects arguments across calls until it has at least `fn.length` arguments, then invokes `fn`."
      },
      "examples": [
        "// Basic example\nfunction add(a, b, c) { return a + b + c; }\nconst curriedAdd = curry(add);\ncurriedAdd(1)(2)(3) // => 6",
        "// Partial application\nconst add5 = curriedAdd(2)(3);\nadd5(10) // => 15",
        "// Works with different argument counts\nconst multiply = (a, b) => a * b;\ncurry(multiply)(4)(5) // => 20",
        "// Mixed grouping is fine too\ncurriedAdd(1, 2)(3) // => 6\ncurriedAdd(1)(2, 3) // => 6"
      ]
    },
    "starterCode": "export default function curry(fn) {\n  // TODO: Transform fn into a curried version\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function curry(fn: Function): Function {\n  // TODO: Transform fn into a curried version\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: turn an N-ary function into a chain that collects arguments across calls until it has at least `fn.length`, then invokes `fn`. Enables partial application while preserving argument order.",
      "approaches": [
        {
          "title": "Approach 1: Variadic accumulator using closures (simplest)",
          "prose": "Idea: keep collecting arguments in a closure. If collected args are **>=** `fn.length`, call `fn`; otherwise, return a function that keeps collecting.\n\nHow it works:\n1. Read `fn.length` to know how many parameters are required.\n2. Define inner `curried(...args)` that checks how many arguments have been collected.\n3. If `args.length >= fn.length`, call `fn(...args)` and return the result.\n4. Otherwise, return a new function that gathers more arguments and calls `curried(...args, ...next)`.\n\nWhy it works: closures preserve previously provided args; callers can group arguments arbitrarily (`f(1)(2)(3)`, `f(1, 2)(3)`, `f(1)(2, 3)`, etc.).",
          "codeJs": "export default function curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn(...args);\n    }\n    return (...next) => curried(...args, ...next);\n  };\n}\n",
          "codeTs": "export default function curry(fn: Function): Function {\n  const curried = (...args: any[]): any => {\n    return args.length >= fn.length\n      ? fn(...args)\n      : (...next: any[]) => curried(...args, ...next);\n  };\n  return curried;\n}\n"
        },
        {
          "title": "Approach 2: Same idea with concat (slightly different style)",
          "prose": "Idea: use the same `curried(...args)` pattern as Approach 1, but accumulate arguments using `concat` instead of spread. Behavior is the same; this is just a stylistic variation.\n\nHow it works:\n1. Define inner `curried(...args)` that represents the partially applied function.\n2. If `args.length >= fn.length`, immediately invoke `fn(...args)`.\n3. Otherwise, return a function that takes `...next` arguments and calls `curried(...args.concat(next))` to keep collecting.\n\nThis version highlights that you can implement currying with any mechanism that accumulates arguments (spread, concat, etc.).",
          "codeJs": "export default function curry(fn) {\n  const curried = (...args) => {\n    if (args.length >= fn.length) return fn(...args);\n    return (...next) => curried(...args.concat(next));\n  };\n  return curried;\n}\n",
          "codeTs": "export default function curry(fn: Function): Function {\n  const curried = (...args: any[]): any => {\n    if (args.length >= fn.length) return fn(...args);\n    return (...next: any[]) => curried(...args.concat(next));\n  };\n  return curried;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "`fn.length` ignores default/rest parameters; advanced typings for perfect TS inference are omitted for clarity.",
          "These simple versions don’t preserve the original `this` binding (they call `fn(...args)`); they’re intended for plain functions rather than methods."
        ],
        "edgeCases": [
          "Unary functions return immediately once called.",
          "Extra arguments beyond `fn.length` are still forwarded to `fn`.",
          "Functions with `length === 0` will be invoked on the first call, even if you pass no arguments."
        ],
        "techniques": [
          "Closures to capture partial arguments.",
          "Arity inspection via `fn.length`.",
          "Building higher-order functions that return other functions."
        ]
      },
      "followUpQuestions": [
        "js-compose",
        "js-memoize-function"
      ],
      "resources": [
        {
          "title": "MDN – Function.length",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length"
        },
        {
          "title": "MDN – Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        }
      ]
    },
    "tests": "import curry from './curry';\n\ndescribe('curry', () => {\n  test('curries a multi-argument function', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1)(2)(3)).toBe(6);\n  });\n\n  test('supports partial application', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    const add5 = curriedAdd(2)(3);\n    expect(add5(10)).toBe(15);\n  });\n\n  test('accepts mixed grouping of arguments', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1, 2)(3)).toBe(6);\n    expect(curriedAdd(1)(2, 3)).toBe(6);\n  });\n\n  test('works for 2-argument functions', () => {\n    const multiply = (a, b) => a * b;\n    const curried = curry(multiply);\n    expect(curried(4)(5)).toBe(20);\n    expect(curried(4, 5)).toBe(20);\n  });\n\n  test('handles single-argument functions', () => {\n    const square = x => x * x;\n    const curriedSquare = curry(square);\n    expect(curriedSquare(5)).toBe(25);\n  });\n});\n",
    "testsTs": "import curry from './curry';\n\ndescribe('curry (TypeScript)', () => {\n  it('curries a three-argument function', () => {\n    const add = (a: number, b: number, c: number) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1)(2)(3)).toBe(6);\n  });\n\n  it('supports partial application', () => {\n    const add = (a: number, b: number, c: number) => a + b + c;\n    const curriedAdd = curry(add);\n    const add5 = curriedAdd(2)(3);\n    expect(add5(10)).toBe(15);\n  });\n\n  it('works with binary functions and mixed grouping', () => {\n    const multiply = (a: number, b: number) => a * b;\n    const curriedMultiply = curry(multiply);\n    expect(curriedMultiply(4)(5)).toBe(20);\n    expect(curriedMultiply(4, 5)).toBe(20);\n  });\n\n  it('handles unary functions', () => {\n    const negate = (x: number) => -x;\n    const curriedNegate = curry(negate);\n    expect(curriedNegate(3)).toBe(-3);\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-memoize-function",
    "title": "Memoization",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "importance": 5,
    "difficulty": "intermediate",
    "tags": [
      "caching",
      "functions",
      "optimization",
      "performance"
    ],
    "description": {
      "summary": "Implement a function `memoize(fn)` that caches results of previous function calls based on their input arguments to avoid recomputation.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "A pure function whose results can be safely cached based on input arguments."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A new function that returns cached results for previously computed arguments."
      },
      "examples": [
        "// Basic example\nconst slowAdd = (a, b) => { for (let i=0;i<1e6;i++); return a + b; };\nconst memoizedAdd = memoize(slowAdd);\nconsole.time('first'); memoizedAdd(3,4); console.timeEnd('first');\nconsole.time('second'); memoizedAdd(3,4); console.timeEnd('second'); // much faster",
        "// Works with multiple arguments\nconst multiply = (a, b, c) => a * b * c;\nconst fastMultiply = memoize(multiply);\nfastMultiply(2,3,4) // computed\nfastMultiply(2,3,4) // cached",
        "// Handles different input sets separately\nmemoizedAdd(5,5) // => 10 (new computation)"
      ]
    },
    "starterCode": "export default function memoize(fn) {\n  // TODO: Cache function results by input arguments\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  // TODO: Cache function results by input arguments\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: cache previous function call results keyed by their input arguments so repeated calls with the same inputs can reuse the previous result — ideal for expensive or recursive functions.",
      "approaches": [
        {
          "title": "Approach 1: Using Map with JSON key (simple & effective)",
          "prose": "Idea: store previous results in a `Map`, where the key is a serialized version of the arguments.\n\nHow it works\n1. Create a `Map` to store results.\n2. Convert arguments to a cache key using `JSON.stringify`.\n3. If the key exists, return the cached value.\n4. Otherwise compute, store, and return the result.\n\nWhy use it: straightforward and effective for primitive and serializable arguments; different argument tuples (e.g. `(2, 3)` vs `(3, 2)`) get different cache entries.",
          "codeJs": "export default function memoize(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n",
          "codeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  const cache = new Map<string, ReturnType<F>>();\n  const memoized = (...args: Parameters<F>): ReturnType<F> => {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key)!;\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n  return memoized as F;\n}\n"
        },
        {
          "title": "Approach 2: Nested Map (advanced for deep argument types)",
          "prose": "Idea: instead of serializing arguments, use nested `Map`s — one per argument — to handle non-serializable inputs safely.\n\nHow it works\n1. Start with an empty root `Map`.\n2. For each argument, go one level deeper — each key in the chain is the argument value itself.\n3. On the final map node, store the computed result under a sentinel key (like `'result'`).\n\nWhy use it: avoids `JSON.stringify` limitations and keys by reference identity, which is useful for object or reference-based arguments.",
          "codeJs": "export default function memoize(fn) {\n  const root = new Map();\n  return function memoized(...args) {\n    let map = root;\n    for (const arg of args) {\n      if (!map.has(arg)) map.set(arg, new Map());\n      map = map.get(arg);\n    }\n    if (map.has('result')) return map.get('result');\n    const result = fn(...args);\n    map.set('result', result);\n    return result;\n  };\n}\n",
          "codeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  const root = new Map<any, any>();\n  const memoized = (...args: Parameters<F>): ReturnType<F> => {\n    let map = root;\n    for (const arg of args) {\n      if (!map.has(arg)) map.set(arg, new Map());\n      map = map.get(arg);\n    }\n    if (map.has('result')) return map.get('result');\n    const result = fn(...args);\n    map.set('result', result);\n    return result;\n  };\n  return memoized as F;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "JSON.stringify cannot handle functions, symbols, or circular structures and may behave unexpectedly for certain complex objects.",
          "Objects with the same JSON representation will share a cache entry in the JSON-based approach; if you care about reference identity, use the nested Map version.",
          "These simple versions call `fn(...args)` and do not preserve `this` for methods; memoize plain functions or bind the method first if needed."
        ],
        "edgeCases": [
          "Functions with no arguments still work — the same cache entry is reused because the argument list is always empty.",
          "Different argument order yields distinct cache entries.",
          "Arguments that are `NaN`, `Infinity`, or objects are cached according to how they are stringified (Approach 1) or by reference identity (Approach 2)."
        ],
        "techniques": [
          "Closure retains cache between invocations.",
          "Using `Map` prevents accidental key collisions from the prototype chain.",
          "Keying by serialized argument lists (JSON) vs. keying by reference identity (nested Maps)."
        ]
      },
      "followUpQuestions": [
        "js-throttle",
        "js-debounce"
      ],
      "resources": [
        {
          "title": "MDN – Map",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
        },
        {
          "title": "MDN – Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        }
      ]
    },
    "tests": "import memoize from './memoize';\n\ndescribe('memoize', () => {\n  test('caches results for repeated calls', () => {\n    let calls = 0;\n    const add = (a, b) => { calls++; return a + b; };\n    const memoAdd = memoize(add);\n    expect(memoAdd(1, 2)).toBe(3);\n    expect(memoAdd(1, 2)).toBe(3);\n    expect(calls).toBe(1);\n  });\n\n  test('handles different arguments separately', () => {\n    let calls = 0;\n    const multiply = (a, b) => { calls++; return a * b; };\n    const memoMult = memoize(multiply);\n    memoMult(2, 3);\n    memoMult(3, 4);\n    expect(calls).toBe(2);\n  });\n\n  test('works with multiple argument calls', () => {\n    const join = (...args) => args.join('-');\n    const memoJoin = memoize(join);\n    expect(memoJoin('a', 'b', 'c')).toBe('a-b-c');\n    expect(memoJoin('a', 'b', 'c')).toBe('a-b-c');\n  });\n});\n",
    "testsTs": "import memoize from './memoize';\n\ndescribe('memoize (TypeScript)', () => {\n  it('caches computed results', () => {\n    let count = 0;\n    const add = (a: number, b: number) => { count++; return a + b; };\n    const memoAdd = memoize(add);\n    expect(memoAdd(3, 4)).toBe(7);\n    expect(memoAdd(3, 4)).toBe(7);\n    expect(count).toBe(1);\n  });\n\n  it('treats unique argument sets separately', () => {\n    let count = 0;\n    const diff = (a: number, b: number) => { count++; return a - b; };\n    const memoDiff = memoize(diff);\n    memoDiff(10, 5);\n    memoDiff(8, 3);\n    expect(count).toBe(2);\n  });\n\n  it('works for multi-arg functions', () => {\n    const concat = (...args: string[]) => args.join('_');\n    const memoConcat = memoize(concat);\n    expect(memoConcat('a', 'b', 'c')).toBe('a_b_c');\n    expect(memoConcat('a', 'b', 'c')).toBe('a_b_c');\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-compose",
    "title": "Compose Function",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "composition",
      "functions",
      "higher-order",
      "utilities"
    ],
    "description": {
      "summary": "Implement `compose(...fns)` that returns a new function applying the provided functions from **right to left**. The rightmost function may accept multiple arguments; every other function is unary and receives the previous result. If no functions are provided, return an identity function `(x) => x`.",
      "arguments": [
        {
          "name": "fns",
          "type": "Function[]",
          "desc": "Functions to compose. The rightmost function can be variadic; the rest are unary."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A composed function that runs all provided functions in right-to-left order."
      },
      "examples": [
        "// Basic example",
        "const add1 = n => n + 1;",
        "const double = n => n * 2;",
        "const subtract10 = n => n - 10;",
        "const composedFn = compose(subtract10, double, add1);",
        "composedFn(3); // => -2",
        "",
        "// Identity function",
        "compose()(5); // => 5",
        "",
        "// Rightmost function with multiple arguments",
        "const add = (a, b) => a + b;",
        "const double2 = n => n * 2;",
        "const fn = compose(double2, add);",
        "fn(2, 3); // => 10",
        "",
        "// Pipeline can change types",
        "const toStr = n => String(n);",
        "const wrap = s => `#${s}`;",
        "const fn2 = compose(wrap, toStr, add);",
        "fn2(2, 3); // => \"#5\""
      ]
    },
    "starterCode": "export default function compose(...fns) {\n  // TODO: Implement function composition (right-to-left)\n  // Rightmost function may take multiple arguments; the rest should be unary.\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function compose(...fns: Function[]): Function {\n  // TODO: Implement function composition (right-to-left)\n  // Rightmost function may take multiple arguments; the rest should be unary.\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: build a composed function that runs several functions from right to left. The rightmost function can take multiple arguments; its return value is passed through the remaining functions one by one as a single argument. If no functions are given, return an identity function `(x) => x`.",
      "approaches": [
        {
          "title": "Approach 1: Explicit loop (clear + variadic rightmost)",
          "prose": "Idea: treat composition as a right-to-left chain.\n\nHow it works:\n1) If `fns.length === 0`, return identity.\n2) Call the rightmost function with all incoming args.\n3) Feed the result into each remaining function moving left.\n\nWhy use it: explicit, debuggable, and correctly supports a multi-argument rightmost function.",
          "codeJs": "export default function compose(...fns) {\n  if (fns.length === 0) return x => x;\n\n  return function (...args) {\n    let i = fns.length - 1;\n    let result = fns[i](...args);\n\n    for (i = i - 1; i >= 0; i--) {\n      result = fns[i](result);\n    }\n\n    return result;\n  };\n}\n",
          "codeTs": "export default function compose(...fns: Function[]): Function {\n  if (fns.length === 0) {\n    return (x: any) => x;\n  }\n\n  return function (...args: any[]): any {\n    let i = fns.length - 1;\n    let result = (fns[i] as any)(...args);\n\n    for (i = i - 1; i >= 0; i--) {\n      result = (fns[i] as any)(result);\n    }\n\n    return result;\n  };\n}\n"
        },
        {
          "title": "Approach 2: reduceRight (concise + functional)",
          "prose": "Idea: `reduceRight` naturally models right-to-left application.\n\nKey detail: only the rightmost function can be variadic. We handle that by calling it first with `...args`, then reduceRight over the remaining functions (unary).\n\nWhy use it: shorter implementation, still interview-grade if you keep the variadic-rightmost rule correct.",
          "codeJs": "export default function compose(...fns) {\n  if (fns.length === 0) return x => x;\n\n  return function (...args) {\n    const lastIndex = fns.length - 1;\n    const initial = fns[lastIndex](...args);\n\n    return fns\n      .slice(0, lastIndex)\n      .reduceRight((acc, fn) => fn(acc), initial);\n  };\n}\n",
          "codeTs": "export default function compose(...fns: Function[]): Function {\n  if (fns.length === 0) {\n    return (x: any) => x;\n  }\n\n  return function (...args: any[]): any {\n    const lastIndex = fns.length - 1;\n    const initial = (fns[lastIndex] as any)(...args);\n\n    return fns\n      .slice(0, lastIndex)\n      .reduceRight((acc: any, fn: any) => fn(acc), initial);\n  };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Only the rightmost function can take multiple arguments. All other functions are treated as unary and receive a single value.",
          "If you pass no functions at all, you must still return a callable function (the identity), not `undefined`.",
          "Composition is not type-safe in plain JS: if a function returns an unexpected type, the next function will receive it as-is."
        ],
        "edgeCases": [
          "No functions → `compose()` returns identity, so `compose()(value)` returns `value` unchanged.",
          "Single function → `compose(fn)` returns a wrapper that forwards its arguments to `fn`.",
          "Each composed call runs O(n) functions; each function is called exactly once."
        ],
        "techniques": [
          "Rest parameters (`...fns`, `...args`).",
          "Right-to-left iteration (manual loop) vs `reduceRight`.",
          "Identity function as the neutral element for composition."
        ]
      },
      "followUpQuestions": [
        "js-pipe",
        "js-curry"
      ],
      "resources": [
        {
          "title": "MDN – Rest parameters",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"
        },
        {
          "title": "MDN – Array.prototype.reduceRight()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight"
        }
      ]
    },
    "tests": "import compose from './compose';\n\ndescribe('compose', () => {\n  const add1 = n => n + 1;\n  const double = n => n * 2;\n  const subtract10 = n => n - 10;\n\n  test('applies functions right-to-left', () => {\n    const fn = compose(subtract10, double, add1);\n    expect(fn(3)).toBe(-2);\n  });\n\n  test('works with single function', () => {\n    const fn = compose(add1);\n    expect(fn(4)).toBe(5);\n  });\n\n  test('returns identity when empty', () => {\n    const fn = compose();\n    expect(fn(5)).toBe(5);\n  });\n\n  test('allows rightmost function to take multiple arguments', () => {\n    const add = (a, b) => a + b;\n    const double2 = n => n * 2;\n    const fn = compose(double2, add);\n    expect(fn(2, 3)).toBe(10);\n  });\n\n  test('supports type transformation in the middle of the pipeline', () => {\n    const add = (a, b) => a + b; // number\n    const toStr = n => String(n); // number -> string\n    const wrap = s => `#${s}`; // string -> string\n\n    const fn = compose(wrap, toStr, add);\n    expect(fn(2, 3)).toBe('#5');\n  });\n});\n",
    "testsTs": "import compose from './compose';\n\ndescribe('compose (TypeScript)', () => {\n  const add1 = (n: number) => n + 1;\n  const double = (n: number) => n * 2;\n  const subtract10 = (n: number) => n - 10;\n\n  it('applies functions right-to-left', () => {\n    const fn = compose(subtract10, double, add1);\n    expect(fn(3)).toBe(-2);\n  });\n\n  it('works with single function', () => {\n    const fn = compose(add1);\n    expect(fn(4)).toBe(5);\n  });\n\n  it('returns identity when empty', () => {\n    const fn = compose();\n    expect(fn(10)).toBe(10);\n  });\n\n  it('allows rightmost function to take multiple arguments', () => {\n    const add = (a: number, b: number) => a + b;\n    const double2 = (n: number) => n * 2;\n    const fn = compose(double2, add);\n    expect(fn(2, 3)).toBe(10);\n  });\n\n  it('supports type transformation in the middle of the pipeline', () => {\n    const add = (a: number, b: number) => a + b; // number\n    const toStr = (n: number) => String(n); // number -> string\n    const wrap = (s: string) => `#${s}`; // string -> string\n\n    const fn = compose(wrap, toStr, add);\n    expect(fn(2, 3)).toBe('#5');\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-group-by",
    "title": "Group By",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "arrays",
      "grouping",
      "objects",
      "reduction"
    ],
    "description": {
      "summary": "Implement a function `groupBy(arr, keyFn)` that groups array elements based on the result of applying a key function to each element.",
      "arguments": [
        {
          "name": "arr",
          "type": "T[]",
          "desc": "The array of elements to group."
        },
        {
          "name": "keyFn",
          "type": "(item: T) => K",
          "desc": "A function that returns a key to group each element under."
        }
      ],
      "returns": {
        "type": "Record<K, T[]>",
        "desc": "An object whose keys are the computed group keys, and values are arrays of elements belonging to each group."
      },
      "examples": [
        "// Basic examples",
        "groupBy([6.1, 4.2, 6.3], Math.floor) // => { '4': [4.2], '6': [6.1, 6.3] }",
        "groupBy(['one', 'two', 'three'], str => str.length) // => { '3': ['one', 'two'], '5': ['three'] }",
        "groupBy([{type:'a'}, {type:'b'}, {type:'a'}], x => x.type) // => { a: [{type:'a'}, {type:'a'}], b: [{type:'b'}] }"
      ]
    },
    "starterCode": "export default function groupBy(arr, keyFn) {\n  // TODO: Group array elements by keyFn(item)\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  // TODO: Group array elements by keyFn(item)\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: convert a flat list into an object keyed by `keyFn(item)`, where each key stores an array of matching items. All approaches run in O(n) time and O(n) additional space.",
      "approaches": [
        {
          "title": "Approach 1: Simple loop (clear baseline)",
          "prose": "Idea: iterate once over the array, compute a key for each item, initialize the bucket if it does not exist yet, and push the item into that bucket.\n\nHow it works – step by step:\n1. Create an empty object `result = {}`.\n2. Loop over each `item` in `arr` using a `for...of` loop.\n3. For each item, compute `const key = keyFn(item)`.\n4. Check whether `result` already has this key as its own property. If not, initialize it with an empty array: `result[key] = []`.\n5. Push the current `item` into `result[key]`.\n6. After the loop finishes, return `result`.\n\nThis gives you a single pass, easy-to-read implementation that makes the grouping logic very explicit.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  const result = {};\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = [];\n    }\n    result[key].push(item);\n  }\n  return result;\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  const result = {} as Record<K, T[]>;\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = [] as T[];\n    }\n    result[key].push(item);\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Array.reduce (concise)",
          "prose": "Idea: fold the array into an accumulator object with `reduce`, creating buckets lazily as you go.\n\nHow it works – step by step:\n1. Call `arr.reduce` with an initial accumulator of `{}`.\n2. For each `item` in the array, compute `const key = keyFn(item)`.\n3. Check whether `acc[key]` exists. If not, initialize it as an empty array (`acc[key] ||= []`).\n4. Push the current `item` into `acc[key]`.\n5. Return the accumulator from the reducer callback so it flows into the next iteration.\n6. After `reduce` completes, the final accumulator is the grouped object; return it.\n\nThis gives a shorter, functional-style implementation while keeping the same behavior as the simple loop.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  return arr.reduce((acc, item) => {\n    const key = keyFn(item);\n    (acc[key] ||= []).push(item);\n    return acc;\n  }, {});\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  return arr.reduce((acc, item) => {\n    const key = keyFn(item);\n    (acc[key] ||= [] as T[]).push(item);\n    return acc;\n  }, {} as Record<K, T[]>);\n}\n"
        },
        {
          "title": "Approach 3: Map-based grouping (avoids prototype issues, then to object)",
          "prose": "Idea: accumulate groups in a `Map` to avoid prototype collisions and allow any key type inside the map, then convert the result to a plain object for the final return value.\n\nHow it works – step by step:\n1. Create a root `const map = new Map()`.\n2. Loop over each `item` in `arr`.\n3. For each `item`, compute `const key = keyFn(item)`.\n4. If `map` does not have this key yet, create a new bucket: `map.set(key, [])`.\n5. Retrieve the bucket with `map.get(key)` and push the `item` into it.\n6. After processing all items, convert `map.entries()` to a plain object using `Object.fromEntries`, stringifying keys as needed: `Object.fromEntries([...map.entries()].map(([k, v]) => [String(k), v]))`.\n7. Return the resulting object.\n\nNote: the returned object’s keys are still strings (because object keys are string/symbol), so non-string keys will be stringified (for example, `undefined` becomes `'undefined'`). The `Map` stage mainly avoids prototype pollution and makes the grouping logic explicit.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  const map = new Map();\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!map.has(key)) map.set(key, []);\n    map.get(key).push(item);\n  }\n  // Convert to plain object with string keys\n  return Object.fromEntries(Array.from(map.entries(), ([k, v]) => [String(k), v]));\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  const map = new Map<K, T[]>();\n  for (const item of arr) {\n    const key = keyFn(item);\n    const bucket = map.get(key);\n    if (bucket) bucket.push(item); else map.set(key, [item]);\n  }\n  const out = {} as Record<K, T[]>;\n  for (const [k, v] of map.entries()) out[k] = v;\n  return out;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Plain object keys are strings/symbols — non-string keys will be stringified.",
          "Ensure `keyFn` is deterministic (same input → same key)."
        ],
        "edgeCases": [
          "Empty array → `{}`.",
          "Many items mapping to the same key → all coalesce into one bucket.",
          "`undefined` or `null` keys are valid but will become the string 'undefined'/'null' when used as object keys."
        ],
        "techniques": [
          "Reduction/folding patterns.",
          "Bucket initialization with nullish coalescing or `||=`.",
          "Using `Map` to avoid prototype collisions, then converting to an object."
        ]
      },
      "followUpQuestions": [
        "js-sum-numbers",
        "js-unique-array"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        },
        {
          "title": "MDN – Map",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
        }
      ]
    },
    "tests": "import groupBy from './groupBy';\n\ndescribe('groupBy', () => {\n  test('groups numbers by Math.floor', () => {\n    const result = groupBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: [4.2], 6: [6.1, 6.3] });\n  });\n\n  test('groups strings by length', () => {\n    const result = groupBy(['one', 'two', 'three'], str => str.length);\n    expect(result).toEqual({ 3: ['one', 'two'], 5: ['three'] });\n  });\n\n  test('groups objects by property', () => {\n    const data = [{ type: 'a' }, { type: 'b' }, { type: 'a' }];\n    const result = groupBy(data, x => x.type);\n    expect(result).toEqual({ a: [{ type: 'a' }, { type: 'a' }], b: [{ type: 'b' }] });\n  });\n\n  test('returns empty object for empty array', () => {\n    expect(groupBy([], Math.floor)).toEqual({});\n  });\n});\n",
    "testsTs": "import groupBy from './groupBy';\n\ndescribe('groupBy (TypeScript)', () => {\n  it('groups numbers by Math.floor', () => {\n    const result = groupBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: [4.2], 6: [6.1, 6.3] });\n  });\n\n  it('groups strings by length', () => {\n    const result = groupBy(['one', 'two', 'three'], str => str.length);\n    expect(result).toEqual({ 3: ['one', 'two'], 5: ['three'] });\n  });\n\n  it('groups objects by property', () => {\n    const data = [{ type: 'a' }, { type: 'b' }, { type: 'a' }];\n    const result = groupBy(data, x => x.type);\n    expect(result).toEqual({ a: [{ type: 'a' }, { type: 'a' }], b: [{ type: 'b' }] });\n  });\n\n  it('returns empty object for empty array', () => {\n    expect(groupBy([], Math.floor)).toEqual({});\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-event-emitter-mini",
    "title": "Event Emitter (Mini Implementation)",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "async",
      "design-patterns",
      "oop"
    ],
    "description": {
      "summary": "Implement a simple `Emitter` class that allows subscribing to events with `.on()`, unsubscribing with `.off()`, and triggering events with `.emit()`.",
      "arguments": [],
      "returns": {
        "type": "Emitter",
        "desc": "An instance that supports registering, removing, and invoking event listeners."
      },
      "examples": [
        "// Basic example\nconst emitter = new Emitter()\nconst greet = name => console.log(`Hello, ${name}!`)\nemitter.on('greet', greet)\nemitter.emit('greet', 'Alice') // => Hello, Alice!\n\n// Remove listener\nemitter.off('greet', greet)\nemitter.emit('greet', 'Bob') // => (nothing happens)"
      ]
    },
    "starterCode": "export default class Emitter {\n  constructor() {\n    // TODO: Initialize event storage, e.g. this.events = {}\n  }\n\n  on(event, listener) {\n    // TODO: Add listener to event\n  }\n\n  off(event, listener) {\n    // TODO: Remove listener from event\n  }\n\n  emit(event, ...args) {\n    // TODO: Call all listeners for event\n  }\n}\n",
    "starterCodeTs": "export default class Emitter {\n  private events: Record<string, Array<(...args: any[]) => void>>\n\n  constructor() {\n    // TODO: Initialize event storage\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    // TODO: Add listener to event\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    // TODO: Remove listener from event\n  }\n\n  emit(event: string, ...args: any[]): void {\n    // TODO: Call all listeners for event\n  }\n}\n",
    "solutionBlock": {
      "overview": "Goal: implement a simple publish/subscribe system that allows components to communicate through events without tight coupling. The emitter is synchronous: when you call `emit`, all listeners run immediately in registration order (even if those listeners themselves return promises).",
      "approaches": [
        {
          "title": "Approach 1: Object-based event registry (baseline)",
          "prose": "Idea: store listeners in a plain object where each key is an event name and the value is an array of listener functions.\n\nHow it works – step by step:\n1. In the constructor, initialize `this.events = {}` to hold event → listeners mapping.\n2. In `.on(event, listener)`, check if `this.events[event]` exists; if not, set it to an empty array, then `push` the `listener` into that array.\n3. In `.off(event, listener)`, read the listener list for that event. If there is no list, return early. Otherwise, replace it with a filtered copy that removes the exact `listener` reference (`l !== listener`).\n4. In `.emit(event, ...args)`, read the listener list for that event. If no listeners, return. Otherwise, clone the list with `.slice()` and iterate over the clone, calling each listener with `l(...args)` so all listeners receive the same arguments.\n5. Cloning before iteration avoids issues if a listener calls `.off` on itself or others while `emit` is still iterating.\n\nWhy use it: very readable, easy to implement in an interview, and closely mirrors the behavior of a minimal Node.js-style EventEmitter.",
          "codeJs": "export default class Emitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, listener) {\n    if (!this.events[event]) this.events[event] = [];\n    this.events[event].push(listener);\n  }\n\n  off(event, listener) {\n    const list = this.events[event];\n    if (!list) return;\n    this.events[event] = list.filter(l => l !== listener);\n  }\n\n  emit(event, ...args) {\n    const list = this.events[event];\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n",
          "codeTs": "export default class Emitter {\n  private events: Record<string, Array<(...args: any[]) => void>>;\n\n  constructor() {\n    this.events = {};\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    if (!this.events[event]) this.events[event] = [];\n    this.events[event].push(listener);\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    const list = this.events[event];\n    if (!list) return;\n    this.events[event] = list.filter(l => l !== listener);\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const list = this.events[event];\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n"
        },
        {
          "title": "Approach 2: Map-based storage (cleaner key isolation)",
          "prose": "Idea: use a `Map` instead of a plain object so you don’t inherit prototype keys and you keep the event registry separate from the instance’s other properties.\n\nHow it works – step by step:\n1. In the constructor, initialize `this.events = new Map()`; each key will be an event name and each value an array of listeners.\n2. In `.on(event, listener)`, check `this.events.has(event)`. If it’s missing, insert a new empty array for that key, then push the `listener` into the array for that event.\n3. In `.off(event, listener)`, read the current listener array via `this.events.get(event)`. If there is no entry, return early. Otherwise, create a new array by filtering out the `listener` and store it back with `this.events.set(event, filteredList)`.\n4. In `.emit(event, ...args)`, get the listeners array with `this.events.get(event)`. If none or empty, return. If present, clone it with `.slice()` and loop through the clone, calling each listener with the provided arguments: `l(...args)`.\n5. As with the object-based version, cloning the listeners array before iterating avoids bugs when listeners deregister themselves during emission.\n\nWhy use it: avoids prototype collisions (`toString`, `constructor`, etc.), keeps the registry nicely encapsulated, and is a clean, idiomatic use of `Map` for key → listeners collections.",
          "codeJs": "export default class Emitter {\n  constructor() {\n    this.events = new Map();\n  }\n\n  on(event, listener) {\n    if (!this.events.has(event)) this.events.set(event, []);\n    this.events.get(event).push(listener);\n  }\n\n  off(event, listener) {\n    const list = this.events.get(event);\n    if (!list) return;\n    this.events.set(event, list.filter(l => l !== listener));\n  }\n\n  emit(event, ...args) {\n    const list = this.events.get(event);\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n",
          "codeTs": "export default class Emitter {\n  private events: Map<string, Array<(...args: any[]) => void>>;\n\n  constructor() {\n    this.events = new Map();\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    if (!this.events.has(event)) this.events.set(event, []);\n    this.events.get(event)!.push(listener);\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    const list = this.events.get(event);\n    if (!list) return;\n    this.events.set(event, list.filter(l => l !== listener));\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const list = this.events.get(event);\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Removing a listener that doesn’t exist should do nothing (no error).",
          "Mutating a listener array while emitting may skip calls — cloning with `slice()` before iteration avoids this.",
          "Emitting is synchronous; if listeners are slow or throw errors, they will affect the caller unless you handle that explicitly."
        ],
        "edgeCases": [
          "Emitting an event that has no listeners → should be a no-op (no error).",
          "Removing all listeners for an event leaves an empty array or an empty `Map` entry.",
          "Multiple listeners on the same event should all be called in registration order."
        ],
        "techniques": [
          "Encapsulating internal state in a class field (`events`).",
          "Cloning arrays before iteration to avoid concurrent modification bugs.",
          "Using `Map` versus plain objects depending on how strict you want key isolation to be."
        ]
      },
      "followUpQuestions": [
        "js-throttle"
      ],
      "resources": [
        {
          "title": "Node.js EventEmitter Docs",
          "url": "https://nodejs.org/api/events.html"
        },
        {
          "title": "MDN – Observer Pattern",
          "url": "https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Code_snippets/Custom_events"
        }
      ]
    },
    "tests": "import Emitter from './Emitter';\n\nconst makeSpy = () => {\n  const fn = (...args) => { fn.calls.push(args); };\n  fn.calls = [];\n  return fn;\n};\n\ndescribe('Emitter', () => {\n  test('calls listener when event is emitted', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 'data');\n    expect(spy.calls.length).toBe(1);\n    expect(spy.calls[0]).toEqual(['data']);\n  });\n\n  test('removes listener correctly', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 1);\n    expect(spy.calls.length).toBe(1);\n    emitter.off('ping', spy);\n    emitter.emit('ping', 2);\n    expect(spy.calls.length).toBe(1);\n  });\n\n  test('handles multiple listeners for same event', () => {\n    const emitter = new Emitter();\n    const a = makeSpy();\n    const b = makeSpy();\n    emitter.on('ping', a);\n    emitter.on('ping', b);\n    emitter.emit('ping', 42);\n    expect(a.calls[0]).toEqual([42]);\n    expect(b.calls[0]).toEqual([42]);\n  });\n});\n",
    "testsTs": "import Emitter from './Emitter';\n\ntype Spy = ((...args: any[]) => void) & { calls: any[][] };\nconst makeSpy = (): Spy => {\n  const fn: any = (...args: any[]) => { fn.calls.push(args); };\n  fn.calls = [] as any[][];\n  return fn as Spy;\n};\n\ndescribe('Emitter (TypeScript)', () => {\n  it('calls listener when event is emitted', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 'data');\n    expect(spy.calls.length).toBe(1);\n    expect(spy.calls[0]).toEqual(['data']);\n  });\n\n  it('removes listener correctly', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 1);\n    expect(spy.calls.length).toBe(1);\n    emitter.off('ping', spy);\n    emitter.emit('ping', 2);\n    expect(spy.calls.length).toBe(1);\n  });\n\n  it('handles multiple listeners for same event', () => {\n    const emitter = new Emitter();\n    const a = makeSpy();\n    const b = makeSpy();\n    emitter.on('ping', a);\n    emitter.on('ping', b);\n    emitter.emit('ping', 42);\n    expect(a.calls[0]).toEqual([42]);\n    expect(b.calls[0]).toEqual([42]);\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-concurrency-map-limit",
    "title": "Concurrency-Limited Map (order-preserving)",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "async",
      "concurrency",
      "promise",
      "control-flow"
    ],
    "teaches": [
      "Concurrency control with a worker pool",
      "Backpressure (don’t start new work until a slot frees)",
      "Order-preserving aggregation",
      "Configurable error handling: fail-fast vs all-settled"
    ],
    "description": {
      "summary": "Implement `mapAsyncLimit(items, limit, worker, strategy?)` that runs at most `limit` jobs concurrently, returns results in input order, and supports error strategies `'fail-fast'` or `'all-settled'`.",
      "arguments": [
        {
          "name": "items",
          "type": "T[]",
          "desc": "Inputs to process."
        },
        {
          "name": "limit",
          "type": "number",
          "desc": "Max number of concurrent worker calls. Must be ≥ 1."
        },
        {
          "name": "worker",
          "type": "(item: T, index: number) => Promise<R>",
          "desc": "Async mapper."
        },
        {
          "name": "strategy",
          "type": "'fail-fast' | 'all-settled'",
          "desc": "Optional error handling strategy (default `'fail-fast'`). On error: either reject immediately (`'fail-fast'`) or collect all outcomes (`'all-settled'`)."
        }
      ],
      "returns": {
        "type": "Promise<R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>>",
        "desc": "If `'fail-fast'`, resolves to `R[]` or rejects on the first error. If `'all-settled'`, always resolves to settled outcomes in input order."
      },
      "examples": [
        "// Basic (fail-fast)\nawait mapAsyncLimit([3,1,2], 2, async (n,i) => { await sleep(n*10); return n*n })\n// => [9,1,4]\n",
        "// All-settled\nawait mapAsyncLimit([1,2,3], 2, async (n) => { if(n===2) throw new Error('boom'); return n; }, 'all-settled')\n// => [\n//   { status: 'fulfilled', value: 1 },\n//   { status: 'rejected',  reason: Error('boom') },\n//   { status: 'fulfilled', value: 3 }\n// ]"
      ]
    },
    "starterCode": "export default async function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  // TODO:\n  // 1) Validate inputs (limit >= 1)\n  // 2) Launch up to `limit` concurrent runners\n  // 3) Each runner pulls the next index and writes its result at that index\n  // 4) 'fail-fast' rejects on first error, 'all-settled' aggregates statuses\n}\n\nexport const sleep = (ms) => new Promise(r => setTimeout(r, ms));\n",
    "solutionBlock": {
      "overview": "Goal: execute async work in parallel but never exceed a maximum number of concurrent tasks, while preserving input order and supporting different error-handling strategies (`'fail-fast'` vs `'all-settled'`).\n\nMental model:\n- Think of a **worker pool**: you have `limit` workers pulling jobs from a queue.\n- Each worker processes one item at a time and writes its result at the same index.\n- For `'fail-fast'`, as soon as any worker throws, the whole operation rejects.\n- For `'all-settled'`, every job produces a `{ status, value|reason }` entry, and the outer promise always resolves.",
      "approaches": [
        {
          "title": "Approach 1: Worker-pool with shared index (clean & readable)",
          "prose": "Idea: maintain a shared `next` index and spawn up to `limit` workers that each pull new tasks until none remain.\n\nSolving steps:\n1. Validate input: throw if `limit < 1` or `limit` is not finite.\n2. Preallocate results: create `results = new Array(items.length)` to preserve order and output indexing.\n3. Initialize shared state: `next` (index of the next item to assign), `done` (how many items have finished, fulfilled or rejected), `failed` (whether we've seen an error in 'fail-fast' mode), and `allSettled = strategy === 'all-settled'`.\n4. Define `runner`: inside a `while (true)` loop, grab `i = next++`. If `i >= n` or (`failed` and not `allSettled`), break. Call `await worker(items[i], i)`. On success, write either `v` or `{ status: 'fulfilled', value: v }` to `results[i]` depending on `strategy`. On error, if `allSettled` store `{ status: 'rejected', reason: err }` and continue; otherwise set `failed = true`, call `reject(err)`, and `return`. In `finally`, increment `done` and if `done === n` and (`!failed` or `allSettled`), resolve with `results`.\n5. Spawn the pool: compute `k = Math.min(limit, n)` and call `runner()` `k` times so the workers drain all remaining items.\n\nWhy use it: explicit and predictable concurrency control, clear error semantics, and stable result ordering.",
          "codeJs": "export default function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  if (!Number.isFinite(limit) || limit < 1) throw new Error('limit must be >= 1');\n  const n = items.length;\n  const allSettled = strategy === 'all-settled';\n  const results = new Array(n);\n  if (n === 0) return Promise.resolve(results);\n\n  let next = 0;\n  let done = 0;\n  let failed = false;\n\n  return new Promise((resolve, reject) => {\n    const runner = async () => {\n      while (true) {\n        const i = next++;\n        if (i >= n || (failed && !allSettled)) break;\n        try {\n          const v = await worker(items[i], i);\n          results[i] = allSettled\n            ? { status: 'fulfilled', value: v }\n            : v;\n        } catch (err) {\n          if (allSettled) {\n            results[i] = { status: 'rejected', reason: err };\n          } else {\n            failed = true;\n            reject(err);\n            return;\n          }\n        } finally {\n          if (++done === n && (!failed || allSettled)) {\n            resolve(results);\n          }\n        }\n      }\n    };\n\n    const k = Math.min(limit, n);\n    for (let j = 0; j < k; j++) {\n      runner();\n    }\n  });\n}\n",
          "codeTs": "export default function mapAsyncLimit<T, R>(\n  items: T[],\n  limit: number,\n  worker: (item: T, index: number) => Promise<R>,\n  strategy: 'fail-fast' | 'all-settled' = 'fail-fast'\n): Promise<R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>> {\n  if (!Number.isFinite(limit) || limit < 1) throw new Error('limit must be >= 1');\n\n  const n = items.length;\n  const allSettled = strategy === 'all-settled';\n  const results: any[] = new Array(n);\n  if (n === 0) return Promise.resolve(results);\n\n  let next = 0;\n  let done = 0;\n  let failed = false;\n\n  return new Promise((resolve, reject) => {\n    const runner = async () => {\n      while (true) {\n        const i = next++;\n        if (i >= n || (failed && !allSettled)) break;\n        try {\n          const v = await worker(items[i], i);\n          results[i] = allSettled\n            ? { status: 'fulfilled', value: v }\n            : v;\n        } catch (err) {\n          if (allSettled) {\n            results[i] = { status: 'rejected', reason: err };\n          } else {\n            failed = true;\n            reject(err);\n            return;\n          }\n        } finally {\n          if (++done === n && (!failed || allSettled)) {\n            resolve(results);\n          }\n        }\n      }\n    };\n\n    const k = Math.min(limit, n);\n    for (let j = 0; j < k; j++) {\n      runner();\n    }\n  });\n}\n"
        },
        {
          "title": "Approach 2: Queue-style control with recursive runners",
          "prose": "Idea: treat `items` as a queue and recursively chain `run()` so that each worker, when it finishes, immediately grabs the next item until the queue is empty.\n\nSolving steps:\n1. Validate `limit`: throw if `limit < 1` or `limit` is not finite.\n2. Preallocate `results` with length `items.length` so we can write outputs in input order.\n3. Set up shared state: `current = 0` to track the next index to hand out, and `allSettled = strategy === 'all-settled'`.\n4. Define async `run()`: read `i = current++`; if `i >= items.length`, return. Call `await worker(items[i], i)`. On success, store either the raw value (`results[i] = val`) or `{ status: 'fulfilled', value: val }` based on `strategy`. On error, if `strategy === 'fail-fast'` rethrow so the surrounding `Promise.all` rejects; if `'all-settled'`, store `{ status: 'rejected', reason: err }` in `results[i]` and continue. At the end of `run`, call `run()` again to refill this concurrency slot with the next index.\n5. Start the pool: compute `k = Math.min(limit, items.length)` and create `k` initial promises by calling `run()` and storing them in `runners`.\n6. Wait for completion: if `strategy === 'fail-fast'`, return `Promise.all(runners).then(() => results)` so the outer promise rejects on the first failure; otherwise return `Promise.allSettled(runners).then(() => results)` so all tasks finish and `results` contains settled outcomes.\n\nWhy use it: easy to reason about (\"when a worker finishes, it grabs the next job\") and makes refilling concurrency slots explicit without an inner `while` loop.",
          "codeJs": "export default function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  if (!Number.isFinite(limit) || limit < 1) throw new Error('limit must be >= 1');\n\n  const allSettled = strategy === 'all-settled';\n  const results = new Array(items.length);\n  let current = 0;\n\n  const run = async () => {\n    const i = current++;\n    if (i >= items.length) return;\n\n    try {\n      const val = await worker(items[i], i);\n      results[i] = allSettled\n        ? { status: 'fulfilled', value: val }\n        : val;\n    } catch (err) {\n      if (!allSettled) throw err;\n      results[i] = { status: 'rejected', reason: err };\n    }\n\n    return run(); // refill this slot with the next item\n  };\n\n  const k = Math.min(limit, items.length);\n  const runners = Array.from({ length: k }, () => run());\n\n  return allSettled\n    ? Promise.allSettled(runners).then(() => results)\n    : Promise.all(runners).then(() => results);\n}\n",
          "codeTs": "export default function mapAsyncLimit<T, R>(\n  items: T[],\n  limit: number,\n  worker: (item: T, index: number) => Promise<R>,\n  strategy: 'fail-fast' | 'all-settled' = 'fail-fast'\n): Promise<\n  R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>\n> {\n  if (!Number.isFinite(limit) || limit < 1) {\n    throw new Error('limit must be >= 1');\n  }\n\n  const results: any[] = new Array(items.length);\n  let current = 0;\n  const allSettled = strategy === 'all-settled';\n\n  const run = async (): Promise<void> => {\n    const i = current++;\n    if (i >= items.length) return;\n\n    try {\n      const val = await worker(items[i], i);\n      results[i] = allSettled\n        ? { status: 'fulfilled', value: val }\n        : val;\n    } catch (err) {\n      if (!allSettled) throw err;\n      results[i] = { status: 'rejected', reason: err };\n    }\n\n    return run();\n  };\n\n  const k = Math.min(limit, items.length);\n  const runners = Array.from({ length: k }, () => run());\n\n  return allSettled\n    ? Promise.allSettled(runners).then(() => results)\n    : Promise.all(runners).then(() => results);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to preserve order — storing results in completion order breaks determinism.",
          "Swallowing rejections when `'fail-fast'` should actually propagate the first error.",
          "Allowing `limit < 1` can lead to hangs or division-by-zero style bugs."
        ],
        "edgeCases": [
          "Empty input array resolves immediately.",
          "If `limit >= items.length`, all jobs run at once (like `Promise.all`)."
        ],
        "techniques": [
          "Shared index for task dispatch across workers.",
          "Pre-sized result array to preserve input order.",
          "Worker-pool pattern for explicit concurrency control.",
          "Strategy flag (`'fail-fast'` vs `'all-settled'`) to demonstrate configurable error policies."
        ]
      },
      "followUpQuestions": [
        "js-add-two-promises",
        "js-throttle"
      ],
      "resources": [
        {
          "title": "MDN – Using Promises",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises"
        },
        {
          "title": "Jake Archibald – In The Loop (Concurrency explained)",
          "url": "https://www.youtube.com/watch?v=cCOL7MC4Pl0"
        }
      ]
    },
    "tests": "import mapAsyncLimit from './mapAsyncLimit';\n\nconst sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\ndescribe('mapAsyncLimit', () => {\n  test('preserves order with mixed durations', async () => {\n    const items = [30, 10, 20];\n    const out = await mapAsyncLimit(items, 2, async (ms) => { await sleep(ms); return ms / 10; });\n    expect(out).toEqual([3, 1, 2]);\n  });\n\n  test('respects concurrency limit (no more than limit active)', async () => {\n    const items = [30, 30, 30, 30, 30];\n    let active = 0, maxActive = 0;\n    const out = await mapAsyncLimit(items, 2, async (ms) => {\n      active++; if (active > maxActive) maxActive = active;\n      await sleep(ms);\n      active--;\n      return ms;\n    });\n    expect(out).toEqual(items);\n    expect(maxActive <= 2).toEqual(true);\n  });\n\n  test('fail-fast rejects on first error', async () => {\n    const items = [5, 10, 5];\n    let threw = false;\n    try {\n      await mapAsyncLimit(items, 2, async (ms, idx) => {\n        await sleep(ms);\n        if (idx === 1) throw new Error('boom');\n        return idx;\n      }, 'fail-fast');\n    } catch (e) {\n      threw = true;\n      expect(e && e.message).toEqual('boom');\n    }\n    expect(threw).toEqual(true);\n  });\n\n  test('all-settled aggregates outcomes', async () => {\n    const res = await mapAsyncLimit([10, 5, 10, 5], 2, async (ms, idx) => {\n      await sleep(ms);\n      if (idx % 2 === 1) throw new Error('odd');\n      return idx * 10;\n    }, 'all-settled');\n\n    expect(res[0]).toEqual({ status: 'fulfilled', value: 0 });\n    expect(res[1].status).toEqual('rejected');\n    expect(res[2]).toEqual({ status: 'fulfilled', value: 20 });\n    expect(res[3].status).toEqual('rejected');\n  });\n\n  test('throws if limit < 1', () => {\n    let threw = false;\n    try { mapAsyncLimit([1], 0, async (x) => x); } catch (e) { threw = true; }\n    expect(threw).toEqual(true);\n  });\n});\n",
    "testsTs": "import mapAsyncLimit from './mapAsyncLimit';\n\nconst sleep = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\ndescribe('mapAsyncLimit (TS)', () => {\n  test('keeps output order', async () => {\n    const res = await mapAsyncLimit<number, number>([15, 5, 10], 2, async (ms) => { await sleep(ms); return ms / 5; });\n    expect(res).toEqual([3, 1, 2]);\n  });\n\n  test('caps concurrency', async () => {\n    const items = [20, 20, 20, 20];\n    let active = 0, maxActive = 0;\n    const res = await mapAsyncLimit<number, number>(items, 2, async (ms) => {\n      active++; if (active > maxActive) maxActive = active;\n      await sleep(ms);\n      active--; return ms;\n    });\n    expect(res).toEqual(items);\n    expect(maxActive <= 2).toEqual(true);\n  });\n\n  test('fail-fast rejects on first error', async () => {\n    let threw = false;\n    try {\n      await mapAsyncLimit<number, number>([5, 10, 5], 2, async (ms, idx) => {\n        await sleep(ms);\n        if (idx === 1) throw new Error('boom');\n        return idx;\n      }, 'fail-fast');\n    } catch (e: any) {\n      threw = true;\n      expect(e && e.message).toEqual('boom');\n    }\n    expect(threw).toEqual(true);\n  });\n\n  test('all-settled returns settled outcomes', async () => {\n    const res = await mapAsyncLimit<number, number>([5, 10, 5], 2, async (ms, idx) => {\n      await sleep(ms);\n      if (idx === 1) throw new Error('x');\n      return idx * 2;\n    }, 'all-settled') as Array<{ status: 'fulfilled' | 'rejected'; value?: number; reason?: any }>;\n\n    expect(res[0]).toEqual({ status: 'fulfilled', value: 0 });\n    expect(res[1].status).toEqual('rejected');\n    expect(typeof (res[1] as any).reason).toEqual('object');\n    expect(res[2]).toEqual({ status: 'fulfilled', value: 4 });\n  });\n\n  test('throws on invalid limit', () => {\n    let threw = false;\n    try { mapAsyncLimit<number, number>([1], 0, async (x) => x); } catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-abortable-helpers",
    "title": "Abortable Helpers (Timeout + Composed Abort)",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "abort-controller",
      "async",
      "cancellation",
      "promise",
      "utilities"
    ],
    "description": {
      "summary": "Provide utilities to combine timeouts with AbortController, and to compose multiple signals (abort if any fires). All helpers are exposed via a single default export function whose properties are the helpers.",
      "arguments": [
        {
          "name": "withTimeout<T>(p, ms, reason?)",
          "type": "Promise<T>, number, any",
          "desc": "Race a promise against a timeout. Reject with `reason` (or an Error) if the timeout fires; clear the timer if the promise settles first."
        },
        {
          "name": "withAbort<T>(factory, signal)",
          "type": "(signal: AbortSignal) => Promise<T>, AbortSignal",
          "desc": "Run `factory(signal)` and reject if `signal` aborts. If already aborted, reject immediately. Ensure listeners are cleaned up when done."
        },
        {
          "name": "composeAbort(...signals)",
          "type": "AbortSignal[]",
          "desc": "Return a new `AbortSignal` that aborts if ANY input signal aborts; if any is already aborted, the result aborts immediately with the same reason."
        },
        {
          "name": "sleep(ms)",
          "type": "number",
          "desc": "Utility helper that returns a promise resolved after `ms` milliseconds. Useful for tests and examples."
        }
      ],
      "returns": {
        "type": "Default export function with properties: { withTimeout, withAbort, composeAbort, sleep }",
        "desc": "Import the default and destructure its properties to use the helpers."
      },
      "examples": [
        "import helpers from './abortable-helpers';",
        "const { withTimeout, withAbort, composeAbort, sleep } = helpers;",
        "",
        "await withTimeout(fetch(url), 2000, new Error('Timeout'));",
        "const ac = new AbortController();",
        "await withAbort(doWork, ac.signal);",
        "const combined = composeAbort(ac.signal, new AbortController().signal);"
      ]
    },
    "starterCode": "function abortableHelpers() {}\n\nabortableHelpers.sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\nabortableHelpers.withTimeout = function withTimeout(p, ms, reason) {\n  // TODO: Start a timer; race with p. On settle, clear the timer. On timeout, reject with `reason` or Error('Timeout').\n};\n\nabortableHelpers.withAbort = function withAbort(factory, signal) {\n  // TODO: If signal.aborted -> reject immediately. Otherwise run factory(signal) and listen for 'abort'. Clean up listeners on settle.\n};\n\nabortableHelpers.composeAbort = function composeAbort(...signals) {\n  // TODO: New AbortController; if any input already aborted, abort immediately with its reason; otherwise forward first abort and detach listeners.\n};\n\nexport default abortableHelpers;\n",
    "starterCodeTs": "function abortableHelpers() {}\n\nabortableHelpers['sleep'] = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\nabortableHelpers['withTimeout'] = function withTimeout<T>(p: Promise<T>, ms: number, reason?: any): Promise<T> {\n  // TODO\n  return new Promise<T>((resolve, reject) => { /* impl */ });\n};\n\nabortableHelpers['withAbort'] = function withAbort<T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal): Promise<T> {\n  // TODO\n  return new Promise<T>((resolve, reject) => { /* impl */ });\n};\n\nabortableHelpers['composeAbort'] = function composeAbort(...signals: AbortSignal[]): AbortSignal {\n  // TODO\n  const ac = new AbortController();\n  return ac.signal;\n};\n\nexport default abortableHelpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n",
    "solutionBlock": {
      "overview": "Goal: enable cooperative cancellation and safe async composition using `AbortController`. Helpers simplify racing timeouts, making async functions abortable, and merging multiple signals cleanly.\n\nWe implement a single export `abortableHelpers` object with methods `withTimeout`, `withAbort`, `composeAbort`, and `sleep`.\n\n- `withTimeout(p, ms, reason)`: race a promise against a timer.\n- `withAbort(factory, signal)`: wrap async work so it can be cancelled by an `AbortSignal`.\n- `composeAbort(...signals)`: merge multiple signals into one that aborts when any source aborts.\n\nEach helper ensures proper cleanup of timers or listeners to prevent leaks and double resolution.",
      "approaches": [
        {
          "title": "Core idea and cleanup discipline",
          "prose": "We attach all helpers as properties on a single exported function `abortableHelpers`.\n\n**Solving steps – `withTimeout(p, ms, reason?)`**\n1. Create a new `Promise` that will resolve or reject based on the earlier of the inner promise or a timeout.\n2. Start a `setTimeout` for `ms` milliseconds. When it fires, if the wrapper hasn't settled yet, mark it as settled and `reject(reason ?? new Error('Timeout'))`.\n3. Wrap `p` with `Promise.resolve(p)` (so it can be a value or a promise) and hook `.then` / `.catch`. On fulfillment or rejection, if not already settled, mark as settled, `clearTimeout(id)`, and forward the value or error.\n4. Use a `settled` flag to ensure the outer promise resolves/rejects only once, and that the timer is always cleared when the inner promise wins.\n\n**Solving steps – `withAbort(factory, signal)`**\n1. If `signal.aborted` is already `true`, immediately reject with `signal.reason` (or `new Error('Aborted')`). No listeners are attached in this case.\n2. Inside a new `Promise`, create a `finished` flag and an `onAbort` handler. When `onAbort` runs, if not finished, mark finished and `reject(signal.reason ?? new Error('Aborted'))`.\n3. Register `onAbort` as a one-time listener: `signal.addEventListener('abort', onAbort, { once: true })`.\n4. Start the actual work by calling `factory(signal)` inside a resolved promise chain. On success, if not finished, mark finished, remove the abort listener, and `resolve(value)`.\n5. On error, if not finished, mark finished, remove the abort listener, and `reject(error)`.\n6. The combination of `finished` + `removeEventListener` guarantees no leaks and no double resolution.\n\n**Solving steps – `composeAbort(...signals)`**\n1. Create a new `AbortController` `ac` and return `ac.signal` to callers.\n2. If `signals` is empty, just return `ac.signal` (it will never abort unless someone aborts `ac` manually).\n3. Check whether any input signal is already aborted. If found, immediately `ac.abort(already.reason)` and return `ac.signal`.\n4. Otherwise, for each source signal `s`, attach a one-time `abort` listener that calls a shared `abortOnce(reason)` helper.\n5. `abortOnce` aborts the combined signal if not already aborted, then iterates over all stored listeners and removes them, clearing the `listeners` array to avoid leaks.\n6. When any input signal aborts, the combined signal aborts with the same `reason`, and all other listeners are detached.\n\nThis pattern gives you: (a) precise timeout control, (b) clean abort wiring for individual async tasks, and (c) a reusable way to merge cancellation sources.",
          "codeJs": "function abortableHelpers() {}\n\nabortableHelpers.sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\nabortableHelpers.withTimeout = function withTimeout(p, ms, reason) {\n  return new Promise((resolve, reject) => {\n    let settled = false;\n    const id = setTimeout(() => {\n      if (settled) return;\n      settled = true;\n      reject(reason ?? new Error('Timeout'));\n    }, ms);\n\n    Promise.resolve(p).then(\n      v => { if (!settled) { settled = true; clearTimeout(id); resolve(v); } },\n      e => { if (!settled) { settled = true; clearTimeout(id); reject(e); } }\n    );\n  });\n};\n\nabortableHelpers.withAbort = function withAbort(factory, signal) {\n  return new Promise((resolve, reject) => {\n    if (signal?.aborted) { reject(signal.reason ?? new Error('Aborted')); return; }\n\n    let finished = false;\n    const onAbort = () => {\n      if (finished) return;\n      finished = true;\n      reject(signal.reason ?? new Error('Aborted'));\n    };\n\n    signal?.addEventListener('abort', onAbort, { once: true });\n\n    Promise.resolve()\n      .then(() => factory(signal))\n      .then(v => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); resolve(v); } })\n      .catch(e => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); reject(e); } });\n  });\n};\n\nabortableHelpers.composeAbort = function composeAbort(...signals) {\n  const ac = new AbortController();\n  if (!signals || signals.length === 0) return ac.signal;\n\n  const already = signals.find(s => s?.aborted);\n  if (already) { ac.abort(already.reason); return ac.signal; }\n\n  const listeners = [];\n  const abortOnce = (reason) => {\n    if (!ac.signal.aborted) ac.abort(reason);\n    for (const { s, fn } of listeners) s.removeEventListener('abort', fn);\n    listeners.length = 0;\n  };\n\n  for (const s of signals) {\n    if (!s) continue;\n    const fn = () => abortOnce(s.reason);\n    s.addEventListener('abort', fn, { once: true });\n    listeners.push({ s, fn });\n  }\n\n  return ac.signal;\n};\n\nexport default abortableHelpers;\n",
          "codeTs": "function abortableHelpers() {}\n\nabortableHelpers['sleep'] = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\nabortableHelpers['withTimeout'] = function withTimeout<T>(p: Promise<T>, ms: number, reason?: any): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    let settled = false;\n    const id = setTimeout(() => {\n      if (settled) return;\n      settled = true;\n      reject(reason ?? new Error('Timeout'));\n    }, ms);\n\n    Promise.resolve(p).then(\n      v => { if (!settled) { settled = true; clearTimeout(id); resolve(v); } },\n      e => { if (!settled) { settled = true; clearTimeout(id); reject(e); } }\n    );\n  });\n};\n\nabortableHelpers['withAbort'] = function withAbort<T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    if (signal?.aborted) { reject((signal as any).reason ?? new Error('Aborted')); return; }\n\n    let finished = false;\n    const onAbort = () => {\n      if (finished) return;\n      finished = true;\n      reject((signal as any).reason ?? new Error('Aborted'));\n    };\n\n    signal?.addEventListener('abort', onAbort, { once: true });\n\n    Promise.resolve()\n      .then(() => factory(signal))\n      .then(v => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); resolve(v); } })\n      .catch(e => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); reject(e); } });\n  });\n};\n\nabortableHelpers['composeAbort'] = function composeAbort(...signals: AbortSignal[]): AbortSignal {\n  const ac = new AbortController();\n  if (!signals || signals.length === 0) return ac.signal;\n\n  const already = signals.find(s => s?.aborted);\n  if (already) { ac.abort((already as any).reason); return ac.signal; }\n\n  type L = { s: AbortSignal; fn: () => void };\n  const listeners: L[] = [];\n  const abortOnce = (reason: any) => {\n    if (!ac.signal.aborted) ac.abort(reason);\n    for (const { s, fn } of listeners) s.removeEventListener('abort', fn);\n    listeners.length = 0;\n  };\n\n  for (const s of signals) {\n    if (!s) continue;\n    const fn = () => abortOnce((s as any).reason);\n    s.addEventListener('abort', fn, { once: true });\n    listeners.push({ s, fn });\n  }\n\n  return ac.signal;\n};\n\nexport default abortableHelpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Always remove abort listeners and clear timers to avoid leaks.",
          "Avoid double resolution; track state with a `settled` / `finished` flag.",
          "If a signal is already aborted, reject immediately without attaching listeners.",
          "`withTimeout` does not automatically cancel the underlying work — it only rejects the wrapper promise. Combine with `withAbort` or an abort-aware API if you need real cancellation."
        ],
        "edgeCases": [
          "Zero-timeout case (ms = 0) → rejects immediately if the timer wins.",
          "Aborted signal passed to `withAbort` → immediate rejection.",
          "Composed signal with any already-aborted input → aborts instantly with that reason.",
          "No signals passed to `composeAbort` → returned signal never aborts on its own."
        ],
        "techniques": [
          "Use AbortController to coordinate cancellations.",
          "Use Promise.race-style logic for timeouts.",
          "Clean up listeners and timers explicitly.",
          "Model composed cancellation via a shared AbortController and mirrored abort events."
        ]
      },
      "followUpQuestions": [
        "js-add-two-promises"
      ],
      "resources": [
        {
          "title": "MDN – AbortController",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController"
        },
        {
          "title": "MDN – Promise.race()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"
        }
      ]
    },
    "tests": "import helpers from './abortable-helpers';\nconst { withTimeout, withAbort, composeAbort, sleep } = helpers as any;\nfunction _sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }\nconst nap = typeof sleep === 'function' ? sleep : _sleep;\n\ndescribe('Abortable Helpers', () => {\n  test('withTimeout resolves when promise is fast', async () => {\n    const res = await withTimeout(nap(30).then(()=>42), 200);\n    expect(res).toEqual(42);\n  });\n\n  test('withTimeout rejects when timeout wins', async () => {\n    let threw = false; let msg = '';\n    try { await withTimeout(nap(200), 30, new Error('Timeout')); }\n    catch(e){ threw = true; msg = e && e.message; }\n    expect(threw).toEqual(true);\n    expect(!!msg).toEqual(true);\n  });\n\n  test('withAbort resolves if not aborted', async () => {\n    const ac = new AbortController();\n    const val = await withAbort(async (signal) => { await nap(20); return signal.aborted ? -1 : 7; }, ac.signal);\n    expect(val).toEqual(7);\n  });\n\n  test('withAbort rejects when signal aborts', async () => {\n    const ac = new AbortController();\n    let threw = false;\n    try {\n      const p = withAbort(async () => { await nap(100); return 1; }, ac.signal);\n      setTimeout(()=>ac.abort(new Error('Cancelled')), 20);\n      await p;\n    } catch{ threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort aborts when any source aborts', async () => {\n    const a = new AbortController();\n    const b = new AbortController();\n    const c = composeAbort(a.signal, b.signal);\n    expect(c.aborted).toEqual(false);\n\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 'ok'; }, c);\n    setTimeout(()=> b.abort(new Error('Bailed')), 10);\n    try { await p; } catch{ threw = true; }\n    expect(threw).toEqual(true);\n    expect(c.aborted).toEqual(true);\n  });\n\n  test('composeAbort is already aborted if any input is aborted', () => {\n    const a = new AbortController();\n    a.abort(new Error('early'));\n    const c = composeAbort(a.signal, new AbortController().signal);\n    expect(c.aborted).toEqual(true);\n  });\n});\n",
    "testsTs": "import helpers from './abortable-helpers';\nconst { withTimeout, withAbort, composeAbort, sleep } = helpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n\nfunction _sleep(ms: number){ return new Promise<void>(r=>setTimeout(r, ms)); }\nconst nap = typeof sleep === 'function' ? sleep : _sleep;\n\ndescribe('Abortable Helpers (TS)', () => {\n  test('withTimeout resolves fast', async () => {\n    const res = await withTimeout(Promise.resolve(5), 100);\n    expect(res).toEqual(5);\n  });\n\n  test('withTimeout rejects on timeout', async () => {\n    let threw = false;\n    try { await withTimeout(nap(200).then(()=>42), 10, new Error('Timeout')); }\n    catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('withAbort resolves when not aborted', async () => {\n    const ac = new AbortController();\n    const v = await withAbort(async (signal) => { await nap(15); return signal.aborted ? -1 : 9; }, ac.signal);\n    expect(v).toEqual(9);\n  });\n\n  test('withAbort rejects when aborted', async () => {\n    const ac = new AbortController();\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 1; }, ac.signal);\n    setTimeout(()=>ac.abort(new Error('cancel')), 10);\n    try { await p; } catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort aborts if any input aborts', async () => {\n    const a = new AbortController();\n    const b = new AbortController();\n    const sig = composeAbort(a.signal, b.signal);\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 'ok'; }, sig);\n    setTimeout(()=>a.abort(new Error('stop')), 10);\n    try { await p; } catch { threw = true; }\n    expect(sig.aborted).toEqual(true);\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort reflects already-aborted inputs', () => {\n    const a = new AbortController(); a.abort(new Error('early'));\n    const sig = composeAbort(a.signal);\n    expect(sig.aborted).toEqual(true);\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-streaming-ndjson-parser",
    "title": "Streaming NDJSON Parser (Web Streams)",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "backpressure",
      "ndjson",
      "parsing",
      "streams",
      "text-decoder"
    ],
    "description": {
      "summary": "Implement a **streaming** parser for NDJSON (newline-delimited JSON). Read from a `ReadableStream<Uint8Array>`, decode incrementally, split on newlines, parse each line into an object, and recover from malformed lines via a callback without stopping the stream.",
      "arguments": [
        {
          "name": "stream",
          "type": "ReadableStream<Uint8Array>",
          "desc": "Binary stream producing UTF-8 chunks of text containing one JSON object per line."
        },
        {
          "name": "onError",
          "type": "(line: string, err: any) => void (optional)",
          "desc": "Called when a line fails to parse. The parser must **continue** parsing subsequent lines."
        }
      ],
      "returns": {
        "type": "Promise<any[]>",
        "desc": "Resolves with an array of successfully parsed objects (malformed lines are skipped but reported via `onError`)."
      },
      "examples": [
        "// Given a Response with NDJSON body\nconst res = await fetch('/events.ndjson');\nconst objects = await parseNDJSON(res.body, (line, err) => console.warn('bad line:', line, err));\n// objects => an array of parsed items, in order"
      ]
    },
    "starterCode": "/*\n * parseNDJSON(stream, onError?)\n * - Consume a ReadableStream<Uint8Array> using a reader\n * - Use TextDecoder with { stream: true } to correctly handle UTF-8 boundaries\n * - Accumulate into a string buffer; split by \"\\n\" to get complete lines\n * - Keep the trailing partial line in the buffer and prepend the next chunk\n * - For each non-empty line, JSON.parse; on error, call onError(line, err) and continue\n * - After the stream ends, flush the decoder and process the final buffer\n */\nexport default async function parseNDJSON(stream, onError) {\n  // TODO: implement as described above\n}\n\n// CommonJS fallback for runners that require module.exports\ntry { if (typeof module !== 'undefined') module.exports = parseNDJSON; } catch (_) {}\n",
    "starterCodeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: any) => void\n): Promise<any[]> {\n  // TODO: implement\n  return []\n}\n\n// CommonJS fallback\n// @ts-ignore\ntry { if (typeof module !== 'undefined') (module as any).exports = parseNDJSON; } catch (_) {}\n",
    "solutionBlock": {
      "overview": "Goal: build a robust streaming NDJSON parser that respects backpressure, decodes UTF-8 across chunk boundaries, preserves order, and isolates per-line JSON errors so parsing continues.",
      "approaches": [
        {
          "title": "Approach 1: Built-ins pipeline (easiest)",
          "prose": "Use `TextDecoderStream` to handle UTF-8 boundaries and a tiny `TransformStream` to split lines.\n\nSolving steps:\n1. Build a line-splitting `TransformStream` that keeps an internal buffer string. For each incoming chunk, append it, split on `\"\\n\"`, keep the last partial line in the buffer, and enqueue trimmed, non-empty full lines.\n2. Pipe the byte stream through `new TextDecoderStream()` and then through the line splitter to get a stream of text lines.\n3. Get a reader from this line stream.\n4. In a loop, `await reader.read()`. For each `value`, attempt `JSON.parse(value)` and push the result into an output array; on parse error, call `onError?.(value, err)` and continue.\n5. When `done` is true, release the reader lock and return the collected output array.\n\nWhy it works: `TextDecoderStream` handles UTF-8 boundaries, the transform isolates whole lines across chunk boundaries, and per-line try/catch keeps the stream robust in the face of malformed records.",
          "codeJs": "export default async function parseNDJSON(stream, onError){\n  if (!stream?.pipeThrough) throw new Error('ReadableStream expected');\n  const lineSplitter = new TransformStream({\n    start(){ this.buf = ''; },\n    transform(chunk, controller){\n      this.buf += chunk; const parts = this.buf.split('\\n');\n      this.buf = parts.pop() ?? '';\n      for (const line of parts){ const t=line.trim(); if (t) controller.enqueue(t); }\n    },\n    flush(controller){ const t = this.buf.trim(); if (t) controller.enqueue(t); }\n  });\n\n  const out = [];\n  const reader = stream\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(lineSplitter)\n    .getReader();\n\n  while (true){\n    const { value, done } = await reader.read(); if (done) break;\n    try { out.push(JSON.parse(value)); } catch (e){ onError?.(value, e); }\n  }\n  try{ reader.releaseLock(); }catch{}\n  return out;\n}",
          "codeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: unknown) => void\n): Promise<any[]> {\n  if (!('pipeThrough' in stream)) throw new Error('ReadableStream expected');\n\n  const lineSplitter = new TransformStream<string, string>({\n    start() { (this as any).buf = ''; },\n    transform(chunk, controller) {\n      (this as any).buf += chunk;\n      const parts = (this as any).buf.split('\\n');\n      (this as any).buf = parts.pop() ?? '';\n      for (const line of parts) {\n        const t = line.trim();\n        if (t) controller.enqueue(t);\n      }\n    },\n    flush(controller) {\n      const t = ((this as any).buf as string).trim();\n      if (t) controller.enqueue(t);\n    }\n  });\n\n  const out: any[] = [];\n  const reader = stream\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(lineSplitter)\n    .getReader();\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    try { out.push(JSON.parse(value)); } catch (e) { onError?.(value, e); }\n  }\n  try { reader.releaseLock(); } catch {}\n  return out;\n}"
        },
        {
          "title": "Approach 2: Async iterator style (clean & concise)",
          "prose": "Consume bytes manually with a reader and `TextDecoder`, keeping a small buffer string.\n\nSolving steps:\n1. Create `const reader = stream.getReader()` and `const decoder = new TextDecoder()`.\n2. Maintain a `buf` string and an `out` array, and define a `drain()` helper that splits `buf` on `\"\\n\"`, keeps the last element as the new `buf` (the potential partial line), and for each full line: trims it and, if non-empty, tries `JSON.parse(line)` in a try/catch; on success pushes into `out`, on failure calls `onError?.(line, err)` and continues.\n3. In a `while (true)` loop, `await reader.read()`. For each chunk, append `decoder.decode(value, { stream: true })` to `buf` and call `drain()`.\n4. After `done` is true, flush any remaining bytes with `buf += decoder.decode()`, then call `drain()` again to handle any remaining full lines.\n5. If there's still a non-empty `buf` (final line without trailing newline), parse it with the same try/catch + `onError` logic, then release the reader lock in a `try/catch` and return `out`.\n\nWhy it works: incremental decoding plus a carry-over buffer ensures JSON objects are never split incorrectly across chunks, while keeping memory usage bounded and isolating malformed lines.",
          "codeJs": "export default async function parseNDJSON(stream, onError){\n  const reader = stream.getReader(); const dec = new TextDecoder();\n  let buf = '', out = [];\n  const drain = () => { const parts = buf.split('\\n'); buf = parts.pop() ?? '';\n    for (let l of parts){ l = l.trim(); if(!l) continue; try{ out.push(JSON.parse(l)); }catch(e){ onError?.(l,e); } }\n  };\n  while(true){ const {value,done}=await reader.read(); if(done) break;\n    buf += dec.decode(value,{stream:true}); drain(); }\n  buf += dec.decode(); drain(); const tail=buf.trim();\n  if(tail){ try{ out.push(JSON.parse(tail)); }catch(e){ onError?.(tail,e); } }\n  try{ reader.releaseLock(); }catch{}\n  return out;\n}",
          "codeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: unknown) => void\n): Promise<any[]> {\n  const reader = stream.getReader();\n  const dec = new TextDecoder();\n  let buf = '';\n  const out: any[] = [];\n\n  const drain = () => {\n    const parts = buf.split('\\n');\n    buf = parts.pop() ?? '';\n    for (let l of parts) {\n      const t = l.trim();\n      if (!t) continue;\n      try { out.push(JSON.parse(t)); }\n      catch (e) { onError?.(t, e); }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buf += dec.decode(value, { stream: true });\n    drain();\n  }\n\n  buf += dec.decode();\n  drain();\n  const tail = buf.trim();\n  if (tail) {\n    try { out.push(JSON.parse(tail)); }\n    catch (e) { onError?.(tail, e); }\n  }\n\n  try { reader.releaseLock(); } catch {}\n  return out;\n}"
        },
        {
          "title": "Approach 3: Backpressure-focused reader loop (most control)",
          "prose": "A more verbose, production-oriented variant that uses an explicit reader loop, `{ stream: true }` decoding, and careful cleanup.\n\nSolving steps:\n1. Validate that `stream` looks like a `ReadableStream<Uint8Array>`; if not, throw a clear error.\n2. Create `const reader = stream.getReader()` and `const decoder = new TextDecoder('utf-8')`. Maintain a `buffer` string and an `out` array, and define a `drainLines()` helper that splits `buffer` on `\"\\n\"`, keeps the last element as the new `buffer`, and for each full line: trims it, skips empty lines, and `JSON.parse`s it in a try/catch; on success pushes into `out`, on failure calls `onError(line, err)` if provided.\n3. In a `while (true)` loop, `await reader.read()`. For each chunk, append `decoder.decode(value, { stream: true })` to `buffer` and call `drainLines()` so lines are processed incrementally as data arrives.\n4. When `done` is true, flush any remaining bytes with `buffer += decoder.decode()`, then call `drainLines()` again to handle any final full lines.\n5. If there's still a non-empty `buffer` (final line without trailing newline), parse it with the same try/catch + `onError` logic, then release the reader lock in a `try/catch` and return the `out` array.\n\nWhy use it: when you need tight control over resource management, metrics, or instrumentation (for example logging per-chunk progress or enforcing custom backpressure policies), this pattern gives you full control while following the same buffer + split + parse strategy as the other approaches.",
          "codeJs": "/*\n * Streaming NDJSON parser\n * - Efficient: processes data chunk-by-chunk (low memory) and preserves order\n * - Robust: isolates malformed lines via onError callback and continues\n * - Correct decoding: uses TextDecoder(stream:true) for UTF-8 boundaries\n */\nexport default async function parseNDJSON(stream, onError) {\n  if (!stream || typeof stream.getReader !== 'function') {\n    throw new Error('parseNDJSON: expected a ReadableStream<Uint8Array>');\n  }\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n  const out = [];\n\n  const drainLines = () => {\n    const parts = buffer.split('\\n');\n    buffer = parts.pop() ?? '';\n    for (let line of parts) {\n      line = line.trim();\n      if (line === '') continue;\n      try {\n        out.push(JSON.parse(line));\n      } catch (err) {\n        if (typeof onError === 'function') onError(line, err);\n      }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, { stream: true });\n    drainLines();\n  }\n\n  buffer += decoder.decode();\n  drainLines();\n  const tail = buffer.trim();\n  if (tail !== '') {\n    try { out.push(JSON.parse(tail)); }\n    catch (err) { if (typeof onError === 'function') onError(tail, err); }\n  }\n\n  try { reader.releaseLock(); } catch (_) {}\n  return out;\n}\n\ntry { if (typeof module !== 'undefined') module.exports = parseNDJSON; } catch (_) {}\n",
          "codeTs": "/*\n * Streaming NDJSON parser (TypeScript)\n * Same logic, with typed signatures for clarity.\n */\nexport default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: any) => void\n): Promise<any[]> {\n  if (!stream || typeof (stream as any).getReader !== 'function') {\n    throw new Error('parseNDJSON: expected a ReadableStream<Uint8Array>');\n  }\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n  const out: any[] = [];\n\n  const drainLines = () => {\n    const parts = buffer.split('\\n');\n    buffer = parts.pop() ?? '';\n    for (let raw of parts) {\n      const line = raw.trim();\n      if (line === '') continue;\n      try { out.push(JSON.parse(line)); }\n      catch (err) { if (onError) onError(line, err); }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, { stream: true });\n    drainLines();\n  }\n\n  buffer += decoder.decode();\n  drainLines();\n  const tail = buffer.trim();\n  if (tail !== '') {\n    try { out.push(JSON.parse(tail)); }\n    catch (err) { if (onError) onError(tail, err); }\n  }\n\n  try { reader.releaseLock(); } catch {}\n  return out;\n}\n\n// CommonJS fallback\n// @ts-ignore\ntry { if (typeof module !== 'undefined') (module as any).exports = parseNDJSON; } catch {}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting `{ stream: true }` on `TextDecoder.decode` can corrupt multi-byte characters split across chunks.",
          "Dropping the trailing partial line between chunks leads to truncated/invalid JSON.",
          "Throwing on a single bad line halts the entire parse — prefer `onError` and continue."
        ],
        "edgeCases": [
          "CRLF endings: `\\r\\n` — use `trim()` before parsing to remove stray `\\r`.",
          "Empty lines: skip safely.",
          "Final line without trailing `\\n`: parse it after flushing the decoder."
        ],
        "techniques": [
          "Respect backpressure with `getReader()` and `await reader.read()`.",
          "Incremental decode using `TextDecoder` with stream mode.",
          "Carry-over buffer + split-on-newline to align record boundaries."
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "MDN – Streams API",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Streams_API"
        },
        {
          "title": "MDN – TextDecoder",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder"
        }
      ]
    },
    "tests": "import parseNDJSON from './ndjson-parser';\n\n// Helper: build a ReadableStream<Uint8Array> that emits given string chunks\nconst te = new TextEncoder();\nfunction streamFromStrings(chunks) {\n  return new ReadableStream({\n    start(controller) {\n      let i = 0;\n      const pump = () => {\n        if (i >= chunks.length) { controller.close(); return; }\n        controller.enqueue(te.encode(chunks[i++]));\n        setTimeout(pump, 0); // async to exercise the reader loop\n      };\n      pump();\n    }\n  });\n}\n\nfunction expectEqual(a, b){ expect(JSON.stringify(a)).toEqual(JSON.stringify(b)); }\n\ndescribe('Streaming NDJSON Parser', () => {\n  test('parses lines across arbitrary chunk boundaries', async () => {\n    const chunks = [\n      '{\"a\":1}\\n{\"b\"',\n      ':2}\\n{\"c\":3}\\n',\n    ];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{a:1},{b:2},{c:3}]);\n  });\n\n  test('handles last line without trailing newline', async () => {\n    const chunks = ['{\"x\":1}\\n{\"y\":2}'];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{x:1},{y:2}]);\n  });\n\n  test('skips blank lines and trims CRLF', async () => {\n    const chunks = ['\\r\\n', '{\"n\":1}\\r\\n', '\\n', '{\"m\":2}\\n'];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{n:1},{m:2}]);\n  });\n\n  test('reports malformed lines via onError and continues', async () => {\n    const bad = []; // collect bad lines\n    const chunks = ['{\"ok\":1}\\n', '{bad json}\\n', '{\"ok\":2}\\n'];\n    const res = await parseNDJSON(streamFromStrings(chunks), (line, err) => { bad.push(line); });\n    expectEqual(res, [{ok:1},{ok:2}]);\n    expectEqual(bad, ['{bad json}']);\n  });\n});\n",
    "testsTs": "import parseNDJSON from './ndjson-parser';\n\nconst te = new TextEncoder();\nfunction streamFromStrings(chunks: string[]): ReadableStream<Uint8Array> {\n  return new ReadableStream<Uint8Array>({\n    start(controller) {\n      let i = 0;\n      const pump = () => {\n        if (i >= chunks.length) { controller.close(); return; }\n        controller.enqueue(te.encode(chunks[i++]));\n        setTimeout(pump, 0);\n      };\n      pump();\n    }\n  });\n}\n\nfunction expectEqual(a: any, b: any){ expect(JSON.stringify(a)).toEqual(JSON.stringify(b)); }\n\ndescribe('Streaming NDJSON Parser (TS)', () => {\n  test('parses across chunk boundaries', async () => {\n    const res = await parseNDJSON(streamFromStrings(['{\"a\":1}\\n{\"b\"', ':2}\\n']));\n    expectEqual(res, [{a:1},{b:2}]);\n  });\n\n  test('no trailing newline', async () => {\n    const res = await parseNDJSON(streamFromStrings(['{\"x\":1}\\n{\"y\":2}']));\n    expectEqual(res, [{x:1},{y:2}]);\n  });\n\n  test('error isolation', async () => {\n    const errors: string[] = [];\n    const res = await parseNDJSON(streamFromStrings(['{\"ok\":1}\\n','{oops}\\n','{\"ok\":2}\\n']), (line) => errors.push(line));\n    expectEqual(res, [{ok:1},{ok:2}]);\n    expectEqual(errors, ['{oops}']);\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-array-prototype-map",
    "title": "Implement Array.prototype.map",
    "type": "coding",
    "companies": [
      "amazon",
      "apple"
    ],
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "callbacks",
      "iteration",
      "polyfills"
    ],
    "teaches": [
      "How built-in array iteration works under the hood",
      "Correct callback invocation and thisArg binding",
      "Handling sparse arrays (holes) correctly",
      "Length snapshot + per-index existence checks"
    ],
    "description": {
      "summary": "Recreate the native `.map()` method **without using it**. Your `myMap` must call `callbackFn(value, index, array)` for each **existing** index, bind `thisArg`, and return a new array with the **same length** where holes stay holes (no callback for missing indices). It must snapshot the initial `length` and must not visit elements appended beyond that length during iteration (native behavior).",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "(currentValue: any, index: number, array: any[]) => any",
          "desc": "Function to execute on each existing element."
        },
        {
          "name": "thisArg",
          "type": "any (optional)",
          "desc": "Value to use as `this` when executing callback."
        }
      ],
      "returns": {
        "type": "Array",
        "desc": "A new array with the results of calling `callbackFn` on every existing element, preserving length and holes."
      },
      "examples": [
        "[1, 2, 3].myMap(x => x * 2) // => [2, 4, 6]",
        "[, 10, , 30].myMap((v,i) => i) // => [ , 1, , 3 ] (holes preserved)",
        "[1].myMap(function(x){ return this.add + x }, { add: 5 }) // => [6]"
      ]
    },
    "starterCode": "/* Boilerplate — replace the throw with a correct implementation */\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};\n",
    "starterCodeTs": "declare global {\n  interface Array<T> {\n    myMap<U>(\n      callbackFn: (value: T, index: number, array: Array<T>) => U,\n      thisArg?: any\n    ): Array<U>;\n  }\n}\n\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};\n",
    "solutionBlock": {
      "overview": "Goal: implement a `.map()`-like method that snapshots `length` once, iterates `0..len-1`, calls the callback with `(value, index, array)` for existing indices only, binds `thisArg`, and returns a new array of the same length where holes remain holes.",
      "approaches": [
        {
          "title": "Single approach: length snapshot + own-property check (chosen for clarity)",
          "prose": "We intentionally use an **own-property** check (`Object.prototype.hasOwnProperty.call`) to define “existing element” as an actual slot on the array object. This is the simplest mental model for learners and matches the key interview lesson: **holes are skipped**.\n\nSpec note (1 line): The ECMAScript spec uses `k in O` (includes inherited numeric keys). We avoid that here to keep the exercise focused on holes/length snapshot without prototype-chain surprises.",
          "codeJs": "Array.prototype.myMap = function (callbackFn, thisArg) {\n  if (this == null) throw new TypeError('Array.prototype.myMap called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n\n  const O = Object(this);\n  const len = O.length >>> 0; // snapshot length once\n  const out = new Array(len);\n\n  for (let k = 0; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      out[k] = callbackFn.call(thisArg, O[k], k, O);\n    }\n    // else: hole stays hole in out\n  }\n\n  return out;\n};\n",
          "codeTs": "declare global {\n  interface Array<T> {\n    myMap<U>(\n      callbackFn: (value: T, index: number, array: Array<T>) => U,\n      thisArg?: any\n    ): Array<U>;\n  }\n}\n\nArray.prototype.myMap = function <T, U>(\n  this: T[],\n  callbackFn: (value: T, index: number, array: T[]) => U,\n  thisArg?: any,\n): U[] {\n  if (this == null) throw new TypeError('Array.prototype.myMap called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n\n  const O = Object(this) as { [k: number]: T; length: number };\n  const len = O.length >>> 0; // snapshot length once\n  const out = new Array<U>(len);\n\n  for (let k = 0; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      out[k] = callbackFn.call(thisArg, O[k], k, O as any);\n    }\n  }\n\n  return out;\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Missing runtime guard: native `.map()` throws if `callbackFn` is not a function.",
          "Using `push` instead of writing by index will destroy hole positions and length alignment.",
          "`thisArg` is ignored by arrow functions by design—use a normal function if you need `this`."
        ],
        "edgeCases": [
          "Sparse arrays: callback is not called for missing indices; output preserves holes.",
          "Mutations during mapping can affect later indices (native behavior), but length is snapshotted at the start.",
          "Appended elements beyond the initial length are not visited."
        ],
        "techniques": [
          "Box receiver with `Object(this)` and snapshot `length` once (`>>> 0`).",
          "Use `Object.prototype.hasOwnProperty.call(O, k)` to skip holes (own slots only).",
          "Bind `thisArg` with `.call(thisArg, value, index, array)`.",
          "Preallocate the output array to keep indices aligned."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-filter",
        "js-array-prototype-reduce",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.map()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"
        },
        {
          "title": "ECMAScript Spec – Array.prototype.map",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.map"
        }
      ]
    },
    "tests": "describe('Array.prototype.myMap', () => {\n  const identity = (x) => x;\n  const square = (n) => n * n;\n\n  test('throws if callbackFn is not a function', () => {\n    expect(() => [1, 2].myMap(null)).toThrow(TypeError);\n  });\n\n  test('identity', () => {\n    expect([10].myMap(identity)).toEqual([10]);\n    expect([10, 20].myMap(identity)).toEqual([10, 20]);\n  });\n\n  test('square', () => {\n    expect([-4].myMap(square)).toEqual([16]);\n    expect([5].myMap(square)).toEqual([25]);\n  });\n\n  test('skips holes and preserves length/holes', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a = [, 10, , 30];\n    const r = a.myMap((v, i) => i);\n    expect(r.length).toBe(4);\n    expect(0 in r).toBe(false);\n    expect(1 in r).toBe(true);\n    expect(2 in r).toBe(false);\n    expect(3 in r).toBe(true);\n    expect(r[1]).toBe(1);\n    expect(r[3]).toBe(3);\n  });\n\n  test('binds thisArg', () => {\n    const ctx = { add: 5 };\n    const out = [1].myMap(function (x) { return this.add + x; }, ctx);\n    expect(out).toEqual([6]);\n  });\n\n  test('length snapshot: does not visit appended elements beyond initial length', () => {\n    const arr = [1, 2, 3];\n    const seen = [];\n    const out = arr.myMap((v, i, a) => {\n      seen.push(v);\n      if (i === 0) a.push(999);\n      return v;\n    });\n    expect(out).toEqual([1, 2, 3]);\n    expect(seen).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "// @ts-nocheck\n\ndescribe('Array.prototype.myMap (TypeScript)', () => {\n  it('throws if callbackFn is not a function', () => {\n    expect(() => ([1, 2] as any).myMap(null)).toThrow(TypeError);\n  });\n\n  it('maps values and preserves holes', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a: any[] = [, 10, , 30];\n    const r = (a as any).myMap((v: any, i: number) => i);\n    expect(r.length).toBe(4);\n    expect(0 in r).toBe(false);\n    expect(1 in r).toBe(true);\n    expect(2 in r).toBe(false);\n    expect(3 in r).toBe(true);\n  });\n\n  it('binds thisArg', () => {\n    const ctx = { add: 5 };\n    const out = ([1] as any).myMap(function (x: number) { return (this as any).add + x; }, ctx);\n    expect(out).toEqual([6]);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-array-prototype-reduce",
    "title": "Implement Array.prototype.reduce",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "amazon",
      "apple"
    ],
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "arrays",
      "callbacks",
      "iteration",
      "polyfills",
      "accumulators"
    ],
    "teaches": [
      "How array reduction works under the hood",
      "Accumulator initialization with or without an initial value",
      "Handling sparse arrays (holes) correctly",
      "Throwing on empty arrays without an initial value"
    ],
    "description": {
      "summary": "Recreate the native `.reduce()` method **without using it**. Your `myReduce` must call the reducer with `(accumulator, currentValue, index, array)` only for existing indices, handle an optional `initialValue`, and return the final accumulator. If no `initialValue` is provided, use the **first existing element** as the initial accumulator. If there is **no existing element** and no `initialValue`, throw a `TypeError`.",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "(accumulator: any, currentValue: any, index: number, array: any[]) => any",
          "desc": "Reducer function applied to each existing element."
        },
        {
          "name": "initialValue",
          "type": "any (optional)",
          "desc": "Value to use as the first accumulator. If omitted, the first existing element is used."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "The final accumulated value after iterating through the array."
      },
      "examples": [
        "[1, 2, 3].myReduce((acc, x) => acc + x, 0) // => 6",
        "[, 1, , 3].myReduce((acc, x) => acc + x)   // => 4 (skips holes; starts at 1)",
        "[].myReduce((a, x) => a + x, 10)           // => 10"
      ]
    },
    "starterCode": "/* Boilerplate — replace the throw with a correct implementation */\nArray.prototype.myReduce = function (callbackFn, initialValue) {\n  throw 'Not implemented!';\n};\n",
    "starterCodeTs": "declare global {\n  interface Array<T> {\n    myReduce<U>(\n      callbackFn: (accumulator: U, currentValue: T, index: number, array: Array<T>) => U,\n      initialValue: U\n    ): U;\n    myReduce(\n      callbackFn: (accumulator: T, currentValue: T, index: number, array: Array<T>) => T\n    ): T;\n  }\n}\n\nArray.prototype.myReduce = function (callbackFn: any, initialValue?: any) {\n  throw 'Not implemented!';\n};\n",
    "solutionBlock": {
      "overview": "What a correct `.reduce()` must do: (1) Work on the receiver and read its `length` directly. (2) If `initialValue` is provided, start with it; otherwise find the first existing element as the initial accumulator (skip holes) or throw on empty. (3) For each existing index, call `callbackFn(acc, value, index, array)` and store back to `acc`. (4) Skip holes using an own-property check (or `k in O` for spec-leaning behavior). (5) Return the final `acc`.",
      "approaches": [
        {
          "title": "Approach 1: Simple for-loop (practical baseline)",
          "prose": "Iterate 0..length−1, seed the accumulator from `initialValue` or the first present element, and skip holes with an own-property check. Clear, fast, and mirrors everyday expectations.\n\nSolving steps:\n1. Coerce the receiver: `const O = Object(this)`.\n2. Coerce `length`: `const len = O.length >>> 0` (uint32, like the spec).\n3. Decide whether an `initialValue` was provided: `const initProvided = arguments.length > 1`.\n4. If `initProvided` is true, set `acc = initialValue` and start from `k = 0`. Otherwise, scan from `k = 0` until you find the first own property; if none exists, throw `TypeError('Reduce of empty array with no initial value')`; otherwise use that element as `acc` and start after it.\n5. From the current `k` up to `len − 1`, if `O` has own property `k`, call `callbackFn(acc, O[k], k, O)` and store the result back into `acc`.\n6. Return `acc`.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = O.length >>> 0; // coerce to uint32\n  let k = 0;\n  let acc;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(O, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      acc = callbackFn(acc, O[k], k, O);\n    }\n  }\n  return acc;\n};\n",
          "codeTs": "declare global {\n  interface Array<T> {\n    myReduce<U>(cb: (acc: U, cur: T, idx: number, arr: T[]) => U, initialValue: U): U;\n    myReduce(cb: (acc: T, cur: T, idx: number, arr: T[]) => T): T;\n  }\n}\n\nArray.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as T[] & { length: number };\n  const len: number = O.length >>> 0;\n  let k = 0;\n  let acc: any;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue as U;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(O, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = (O as any)[k++];\n  }\n  for (; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      acc = (callbackFn as any)(acc, (O as any)[k], k, O);\n    }\n  }\n  return acc as any;\n};\n"
        },
        {
          "title": "Approach 2: Spec-leaning (`ToObject`, length coercion, `k in O`)",
          "prose": "Closer to native semantics: coerce `this` with `Object(this)`, coerce `length` via `Number` + `Math.floor`, and use `k in O` to honor inherited index accessors (native `.reduce` does this).\n\nSolving steps:\n1. Box the receiver: `const O = Object(this)` so it works on array-like values.\n2. Coerce `length`: `const len = Math.max(0, Math.floor(Number(O.length) || 0))`.\n3. Compute `const initProvided = arguments.length > 1` to distinguish the two call forms.\n4. If `initProvided`, set `acc = initialValue` and start from `k = 0`; otherwise scan `k` upwards while `!(k in O)`. If you reach `k >= len`, throw the same `TypeError`; otherwise seed `acc = O[k]` and increment `k`.\n5. For `k` from current value up to `len − 1`, if `k in O`, call `callbackFn(acc, O[k], k, O)` and store the result.\n6. Return `acc`.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = Math.max(0, Math.floor(Number(O.length) || 0));\n  let k = 0;\n  let acc;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue;\n  } else {\n    while (k < len && !(k in O)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) {\n    if (k in O) acc = callbackFn(acc, O[k], k, O);\n  }\n  return acc;\n};\n",
          "codeTs": "Array.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as Record<number, T> & { length: number };\n  const len: number = Math.max(0, Math.floor(Number(O.length) || 0));\n  let k = 0;\n  let acc: any;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue as U;\n  } else {\n    while (k < len && !(k in O)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) {\n    if (k in O) acc = (callbackFn as any)(acc, O[k], k, O as any);\n  }\n  return acc as any;\n};\n"
        },
        {
          "title": "Approach 3: Helper-driven (readability: `nextPresentIndex`)",
          "prose": "Extract the \"find next present element\" logic into a tiny helper. This makes the seeding + iteration steps very explicit and easy to reason about for sparse arrays.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = O.length >>> 0;\n  const nextPresentIndex = (start) => {\n    let i = start;\n    while (i < len && !Object.prototype.hasOwnProperty.call(O, i)) i++;\n    return i;\n  };\n  let k = 0;\n  let acc;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue;\n    k = nextPresentIndex(0);\n  } else {\n    k = nextPresentIndex(0);\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (k = nextPresentIndex(k); k < len; k = nextPresentIndex(k + 1)) {\n    acc = callbackFn(acc, O[k], k, O);\n  }\n  return acc;\n};\n",
          "codeTs": "Array.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as T[] & { length: number };\n  const len: number = O.length >>> 0;\n  const hasOwn = Object.prototype.hasOwnProperty;\n  const nextPresentIndex = (start: number): number => {\n    let i = start;\n    while (i < len && !hasOwn.call(O, i)) i++;\n    return i;\n  };\n  let k = 0;\n  let acc: any;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue as U;\n    k = nextPresentIndex(0);\n  } else {\n    k = nextPresentIndex(0);\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = (O as any)[k++];\n  }\n  for (k = nextPresentIndex(k); k < len; k = nextPresentIndex(k + 1)) {\n    acc = (callbackFn as any)(acc, (O as any)[k], k, O);\n  }\n  return acc as any;\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using `this[0]` as the seed even when index 0 is a hole — must scan for the **first present** element.",
          "Forgetting to skip holes (use own-property checks or `k in O` as appropriate).",
          "Not throwing on an empty array when `initialValue` is omitted.",
          "Real `.reduce()` also throws if `callbackFn` is not a function; these implementations assume a valid function and skip that check (good interview talking point)."
        ],
        "edgeCases": [
          "All holes (e.g., `[,,,]`) with no `initialValue` → throw `TypeError`.",
          "Arrays with leading holes (e.g., `[,1,,3]`) → seed from `1` when `initialValue` is omitted.",
          "Arrays with getters on inherited indices: if you use `k in O`, inherited accessors may participate."
        ],
        "techniques": [
          "Coerce the receiver with `Object(this)` before reading `length`.",
          "Seed from `initialValue` when provided; otherwise scan for the first present element.",
          "Use `hasOwnProperty.call(O, k)` to skip holes consistently, or `k in O` when you want inherited index behavior."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-map",
        "js-array-prototype-filter",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        },
        {
          "title": "ECMAScript Spec (Reduce)",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.reduce"
        }
      ]
    },
    "notes": {
      "pitfalls": [
        "Using `this[0]` as the seed even when index 0 is a hole — must scan for the **first present** element.",
        "Forgetting to skip holes (use own-property checks or `k in O` as appropriate).",
        "Not throwing on an empty array when `initialValue` is omitted."
      ],
      "edgeCases": [
        "All holes (e.g., `[,,,]`) with no `initialValue` → throw `TypeError`.",
        "Arrays with leading holes (e.g., `[,1,,3]`) → seed from `1` when `initialValue` is omitted.",
        "Arrays with getters on inherited indices: if you use `k in O`, inherited accessors may participate."
      ],
      "techniques": [
        "Coerce the receiver with `Object(this)` before reading `length`.",
        "Seed from `initialValue` when provided; otherwise scan for the first present element.",
        "Use `hasOwnProperty.call(O, k)` to skip holes consistently."
      ]
    },
    "followUpQuestions": [
      "js-array-prototype-map",
      "js-array-prototype-filter",
      "js-array-prototype-some"
    ],
    "resources": [
      {
        "title": "MDN – Array.prototype.reduce()",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
      },
      {
        "title": "ECMAScript Spec (Reduce)",
        "url": "https://tc39.es/ecma262/#sec-array.prototype.reduce"
      }
    ],
    "tests": "const sum = (a, x) => a + x;\nconst pair = (a, x, i) => a.concat([[i, x]]);\n\n// helper for throw assertions (no toThrow in this runner)\nconst expectThrowsTypeError = (fn) => {\n  let ok = false;\n  try { fn(); } catch (e) { ok = e instanceof TypeError; }\n  expect(ok).toBe(true);\n};\n\ndescribe('Array.prototype.myReduce', () => {\n  test('with initialValue on dense arrays', () => {\n    expect([1, 2, 3].myReduce(sum, 0)).toBe(6);\n    expect([5].myReduce(sum, 10)).toBe(15);\n  });\n\n  test('without initialValue uses first existing element (handles leading holes)', () => {\n    const a = [, 1, , 3];\n    expect(a.myReduce(sum)).toBe(4);\n  });\n\n  test('skips holes (sparse arrays) with initialValue', () => {\n    const a = [, 1, , 3];\n    expect(a.myReduce(sum, 0)).toBe(4);\n  });\n\n  test('passes index and array correctly', () => {\n    const out = [10, 20].myReduce(pair, []);\n    expect(out).toEqual([[0, 10], [1, 20]]);\n  });\n\n  test('empty array with initialValue returns initialValue', () => {\n    expect([].myReduce(sum, 42)).toBe(42);\n  });\n\n  test('empty array without initialValue throws TypeError', () => {\n    expectThrowsTypeError(() => [].myReduce(sum));\n  });\n});\n",
    "testsTs": "// @ts-nocheck\nconst _shimReduce = (arr, cb, initProvided, initVal) => {\n  const len = arr.length;\n  let k = 0;\n  let acc;\n  if (initProvided) {\n    acc = initVal;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(arr, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = arr[k++];\n  }\n  for (; k < len; k++) if (Object.prototype.hasOwnProperty.call(arr, k)) acc = cb(acc, arr[k], k, arr);\n  return acc;\n};\n\nconst callReduce = (arr, cb, ...rest) =>\n  typeof arr.myReduce === 'function'\n    ? arr.myReduce(cb, ...rest)\n    : _shimReduce(arr, cb, rest.length > 0, rest[0]);\n\nconst sum = (a, x) => a + x;\n\nconst expectThrowsTypeError = (fn) => {\n  let ok = false; try { fn(); } catch (e) { ok = e instanceof TypeError; } expect(ok).toBe(true);\n};\n\ndescribe('Array.prototype.myReduce (TS)', () => {\n  test('sum with initialValue', () => {\n    expect(callReduce([1, 2, 3], sum, 0)).toBe(6);\n  });\n  test('sum without initialValue (holes at start)', () => {\n    expect(callReduce([,1,,3], sum)).toBe(4);\n  });\n  test('sparse array skipping with initialValue', () => {\n    expect(callReduce([,1,,3], sum, 0)).toBe(4);\n  });\n  test('empty + initial returns initial', () => {\n    expect(callReduce([], sum, 7)).toBe(7);\n  });\n  test('empty without initial throws', () => {\n    expectThrowsTypeError(() => callReduce([], sum));\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-array-prototype-filter",
    "title": "Implement Array.prototype.filter",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "amazon",
      "apple"
    ],
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "callbacks",
      "iteration",
      "polyfills",
      "core-js"
    ],
    "description": {
      "summary": "Recreate the native `Array.prototype.filter()` method as `myFilter`. It should call a provided callback once for each existing element in the array, include the element in the new array if the callback returns a truthy value, **skip holes** in sparse arrays, and support an optional `thisArg` for context. Your implementation must snapshot the initial `length` and must not visit elements appended beyond that length during iteration (native behavior).",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "function",
          "desc": "Predicate function called as `(element, index, array)`."
        },
        {
          "name": "thisArg",
          "type": "any",
          "desc": "Value to use as `this` when executing `callbackFn`."
        }
      ],
      "returns": {
        "type": "Array",
        "desc": "A new array with elements that passed the test implemented by `callbackFn`."
      },
      "examples": [
        "// Filter even numbers\n[1, 2, 3, 4, 5].myFilter(n => n % 2 === 0) // => [2, 4]",
        "// Filter by context\n[1, 2, 3, 4, 5].myFilter(function(n) { return n > this.min; }, { min: 3 }) // => [4, 5]"
      ]
    },
    "starterCode": "Array.prototype.myFilter = function(callbackFn, thisArg) {\n  // TODO: Implement Array.prototype.filter behavior.\n  // Requirements:\n  // - Skip holes in sparse arrays\n  // - Support thisArg\n  // - Snapshot initial length (do not iterate appended elements beyond the initial length)\n  throw new Error('Not implemented');\n};\n",
    "starterCodeTs": "interface Array<T> {\n  myFilter(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];\n}\n\nArray.prototype.myFilter = function<T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[] {\n  // TODO: Implement Array.prototype.filter behavior.\n  // Requirements:\n  // - Skip holes in sparse arrays\n  // - Support thisArg\n  // - Snapshot initial length (do not iterate appended elements beyond the initial length)\n  throw new Error('Not implemented');\n};\n",
    "solutionBlock": {
      "overview": "Goal: implement a `.filter()`-like method that iterates indices `0..len-1` where `len` is snapshotted once, calls the predicate with `(value, index, array)`, **skips holes**, respects `thisArg`, and returns a **new** array of values for which the predicate is truthy.",
      "approaches": [
        {
          "title": "Single approach: for-loop + own-property check (skip holes + length snapshot)",
          "prose": "Core rules to match native behavior:\n- Snapshot `len` once at the start.\n- Only call the predicate for indices that exist (skip holes).\n- Do not visit elements appended beyond the initial `len`.\n- Pass `(value, index, array)` and bind `thisArg`.\n\nSpec note (1 line): Native `filter` conceptually uses `k in O` (includes inherited numeric keys). For interview/polyfill practice we use own-property checks to focus on holes + length snapshot behavior.",
          "codeJs": "Array.prototype.myFilter = function(callbackFn, thisArg) {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n\n  const arr = Object(this);\n  const len = arr.length >>> 0; // snapshot length once\n  const result = [];\n\n  for (let i = 0; i < len; i++) {\n    // skip holes (and skip indices that were never present)\n    if (Object.prototype.hasOwnProperty.call(arr, i)) {\n      const val = arr[i];\n      if (callbackFn.call(thisArg, val, i, arr)) {\n        result.push(val);\n      }\n    }\n  }\n\n  return result;\n};\n",
          "codeTs": "interface Array<T> {\n  myFilter(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];\n}\n\nArray.prototype.myFilter = function<T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[] {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n\n  const arr = Object(this) as { [k: number]: T; length: number };\n  const len = arr.length >>> 0; // snapshot length once\n  const result: T[] = [];\n\n  for (let i = 0; i < len; i++) {\n    if (Object.prototype.hasOwnProperty.call(arr, i)) {\n      const val = arr[i];\n      if (callbackFn.call(thisArg, val, i, arr as any)) {\n        result.push(val);\n      }\n    }\n  }\n\n  return result;\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to snapshot `length` can cause your loop to visit appended elements (native `filter` does not).",
          "Calling the predicate for holes — use an existence check (`Object.prototype.hasOwnProperty.call`) before reading/calling.",
          "`thisArg` does not affect arrow functions because arrows don’t have their own `this`."
        ],
        "edgeCases": [
          "Sparse arrays: `[1, , 3]` should not call the predicate for the missing index and should return `[1, 3]` when predicate is always true.",
          "Mutations during iteration: deleted elements should not be visited if they become holes before the index is reached; appended elements beyond the initial length should not be visited."
        ],
        "techniques": [
          "`Object(this)` to safely handle array-like receivers.",
          "`len = arr.length >>> 0` to coerce and snapshot length once.",
          "Existence check with `Object.prototype.hasOwnProperty.call(arr, i)` to skip holes.",
          "`.call(thisArg, value, index, array)` for context binding."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-map",
        "js-array-prototype-reduce",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        },
        {
          "title": "ECMAScript Spec (Filter)",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.filter"
        }
      ]
    },
    "tests": "describe('Array.prototype.myFilter', () => {\n  test('filters even numbers', () => {\n    const res = [1, 2, 3, 4, 5].myFilter(x => x % 2 === 0);\n    expect(res).toEqual([2, 4]);\n  });\n\n  test('returns empty array when nothing matches', () => {\n    const res = [1, 3, 5].myFilter(x => x % 2 === 0);\n    expect(res).toEqual([]);\n  });\n\n  test('does not mutate original array', () => {\n    const arr = [1, 2, 3];\n    arr.myFilter(x => x > 1);\n    expect(arr).toEqual([1, 2, 3]);\n  });\n\n  test('uses thisArg correctly', () => {\n    const ctx = { min: 3 };\n    const res = [1, 2, 3, 4, 5].myFilter(function(x) { return x > this.min; }, ctx);\n    expect(res).toEqual([4, 5]);\n  });\n\n  test('skips holes in sparse arrays', () => {\n    const arr = [1, , 3];\n    const res = arr.myFilter(() => true);\n    expect(res).toEqual([1, 3]);\n  });\n\n  test('snapshots length (does not visit appended elements beyond initial length)', () => {\n    const arr = [1, 2, 3];\n    const seen = [];\n\n    const res = arr.myFilter((v, i, a) => {\n      seen.push(v);\n      if (i === 0) a.push(999); // appended beyond initial length\n      return true;\n    });\n\n    expect(res).toEqual([1, 2, 3]);\n    expect(seen).toEqual([1, 2, 3]);\n  });\n\n  test('skips elements deleted before their turn (becomes a hole)', () => {\n    const arr = [1, 2, 3];\n    const seen = [];\n\n    const res = arr.myFilter((v, i, a) => {\n      if (i === 0) delete a[1];\n      seen.push(v);\n      return true;\n    });\n\n    // index 1 was deleted before iteration reached it => skip it\n    expect(res).toEqual([1, 3]);\n    expect(seen).toEqual([1, 3]);\n  });\n});\n",
    "testsTs": "describe('Array.prototype.myFilter (TypeScript)', () => {\n  it('should filter even numbers', () => {\n    const result = [1, 2, 3, 4, 5].myFilter(n => n % 2 === 0);\n    expect(result).toEqual([2, 4]);\n  });\n\n  it('should handle empty results correctly', () => {\n    const result = [1, 3, 5].myFilter(n => n % 2 === 0);\n    expect(result).toEqual([]);\n  });\n\n  it('should use thisArg for context', () => {\n    const ctx = { min: 3 };\n    const result = [1, 2, 3, 4, 5].myFilter(function(x) { return x > this.min; }, ctx);\n    expect(result).toEqual([4, 5]);\n  });\n\n  it('snapshots length (does not visit appended elements)', () => {\n    const arr = [1, 2, 3];\n    const seen: number[] = [];\n\n    const res = arr.myFilter((v, i, a) => {\n      seen.push(v);\n      if (i === 0) (a as any).push(999);\n      return true;\n    });\n\n    expect(res).toEqual([1, 2, 3]);\n    expect(seen).toEqual([1, 2, 3]);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-array-foreach",
    "title": "Implement arrayForEach (no prototype mutation)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "iteration",
      "callbacks",
      "edge-cases"
    ],
    "description": {
      "summary": "Write an `arrayForEach(arr, callbackFn, thisArg?)` helper (do NOT touch prototypes). It must iterate left→right over indices `0..len-1` where `len` is snapshotted once at the start, **skip holes**, bind `thisArg` for non-arrow callbacks, and return `undefined`. It must not visit elements appended beyond the initial length, and it must skip elements deleted before their index is reached.",
      "arguments": [
        {
          "name": "arr",
          "type": "Array<any>",
          "desc": "Source array to iterate. Sparse slots must be skipped."
        },
        {
          "name": "callbackFn",
          "type": "(value:any, index:number, array:any[]) => void",
          "desc": "Function to invoke for each present element."
        },
        {
          "name": "thisArg",
          "type": "any (optional)",
          "desc": "Value of `this` inside `callbackFn`."
        }
      ],
      "returns": {
        "type": "void",
        "desc": "No return value (returns `undefined`)."
      },
      "examples": [
        "// Sum values\nlet sum = 0; arrayForEach([1,2,3], v => { sum += v; }); // sum = 6",
        "// Respect thisArg\nconst ctx = { seen: [] }; arrayForEach(['a','b'], function (v) { this.seen.push(v); }, ctx); // ctx.seen = ['a','b']",
        "// Skip holes\nconst a = [1, , 3]; arrayForEach(a, (v, i) => { /* called for i=0 and i=2 only */ });"
      ]
    },
    "starterCode": "export default function arrayForEach(arr, callbackFn, thisArg) {\n  // Requirements:\n  // - Snapshot initial length (do not visit appended elements beyond initial length)\n  // - Skip holes (sparse slots)\n  // - Skip elements deleted before their index is reached\n  // - Bind thisArg using .call\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function arrayForEach<T>(\n  arr: (T | undefined)[],\n  callbackFn: (value: T, index: number, array: (T | undefined)[]) => void,\n  thisArg?: any,\n): void {\n  // Requirements:\n  // - Snapshot initial length (do not visit appended elements beyond initial length)\n  // - Skip holes (sparse slots)\n  // - Skip elements deleted before their index is reached\n  // - Bind thisArg using .call\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Behave like native `Array.prototype.forEach` (but as a helper): snapshot `length` once, iterate left→right, call the callback only for existing indices (skip holes), bind `thisArg`, and return `undefined`.",
      "approaches": [
        {
          "title": "Single approach: length snapshot + own-property check (recommended)",
          "prose": "Core lesson = native iteration semantics.\n\nRules implemented:\n- Snapshot `len = arr.length` once.\n- For each `i` in `0..len-1`, only call the callback if the index exists (not a hole).\n- If an element is deleted before its turn, it becomes a hole and is skipped.\n- Elements appended beyond the initial `len` are not visited.\n\nWhy it works:\n- `hasOwnProperty` checks existence at the time of visit (captures delete-before-visit behavior).\n- Snapshot length prevents chasing new pushes.",
          "codeJs": "export default function arrayForEach(arr, callbackFn, thisArg) {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n\n  const len = arr.length; // snapshot once\n  const hasOwn = Object.prototype.hasOwnProperty;\n\n  for (let i = 0; i < len; i++) {\n    if (hasOwn.call(arr, i)) {\n      callbackFn.call(thisArg, arr[i], i, arr);\n    }\n  }\n\n  return undefined;\n}\n",
          "codeTs": "export default function arrayForEach<T>(\n  arr: (T | undefined)[],\n  callbackFn: (value: T, index: number, array: (T | undefined)[]) => void,\n  thisArg?: any,\n): void {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n\n  const len = arr.length; // snapshot once\n  const hasOwn = Object.prototype.hasOwnProperty;\n\n  for (let i = 0; i < len; i++) {\n    if (hasOwn.call(arr, i)) {\n      callbackFn.call(thisArg, arr[i] as T, i, arr);\n    }\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "If you use `for (let i = 0; i < arr.length; i++)`, you may accidentally iterate elements appended during iteration.",
          "If you don’t check for existence, you’ll call the callback on holes (native forEach skips them).",
          "`thisArg` won’t affect arrow functions (they don’t bind `this`)."
        ],
        "edgeCases": [
          "Sparse arrays like `[1, , 3]`: callback runs for indices 0 and 2 only.",
          "Delete-before-visit: if index 1 is deleted while processing index 0, index 1 must be skipped.",
          "Push-during-iteration: elements appended after the call starts must not be visited."
        ],
        "techniques": [
          "Snapshot length once.",
          "Use `hasOwnProperty.call(arr, i)` to skip holes and to respect delete-before-visit.",
          "Use `.call(thisArg, value, index, array)` to bind context."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-map",
        "js-array-prototype-filter",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.forEach()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"
        },
        {
          "title": "ECMAScript Spec – Array.prototype.forEach",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.foreach"
        }
      ]
    },
    "tests": "import arrayForEach from './file';\n\ndescribe('arrayForEach', () => {\n  test('iterates in order', () => {\n    const seen = [];\n    arrayForEach([3, 1, 2], (v) => seen.push(v));\n    expect(seen).toEqual([3, 1, 2]);\n  });\n\n  test('binds thisArg', () => {\n    const ctx = { out: '' };\n    arrayForEach(['a', 'b'], function (v) { this.out += v; }, ctx);\n    expect(ctx.out).toBe('ab');\n  });\n\n  test('skips holes (sparse arrays)', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a = [1, , 3];\n    const seen = [];\n    arrayForEach(a, (v, i) => seen.push([v, i]));\n    expect(seen).toEqual([[1, 0], [3, 2]]);\n  });\n\n  test('snapshots length (push during iteration not visited)', () => {\n    const arr = [1, 2, 3];\n    const seen = [];\n\n    arrayForEach(arr, (v, i, a) => {\n      seen.push(v);\n      if (i === 0) a.push(999);\n    });\n\n    expect(seen).toEqual([1, 2, 3]);\n  });\n\n  test('skips elements deleted before their turn (hole check)', () => {\n    const arr = [1, 2, 3];\n    const seen = [];\n\n    arrayForEach(arr, (v, i, a) => {\n      if (i === 0) delete a[1];\n      seen.push(v);\n    });\n\n    // index 1 was deleted before iteration reached it => skip it\n    expect(seen).toEqual([1, 3]);\n  });\n});\n",
    "testsTs": "import arrayForEach from './file';\n\ndescribe('arrayForEach (TypeScript)', () => {\n  it('iterates in order', () => {\n    const a = [3, 1, 2];\n    const seen: number[] = [];\n    arrayForEach(a, (v) => { seen.push(v as number); });\n    expect(seen).toEqual([3, 1, 2]);\n  });\n\n  it('binds thisArg', () => {\n    const ctx = { out: '' };\n    arrayForEach(['a', 'b'], function(v) { this.out += v; }, ctx);\n    expect(ctx.out).toBe('ab');\n  });\n\n  it('skips holes (sparse arrays)', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a = [1, , 3];\n    const seen: Array<[number, number]> = [];\n    arrayForEach(a, (v, i) => { if (v !== undefined) seen.push([v as number, i]); });\n    expect(seen).toEqual([[1, 0], [3, 2]]);\n  });\n\n  it('snapshots length (push during iteration not visited)', () => {\n    const arr = [1, 2, 3];\n    const seen: number[] = [];\n\n    arrayForEach(arr, (v, i, a) => {\n      seen.push(v as number);\n      if (i === 0) (a as any).push(999);\n    });\n\n    expect(seen).toEqual([1, 2, 3]);\n  });\n\n  it('skips elements deleted before their turn (hole check)', () => {\n    const arr = [1, 2, 3];\n    const seen: number[] = [];\n\n    arrayForEach(arr, (v, i, a) => {\n      if (i === 0) delete (a as any)[1];\n      seen.push(v as number);\n    });\n\n    expect(seen).toEqual([1, 3]);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-array-sort",
    "title": "Sort Numbers with Array.prototype.sort",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "amazon"
    ],
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "sorting"
    ],
    "description": {
      "summary": "Implement a function `sortNumbers(arr, ascending = true)` that returns a **new array** of numbers sorted numerically in ascending or descending order. The original array must not be mutated, and you should use `Array.prototype.sort()` correctly with a compare function.",
      "arguments": [
        {
          "name": "arr",
          "type": "number[]",
          "desc": "An array of numbers to sort."
        },
        {
          "name": "ascending",
          "type": "boolean",
          "desc": "If `true` (default), sort in ascending order; if `false`, sort in descending order."
        }
      ],
      "returns": {
        "type": "number[]",
        "desc": "A new array containing the sorted numbers."
      },
      "examples": [
        "// Basic ascending sort\nsortNumbers([3, 1, 10]) // => [1, 3, 10]",
        "// Descending sort\nsortNumbers([3, 1, 10], false) // => [10, 3, 1]",
        "// Handles negative numbers\nsortNumbers([-2, 5, 0, -10]) // => [-10, -2, 0, 5]",
        "// Original array is not mutated\nconst nums = [5, 2, 11]\nconst sorted = sortNumbers(nums)\n// nums is still [5, 2, 11]"
      ]
    },
    "starterCode": "export default function sortNumbers(arr, ascending = true) {\n  // TODO:\n  // 1. Do NOT mutate the original array.\n  // 2. Use Array.prototype.sort() with a numeric compare function.\n  // 3. Respect the `ascending` flag.\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function sortNumbers(arr: number[], ascending = true): number[] {\n  // TODO:\n  // 1. Do NOT mutate the original array.\n  // 2. Use Array.prototype.sort() with a numeric compare function.\n  // 3. Respect the `ascending` flag.\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: sort an array of numbers **numerically**, not lexicographically, using `Array.prototype.sort()` — and return a **new** sorted array without mutating the original.\n\nThis tests understanding of:\n- How `.sort()` works by default (string/lexicographic behavior).\n- Writing a numeric compare function (`(a, b) => a - b`).\n- Avoiding mutation by cloning the input first.",
      "approaches": [
        {
          "title": "Approach 1: Clone + numeric compare function (canonical)",
          "prose": "Idea: make a shallow copy of the array, then call `.sort()` with a numeric compare function that respects the `ascending` flag.\n\nHow it works\n1) Clone the input: `const copy = [...arr]` (or `arr.slice()`) so the original is never mutated.\n2) Choose the compare function based on `ascending`:\n   - If `ascending` is `true`, return `a - b`.\n   - If `ascending` is `false`, return `b - a`.\n3) Call `copy.sort(compareFn)` and return `copy`.\n\nWhy it works\n- Explicit numeric comparison avoids the default lexicographic sort like `[10, 2].sort()`.\n- The `ascending` flag is handled in one place, inside the compare function.\n- Sorting the cloned array keeps the original array intact.\n\nComplexity\n- Time: typically O(n log n) for the sort.\n- Space: O(n) for the cloned array (plus whatever the engine uses internally for sorting).",
          "codeJs": "export default function sortNumbers(arr, ascending = true) {\n  // Clone to avoid mutating the original\n  const copy = [...arr];\n\n  copy.sort((a, b) => {\n    if (ascending) {\n      return a - b; // negative if a < b, positive if a > b\n    }\n    return b - a;   // flipped for descending\n  });\n\n  return copy;\n}\n",
          "codeTs": "export default function sortNumbers(arr: number[], ascending = true): number[] {\n  // Clone to avoid mutating the original\n  const copy = [...arr];\n\n  copy.sort((a, b) => {\n    if (ascending) {\n      return a - b; // negative if a < b, positive if a > b\n    }\n    return b - a;   // flipped for descending\n  });\n\n  return copy;\n}\n"
        },
        {
          "title": "Approach 2: Always sort ascending, then reverse if needed",
          "prose": "Idea: keep the compare function minimal by always sorting ascending, then reverse the array when `ascending` is `false`.\n\nHow it works\n1) Clone the input: `const copy = [...arr]`.\n2) Sort numerically ascending: `copy.sort((a, b) => a - b)`.\n3) If `ascending` is `false`, call `copy.reverse()`.\n4) Return `copy`.\n\nWhy it works\n- The compare function is fixed and easy to read.\n- The ascending/descending choice is expressed directly via `reverse()`.\n\nComplexity\n- Time: O(n log n) for `sort` + O(n) for `reverse()`.\n- Space: O(n) for the cloned array.",
          "codeJs": "export default function sortNumbers(arr, ascending = true) {\n  const copy = [...arr];\n  copy.sort((a, b) => a - b); // numeric ascending\n  if (!ascending) {\n    copy.reverse();\n  }\n  return copy;\n}\n",
          "codeTs": "export default function sortNumbers(arr: number[], ascending = true): number[] {\n  const copy = [...arr];\n  copy.sort((a, b) => a - b); // numeric ascending\n  if (!ascending) {\n    copy.reverse();\n  }\n  return copy;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Default `.sort()` casts values to strings and sorts lexicographically: `[10, 2].sort()` → `[10, 2]`, not `[2, 10]`.",
          "`.sort()` **mutates** the array it’s called on — always clone when you must not change the input.",
          "Compare functions must return a negative value if `a` comes before `b`, positive if `a` comes after `b`, and `0` if their relative order doesn’t matter.",
          "If `arr` contains non-numbers (`NaN`, strings, etc.), numeric comparison can produce surprising results. In this kata we assume valid numbers."
        ],
        "edgeCases": [
          "Empty array → returns `[]`.",
          "Single-element array → unchanged.",
          "Already sorted array → returns a sorted copy; original is still intact.",
          "All equal numbers → order is effectively unchanged."
        ],
        "techniques": [
          "Using spread syntax (`[...]`) or `.slice()` to clone arrays.",
          "Writing numeric compare functions for `.sort()`.",
          "Controlling sort direction with a flag.",
          "Understanding mutation vs. immutability when working with arrays."
        ]
      },
      "followUpQuestions": [
        "js-unique-array",
        "js-flatten-once"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.sort()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"
        },
        {
          "title": "MDN – Array.prototype.reverse()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse"
        }
      ]
    },
    "tests": "import sortNumbers from './sortNumbers';\n\ndescribe('sortNumbers', () => {\n  test('sorts numbers ascending by default', () => {\n    expect(sortNumbers([3, 1, 10])).toEqual([1, 3, 10]);\n    expect(sortNumbers([-2, 5, 0, -10])).toEqual([-10, -2, 0, 5]);\n  });\n\n  test('sorts numbers descending when ascending is false', () => {\n    expect(sortNumbers([3, 1, 10], false)).toEqual([10, 3, 1]);\n    expect(sortNumbers([-2, 5, 0, -10], false)).toEqual([5, 0, -2, -10]);\n  });\n\n  test('does not mutate the original array', () => {\n    const nums = [5, 2, 11];\n    const copy = [...nums];\n    const sorted = sortNumbers(nums);\n\n    expect(sorted).toEqual([2, 5, 11]);\n    expect(nums).toEqual(copy); // original remains unchanged\n  });\n\n  test('handles empty and single-element arrays', () => {\n    expect(sortNumbers([])).toEqual([]);\n    expect(sortNumbers([42])).toEqual([42]);\n  });\n});\n",
    "testsTs": "import sortNumbers from './sortNumbers';\n\ndescribe('sortNumbers (TypeScript)', () => {\n  it('sorts numbers ascending by default', () => {\n    expect(sortNumbers([3, 1, 10])).toEqual([1, 3, 10]);\n    expect(sortNumbers([-2, 5, 0, -10])).toEqual([-10, -2, 0, 5]);\n  });\n\n  it('sorts numbers descending when ascending is false', () => {\n    expect(sortNumbers([3, 1, 10], false)).toEqual([10, 3, 1]);\n    expect(sortNumbers([-2, 5, 0, -10], false)).toEqual([5, 0, -2, -10]);\n  });\n\n  it('does not mutate the original array', () => {\n    const nums = [5, 2, 11];\n    const copy = [...nums];\n    const sorted = sortNumbers(nums);\n\n    expect(sorted).toEqual([2, 5, 11]);\n    expect(nums).toEqual(copy);\n  });\n\n  it('handles empty and single-element arrays', () => {\n    expect(sortNumbers([])).toEqual([]);\n    expect(sortNumbers([42])).toEqual([42]);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-create-counter",
    "title": "Create a Counter Function",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "closure",
      "functions",
      "increment",
      "state"
    ],
    "description": {
      "summary": "Implement `createCounter(n)` that returns a counter function. The **first** call should return `n`, the next call `n + 1`, then `n + 2`, and so on. Each counter instance must keep its own state via a closure. This tests closure scope and persistent state handling.",
      "arguments": [
        {
          "name": "n",
          "type": "number",
          "desc": "The starting integer for the counter."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A function that returns the current integer and then increments its internal state for the next call."
      },
      "examples": [
        "// Example 1\nconst counter = createCounter(10);\ncounter(); // => 10\ncounter(); // => 11\ncounter(); // => 12",
        "// Example 2\nconst counter = createCounter(-2);\ncounter(); // => -2\ncounter(); // => -1\ncounter(); // => 0"
      ]
    },
    "starterCode": "export default function createCounter(n) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function createCounter(n: number): () => number {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: use a closure so each call to `createCounter` produces an independent function that remembers its own `n`, returns the current value, and then increments `n` for the next call.",
      "approaches": [
        {
          "title": "Approach: Closure-based counter (recommended)",
          "prose": "Idea\nCapture the starting value `n` in the outer function, and have the inner function both read and update it. Each call returns the current value and then increments `n`.\n\nHow it works\n1) `createCounter` takes `n` and defines an inner function.\n2) Inside the inner function, store the current value in a local `current`.\n3) Increment `n` so the next call sees `n + 1`.\n4) Return `current`.\n\nWhy it works\n- JavaScript closures let the inner function keep access to `n` even after `createCounter` has returned.\n- Each call to `createCounter` creates a new `n` binding, so counters are independent.\n\nComplexity\n- Time: O(1) per call.\n- Space: O(1) per counter (just the captured number).",
          "codeJs": "export default function createCounter(n) {\n  return function() {\n    const current = n;\n    n += 1;\n    return current;\n  };\n}\n",
          "codeTs": "export default function createCounter(n: number): () => number {\n  return function(): number {\n    const current = n;\n    n += 1;\n    return current;\n  };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using a global variable will share state across all counters — use a closure per instance.",
          "Returning `++n` vs. current value changes behavior (off-by-one). This task expects returning the current and then incrementing.",
          "Mutating objects captured in closures can cause shared state; here we keep only a primitive number."
        ],
        "edgeCases": [
          "Negative starts (e.g., `-2`) should count upward correctly.",
          "Large numbers work until you hit `Number.MAX_SAFE_INTEGER` (then precision issues can appear).",
          "Multiple counters created from separate calls must not interfere with each other."
        ],
        "techniques": [
          "Leverage lexical scoping: inner function closes over `n`.",
          "Prefer returning a function over exposing mutable objects to keep encapsulation tight."
        ]
      },
      "followUpQuestions": [
        "js-memoize-function"
      ],
      "resources": [
        {
          "title": "MDN – Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        },
        {
          "title": "You Don’t Know JS Yet – Scope & Closures (free book)",
          "url": "https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures"
        }
      ]
    },
    "tests": "import createCounter from './file';\n\ndescribe('createCounter', () => {\n  test('increments sequentially', () => {\n    const counter = createCounter(10);\n    expect(counter()).toBe(10);\n    expect(counter()).toBe(11);\n    expect(counter()).toBe(12);\n  });\n\n  test('works with negative numbers', () => {\n    const counter = createCounter(-2);\n    expect(counter()).toBe(-2);\n    expect(counter()).toBe(-1);\n    expect(counter()).toBe(0);\n  });\n\n  test('separate counters maintain independent state', () => {\n    const c1 = createCounter(0);\n    const c2 = createCounter(100);\n    expect(c1()).toBe(0);\n    expect(c2()).toBe(100);\n    expect(c1()).toBe(1);\n    expect(c2()).toBe(101);\n  });\n});\n",
    "testsTs": "import createCounter from './file';\n\ndescribe('createCounter (TypeScript)', () => {\n  it('increments sequentially', () => {\n    const counter = createCounter(5);\n    expect(counter()).toBe(5);\n    expect(counter()).toBe(6);\n    expect(counter()).toBe(7);\n  });\n\n  it('works with negative numbers', () => {\n    const counter = createCounter(-2);\n    expect(counter()).toBe(-2);\n    expect(counter()).toBe(-1);\n    expect(counter()).toBe(0);\n  });\n\n  it('independent counters maintain separate state', () => {\n    const c1 = createCounter(1);\n    const c2 = createCounter(50);\n    expect(c1()).toBe(1);\n    expect(c2()).toBe(50);\n    expect(c1()).toBe(2);\n    expect(c2()).toBe(51);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-is-object-empty",
    "title": "Check if an Object or Array is Empty",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "objects",
      "arrays",
      "basics",
      "validation"
    ],
    "description": {
      "summary": "Implement `isEmpty(obj)` that returns `true` only if the input is an object or array with no own keys/elements, and `false` otherwise. For non-object/array inputs (like numbers or strings), the function should throw a `TypeError`.",
      "arguments": [
        {
          "name": "obj",
          "type": "Object | Array",
          "desc": "An object or array parsed from JSON."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "Returns `true` if the object/array is empty; otherwise `false`."
      },
      "examples": [
        "// Example 1\nisEmpty({ x: 5, y: 42 }); // => false",
        "// Example 2\nisEmpty({}); // => true",
        "// Example 3\nisEmpty([null, false, 0]); // => false",
        "// Example 4\nisEmpty([]); // => true"
      ]
    },
    "starterCode": "export default function isEmpty(obj) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function isEmpty(obj: Record<string, any> | any[]): boolean {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: implement `isEmpty(obj)` so that it returns `true` only when the input is an array with length 0 or an object whose own enumerable keys list is empty, and throws a `TypeError` for non-object/array inputs.",
      "approaches": [
        {
          "title": "Approach: Handle arrays and objects separately",
          "prose": "1. **Array check:** If `Array.isArray(obj)` is true, simply return whether `obj.length === 0`.\n2. **Object check:** If `obj` is non-null and `typeof obj === 'object'`, get its own enumerable keys with `Object.keys(obj)` and check if that list is empty.\n3. **Invalid input:** For any other type (number, string, boolean, etc.), throw a `TypeError` to signal misuse.\n4. **Return result:** Return a boolean indicating emptiness for arrays/objects.",
          "codeJs": "export default function isEmpty(obj) {\n  if (Array.isArray(obj)) return obj.length === 0;\n  if (obj && typeof obj === 'object') return Object.keys(obj).length === 0;\n  throw new TypeError('Expected object or array');\n}\n",
          "codeTs": "export default function isEmpty(obj: Record<string, any> | any[]): boolean {\n  if (Array.isArray(obj)) return obj.length === 0;\n  if (obj && typeof obj === 'object') return Object.keys(obj).length === 0;\n  throw new TypeError('Expected object or array');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Checking `Object.keys()` on `null` or `undefined` will throw — always guard with `obj && typeof obj === 'object'`.",
          "Strings also have `.length`, but should not be considered valid inputs here (this implementation throws `TypeError` for them).",
          "Prototype-inherited properties are ignored by `Object.keys()`, which is correct for this task."
        ],
        "edgeCases": [
          "`[]` → true (no elements).",
          "`{}` → true (no keys).",
          "`[null, false, 0]` → false (contains items even if falsy).",
          "`Object.create(null)` → true (no enumerable keys).",
          "Non-object/array inputs like `42` or `'hi'` → `TypeError`."
        ],
        "techniques": [
          "Use `Array.isArray()` for accurate array detection.",
          "Prefer `Object.keys()` over `for...in` to ignore prototype properties."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN – Object.keys()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"
        },
        {
          "title": "MDN – Array.isArray()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
        }
      ]
    },
    "tests": "import isEmpty from './file';\n\ndescribe('isEmpty', () => {\n  test('returns false for non-empty object', () => {\n    expect(isEmpty({ x: 5, y: 42 })).toBe(false);\n  });\n\n  test('returns true for empty object', () => {\n    expect(isEmpty({})).toBe(true);\n  });\n\n  test('returns false for non-empty array', () => {\n    expect(isEmpty([null, false, 0])).toBe(false);\n  });\n\n  test('returns true for empty array', () => {\n    expect(isEmpty([])).toBe(true);\n  });\n\n  test('throws TypeError for non-object/array inputs', () => {\n    expect(() => isEmpty(42)).toThrow(TypeError);\n    expect(() => isEmpty('foo')).toThrow(TypeError);\n  });\n});\n",
    "testsTs": "import isEmpty from './file';\n\ndescribe('isEmpty (TypeScript)', () => {\n  it('returns false for non-empty object', () => {\n    expect(isEmpty({ x: 5, y: 42 })).toBe(false);\n  });\n\n  it('returns true for empty object', () => {\n    expect(isEmpty({})).toBe(true);\n  });\n\n  it('returns false for non-empty array', () => {\n    expect(isEmpty([1, 2, 3])).toBe(false);\n  });\n\n  it('returns true for empty array', () => {\n    expect(isEmpty([])).toBe(true);\n  });\n\n  it('throws TypeError for non-object/array inputs', () => {\n    expect(() => isEmpty(42 as any)).toThrow(TypeError);\n    expect(() => isEmpty('foo' as any)).toThrow(TypeError);\n  });\n});\n",
    "access": "free"
  },
  {
    "id": "js-add-two-promises",
    "title": "Add Two Promises",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "promise",
      "async",
      "functions",
      "basics",
      "async-await"
    ],
    "description": {
      "summary": "Implement a function that takes two promises resolving to numbers and returns a new promise that resolves to their sum. Tests async/await usage and Promise handling.",
      "arguments": [
        {
          "name": "promise1",
          "type": "Promise<number>",
          "desc": "A promise that resolves with a number."
        },
        {
          "name": "promise2",
          "type": "Promise<number>",
          "desc": "Another promise that resolves with a number."
        }
      ],
      "returns": {
        "type": "Promise<number>",
        "desc": "A promise resolving with the sum of the two resolved values."
      },
      "examples": [
        "// Example 1\nconst p1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\nconst p2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\nawait addTwoPromises(p1, p2); // => 7",
        "// Example 2\nconst p1 = new Promise(resolve => setTimeout(() => resolve(10), 50));\nconst p2 = new Promise(resolve => setTimeout(() => resolve(-12), 30));\nawait addTwoPromises(p1, p2); // => -2"
      ]
    },
    "starterCode": "export default async function addTwoPromises(promise1, promise2) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: combine two asynchronous results and return a promise that resolves to their sum.",
      "approaches": [
        {
          "title": "Approach: Resolve both concurrently using Promise.all",
          "prose": "1. **Wait for both promises:** Use `Promise.all()` so both resolve in parallel.\n2. **Destructure results:** Extract the resolved values `[a, b]` from the array returned by `Promise.all()`.\n3. **Sum and return:** Add the numbers and return the result — wrapped automatically in a promise since the function is `async`.\n4. **Performance:** Both promises run concurrently, so total time equals the slower one’s resolution.",
          "codeJs": "export default async function addTwoPromises(promise1, promise2) {\n  const [a, b] = await Promise.all([promise1, promise2]);\n  return a + b;\n}\n",
          "codeTs": "export default async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\n  const [a, b] = await Promise.all([promise1, promise2]);\n  return a + b;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid chaining with nested `.then()` — it's harder to read and may resolve sequentially.",
          "If either promise rejects, `Promise.all` rejects immediately (propagating the error).",
          "Always `await` or return the result — otherwise it won’t resolve properly."
        ],
        "edgeCases": [
          "Both promises resolve instantly → works fine (microtask scheduling).",
          "One promise resolves slower → result waits for the slower one.",
          "If any promise rejects → the function rejects too (like native Promise.all)."
        ],
        "techniques": [
          "`Promise.all()` for concurrent resolution.",
          "`async/await` for clean and readable syntax.",
          "Destructuring arrays to extract resolved results."
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "MDN – Promise.all()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
        },
        {
          "title": "JavaScript.info – Promises, async/await",
          "url": "https://javascript.info/async-await"
        }
      ]
    },
    "tests": "import addTwoPromises from './file';\n\ndescribe('addTwoPromises', () => {\n  test('resolves with sum of positive numbers', async () => {\n    const p1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\n    const p2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(7);\n  });\n\n  test('handles negative and positive mix', async () => {\n    const p1 = new Promise(resolve => setTimeout(() => resolve(10), 50));\n    const p2 = new Promise(resolve => setTimeout(() => resolve(-12), 30));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(-2);\n  });\n\n  test('works with zero values (edge)', async () => {\n    const result = await addTwoPromises(Promise.resolve(0), Promise.resolve(0));\n    expect(result).toBe(0);\n  });\n});\n",
    "testsTs": "import addTwoPromises from './file';\n\ndescribe('addTwoPromises (TypeScript)', () => {\n  test('resolves with sum of positive numbers', async () => {\n    const p1 = new Promise<number>(resolve => setTimeout(() => resolve(2), 20));\n    const p2 = new Promise<number>(resolve => setTimeout(() => resolve(5), 60));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(7);\n  });\n\n  test('handles mix of negative and positive', async () => {\n    const p1 = new Promise<number>(resolve => setTimeout(() => resolve(10), 50));\n    const p2 = new Promise<number>(resolve => setTimeout(() => resolve(-12), 30));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(-2);\n  });\n\n  test('works with immediately resolved promises (edge)', async () => {\n    const result = await addTwoPromises(Promise.resolve(3), Promise.resolve(4));\n    expect(result).toBe(7);\n  });\n});\n",
    "access": "premium"
  },
  {
    "id": "js-promise-all",
    "title": "Implement Promise.all",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "intermediate",
    "tags": [
      "promise",
      "async",
      "concurrency"
    ],
    "description": {
      "summary": "Implement a function `promiseAll(promises)` that behaves like `Promise.all`. It should take an array of values or promises and return a single promise that resolves to an array of results, preserving order, or rejects as soon as one promise rejects.",
      "arguments": [
        {
          "name": "promises",
          "type": "Array<any | Promise<any>>",
          "desc": "An array of values and/or promises to be resolved."
        }
      ],
      "returns": {
        "type": "Promise<any[]>",
        "desc": "A promise that resolves to an array of resolved values in the same order as the input, or rejects with the first rejection reason."
      },
      "examples": [
        "// All fulfilled\npromiseAll([Promise.resolve(1), Promise.resolve(2), 3])\n  .then(result => {\n    // result => [1, 2, 3]\n  });",
        "// One rejects\npromiseAll([\n  Promise.resolve('ok'),\n  Promise.reject(new Error('fail'))\n])\n  .then(() => {\n    // not called\n  })\n  .catch(err => {\n    // err.message === 'fail'\n  });",
        "// Empty array resolves immediately\npromiseAll([])\n  .then(result => {\n    // result => []\n  });"
      ]
    },
    "starterCode": "export default function promiseAll(promises) {\n  // TODO: Return a Promise that resolves when all inputs resolve, or rejects on the first error\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function promiseAll<T>(promises: Array<T | Promise<T>>): Promise<T[]> {\n  // TODO: Return a Promise that resolves when all inputs resolve, or rejects on the first error\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: reimplement the core behavior of `Promise.all`.\n\n- Accept an array of values/promises.\n- Resolve with an array of results in the **same order**.\n- Reject **immediately** when any input rejects (fail-fast).\n- If the array is empty, resolve to `[]` right away.\n\nThis tests understanding of promises, async coordination, and ordering.",
      "approaches": [
        {
          "title": "Approach 1: Manual aggregation with counter (parallel, spec-like)",
          "prose": "Idea: create a wrapper promise that subscribes to all input values (wrapped via `Promise.resolve`). Track how many results are still pending, and resolve when all have completed.\n\nHow it works\n1. Validate the argument is an array; if not, reject with `TypeError`.\n2. If input length is 0, resolve `[]` immediately.\n3. Initialize `results = new Array(len)` and `remaining = len`.\n4. For each element `p` at index `i`:\n   - Wrap with `Promise.resolve(p)` so non-promises work.\n   - On `then(value)`, store `results[i] = value`, decrement `remaining`.\n   - When `remaining` hits `0`, resolve with `results`.\n   - On `catch(error)`, reject the outer promise once (fail-fast).\n\nWhy use it: matches how `Promise.all` behaves (parallel waiting, order preserved, fail-fast) and is a very common interview solution.",
          "codeJs": "export default function promiseAll(promises) {\n  return new Promise((resolve, reject) => {\n    if (!Array.isArray(promises)) {\n      return reject(new TypeError('Argument must be an array'));\n    }\n\n    const length = promises.length;\n    const results = new Array(length);\n    let remaining = length;\n\n    if (length === 0) {\n      resolve([]);\n      return;\n    }\n\n    promises.forEach((p, index) => {\n      Promise.resolve(p)\n        .then(value => {\n          results[index] = value;\n          remaining -= 1;\n          if (remaining === 0) {\n            resolve(results);\n          }\n        })\n        .catch(reject);\n    });\n  });\n}\n",
          "codeTs": "export default function promiseAll<T>(promises: Array<T | Promise<T>>): Promise<T[]> {\n  return new Promise<T[]>((resolve, reject) => {\n    if (!Array.isArray(promises)) {\n      return reject(new TypeError('Argument must be an array'));\n    }\n\n    const length = promises.length;\n    const results: T[] = new Array(length);\n    let remaining = length;\n\n    if (length === 0) {\n      resolve([]);\n      return;\n    }\n\n    promises.forEach((p, index) => {\n      Promise.resolve(p)\n        .then(value => {\n          results[index] = value as T;\n          remaining -= 1;\n          if (remaining === 0) {\n            resolve(results);\n          }\n        })\n        .catch(reject);\n    });\n  });\n}\n"
        },
        {
          "title": "Approach 2: Sequential `async/await` (simpler but not parallel)",
          "prose": "Idea: as a teaching alternative, resolve each item **one by one** in an `async` function using `await`. This is easier to read but does **not** preserve the parallel behavior of `Promise.all`.\n\nHow it works\n1. Loop over indices `i` from 0 to `promises.length - 1`.\n2. For each element `p`, do `results[i] = await Promise.resolve(p)`.\n3. If any await throws, the whole `promiseAll` rejects (like built-in).\n\nWhy use it: good to reason about success/failure flow with `try/catch`, but real `Promise.all` runs all promises in parallel, while this one runs them serially.",
          "codeJs": "export default async function promiseAllSequential(promises) {\n  if (!Array.isArray(promises)) {\n    throw new TypeError('Argument must be an array');\n  }\n  const results = [];\n  for (let i = 0; i < promises.length; i++) {\n    results[i] = await Promise.resolve(promises[i]);\n  }\n  return results;\n}\n",
          "codeTs": "export default async function promiseAllSequential<T>(promises: Array<T | Promise<T>>): Promise<T[]> {\n  if (!Array.isArray(promises)) {\n    throw new TypeError('Argument must be an array');\n  }\n  const results: T[] = [];\n  for (let i = 0; i < promises.length; i++) {\n    results[i] = await Promise.resolve(promises[i]);\n  }\n  return results;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to handle the **empty array** case (the returned promise should resolve immediately with `[]`).",
          "Not preserving **input order** in the results; you must write into `results[index]`, not just `results.push`.",
          "Calling `resolve` or `reject` multiple times — only the first call has effect, but your logic should naturally avoid extra calls.",
          "Not wrapping values with `Promise.resolve`, which breaks support for non-promise values."
        ],
        "edgeCases": [
          "Empty array → resolves immediately with `[]`.",
          "Array with only non-promise values → resolves immediately with those values.",
          "First element rejects after some others resolve → final result must still be a rejection.",
          "Non-array input → typically throws or rejects with `TypeError` (this implementation rejects)."
        ],
        "techniques": [
          "Using a **wrapper promise** to aggregate multiple async operations.",
          "Using a **counter** (`remaining`) to know when all async tasks have finished.",
          "Using `Promise.resolve` to normalize values and promises.",
          "Fail-fast error propagation via `catch(reject)`."
        ]
      },
      "followUpQuestions": [
        "js-compact",
        "js-unique-array"
      ],
      "resources": [
        {
          "title": "MDN – Promise.all()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
        },
        {
          "title": "MDN – Using Promises",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises"
        }
      ]
    },
    "tests": "import promiseAll from './promiseAll';\n\ndescribe('promiseAll', () => {\n  test('resolves array of values in order when all succeed', async () => {\n    const p1 = Promise.resolve(1);\n    const p2 = new Promise(resolve => setTimeout(() => resolve(2), 5));\n    const p3 = 3; // non-promise value\n\n    await expect(promiseAll([p1, p2, p3])).resolves.toEqual([1, 2, 3]);\n  });\n\n  test('resolves immediately for empty array', async () => {\n    await expect(promiseAll([])).resolves.toEqual([]);\n  });\n\n  test('rejects when any promise rejects', async () => {\n    const error = new Error('fail');\n    const p1 = Promise.resolve('ok');\n    const p2 = Promise.reject(error);\n\n    await expect(promiseAll([p1, p2])).rejects.toThrow('fail');\n  });\n\n  test('rejects with TypeError when input is not an array', async () => {\n    // @ts-expect-error runtime guard only\n    await expect(promiseAll(null)).rejects.toThrow(TypeError);\n  });\n});\n",
    "testsTs": "import promiseAll from './promiseAll';\n\ndescribe('promiseAll (TypeScript)', () => {\n  it('resolves array of values in order when all succeed', async () => {\n    const p1 = Promise.resolve(1);\n    const p2 = new Promise<number>(resolve => setTimeout(() => resolve(2), 5));\n    const p3 = 3;\n\n    await expect(promiseAll([p1, p2, p3])).resolves.toEqual([1, 2, 3]);\n  });\n\n  it('resolves immediately for empty array', async () => {\n    await expect(promiseAll<number>([])).resolves.toEqual([]);\n  });\n\n  it('rejects when any promise rejects', async () => {\n    const error = new Error('fail');\n    const p1 = Promise.resolve('ok');\n    const p2 = Promise.reject(error);\n\n    await expect(promiseAll([p1, p2])).rejects.toThrow('fail');\n  });\n\n  it('rejects with TypeError when input is not an array', async () => {\n    // @ts-expect-error runtime guard only\n    await expect(promiseAll(null as any)).rejects.toThrow(TypeError);\n  });\n});\n",
    "access": "premium"
  }
]
