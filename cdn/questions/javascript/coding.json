[
  {
    "id": "js-number-clamp",
    "title": "Clamp",
    "type": "coding",
    "technology": "javascript",
    "importance": 1,
    "difficulty": "easy",
    "tags": [
      "numbers",
      "math",
      "boundaries",
      "utilities",
      "basics"
    ],
    "description": {
      "summary": "Implement clamp(value, lower, upper) to keep a number within an inclusive range. If the value is below the lower bound, return the lower bound; if above the upper bound, return the upper bound. This is a tiny but common utility for sliders, percentages, and animations. Concepts: numbers, math, boundaries, utilities.",
      "arguments": [
        {
          "name": "value",
          "type": "number",
          "desc": "The number to clamp."
        },
        {
          "name": "lower",
          "type": "number",
          "desc": "The lower bound."
        },
        {
          "name": "upper",
          "type": "number",
          "desc": "The upper bound."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The clamped number."
      },
      "examples": [
        "// Basic examples\nclamp(3, 0, 5) // => 3\nclamp(-10, -3, 5) // => -3\nclamp(10, -5, 5) // => 5\n\n// On the bounds (inclusive)\nclamp(0, 0, 5) // => 0\nclamp(5, 0, 5) // => 5"
      ]
    },
    "starterCode": "export default function clamp(value, lower, upper) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Clamp is a three-branch check that guarantees a value stays inside [lower, upper]. It is intentionally simple and predictable: values below the range snap to the lower bound, values above snap to the upper bound, and in-range values are returned unchanged. Key concepts: numbers, math, boundaries.",
      "approaches": [
        {
          "title": "Approach 1: Branching (readable baseline)",
          "prose": "Implementation:\n- If `value < lower`, return `lower`.\n- Else if `value > upper`, return `upper`.\n- Otherwise return `value`.\n\nComplexity: O(1) time and O(1) space. This is safe for UI state, percentages, and animation progress values.",
          "codeJs": "export default function clamp(value, lower, upper) {\n  if (value < lower) return lower;\n  if (value > upper) return upper;\n  return value;\n}\n",
          "codeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  if (value < lower) return lower;\n  if (value > upper) return upper;\n  return value;\n}\n"
        },
        {
          "title": "Approach 2: Math chaining (compact)",
          "prose": "Idea: clamp in a single expression — first push `value` up to the lower bound, then cap it at the upper bound.\n\nWe can write: `Math.min(Math.max(value, lower), upper)`.\n\nRead it as: *at least `lower`, at most `upper`.*\n\nWhy use it: short, idiomatic, and easy to scan once you're used to it.",
          "codeJs": "export default function clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\n",
          "codeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  return Math.min(Math.max(value, lower), upper);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "`lower` should be `<= upper`. If not guaranteed by caller, normalize or assert.",
          "`NaN` inputs propagate through `Math.min/max` → result becomes `NaN`. Decide whether to coerce or throw.",
          "Non-number inputs (strings, null) will be coerced if you use Math.*; prefer validating types for clarity."
        ],
        "edgeCases": [
          "value exactly equals `lower` or `upper` → return that bound.",
          "Very large magnitudes: works, but be mindful of ±Infinity if it can appear.",
          "Swapped bounds: if it can happen, you can fix with `[lower, upper] = lower <= upper ? [lower, upper] : [upper, lower]`."
        ],
        "techniques": [
          "Guard + early return for clarity (Approach 1).",
          "Common clamping pattern with `Math.min(Math.max(...))` (Approach 2)."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels",
        "js-arrays-equal"
      ],
      "resources": [
        {
          "title": "MDN – Math.max()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max"
        },
        {
          "title": "MDN – Math.min()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min"
        }
      ]
    },
    "tests": "import clamp from './clamp';\n\ndescribe('clamp', () => {\n  test('within range', () => expect(clamp(3, 0, 5)).toBe(3));\n  test('below lower', () => expect(clamp(-10, -3, 5)).toBe(-3));\n  test('above upper', () => expect(clamp(10, -5, 5)).toBe(5));\n  test('on bounds (inclusive)', () => {\n    expect(clamp(0, 0, 5)).toBe(0);\n    expect(clamp(5, 0, 5)).toBe(5);\n  });\n});\n",
    "testsTs": "import clamp from './clamp';\n\ndescribe('clamp (TypeScript)', () => {\n  it('returns the same value when within range', () => {\n    expect(clamp(3, 0, 5)).toBe(3);\n  });\n  it('clamps to lower bound when below range', () => {\n    expect(clamp(-10, -3, 5)).toBe(-3);\n  });\n  it('clamps to upper bound when above range', () => {\n    expect(clamp(10, -5, 5)).toBe(5);\n  });\n  it('returns bounds when value is exactly on them', () => {\n    expect(clamp(0, 0, 5)).toBe(0);\n    expect(clamp(5, 0, 5)).toBe(5);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-reverse-string",
    "title": "Reverse a String",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "strings",
      "iteration",
      "loops",
      "basics"
    ],
    "description": {
      "summary": "Reverse a string by iterating from the end to the start and building a new string, without using `Array.prototype.reverse()` in the main solution. This highlights string immutability and careful index traversal. Concepts: strings, iteration, loops.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to be reversed."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "The reversed string."
      },
      "examples": [
        "// Basic example\nreverseString('abc') // => 'cba'",
        "// Palindrome\nreverseString('racecar') // => 'racecar'",
        "// With spaces and punctuation\nreverseString('A man, a plan') // => 'nalp a ,nam A'"
      ]
    },
    "starterCode": "export default function reverseString(str) {\n  // TODO: Implement without using Array.prototype.reverse()\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function reverseString(str: string): string {\n  // TODO: Implement without using Array.prototype.reverse()\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Walk the string backwards and build a new string character by character. This is the simplest way to reverse without relying on array conversion helpers, and it reinforces that strings are immutable in JavaScript. Key concepts: strings, iteration, loops.",
      "approaches": [
        {
          "title": "Approach 1: Manual loop (explicit and clear)",
          "prose": "Steps:\n1) Initialize `result = ''`.\n2) Loop `i` from `str.length - 1` down to `0`.\n3) Append `str[i]` to `result`.\n4) Return `result`.\n\nComplexity: O(n) time. Space is O(n) for the new string.",
          "codeJs": "export default function reverseString(str) {\n  let out = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    out += str[i];\n  }\n  return out;\n}\n",
          "codeTs": "export default function reverseString(str: string): string {\n  let out = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    out += str[i];\n  }\n  return out;\n}\n"
        },
        {
          "title": "Approach 2: Using array methods (follow-up, compact)",
          "prose": "Idea: convert the string into an array, reverse it, and join it back into a string.\n\nWe can write: `str.split('').reverse().join('')`.\n\nRead it as: *split → reverse → join*.\n\nWhy use it: concise and idiomatic once you know the APIs. In this problem, treat it as an alternate or follow-up solution, because the main requirement is to avoid calling `Array.prototype.reverse()` in your core implementation.",
          "codeJs": "export default function reverseString(str) {\n  return str.split('').reverse().join('');\n}\n",
          "codeTs": "export default function reverseString(str: string): string {\n  return str.split('').reverse().join('');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Strings are immutable — you cannot modify characters in place.",
          "Avoid relying on `.reverse()` in your primary solution if the problem forbids it.",
          "For Unicode characters like emoji, this naive approach may split surrogate pairs incorrectly."
        ],
        "edgeCases": [
          "Empty string → returns `''`.",
          "Single character → unchanged.",
          "Palindrome → returns itself."
        ],
        "techniques": [
          "Iterating in reverse order over a string.",
          "Using concatenation or array methods to reconstruct a string."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels",
        "js-capitalize-words"
      ],
      "resources": [
        {
          "title": "MDN – String.prototype.split()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split"
        },
        {
          "title": "MDN – String.prototype.concat()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat"
        }
      ]
    },
    "tests": "import reverseString from './reverseString';\n\ndescribe('reverseString', () => {\n  test('reverses simple strings (abc)', () => {\n    expect(reverseString('abc')).toBe('cba');\n  });\n\n  test('reverses simple strings (hello)', () => {\n    expect(reverseString('hello')).toBe('olleh');\n  });\n\n  test('handles palindromes', () => {\n    expect(reverseString('racecar')).toBe('racecar');\n  });\n\n  test('reverses with spaces and punctuation', () => {\n    expect(reverseString('A man, a plan')).toBe('nalp a ,nam A');\n  });\n\n  test('handles empty string', () => {\n    expect(reverseString('')).toBe('');\n  });\n\n  test('handles single character', () => {\n    expect(reverseString('x')).toBe('x');\n  });\n});\n",
    "testsTs": "import reverseString from './reverseString';\n\ndescribe('reverseString (TypeScript)', () => {\n  it('reverses simple strings (abc)', () => {\n    expect(reverseString('abc')).toBe('cba');\n  });\n\n  it('reverses simple strings (hello)', () => {\n    expect(reverseString('hello')).toBe('olleh');\n  });\n\n  it('handles palindromes', () => {\n    expect(reverseString('racecar')).toBe('racecar');\n  });\n\n  it('reverses with spaces and punctuation', () => {\n    expect(reverseString('A man, a plan')).toBe('nalp a ,nam A');\n  });\n\n  it('handles empty string', () => {\n    expect(reverseString('')).toBe('');\n  });\n\n  it('handles single character', () => {\n    expect(reverseString('x')).toBe('x');\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01",
    "companies": [
      "apple",
      "meta"
    ]
  },
  {
    "id": "js-count-vowels",
    "title": "Count Vowels",
    "type": "coding",
    "importance": 2,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "strings",
      "iteration",
      "counting",
      "sets",
      "basics"
    ],
    "description": {
      "summary": "Implement countVowels(str) that returns how many vowels appear in a string. Normalize case, decide whether to include 'y', and handle empty input safely. Use a Set for O(1) membership checks and a single O(n) pass. Concepts: strings, iteration, counting, sets.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to analyze."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The number of vowels found in the string."
      },
      "examples": [
        "// Basic examples\ncountVowels('hello') // => 2",
        "countVowels('rhythm') // => 0",
        "countVowels('AEIOU') // => 5",
        "// Mixed case and spaces\ncountVowels('A quick brown fox') // => 5"
      ]
    },
    "starterCode": "export default function countVowels(str) {\n  // TODO: Return how many vowels (a, e, i, o, u) are in the string\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function countVowels(str: string): number {\n  // TODO: Return how many vowels (a, e, i, o, u) are in the string\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Scan the string once, normalize case, and count only characters that belong to a vowel set. This keeps the solution O(n), handles empty input gracefully, and avoids tricky regex edge cases. It’s a classic example of membership checks with a Set. Key concepts: strings, iteration, counting.",
      "approaches": [
        {
          "title": "Approach 1: Iterative counting (explicit and clear)",
          "prose": "Steps:\n1) Create a Set of vowels (e.g., a/e/i/o/u).\n2) Convert the input to lowercase to make matching case-insensitive.\n3) Initialize a counter at 0 and loop through each character.\n4) If the character is in the vowel Set, increment the counter.\n5) Return the counter (0 for empty strings).\n\nComplexity: O(n) time, O(1) space for the fixed vowel set.",
          "codeJs": "export default function countVowels(str) {\n  const vowels = 'aeiou';\n  let count = 0;\n  for (const ch of str.toLowerCase()) {\n    if (vowels.includes(ch)) count++;\n  }\n  return count;\n}\n",
          "codeTs": "export default function countVowels(str: string): number {\n  const vowels = 'aeiou';\n  let count = 0;\n  for (const ch of str.toLowerCase()) {\n    if (vowels.includes(ch)) count++;\n  }\n  return count;\n}\n"
        },
        {
          "title": "Approach 2: Regular expression (concise alternative)",
          "prose": "Idea: use a regular expression to directly match all vowels.\n\nWe can write: `(str.match(/[aeiou]/gi) || []).length`.\n\nRead it as: *find all vowels (case-insensitive) and count them*. The `/g` flag finds all matches, and `/i` makes it case-insensitive.\n\nWhy use it: shorter and declarative, though less explicit than manual iteration. Good as a follow-up solution when you're comfortable with regex.",
          "codeJs": "export default function countVowels(str) {\n  return (str.match(/[aeiou]/gi) || []).length;\n}\n",
          "codeTs": "export default function countVowels(str: string): number {\n  return (str.match(/[aeiou]/gi) || []).length;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Empty strings should return `0`.",
          "Regex approach may be less intuitive for beginners.",
          "Non-letter characters (spaces, punctuation) are simply skipped.",
          "`y` is not treated as a vowel here."
        ],
        "edgeCases": [
          "No vowels → returns `0`.",
          "Mixed case → handled by `toLowerCase()` or the `/i` flag.",
          "Accented vowels (é, ü) → not counted unless explicitly included in the vowel set or regex."
        ],
        "techniques": [
          "String traversal and membership checking.",
          "Regex matching and counting via array length."
        ]
      },
      "followUpQuestions": [
        "js-reverse-string",
        "js-capitalize-words"
      ],
      "resources": [
        {
          "title": "MDN – String.prototype.includes()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes"
        },
        {
          "title": "MDN – String.prototype.match()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match"
        }
      ]
    },
    "tests": "import countVowels from './countVowels';\n\ndescribe('countVowels', () => {\n  test('counts lowercase vowels', () => {\n    expect(countVowels('hello')).toBe(2);\n    expect(countVowels('rhythm')).toBe(0);\n  });\n\n  test('counts uppercase vowels', () => {\n    expect(countVowels('AEIOU')).toBe(5);\n  });\n\n  test('counts vowels in mixed case and spaces', () => {\n    expect(countVowels('A quick brown fox')).toBe(5);\n  });\n\n  test('handles empty string', () => {\n    expect(countVowels('')).toBe(0);\n  });\n});\n",
    "testsTs": "import countVowels from './countVowels';\n\ndescribe('countVowels (TypeScript)', () => {\n  it('counts lowercase vowels', () => {\n    expect(countVowels('hello')).toBe(2);\n    expect(countVowels('rhythm')).toBe(0);\n  });\n\n  it('counts uppercase vowels', () => {\n    expect(countVowels('AEIOU')).toBe(5);\n  });\n\n  it('counts vowels in mixed case and spaces', () => {\n    expect(countVowels('A quick brown fox')).toBe(5);\n  });\n\n  it('handles empty string', () => {\n    expect(countVowels('')).toBe(0);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-flatten-once",
    "title": "Flatten One Level",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrays",
      "flatten",
      "iteration",
      "utilities",
      "basics"
    ],
    "description": {
      "summary": "This should not deep-flatten; only the first nesting level is removed, matching Array.prototype.flat(1). Use it to normalize API data; edge cases include sparse arrays and mixed types. Performance should stay linear, and tests should ensure order is preserved.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "The input array which may contain nested arrays."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array shallow-flattened by one level."
      },
      "examples": [
        "// Basic example\nflattenOnce([1, [2, 3], [4, [5]]]) // => [1, 2, 3, 4, [5]]",
        "// Already flat\nflattenOnce([1, 2, 3]) // => [1, 2, 3]",
        "// Mixed values\nflattenOnce([[1], 2, [3, [4]], 5]) // => [1, 2, 3, [4], 5]"
      ]
    },
    "starterCode": "export default function flattenOnce(arr) {\n  // TODO: Flatten one level deep\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function flattenOnce(arr: any[]): any[] {\n  // TODO: Flatten one level deep\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Because only one level is flattened, you can implement it with a single pass and no recursion while preserving order and immutability.",
      "approaches": [
        {
          "title": "Approach 1: Iterative spread (explicit and clear)",
          "prose": "Mention that non-array values are pushed as-is and that nested arrays deeper than one level remain nested. This helps clarify expected behavior and prevents over-flattening.",
          "codeJs": "export default function flattenOnce(arr) {\n  const result = [];\n  for (const el of arr) {\n    if (Array.isArray(el)) {\n      result.push(...el);\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flattenOnce(arr: any[]): any[] {\n  const result: any[] = [];\n  for (const el of arr) {\n    if (Array.isArray(el)) {\n      result.push(...el);\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using built-in `.flat(1)` (alternate, compact syntax)",
          "prose": "Idea: use the modern `Array.prototype.flat()` method with depth `1`.\n\nWe can write: `arr.flat(1)`.\n\nRead it as: *flatten one layer deep and leave inner arrays untouched*.\n\nWhy use it: concise, modern, and likely optimized. In this question, treat it as an alternate or follow-up solution — the manual approach helps you understand how shallow flattening works internally.",
          "codeJs": "export default function flattenOnce(arr) {\n  return arr.flat(1);\n}\n",
          "codeTs": "export default function flattenOnce(arr: any[]): any[] {\n  return arr.flat(1);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Flattening too deeply defeats the 'one-level' requirement — avoid recursion or `.flat(Infinity)`.",
          "Mutating the original array is not allowed — always return a new one.",
          "Non-array values should remain untouched."
        ],
        "edgeCases": [
          "Empty array → returns `[]`.",
          "Already flat array → identical output.",
          "Mixed values like `[1, [2], 3]` → flattens only first-level arrays."
        ],
        "techniques": [
          "Using `Array.isArray()` for type checking.",
          "Using spread syntax (`...`) for shallow unpacking.",
          "Understanding `.flat(depth)` as a concise modern alternative."
        ]
      },
      "followUpQuestions": [
        "js-flatten-depth"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.flat()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat"
        },
        {
          "title": "MDN – Array.isArray()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
        }
      ]
    },
    "tests": "import flattenOnce from './flattenOnce';\n\ndescribe('flattenOnce', () => {\n  test('flattens a simple nested array', () => {\n    expect(flattenOnce([1, [2, 3], [4, [5]]])).toEqual([1, 2, 3, 4, [5]]);\n  });\n\n  test('returns same array when already flat', () => {\n    expect(flattenOnce([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n\n  test('handles mixed array contents', () => {\n    expect(flattenOnce([[1], 2, [3, [4]], 5])).toEqual([1, 2, 3, [4], 5]);\n  });\n\n  test('returns empty array for empty input', () => {\n    expect(flattenOnce([])).toEqual([]);\n  });\n});\n",
    "testsTs": "import flattenOnce from './flattenOnce';\n\ndescribe('flattenOnce (TypeScript)', () => {\n  it('flattens a simple nested array', () => {\n    expect(flattenOnce([1, [2, 3], [4, [5]]])).toEqual([1, 2, 3, 4, [5]]);\n  });\n\n  it('returns same array when already flat', () => {\n    expect(flattenOnce([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n\n  it('handles mixed array contents', () => {\n    expect(flattenOnce([[1], 2, [3, [4]], 5])).toEqual([1, 2, 3, [4], 5]);\n  });\n\n  it('returns empty array for empty input', () => {\n    expect(flattenOnce([])).toEqual([]);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-unique-array",
    "title": "Remove Duplicates",
    "type": "coding",
    "importance": 4,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrays",
      "sets",
      "deduplication",
      "iteration",
      "basics"
    ],
    "description": {
      "summary": "Implement uniqueArray(arr) that removes duplicates while preserving order. Use a Set for O(n) time and clarify how to treat objects by reference, NaN, and mixed types so behavior is explicit and predictable. Concepts: arrays, sets, deduplication, iteration.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array of items that may contain duplicates."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array with only unique elements, preserving their first occurrence order."
      },
      "examples": [
        "// Basic example\nunique([1, 2, 2, 3, 1]) // => [1, 2, 3]",
        "// Works with strings\nunique(['a', 'b', 'a', 'c', 'b']) // => ['a', 'b', 'c']",
        "// Mixed types\nunique([1, '1', 1]) // => [1, '1']"
      ]
    },
    "starterCode": "export default function unique(arr) {\n  // TODO: Return new array with duplicates removed\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function unique<T>(arr: T[]): T[] {\n  // TODO: Return new array with duplicates removed\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Return a new array containing only the first occurrence of each value. Use a Set to track seen values and push into the result only when a value appears for the first time. This preserves order and runs in linear time. Key concepts: arrays, sets, deduplication.",
      "approaches": [
        {
          "title": "Approach 1: Using a Set to track seen values (explicit control)",
          "prose": "Steps:\n1) Create `const seen = new Set()` and an empty `result`.\n2) Iterate the input array.\n3) If `seen` does not contain the value, add it to `seen` and push to `result`.\n4) Return `result`.\n\nNotes: Set treats `NaN` as the same value and compares objects by reference, which is usually the desired behavior for this question.",
          "codeJs": "export default function unique(arr) {\n  const seen = new Set();\n  const result = [];\n  for (const item of arr) {\n    if (!seen.has(item)) {\n      seen.add(item);\n      result.push(item);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  const seen = new Set<T>();\n  const result: T[] = [];\n  for (const item of arr) {\n    if (!seen.has(item)) {\n      seen.add(item);\n      result.push(item);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using `new Set()` directly (compact form)",
          "prose": "Idea: leverage the fact that a `Set` automatically removes duplicates.\n\nUse `[...new Set(arr)]` to instantly produce a deduplicated array.\n\nRead it as: *wrap the array in a Set to drop duplicates, then spread it back into a new array*.\n\nWhy use it: clean and elegant one-liner, ideal when order preservation and the default value equality semantics are acceptable.",
          "codeJs": "export default function unique(arr) {\n  return [...new Set(arr)];\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  return [...new Set(arr)];\n}\n"
        },
        {
          "title": "Approach 3: Using `filter()` and `indexOf()` (less efficient)",
          "prose": "Idea: only keep items where their first occurrence index matches the current index.\n\nUse `arr.filter((item, idx) => arr.indexOf(item) === idx)`.\n\nWhy use it: clear for learning, but less efficient (O(n²)) since each `indexOf` scan starts from the beginning.",
          "codeJs": "export default function unique(arr) {\n  return arr.filter((item, idx) => arr.indexOf(item) === idx);\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  return arr.filter((item, idx) => arr.indexOf(item) === idx);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Comparisons are done using strict equality (`===`), so `1` and `'1'` are treated differently.",
          "Objects and arrays are compared by reference, not structure.",
          "Avoid using `filter + indexOf` for very large arrays due to quadratic performance."
        ],
        "edgeCases": [
          "Empty array → returns `[]`.",
          "Already unique array → unchanged.",
          "All duplicates → only first kept."
        ],
        "techniques": [
          "Using `Set` for uniqueness tracking.",
          "Maintaining insertion order manually.",
          "Using spread syntax (`...`) for conversion."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN – Set",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"
        },
        {
          "title": "MDN – Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        }
      ]
    },
    "tests": "import unique from './unique';\n\ndescribe('unique', () => {\n  test('removes duplicates from numbers', () => {\n    expect(unique([1, 2, 2, 3, 1])).toEqual([1, 2, 3]);\n  });\n\n  test('works with strings', () => {\n    expect(unique(['a', 'b', 'a', 'c', 'b'])).toEqual(['a', 'b', 'c']);\n  });\n\n  test('handles mixed types', () => {\n    expect(unique([1, '1', 1])).toEqual([1, '1']);\n  });\n\n  test('returns empty array when input is empty', () => {\n    expect(unique([])).toEqual([]);\n  });\n\n  test('returns identical array when all unique', () => {\n    expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "import unique from './unique';\n\ndescribe('unique (TypeScript)', () => {\n  it('removes duplicates from numbers', () => {\n    expect(unique([1, 2, 2, 3, 1])).toEqual([1, 2, 3]);\n  });\n\n  it('works with strings', () => {\n    expect(unique(['a', 'b', 'a', 'c', 'b'])).toEqual(['a', 'b', 'c']);\n  });\n\n  it('handles mixed types', () => {\n    expect(unique([1, '1', 1])).toEqual([1, '1']);\n  });\n\n  it('returns empty array when input is empty', () => {\n    expect(unique([])).toEqual([]);\n  });\n\n  it('returns identical array when all unique', () => {\n    expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ]
  },
  {
    "id": "js-max-char",
    "title": "Find Maximum Occurring Character",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "strings",
      "frequency",
      "hash-map",
      "counting",
      "basics"
    ],
    "description": {
      "summary": "Find the most frequent character in a string using a frequency map. Track counts in one pass and return the character with the highest count (first winner on ties), handling empty strings safely.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to analyze."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "The single character with the highest frequency of occurrence. Returns `''` for an empty string."
      },
      "examples": [
        "// Basic examples\nmaxChar('hello') // => 'l'\nmaxChar('aabbbcc') // => 'b'\nmaxChar('abcccccccd') // => 'c'\n\n// When multiple characters tie, return the first one found\nmaxChar('aabb') // => 'a'\n\n// Empty string\nmaxChar('') // => ''"
      ]
    },
    "starterCode": "export default function maxChar(str) {\n  // TODO: Return the most frequent character in the string\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function maxChar(str: string): string {\n  // TODO: Return the most frequent character in the string\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "This is a classic frequency counting pattern. Build a map of counts while scanning the string, track the current max, and return the winner. It runs in linear time and is robust for repeated characters and long inputs.",
      "approaches": [
        {
          "title": "Approach 1: Frequency map with a loop (efficient and clear)",
          "prose": "If the string is empty, return ''. Otherwise iterate through each character, increment its count, and update max/maxChar when a new maximum is found. Return maxChar at the end. Complexity is O(n) time and O(k) space.",
          "codeJs": "export default function maxChar(str) {\n  if (!str) return '';\n  const charCount = {};\n  let max = 0;\n  let maxChar = '';\n\n  for (const ch of str) {\n    charCount[ch] = (charCount[ch] || 0) + 1;\n    if (charCount[ch] > max) {\n      max = charCount[ch];\n      maxChar = ch;\n    }\n  }\n\n  return maxChar;\n}\n",
          "codeTs": "export default function maxChar(str: string): string {\n  if (!str) return '';\n  const charCount: Record<string, number> = {};\n  let max = 0;\n  let maxChar = '';\n\n  for (const ch of str) {\n    charCount[ch] = (charCount[ch] || 0) + 1;\n    if (charCount[ch] > max) {\n      max = charCount[ch];\n      maxChar = ch;\n    }\n  }\n\n  return maxChar;\n}\n"
        },
        {
          "title": "Approach 2: Using `reduce()` for a functional style",
          "prose": "Idea: first build a frequency map with `Array.prototype.reduce()`, then scan that map to find the character with the highest count.\n\nHow it works:\n1. If `str` is empty, return `''` immediately.\n2. Use `reduce` over the characters of `str` to build an object `freq` where keys are characters and values are counts.\n3. Initialize `maxChar = ''` and `max = 0`.\n4. Loop over `Object.entries(freq)` and update `max` / `maxChar` whenever you see a larger count.\n5. Return `maxChar`.\n\nWhy use it: keeps the counting logic in a single expression and can feel more declarative, but is slightly less direct than the plain loop for beginners.",
          "codeJs": "export default function maxChar(str) {\n  if (!str) return '';\n  const freq = [...str].reduce((acc, ch) => {\n    acc[ch] = (acc[ch] || 0) + 1;\n    return acc;\n  }, {});\n\n  let maxChar = '';\n  let max = 0;\n  for (const [ch, count] of Object.entries(freq)) {\n    if (count > max) {\n      max = count;\n      maxChar = ch;\n    }\n  }\n  return maxChar;\n}\n",
          "codeTs": "export default function maxChar(str: string): string {\n  if (!str) return '';\n  const freq = Array.from(str).reduce<Record<string, number>>((acc, ch) => {\n    acc[ch] = (acc[ch] || 0) + 1;\n    return acc;\n  }, {});\n\n  let maxChar = '';\n  let max = 0;\n  for (const [ch, count] of Object.entries(freq)) {\n    if (count > max) {\n      max = count;\n      maxChar = ch;\n    }\n  }\n  return maxChar;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Do not forget to handle the empty string case — return `''`.",
          "Comparisons are case-sensitive (`'A'` and `'a'` are counted separately).",
          "Ties are resolved by returning the first character that reaches the maximum count (due to the `>` comparison)."
        ],
        "edgeCases": [
          "Empty string → returns `''`.",
          "All unique characters → returns the first character.",
          "Multiple max chars → returns the earliest one by position in the string."
        ],
        "techniques": [
          "Using frequency maps (hash tables) to count occurrences.",
          "Tracking the current maximum value during iteration instead of doing a second pass.",
          "Reasoning about O(n) time and O(k) extra space where k is the number of unique characters."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels"
      ],
      "resources": [
        {
          "title": "MDN – Object.entries()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"
        },
        {
          "title": "MDN – for...of statement",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"
        }
      ]
    },
    "tests": "import maxChar from './maxChar';\n\ndescribe('maxChar', () => {\n  test('finds the most common letter', () => {\n    expect(maxChar('hello')).toBe('l');\n  });\n\n  test('works with multiple repetitions', () => {\n    expect(maxChar('aabbbcc')).toBe('b');\n    expect(maxChar('abcccccccd')).toBe('c');\n  });\n\n  test('returns first character when tie', () => {\n    expect(maxChar('aabb')).toBe('a');\n  });\n\n  test('returns empty string when input is empty', () => {\n    expect(maxChar('')).toBe('');\n  });\n});\n",
    "testsTs": "import maxChar from './maxChar';\n\ndescribe('maxChar (TypeScript)', () => {\n  it('finds the most common letter', () => {\n    expect(maxChar('hello')).toBe('l');\n  });\n\n  it('works with multiple repetitions', () => {\n    expect(maxChar('aabbbcc')).toBe('b');\n    expect(maxChar('abcccccccd')).toBe('c');\n  });\n\n  it('returns first character when tie', () => {\n    expect(maxChar('aabb')).toBe('a');\n  });\n\n  it('returns empty string when input is empty', () => {\n    expect(maxChar('')).toBe('');\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-capitalize-words",
    "title": "Capitalize Words",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "strings",
      "transforms",
      "arrays",
      "basics",
      "iteration"
    ],
    "description": {
      "summary": "Capitalize the first letter of every word while preserving spacing. Handle multiple spaces and punctuation without collapsing the original string, and keep non-letter characters intact. This tests string parsing and careful output formatting. Concepts: strings, transforms, arrays, iteration.",
      "arguments": [
        {
          "name": "sentence",
          "type": "string",
          "desc": "A sentence consisting of one or more words separated by spaces. May contain leading, trailing, or multiple spaces between words."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "A new string where each word starts with an uppercase letter and the rest of the word is lowercase. Returns `''` for an empty string."
      },
      "examples": [
        "// Basic examples",
        "capitalizeWords('hello world') // => 'Hello World'",
        "capitalizeWords('javascript is fun') // => 'Javascript Is Fun'",
        "// Handles extra spaces",
        "capitalizeWords('  welcome   to  earth  ') // => '  Welcome   To  Earth  '",
        "// Empty string",
        "capitalizeWords('') // => ''"
      ]
    },
    "starterCode": "export default function capitalizeWords(sentence) {\n  // TODO: Capitalize first letter of each word\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function capitalizeWords(sentence: string): string {\n  // TODO: Capitalize first letter of each word\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure each word in a sentence starts with an uppercase letter while preserving spacing and keeping the rest of the letters lowercase. If the input is empty, return `''`. This builds practical mastery over string splitting, mapping, joining, and basic character processing. Key concepts: strings, transforms, arrays.",
      "approaches": [
        {
          "title": "Approach 1: Split–Map–Join (clean and readable)",
          "prose": "Idea: split the sentence into parts by spaces, capitalize the first letter of each non-empty part, and then join them back together.\n\nHow it works:\n1. If `sentence` is falsy (for example, an empty string), return `''`.\n2. Use `.split(' ')` to break the sentence into an array of substrings separated by single spaces.\n3. For each element `word` in the array, if `word` is an empty string (extra space), leave it as is; otherwise build `word[0].toUpperCase() + word.slice(1).toLowerCase()`.\n4. Join the transformed array back into a string with `' '` as the separator.\n5. Return the final joined string.\n\nWhy use it: clear logic, preserves multiple spaces exactly as they are, and doesn’t require regex — a straightforward approach for readability and maintainability.",
          "codeJs": "export default function capitalizeWords(sentence) {\n  if (!sentence) return '';\n  return sentence\n    .split(' ')\n    .map(word => {\n      if (!word) return word;\n      return word[0].toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ');\n}\n",
          "codeTs": "export default function capitalizeWords(sentence: string): string {\n  if (!sentence) return '';\n  return sentence\n    .split(' ')\n    .map(word => {\n      if (!word) return word;\n      return word[0].toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ');\n}\n"
        },
        {
          "title": "Approach 2: Character iteration (manual traversal)",
          "prose": "Idea: iterate through each character and capitalize when the previous character was a space.\n\nHow it works:\n1. If `sentence` is falsy, return `''`.\n2. Initialize an empty string `result = ''` and a boolean flag `capitalizeNext = true`.\n3. For each character `ch` in `sentence`, if `ch === ' '`, append it to `result` and set `capitalizeNext = true`; otherwise, if `capitalizeNext` is true, append `ch.toUpperCase()` and set `capitalizeNext = false`, and if it is false, append `ch.toLowerCase()`.\n4. After processing all characters, return `result`.\n\nWhy use it: avoids splitting and joining, and gives fine-grained control over character-by-character behavior. Efficient for long strings and useful when you want to extend the logic (for example, treat other delimiters as word boundaries).",
          "codeJs": "export default function capitalizeWords(sentence) {\n  if (!sentence) return '';\n  let result = '';\n  let capitalizeNext = true;\n\n  for (const ch of sentence) {\n    if (ch === ' ') {\n      result += ch;\n      capitalizeNext = true;\n    } else if (capitalizeNext) {\n      result += ch.toUpperCase();\n      capitalizeNext = false;\n    } else {\n      result += ch.toLowerCase();\n    }\n  }\n\n  return result;\n}\n",
          "codeTs": "export default function capitalizeWords(sentence: string): string {\n  if (!sentence) return '';\n  let result = '';\n  let capitalizeNext = true;\n\n  for (const ch of sentence) {\n    if (ch === ' ') {\n      result += ch;\n      capitalizeNext = true;\n    } else if (capitalizeNext) {\n      result += ch.toUpperCase();\n      capitalizeNext = false;\n    } else {\n      result += ch.toLowerCase();\n    }\n  }\n\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid trimming spaces — leading, trailing, and repeated spaces must be preserved.",
          "Punctuation and digits are treated as part of a word; only the first character after a space is uppercased.",
          "Always lowercase the rest of each word to normalize mixed casing."
        ],
        "edgeCases": [
          "Empty string → `''`.",
          "Extra spaces between words → preserved exactly.",
          "Already title-cased input → unchanged.",
          "Mixed casing → normalized to Title Case (e.g. `jaVaScript IS fUn` → `Javascript Is Fun`)."
        ],
        "techniques": [
          "Using `.split()`, `.map()`, and `.join()` for immutable string transformations.",
          "String iteration and character-based logic.",
          "Applying capitalization rules based on simple word boundaries (spaces)."
        ]
      },
      "followUpQuestions": [
        "js-reverse-string"
      ],
      "resources": [
        {
          "title": "MDN – String.prototype.split()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split"
        },
        {
          "title": "MDN – String.prototype.toUpperCase()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase"
        }
      ]
    },
    "tests": "import capitalizeWords from './capitalizeWords';\n\ndescribe('capitalizeWords', () => {\n  test('capitalizes each word in a simple sentence', () => {\n    expect(capitalizeWords('hello world')).toBe('Hello World');\n  });\n\n  test('handles mixed casing', () => {\n    expect(capitalizeWords('jaVaScript IS fUn')).toBe('Javascript Is Fun');\n  });\n\n  test('preserves multiple spaces', () => {\n    expect(capitalizeWords('  welcome   to  earth  ')).toBe('  Welcome   To  Earth  ');\n  });\n\n  test('returns empty string for empty input', () => {\n    expect(capitalizeWords('')).toBe('');\n  });\n});\n",
    "testsTs": "import capitalizeWords from './capitalizeWords';\n\ndescribe('capitalizeWords (TypeScript)', () => {\n  it('capitalizes each word in a simple sentence', () => {\n    expect(capitalizeWords('hello world')).toBe('Hello World');\n  });\n\n  it('handles mixed casing', () => {\n    expect(capitalizeWords('jaVaScript IS fUn')).toBe('Javascript Is Fun');\n  });\n\n  it('preserves multiple spaces', () => {\n    expect(capitalizeWords('  welcome   to  earth  ')).toBe('  Welcome   To  Earth  ');\n  });\n\n  it('returns empty string for empty input', () => {\n    expect(capitalizeWords('')).toBe('');\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-sum-numbers",
    "title": "Sum of Numbers in an Array",
    "type": "coding",
    "importance": 2,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrays",
      "numbers",
      "filtering",
      "type-checking",
      "reduce"
    ],
    "description": {
      "summary": "Sum only numeric values from an input array, ignoring non-numbers and `NaN`. This reinforces safe type checking, accumulator patterns, and the idea that you shouldn’t coerce strings like `'5'` into numbers unless the problem explicitly asks for it.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array containing numbers and possibly other types (e.g., strings, booleans, nulls). Only actual numbers should be summed."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The sum of all numeric (non-NaN) elements in the array. Returns `0` if there are no numeric entries."
      },
      "examples": [
        "// Basic examples",
        "sum([1, 2, 3]) // => 6",
        "// '20' is a string → ignored",
        "sum([10, '20', 30]) // => 40",
        "// Ignores non-numbers",
        "sum(['a', 5, true, 7]) // => 12",
        "// Handles empty array",
        "sum([]) // => 0"
      ]
    },
    "starterCode": "export default function sum(arr) {\n  // TODO: Return the sum of all numeric elements, ignoring non-numbers\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function sum(arr: any[]): number {\n  // TODO: Return the sum of all numeric elements, ignoring non-numbers\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Iterate through the array, accumulate only valid numbers, and skip everything else. The key is to use `typeof === 'number'` and `Number.isNaN` so that `NaN` doesn’t poison the sum and strings/booleans aren’t implicitly coerced.",
      "approaches": [
        {
          "title": "Approach 1: Imperative loop (explicit and safe)",
          "prose": "Steps:\n1) Initialize `total = 0`.\n2) For each value `v` in the array, check `typeof v === 'number'` and `!Number.isNaN(v)`.\n3) If valid, add it to the total.\n4) Return the total after the loop.\n\nComplexity: O(n) time, O(1) space. This is predictable and avoids hidden coercions.",
          "codeJs": "export default function sum(arr) {\n  let total = 0;\n  for (const el of arr) {\n    if (typeof el === 'number' && !Number.isNaN(el)) {\n      total += el;\n    }\n  }\n  return total;\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  let total = 0;\n  for (const el of arr) {\n    if (typeof el === 'number' && !Number.isNaN(el)) {\n      total += el;\n    }\n  }\n  return total;\n}\n"
        },
        {
          "title": "Approach 2: Filter + Reduce (functional style)",
          "prose": "Idea: first filter the array to only include valid numbers, then sum them using `reduce()`.\n\nHow it works:\n1. Use `filter()` to keep only elements where `typeof el === 'number' && !Number.isNaN(el)`.\n2. Use `reduce()` with an accumulator starting from `0` to sum the filtered values.\n\nWhy use it: concise and expressive, and the TypeScript version benefits from a type guard.",
          "codeJs": "export default function sum(arr) {\n  return arr\n    .filter(el => typeof el === 'number' && !Number.isNaN(el))\n    .reduce((total, el) => total + el, 0);\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  return arr\n    .filter((el): el is number => typeof el === 'number' && !Number.isNaN(el))\n    .reduce((total, el) => total + el, 0);\n}\n"
        },
        {
          "title": "Approach 3: Reduce-only with inline check",
          "prose": "Idea: combine filtering and summing into a single `reduce()` call.\n\nHow it works:\n1. Start with `total = 0`.\n2. For each `el` in `arr`, check if it is a valid number.\n3. If so, add it to `total`.\n4. Return the final `total`.\n\nWhy use it: avoids creating an intermediate array, which can be more efficient for large inputs.",
          "codeJs": "export default function sum(arr) {\n  return arr.reduce((total, el) => {\n    if (typeof el === 'number' && !Number.isNaN(el)) {\n      total += el;\n    }\n    return total;\n  }, 0);\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  return arr.reduce((total, el) => {\n    if (typeof el === 'number' && !Number.isNaN(el)) {\n      total += el;\n    }\n    return total;\n  }, 0);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid coercing numeric strings — `'20'` should not be counted unless you explicitly convert it.",
          "Skip `NaN` to prevent polluting the final sum.",
          "Ensure non-numeric falsy values like `false`, `null`, or `undefined` are not counted."
        ],
        "edgeCases": [
          "Empty array → returns `0`.",
          "All non-numeric → returns `0`.",
          "Includes `NaN` → ignored.",
          "Mixed types → only valid numbers contribute to the total."
        ],
        "techniques": [
          "Type checking with `typeof` and `Number.isNaN`.",
          "Using loops vs. functional array methods (`filter`, `reduce`).",
          "Accumulator logic for numeric aggregation."
        ]
      },
      "followUpQuestions": [
        "js-flatten-once"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        },
        {
          "title": "MDN – Number.isNaN()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"
        }
      ]
    },
    "tests": "import sum from './sum';\n\ndescribe('sum', () => {\n  test('sums numbers in a simple array', () => {\n    expect(sum([1, 2, 3])).toBe(6);\n  });\n\n  test('ignores non-numeric values', () => {\n    expect(sum(['a', 5, true, 7])).toBe(12);\n  });\n\n  test('ignores numeric strings', () => {\n    expect(sum([10, '20', 30])).toBe(40);\n  });\n\n  test('returns 0 for empty or all-non-numeric arrays', () => {\n    expect(sum([])).toBe(0);\n    expect(sum(['x', false, null])).toBe(0);\n  });\n});\n",
    "testsTs": "import sum from './sum';\n\ndescribe('sum (TypeScript)', () => {\n  it('sums numbers in a simple array', () => {\n    expect(sum([1, 2, 3])).toBe(6);\n  });\n\n  it('ignores non-numeric values', () => {\n    expect(sum(['a', 5, true, 7])).toBe(12);\n  });\n\n  it('ignores numeric strings', () => {\n    expect(sum([10, '20', 30])).toBe(40);\n  });\n\n  it('returns 0 for empty or all-non-numeric arrays', () => {\n    expect(sum([])).toBe(0);\n    expect(sum(['x', false, null])).toBe(0);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-compact",
    "title": "Falsy Bouncer",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrays",
      "filtering",
      "truthy-falsy",
      "functional",
      "basics"
    ],
    "description": {
      "summary": "Remove all falsy values from an array while preserving order. Use a boolean filter to drop false, 0, empty string, null, undefined, and NaN without mutating the input. Concepts: arrays, filtering, truthy-falsy, functional.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array containing any types of elements, including falsy values."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array with all falsy values removed."
      },
      "examples": [
        "// Basic examples\ncompact([0, 1, false, 2, '', 3]) // => [1, 2, 3]",
        "// Works with only truthy values\ncompact(['a', true, 42]) // => ['a', true, 42]",
        "// Handles null and undefined\ncompact([null, undefined, 'x']) // => ['x']",
        "// Handles NaN\ncompact([NaN, 1, 2]) // => [1, 2]"
      ]
    },
    "starterCode": "export default function compact(arr) {\n  // TODO: Remove all falsy values from the array\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function compact(arr: any[]): any[] {\n  // TODO: Remove all falsy values from the array\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Use the Boolean constructor as a predicate to filter out falsy values. This keeps only truthy entries, preserves order, and avoids manual checks for null, undefined, or empty strings. It’s a concise, idiomatic solution that’s easy to read and easy to explain in interviews. Key concepts: arrays, filtering, truthy-falsy.",
      "approaches": [
        {
          "title": "Approach 1: Using filter(Boolean) (concise and expressive)",
          "prose": "Return arr.filter(Boolean) (or arr.filter(v => Boolean(v))). This keeps values like 1, '0', and {} while removing false, 0, '', null, undefined, and NaN. The method returns a new array, so the original is not mutated, and the runtime is linear in the array length.",
          "codeJs": "export default function compact(arr) {\n  return arr.filter(Boolean);\n}\n",
          "codeTs": "export default function compact(arr: any[]): any[] {\n  return arr.filter(Boolean);\n}\n"
        },
        {
          "title": "Approach 2: Manual filtering with explicit check",
          "prose": "Idea: explicitly iterate and push only truthy elements to a new array. Slightly longer but very clear for beginners.\n\nHow it works:\n1. Initialize an empty array `result = []`.\n2. Loop over each element `el` in `arr` and check if it is truthy using `if (el)`.\n3. If the condition is true, push `el` into `result`.\n4. After the loop finishes, return `result`.\n\nWhy use it: makes the truthy/falsy check very explicit and shows how `filter` works under the hood. Also runs in O(n) time and uses O(n) space.",
          "codeJs": "export default function compact(arr) {\n  const result = [];\n  for (const el of arr) {\n    if (el) result.push(el);\n  }\n  return result;\n}\n",
          "codeTs": "export default function compact(arr: any[]): any[] {\n  const result: any[] = [];\n  for (const el of arr) {\n    if (el) result.push(el);\n  }\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid this pattern if you need to keep values like `0` or `''` — this function removes all falsy values by design.",
          "Be aware that `NaN` is also falsy and will be removed."
        ],
        "edgeCases": [
          "Empty array → returns `[]`.",
          "Array with all falsy values → returns `[]`.",
          "Mixed types → only truthy ones remain."
        ],
        "techniques": [
          "Using Boolean coercion in array filtering.",
          "Understanding truthy/falsy evaluation in JavaScript.",
          "Preserving array order during filtering."
        ]
      },
      "followUpQuestions": [
        "js-unique-array"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        },
        {
          "title": "MDN – Boolean() constructor",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"
        }
      ]
    },
    "tests": "import compact from './compact';\n\ndescribe('compact', () => {\n  test('removes falsy values', () => {\n    expect(compact([0, 1, false, 2, '', 3])).toEqual([1, 2, 3]);\n  });\n\n  test('returns same array when all truthy', () => {\n    expect(compact(['a', true, 42])).toEqual(['a', true, 42]);\n  });\n\n  test('removes null and undefined', () => {\n    expect(compact([null, undefined, 'x'])).toEqual(['x']);\n  });\n\n  test('removes NaN', () => {\n    expect(compact([NaN, 1, 2])).toEqual([1, 2]);\n  });\n\n  test('handles empty array', () => {\n    expect(compact([])).toEqual([]);\n  });\n});\n",
    "testsTs": "import compact from './compact';\n\ndescribe('compact (TypeScript)', () => {\n  it('removes falsy values', () => {\n    expect(compact([0, 1, false, 2, '', 3])).toEqual([1, 2, 3]);\n  });\n\n  it('returns same array when all truthy', () => {\n    expect(compact(['a', true, 42])).toEqual(['a', true, 42]);\n  });\n\n  it('removes null and undefined', () => {\n    expect(compact([null, undefined, 'x'])).toEqual(['x']);\n  });\n\n  it('removes NaN', () => {\n    expect(compact([NaN, 1, 2])).toEqual([1, 2]);\n  });\n\n  it('handles empty array', () => {\n    expect(compact([])).toEqual([]);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-arrays-equal",
    "title": "Check if Two Arrays Are Equal",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrays",
      "equality",
      "comparison",
      "iteration",
      "basics"
    ],
    "description": {
      "summary": "Check whether two arrays are equal by length and by value at each index. This is a shallow equality check for primitive elements: order matters, and any mismatch should return false immediately. It highlights iteration, early exits, and strict equality behavior.",
      "arguments": [
        {
          "name": "a",
          "type": "any[]",
          "desc": "The first array to compare."
        },
        {
          "name": "b",
          "type": "any[]",
          "desc": "The second array to compare."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if both arrays are identical in length and elements (in the same order), otherwise `false`."
      },
      "examples": [
        "// Basic examples\narraysEqual([1, 2, 3], [1, 2, 3]) // => true",
        "arraysEqual([1, 2, 3], [3, 2, 1]) // => false",
        "// Different lengths\narraysEqual([1, 2], [1, 2, 3]) // => false",
        "// Works with strings\narraysEqual(['a', 'b'], ['a', 'b']) // => true",
        "// Works with mixed types\narraysEqual([1, '2', 3], [1, 2, 3]) // => false"
      ]
    },
    "starterCode": "export default function arraysEqual(a, b) {\n  // TODO: Return true if both arrays contain the same elements in the same order\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  // TODO: Return true if both arrays contain the same elements in the same order\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Compare arrays by first checking length and then scanning index-by-index for strict equality. This is the standard shallow equality test when arrays contain primitives or stable references, and it avoids expensive conversions or nested loops.",
      "approaches": [
        {
          "title": "Approach 1: Loop-based comparison (explicit and efficient)",
          "prose": "Algorithm:\n1) If `a === b`, return true (same reference).\n2) If either is not an array or lengths differ, return false.\n3) Loop through indices; if `a[i] !== b[i]`, return false.\n4) If the loop completes, return true.\n\nComplexity: O(n) time, O(1) space. This intentionally does not deep-compare nested objects.",
          "codeJs": "export default function arraysEqual(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n"
        },
        {
          "title": "Approach 2: Using every() (declarative style)",
          "prose": "Idea: use `Array.prototype.every()` to ensure that every element in `a` matches the element at the same index in `b`.\n\nHow it works:\n1. If `a.length !== b.length`, return `false`.\n2. Otherwise, return `a.every((el, i) => el === b[i])`.\n\nWhy use it: more declarative and concise than a manual loop, while still running in O(n) time and short-circuiting on the first mismatch.",
          "codeJs": "export default function arraysEqual(a, b) {\n  return a.length === b.length && a.every((el, i) => el === b[i]);\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  return a.length === b.length && a.every((el, i) => el === b[i]);\n}\n"
        },
        {
          "title": "Approach 3: JSON.stringify shortcut (not recommended for complex data)",
          "prose": "Idea: serialize both arrays to JSON strings and compare the resulting strings.\n\nHow it works:\n1. Compute `JSON.stringify(a)` and `JSON.stringify(b)`.\n2. Compare the two strings with `===` and return the result.\n\nWhy use it: very compact and can work for simple arrays of primitives, but it has important caveats — it does not handle `undefined`, functions, or differences in object key order reliably, so it is not suitable for robust deep equality checks.",
          "codeJs": "export default function arraysEqual(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Strict equality (`===`) does not perform deep comparison for objects or nested arrays; it compares references.",
          "Avoid relying on `JSON.stringify` for nested structures, objects with varying key order, or values like `undefined`, functions, or symbols.",
          "Be aware that `['1']` and `[1]` are not considered equal due to type differences."
        ],
        "edgeCases": [
          "Empty arrays → `true`.",
          "Different lengths → `false`.",
          "Different order → `false`.",
          "Mixed types → `false` when any pair differs by value or type.",
          "Nested arrays or objects → compared by reference in Approaches 1 and 2; not reliably by structure in Approach 3."
        ],
        "techniques": [
          "Using index-based loops for element-wise comparison.",
          "Using `every()` for a declarative comparison with early exit.",
          "Understanding reference vs. value equality in JavaScript."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.every()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every"
        },
        {
          "title": "MDN – Equality comparisons and sameness",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness"
        }
      ]
    },
    "tests": "import arraysEqual from './arraysEqual';\n\ndescribe('arraysEqual', () => {\n  test('returns true for identical arrays', () => {\n    expect(arraysEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  });\n\n  test('returns false for different element order', () => {\n    expect(arraysEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  test('returns false for different lengths', () => {\n    expect(arraysEqual([1, 2], [1, 2, 3])).toBe(false);\n  });\n\n  test('works with string arrays', () => {\n    expect(arraysEqual(['a', 'b'], ['a', 'b'])).toBe(true);\n  });\n\n  test('returns false for mixed type differences', () => {\n    expect(arraysEqual([1, '2', 3], [1, 2, 3])).toBe(false);\n  });\n\n  test('handles empty arrays', () => {\n    expect(arraysEqual([], [])).toBe(true);\n  });\n});\n",
    "testsTs": "import arraysEqual from './arraysEqual';\n\ndescribe('arraysEqual (TypeScript)', () => {\n  it('returns true for identical arrays', () => {\n    expect(arraysEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  });\n\n  it('returns false for different element order', () => {\n    expect(arraysEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  it('returns false for different lengths', () => {\n    expect(arraysEqual([1, 2], [1, 2, 3])).toBe(false);\n  });\n\n  it('works with string arrays', () => {\n    expect(arraysEqual(['a', 'b'], ['a', 'b'])).toBe(true);\n  });\n\n  it('returns false for mixed type differences', () => {\n    expect(arraysEqual([1, '2', 3], [1, 2, 3])).toBe(false);\n  });\n\n  it('handles empty arrays', () => {\n    expect(arraysEqual([], [])).toBe(true);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-shallow-clone",
    "title": "Shallow Clone (Object or Array)",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "clone",
      "objects",
      "arrays",
      "immutability",
      "basics"
    ],
    "description": {
      "summary": "Create a shallow copy of an array or object. Copy top-level properties but keep nested references intact, and document that limitation clearly. This clarifies the difference between shallow and deep cloning and helps avoid accidental mutation bugs.",
      "arguments": [
        {
          "name": "value",
          "type": "Object | Array",
          "desc": "The object or array to clone."
        }
      ],
      "returns": {
        "type": "Object | Array",
        "desc": "A new shallow-cloned object or array."
      },
      "examples": [
        "// Object example\nconst obj = { a: 1, b: { c: 2 } };\nconst copy = shallowClone(obj);\ncopy !== obj; // true\ncopy.b === obj.b; // true (shallow)",
        "// Array example\nconst arr = [1, { x: 2 }];\nconst out = shallowClone(arr);\nout !== arr; // true\nout[1] === arr[1]; // true (shallow)"
      ]
    },
    "starterCode": "export default function shallowClone(value) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function shallowClone<T extends Record<string, any> | any[]>(value: T): T {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "A shallow clone copies only the top-level container and its immediate properties. Nested objects and arrays remain shared references, which is the key limitation to call out. This is still valuable for state updates that only change top-level fields or for defensive copying in reducers.",
      "approaches": [
        {
          "title": "Approach: Branch on array vs object",
          "prose": "Check if the input is an array; if so, return value.slice() or [...value]. If it’s a non-null object, return { ...value } or Object.assign({}, value). For non-objects, throw a TypeError. This is O(n) for top-level properties and preserves nested references by design.",
          "codeJs": "export default function shallowClone(value) {\n  if (Array.isArray(value)) return value.slice();\n  if (value && typeof value === 'object') return { ...value };\n  throw new TypeError('Expected object or array');\n}\n",
          "codeTs": "export default function shallowClone<T extends Record<string, any> | any[]>(value: T): T {\n  if (Array.isArray(value)) return value.slice() as T;\n  if (value && typeof value === 'object') return { ...(value as any) } as T;\n  throw new TypeError('Expected object or array');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "This is a shallow clone: nested objects and arrays are still shared by reference.",
          "`null` is an object in JS, so always guard with `value && typeof value === \"object\"`.",
          "Object spread does not preserve prototypes or non-enumerable properties."
        ],
        "edgeCases": [
          "`[]` returns a new empty array (different reference).",
          "`{}` returns a new empty object (different reference).",
          "Nested objects remain the same reference in the clone."
        ],
        "techniques": [
          "Array copying with `.slice()` or spread.",
          "Object copying with spread or `Object.assign`."
        ]
      },
      "followUpQuestions": [
        "js-deep-clone"
      ],
      "resources": [
        {
          "title": "MDN – Object.assign()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"
        },
        {
          "title": "MDN – Array.prototype.slice()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice"
        }
      ]
    },
    "tests": "import shallowClone from './file';\n\ndescribe('shallowClone', () => {\n  test('clones arrays shallowly', () => {\n    const arr = [1, { x: 2 }];\n    const copy = shallowClone(arr);\n    expect(copy).toEqual(arr);\n    expect(copy === arr).toBe(false);\n    expect(copy[1]).toBe(arr[1]);\n  });\n\n  test('clones objects shallowly', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const copy = shallowClone(obj);\n    expect(copy).toEqual(obj);\n    expect(copy === obj).toBe(false);\n    expect(copy.b).toBe(obj.b);\n  });\n\n  test('throws for non-object/array', () => {\n    expect(() => shallowClone(42)).toThrow(TypeError);\n    expect(() => shallowClone('x')).toThrow(TypeError);\n  });\n});\n",
    "testsTs": "import shallowClone from './file';\n\ndescribe('shallowClone (TypeScript)', () => {\n  it('clones arrays shallowly', () => {\n    const arr = [1, { x: 2 }];\n    const copy = shallowClone(arr);\n    expect(copy).toEqual(arr);\n    expect(copy === arr).toBe(false);\n  });\n\n  it('clones objects shallowly', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const copy = shallowClone(obj);\n    expect(copy).toEqual(obj);\n    expect(copy === obj).toBe(false);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-sleep",
    "title": "Sleep / Delay Promise",
    "type": "coding",
    "technology": "javascript",
    "importance": 2,
    "difficulty": "easy",
    "tags": [
      "async",
      "promises",
      "timers",
      "utilities",
      "basics"
    ],
    "description": {
      "summary": "Implement sleep(ms) that returns a Promise resolving after ms milliseconds. Use it to pause async flows like retries, exponential backoff, UI delays, or test helpers without blocking the event loop or freezing the UI thread.",
      "arguments": [
        {
          "name": "ms",
          "type": "number",
          "desc": "The delay in milliseconds."
        }
      ],
      "returns": {
        "type": "Promise<void>",
        "desc": "A promise that resolves after the delay."
      },
      "examples": [
        "// Usage with async/await\nawait sleep(50);\nconsole.log('done');",
        "// Usage with then\nsleep(20).then(() => console.log('ready'));"
      ]
    },
    "starterCode": "export default function sleep(ms) {\n  // TODO: return a Promise that resolves after ms milliseconds\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function sleep(ms: number): Promise<void> {\n  // TODO: return a Promise that resolves after ms milliseconds\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "This utility wraps setTimeout in a Promise so you can pause async control flow without blocking. It’s a common primitive for polling, retry logic, exponential backoff, and UI timing. The function should integrate cleanly with async/await, return a Promise every time, and behave predictably for zero or negative delays.",
      "approaches": [
        {
          "title": "Approach: Promise + setTimeout",
          "prose": "Return new Promise(resolve => setTimeout(resolve, ms)). Ensure you return the Promise so callers can await it or chain then. If ms is negative or NaN, setTimeout resolves immediately, which is acceptable for this helper. Keep the function tiny and deterministic; it should never block the main thread.",
          "codeJs": "export default function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n",
          "codeTs": "export default function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Don't forget to return the Promise (otherwise callers cannot await it).",
          "`setTimeout` returns a timer id, not a Promise.",
          "Negative or NaN delays are treated as 0 by most environments."
        ],
        "edgeCases": [
          "`ms = 0` resolves on the next tick.",
          "Very large delays may be clamped by the environment."
        ],
        "techniques": [
          "Promise construction around callback-based APIs.",
          "Basic async timing utilities."
        ]
      },
      "followUpQuestions": [
        "js-debounce",
        "js-add-two-promises"
      ],
      "resources": [
        {
          "title": "MDN – setTimeout()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        },
        {
          "title": "MDN – Promise",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
        }
      ]
    },
    "tests": "import sleep from './file';\n\ndescribe('sleep', () => {\n  test('returns a promise', () => {\n    const p = sleep(1);\n    expect(p && typeof p.then).toBe('function');\n  });\n\n  test('resolves after at least the delay', async () => {\n    const start = Date.now();\n    await sleep(25);\n    const elapsed = Date.now() - start;\n    expect(elapsed >= 20).toBe(true);\n  });\n});\n",
    "testsTs": "import sleep from './file';\n\ndescribe('sleep (TypeScript)', () => {\n  it('returns a promise', () => {\n    const p = sleep(1);\n    expect(p && typeof p.then).toBe('function');\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-once",
    "title": "Once (Function Wrapper)",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "higher-order",
      "functions",
      "closure",
      "basics"
    ],
    "description": {
      "summary": "Implement once(fn) that returns a wrapper which executes `fn` only on the first call. Cache and return the result on subsequent calls without re-invoking `fn`. This tests closures, memoization, and side-effect control. Concepts: higher-order, functions, closure.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The function to call once."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A wrapped function that only calls `fn` once."
      },
      "examples": [
        "const addOnce = once((a, b) => a + b);\naddOnce(1, 2); // 3\naddOnce(5, 6); // still 3",
        "const obj = { x: 2, get: once(function (n) { return this.x + n; }) };\nobj.get(3); // 5"
      ]
    },
    "starterCode": "export default function once(fn) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function once<F extends (...args: any[]) => any>(fn: F): F {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Wrap a function with a closure that tracks whether it has been called and stores its return value. The first call executes the original function; every later call returns the cached result. This pattern is common for one-time initialization and idempotent setup. Key concepts: higher-order, functions, closure.",
      "approaches": [
        {
          "title": "Approach: Closure with a called flag",
          "prose": "Algorithm:\n- Create `called = false` and `result` in the outer scope.\n- Return a wrapper function that checks `called`.\n- If not called, invoke `fn` with the current arguments/this, store the result, and set `called = true`.\n- Always return `result`.\n\nComplexity: O(1) per call, O(1) extra space.",
          "codeJs": "export default function once(fn) {\n  let called = false;\n  let result;\n  return function (...args) {\n    if (!called) {\n      called = true;\n      result = fn.apply(this, args);\n    }\n    return result;\n  };\n}\n",
          "codeTs": "export default function once<F extends (...args: any[]) => any>(fn: F): F {\n  let called = false;\n  let result: ReturnType<F>;\n  return function (this: any, ...args: Parameters<F>) {\n    if (!called) {\n      called = true;\n      result = fn.apply(this, args);\n    }\n    return result;\n  } as F;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Preserve `this` by using `fn.apply(this, args)`.",
          "Subsequent calls return the first result, even with different arguments.",
          "If `fn` throws, this implementation still marks it as called."
        ],
        "edgeCases": [
          "Functions that return `undefined` still count as called.",
          "Wrapper should work with any number of arguments."
        ],
        "techniques": [
          "Closures for private state.",
          "Higher-order functions."
        ]
      },
      "followUpQuestions": [
        "js-memoize-function"
      ],
      "resources": [
        {
          "title": "MDN – Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        },
        {
          "title": "MDN – Function.prototype.apply()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
        }
      ]
    },
    "tests": "import once from './file';\n\ndescribe('once', () => {\n  test('calls the function only once', () => {\n    let calls = 0;\n    const fn = once(() => { calls += 1; return calls; });\n    expect(fn()).toBe(1);\n    expect(fn()).toBe(1);\n    expect(calls).toBe(1);\n  });\n\n  test('returns the first result on later calls', () => {\n    const add = once((a, b) => a + b);\n    expect(add(1, 2)).toBe(3);\n    expect(add(5, 6)).toBe(3);\n  });\n\n  test('preserves this context', () => {\n    const obj = { x: 2, get: once(function (n) { return this.x + n; }) };\n    expect(obj.get(3)).toBe(5);\n  });\n});\n",
    "testsTs": "import once from './file';\n\ndescribe('once (TypeScript)', () => {\n  it('calls only once', () => {\n    let calls = 0;\n    const fn = once(() => { calls += 1; return calls; });\n    fn();\n    fn();\n    expect(calls).toBe(1);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-object-create",
    "title": "Create Object with Prototype",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "object-creation",
      "prototypes",
      "objects",
      "inheritance",
      "basics"
    ],
    "description": {
      "summary": "Implement objectCreate(proto) to return a new object whose prototype is `proto`. Use a temporary constructor function or Object.create-like pattern and handle `null` prototypes safely. This tests understanding of prototypes and inheritance without mutating __proto__.",
      "arguments": [
        {
          "name": "proto",
          "type": "Object | null",
          "desc": "The prototype for the new object."
        },
        {
          "name": "props",
          "type": "Object (optional)",
          "desc": "Own enumerable properties to copy onto the new object."
        }
      ],
      "returns": {
        "type": "Object",
        "desc": "A new object with the specified prototype and properties."
      },
      "examples": [
        "const proto = { greet() { return 'hi'; } };\nconst obj = createObject(proto, { name: 'Ada' });\nObject.getPrototypeOf(obj) === proto; // true\nobj.name; // 'Ada'\nobj.greet(); // 'hi'",
        "const bare = createObject(null);\nObject.getPrototypeOf(bare) === null; // true"
      ]
    },
    "starterCode": "export default function createObject(proto, props) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function createObject(proto: object | null, props?: Record<string, any>): object {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Create a new object with its internal [[Prototype]] set to the given `proto`. You can do this by temporarily assigning `proto` to a function’s prototype and instantiating it, or by using the Object.create pattern. Guard against invalid prototypes and support `null` when required.",
      "approaches": [
        {
          "title": "Approach: Object.create + Object.assign",
          "prose": "Steps:\n1) Validate that `proto` is an object/function or `null`; otherwise throw a TypeError.\n2) If using the classic pattern, define a function `F`, set `F.prototype = proto`, and return `new F()`.\n3) If `proto` is null, ensure the created object has no prototype.\n\nComplexity: O(1) time and space.",
          "codeJs": "export default function createObject(proto, props) {\n  const validProto = proto === null || typeof proto === 'object' || typeof proto === 'function';\n  if (!validProto) throw new TypeError('proto must be an object or null');\n\n  const obj = Object.create(proto);\n  if (props != null) {\n    if (typeof props !== 'object') throw new TypeError('props must be an object');\n    Object.assign(obj, props);\n  }\n  return obj;\n}\n",
          "codeTs": "export default function createObject(proto: object | null, props?: Record<string, any>): object {\n  const validProto = proto === null || typeof proto === 'object' || typeof proto === 'function';\n  if (!validProto) throw new TypeError('proto must be an object or null');\n\n  const obj = Object.create(proto);\n  if (props != null) {\n    if (typeof props !== 'object') throw new TypeError('props must be an object');\n    Object.assign(obj, props);\n  }\n  return obj;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid assigning to `__proto__` directly; use `Object.create`.",
          "If `props` is `null` or non-object, decide whether to ignore or throw (here we throw).",
          "Objects created with `null` prototype do not inherit `toString`, `hasOwnProperty`, etc."
        ],
        "edgeCases": [
          "`proto = null` should create a null-prototype object.",
          "`props` omitted should still create an object with the right prototype."
        ],
        "techniques": [
          "`Object.create` for prototype wiring.",
          "`Object.assign` for shallow property copy."
        ]
      },
      "followUpQuestions": [
        "js-deep-clone"
      ],
      "resources": [
        {
          "title": "MDN – Object.create()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
        },
        {
          "title": "MDN – Object.getPrototypeOf()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"
        }
      ]
    },
    "tests": "import createObject from './file';\n\ndescribe('createObject', () => {\n  test('sets the prototype and copies props', () => {\n    const proto = { greet() { return 'hi'; } };\n    const obj = createObject(proto, { name: 'Ada' });\n    expect(Object.getPrototypeOf(obj)).toBe(proto);\n    expect(obj.name).toBe('Ada');\n    expect(obj.greet()).toBe('hi');\n  });\n\n  test('supports null prototype', () => {\n    const obj = createObject(null);\n    expect(Object.getPrototypeOf(obj)).toBe(null);\n  });\n\n  test('throws on invalid prototype', () => {\n    expect(() => createObject(42, {})).toThrow(TypeError);\n  });\n});\n",
    "testsTs": "import createObject from './file';\n\ndescribe('createObject (TypeScript)', () => {\n  it('creates object with prototype', () => {\n    const proto = { x: 1 };\n    const obj = createObject(proto, { y: 2 });\n    expect(Object.getPrototypeOf(obj)).toBe(proto);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-update-at-index",
    "title": "Update Array at Index (Immutable)",
    "type": "coding",
    "technology": "javascript",
    "importance": 2,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "immutability",
      "state",
      "basics",
      "utilities"
    ],
    "description": {
      "summary": "Return a new array with one index updated, leaving the original array untouched. This is the core immutable update pattern used in reducers, React state updates, and UI list editing, and it prevents accidental mutation.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "The input array."
        },
        {
          "name": "index",
          "type": "number",
          "desc": "The index to update."
        },
        {
          "name": "value",
          "type": "any",
          "desc": "The new value to write."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array with the update applied (or a copy if out of range)."
      },
      "examples": [
        "updateAt([1, 2, 3], 1, 9); // => [1, 9, 3]",
        "updateAt([1, 2], 5, 9); // => [1, 2]"
      ]
    },
    "starterCode": "export default function updateAt(arr, index, value) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function updateAt<T>(arr: T[], index: number, value: T): T[] {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "This is an immutable update helper: clone the array, update one index, and return the new array. It mirrors reducer patterns used in UI state management. Returning a new array every time avoids accidental mutation and keeps equality checks predictable for change detection and memoization.",
      "approaches": [
        {
          "title": "Approach: Clone then assign",
          "prose": "Create a shallow copy with slice or spread, validate the index, update the value on the copy, and return the copy. If the index is out of range, return the untouched copy for stability. This keeps the original input unchanged and makes the function safe for shared state.",
          "codeJs": "export default function updateAt(arr, index, value) {\n  if (!Array.isArray(arr)) throw new TypeError('Expected array');\n  const copy = arr.slice();\n  if (index < 0 || index >= copy.length) return copy;\n  copy[index] = value;\n  return copy;\n}\n",
          "codeTs": "export default function updateAt<T>(arr: T[], index: number, value: T): T[] {\n  if (!Array.isArray(arr)) throw new TypeError('Expected array');\n  const copy = arr.slice();\n  if (index < 0 || index >= copy.length) return copy;\n  copy[index] = value;\n  return copy;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Don't mutate the original array in-place.",
          "Be explicit about out-of-range indices.",
          "Returning the original array would break immutability expectations."
        ],
        "edgeCases": [
          "Empty array returns a new empty array.",
          "Negative or too-large index returns an unchanged copy.",
          "Index 0 and last index should work normally."
        ],
        "techniques": [
          "Array copying with `.slice()`.",
          "Immutable update patterns."
        ]
      },
      "followUpQuestions": [
        "js-set-by-path-2"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.slice()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice"
        }
      ]
    },
    "tests": "import updateAt from './file';\n\ndescribe('updateAt', () => {\n  test('updates a value immutably', () => {\n    const arr = [1, 2, 3];\n    const out = updateAt(arr, 1, 9);\n    expect(out).toEqual([1, 9, 3]);\n    expect(out === arr).toBe(false);\n    expect(arr).toEqual([1, 2, 3]);\n  });\n\n  test('returns unchanged copy when out of range', () => {\n    const arr = [1, 2];\n    const out = updateAt(arr, 5, 9);\n    expect(out).toEqual([1, 2]);\n    expect(out === arr).toBe(false);\n  });\n\n  test('throws on non-array input', () => {\n    expect(() => updateAt('x', 0, 'y')).toThrow(TypeError);\n  });\n});\n",
    "testsTs": "import updateAt from './file';\n\ndescribe('updateAt (TypeScript)', () => {\n  it('updates immutably', () => {\n    const arr = [1, 2, 3];\n    const out = updateAt(arr, 2, 5);\n    expect(out).toEqual([1, 2, 5]);\n    expect(out === arr).toBe(false);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-debounce",
    "title": "Debounce Function",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "companies": [
      "google",
      "netflix",
      "apple",
      "meta"
    ],
    "difficulty": "intermediate",
    "tags": [
      "async",
      "functions",
      "timing"
    ],
    "description": {
      "summary": "Implement debounce(fn, wait) that delays execution until the user stops triggering events. Clear the previous timer on each call, preserve this/args, and make the timing predictable for search/resize use cases.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The function to be executed after the delay."
        },
        {
          "name": "delay",
          "type": "number",
          "desc": "The number of milliseconds to wait before executing the function."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A debounced version of the original function that delays execution until the delay period has elapsed."
      },
      "examples": [
        "// Basic examples\ndebounce(() => console.log('Hello!'), 300)",
        "// Multiple rapid calls — only last one runs\nconst log = debounce(() => console.log('Run!'), 500)\nlog()\nlog()\nlog() // Only this one executes after 500ms",
        "// With arguments\nconst greet = debounce(name => console.log(`Hi ${name}`), 400)\ngreet('Alice')\ngreet('Bob') // Only 'Hi Bob' logs after 400ms"
      ]
    },
    "starterCode": "export default function debounce(fn, delay) {\n  // TODO: Return a debounced function that delays execution until delay ms have passed\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): F {\n  // TODO: Return a debounced function that delays execution until delay ms have passed\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure `fn` runs only after calls have stopped for `delay` ms (trailing-edge debounce by default). This is common for search inputs, resize/scroll handlers, and deduping rapid UI events. Approaches 2 and 3 show common extensions used in real-world libraries.",
      "approaches": [
        {
          "title": "Approach 1: Timeout-based debounce (canonical)",
          "prose": "Idea: store a `timeoutId`. Each call clears the previous timeout and schedules a new one. When the last timer completes, invoke `fn` with the latest args and `this`.\n\nHow it works:\n1. Keep `let timeoutId` in the closure.\n2. On each call, clear any existing timer with `clearTimeout(timeoutId)`.\n3. Start a new timer: `timeoutId = setTimeout(() => fn.apply(this, args), delay)`.\n4. Return the debounced wrapper function.\n\nThis is the classic trailing-edge debounce: only the last call in a burst actually runs.",
          "codeJs": "export default function debounce(fn, delay) {\n  let timeoutId;\n  return function (...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n",
          "codeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): F {\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  return function (this: any, ...args: Parameters<F>) {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  } as F;\n}\n"
        },
        {
          "title": "Approach 2: Debounce with cancel + flush helpers (extended API)",
          "prose": "Idea: extend the basic debounced function with `.cancel()` and `.flush()` helpers so callers can cancel a pending call or force it to run immediately.\n\nHow it works:\n1. Wrap the debounced function and keep `timeoutId`, `lastArgs`, and `lastThis` in the closure.\n2. On each call, store the latest args/context, clear the previous timer, and start a new one.\n3. `.cancel()` just clears the timer.\n4. `.flush()` clears the timer and immediately invokes `fn` with the last stored args and context.\n\nThis pattern mirrors popular utility libraries (like Lodash) and is an extension beyond the minimal `debounce(fn, delay)` contract.",
          "codeJs": "export default function debounce(fn, delay) {\n  let timeoutId, lastArgs, lastThis;\n  function debounced(...args) {\n    lastArgs = args;\n    lastThis = this;\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }, delay);\n  }\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n  debounced.flush = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }\n  };\n  return debounced;\n}\n",
          "codeTs": "type Debounced<F extends (...a: any[]) => void> = F & { cancel: () => void; flush: () => void };\n\nexport default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): Debounced<F> {\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  let lastArgs: Parameters<F>;\n  let lastThis: any;\n\n  const debounced = function (this: any, ...args: Parameters<F>) {\n    lastArgs = args;\n    lastThis = this;\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }, delay);\n  } as Debounced<F>;\n\n  debounced.cancel = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n    }\n  };\n\n  debounced.flush = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }\n  };\n\n  return debounced;\n}\n"
        },
        {
          "title": "Approach 3: Leading-edge option (extended signature)",
          "prose": "Idea: add an options object to support `leading` mode. With `leading: true`, call `fn` immediately on the first trigger in a burst and then suppress further calls until the delay elapses. With `leading: false` (default), fall back to classic trailing-only debounce.\n\nHow it works:\n1. Track `timeoutId`, plus the last arguments and `this`.\n2. On each call, compute `shouldCallNow = leading && !timeoutId` to know whether this should be an immediate (leading) call.\n3. Clear any existing timer and start a new one. In trailing mode (`leading === false`), the timer will call `fn` after `delay` with the last arguments. In leading mode, the timer simply resets `timeoutId` after `delay` so that a new burst can trigger another leading call.\n4. If `shouldCallNow` is true, invoke `fn` immediately with the current arguments.\n\nThis is an API extension: the base exercise only requires `debounce(fn, delay)`, but this shows how to evolve it to support configurable leading behavior.",
          "codeJs": "export default function debounce(fn, delay, { leading = false } = {}) {\n  let timeoutId, lastArgs, lastThis;\n  return function (...args) {\n    lastArgs = args;\n    lastThis = this;\n    const shouldCallNow = leading && !timeoutId;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      if (!leading) {\n        fn.apply(lastThis, lastArgs);\n      }\n    }, delay);\n\n    if (shouldCallNow) {\n      fn.apply(lastThis, lastArgs);\n    }\n  };\n}\n",
          "codeTs": "export default function debounce<F extends (...a: any[]) => void>(\n  fn: F,\n  delay: number,\n  opts: { leading?: boolean } = {}\n): F {\n  const { leading = false } = opts;\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  let lastArgs: Parameters<F>;\n  let lastThis: any;\n\n  const debounced = function (this: any, ...args: Parameters<F>) {\n    lastArgs = args;\n    lastThis = this;\n    const shouldCallNow = leading && !timeoutId;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      if (!leading) {\n        fn.apply(lastThis, lastArgs);\n      }\n    }, delay);\n\n    if (shouldCallNow) {\n      fn.apply(lastThis, lastArgs);\n    }\n  } as F;\n\n  return debounced;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Return value is usually lost; debounced wrappers typically return `void`. If you need a result, consider callbacks or promises.",
          "Be careful with `this` — use `fn.apply(this, args)` (or `fn.call`) so methods still see the correct context.",
          "Timers differ between environments (Node vs browser), but `setTimeout/clearTimeout` work in both."
        ],
        "edgeCases": [
          "delay = 0 → effectively batches multiple calls into one at the end of the event loop.",
          "Rapid continuous calls → only the last invocation executes after inactivity in trailing mode.",
          "In long-lived components, remember to cancel timers (e.g. via `.cancel()`) on unmount to avoid stray executions."
        ],
        "techniques": [
          "Using closures to store timer and last-arguments state.",
          "Clearing and resetting timeouts to restart the debounce window.",
          "Extending the basic pattern with cancel/flush helpers and leading-edge options."
        ]
      },
      "followUpQuestions": [
        "js-throttle"
      ],
      "resources": [
        {
          "title": "MDN – setTimeout()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        },
        {
          "title": "MDN – Function.prototype.apply()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
        }
      ]
    },
    "tests": "import debounce from './debounce';\n\nconst wait = (ms) => new Promise((r) => setTimeout(r, ms));\n\ndescribe('debounce', () => {\n  test('calls function after delay', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 120);\n\n    debounced();\n    expect(calls).toBe(0);\n\n    await wait(140);\n    expect(calls).toBe(1);\n  });\n\n  test('resets timer on rapid calls (only last executes)', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 100);\n\n    debounced();\n    await wait(50);\n    debounced();\n    await wait(50);\n    debounced();\n\n    await wait(90);\n    expect(calls).toBe(0);\n\n    await wait(20);\n    expect(calls).toBe(1);\n  });\n\n  test('passes arguments (and preserves this via apply)', async () => {\n    let last = '';\n    const debounced = debounce(function (name) {\n      last = `Hi ${name}`;\n    }, 80);\n\n    debounced.call({ tag: 'ctx' }, 'Alice');\n    await wait(100);\n    expect(last).toBe('Hi Alice');\n  });\n});\n",
    "testsTs": "import debounce from './debounce';\n\nconst wait = (ms: number) => new Promise<void>((r) => setTimeout(r, ms));\n\ndescribe('debounce (TypeScript)', () => {\n  it('delays function execution', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 120);\n\n    debounced();\n    expect(calls).toBe(0);\n\n    await wait(140);\n    expect(calls).toBe(1);\n  });\n\n  it('restarts timer on multiple calls', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 100);\n\n    debounced();\n    await wait(50);\n    debounced();\n    await wait(50);\n    debounced();\n\n    await wait(90);\n    expect(calls).toBe(0);\n\n    await wait(20);\n    expect(calls).toBe(1);\n  });\n\n  it('forwards parameters correctly', async () => {\n    let captured = '';\n    const debounced = debounce((msg: string) => { captured = msg; }, 80);\n\n    debounced('Hello');\n    await wait(100);\n    expect(captured).toBe('Hello');\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-throttle",
    "title": "Throttle Function",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "companies": [
      "google",
      "netflix",
      "meta"
    ],
    "difficulty": "intermediate",
    "tags": [
      "async",
      "functions",
      "timing"
    ],
    "description": {
      "summary": "Implement a function `throttle(fn, interval)` that ensures `fn` is executed at most once during every `interval` milliseconds, no matter how many times it's triggered. In this exercise we use a leading-only throttle: the first call in each interval runs immediately; subsequent calls within that window are ignored. Concepts: async, functions, timing.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The function to be throttled."
        },
        {
          "name": "interval",
          "type": "number",
          "desc": "The time window (in milliseconds) within which subsequent calls are ignored."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A throttled version of the original function that executes at most once per interval (leading-edge behavior)."
      },
      "examples": [
        "// Basic examples\nthrottle(() => console.log('Clicked!'), 1000)",
        "// Multiple rapid calls — only the first one executes within the interval\nconst log = throttle(() => console.log('Run!'), 500)\nlog()\nlog()\nlog() // Only the first logs immediately; later calls within 500ms are ignored",
        "// With arguments (leading-only)\nconst greet = throttle(name => console.log(`Hi ${name}`), 800)\ngreet('Alice')\ngreet('Bob') // 'Hi Alice' logs immediately; 'Hi Bob' is ignored because it's inside the 800ms window\n// A call after 800ms (e.g. greet('Charlie')) would run again"
      ]
    },
    "starterCode": "export default function throttle(fn, interval) {\n  // TODO: Execute fn at most once per interval (leading-only)\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  // TODO: Execute fn at most once per interval (leading-only)\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure a function executes at most once within a defined period — controlling execution frequency for performance-critical events (scroll, resize, input). The implementations shown here are **leading-only throttles**: the first call in an interval runs immediately; subsequent calls in the same interval are ignored. In real projects you might extend this to combined leading + trailing behavior (like Lodash's `throttle`). Key concepts: async, functions, timing.",
      "approaches": [
        {
          "title": "Approach 1: Timestamp-based throttle (simple and effective)",
          "prose": "Idea: record the last time the function was called, and skip execution until enough time passes.\n\nHow it works:\n1. Initialize `let lastTime = 0` to remember the last execution time.\n2. On each call, compute `const now = Date.now()` and check `now - lastTime >= interval`.\n3. If the check passes, call `fn` with the current `this` and arguments, then set `lastTime = now`.\n\nWhy use it: straightforward, minimal overhead, and gives consistently spaced executions when calls are frequent.",
          "codeJs": "export default function throttle(fn, interval) {\n  let lastTime = 0;\n  return function (...args) {\n    const now = Date.now();\n    if (now - lastTime >= interval) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  };\n}\n",
          "codeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  let lastTime = 0;\n  return function (this: any, ...args: Parameters<F>) {\n    const now = Date.now();\n    if (now - lastTime >= interval) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  } as F;\n}\n"
        },
        {
          "title": "Approach 2: Timer-based throttle (cooldown flag)",
          "prose": "Idea: run the first call immediately, then use a timer as a cooldown. While the timer is active, additional calls are ignored.\n\nHow it works:\n1. Keep a boolean `waiting = false` in the closure to represent the cooldown.\n2. On each call:\n   - If `waiting` is `true`, ignore the call.\n   - If `waiting` is `false`, invoke `fn` with the current `this` and arguments, set `waiting = true`, and start a `setTimeout` that flips `waiting` back to `false` after `interval` ms.\n\nThis guarantees that once `fn` runs, it cannot run again until at least `interval` ms have passed.\n\nWhy use it: uses timers instead of timestamps, which can feel more intuitive when you already rely heavily on `setTimeout` in your code.",
          "codeJs": "export default function throttle(fn, interval) {\n  let waiting = false;\n  return function (...args) {\n    if (!waiting) {\n      fn.apply(this, args);\n      waiting = true;\n      setTimeout(() => {\n        waiting = false;\n      }, interval);\n    }\n  };\n}\n",
          "codeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  let waiting = false;\n  return function (this: any, ...args: Parameters<F>) {\n    if (!waiting) {\n      fn.apply(this, args);\n      waiting = true;\n      setTimeout(() => {\n        waiting = false;\n      }, interval);\n    }\n  } as F;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "These simple implementations are leading-only: the final event in a burst may be ignored. For guaranteed trailing execution, use a combined leading + trailing throttle (not shown here) or a utility like Lodash.",
          "Avoid mixing throttle and debounce on the same handler unless the expected behavior is very clear.",
          "Ensure consistent `this` context by using `fn.apply(this, args)` (or `fn.call`)."
        ],
        "edgeCases": [
          "interval = 0 → throttling effectively disappears; `fn` runs on every call.",
          "The first call in each interval always executes immediately.",
          "Successive calls within the active interval window are ignored."
        ],
        "techniques": [
          "Controlling execution rate with timestamps or timers.",
          "Tracking `lastTime` or a cooldown flag in a closure.",
          "Preserving caller context with `apply()`."
        ]
      },
      "followUpQuestions": [
        "js-debounce"
      ],
      "resources": [
        {
          "title": "MDN – setTimeout()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        },
        {
          "title": "Lodash – throttle",
          "url": "https://lodash.com/docs/#throttle"
        }
      ]
    },
    "tests": "import throttle from './throttle';\n\nconst wait = (ms) => new Promise((r) => setTimeout(r, ms));\n\ndescribe('throttle', () => {\n  test('executes immediately and ignores rapid calls', async () => {\n    let calls = 0;\n    const throttled = throttle(() => { calls += 1; }, 200);\n\n    throttled(); // should run immediately\n    throttled(); // ignored\n    throttled(); // ignored\n\n    expect(calls).toBe(1);\n\n    await wait(220);\n    throttled(); // should run after interval\n    expect(calls).toBe(2);\n  });\n\n  test('maintains correct interval spacing', async () => {\n    let timestamps = [];\n    const throttled = throttle(() => { timestamps.push(Date.now()); }, 100);\n\n    throttled();\n    await wait(30);\n    throttled();\n    await wait(80);\n    throttled(); // should run after ~110ms total\n\n    await wait(120);\n    throttled(); // another valid call\n\n    expect(timestamps.length).toBe(3);\n  });\n\n  test('passes arguments correctly', async () => {\n    let last = '';\n    const throttled = throttle((msg) => { last = msg; }, 150);\n\n    throttled('Hello');\n    throttled('World'); // ignored\n\n    await wait(160);\n    throttled('Again');\n\n    expect(last).toBe('Again');\n  });\n});\n",
    "testsTs": "import throttle from './throttle';\n\nconst wait = (ms: number) => new Promise<void>((r) => setTimeout(r, ms));\n\ndescribe('throttle (TypeScript)', () => {\n  it('executes immediately and ignores rapid calls', async () => {\n    let calls = 0;\n    const throttled = throttle(() => { calls += 1; }, 200);\n\n    throttled();\n    throttled();\n    throttled();\n\n    expect(calls).toBe(1);\n\n    await wait(220);\n    throttled();\n    expect(calls).toBe(2);\n  });\n\n  it('maintains proper intervals', async () => {\n    let times: number[] = [];\n    const throttled = throttle(() => { times.push(Date.now()); }, 100);\n\n    throttled();\n    await wait(30);\n    throttled();\n    await wait(80);\n    throttled();\n\n    await wait(120);\n    throttled();\n\n    expect(times.length).toBe(3);\n  });\n\n  it('passes arguments correctly', async () => {\n    let last = '';\n    const throttled = throttle((msg: string) => { last = msg; }, 150);\n\n    throttled('Hi');\n    throttled('Ignore');\n\n    await wait(160);\n    throttled('Final');\n\n    expect(last).toBe('Final');\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-deep-clone",
    "title": "Deep Clone",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "difficulty": "hard",
    "tags": [
      "clone",
      "deep-copy",
      "objects",
      "recursion"
    ],
    "description": {
      "summary": "Create a deep clone of an object/array so nested structures are copied by value. Discuss limits (functions, dates, cycles) and choose a strategy that matches constraints, such as recursion with a map to handle circular references.",
      "arguments": [
        {
          "name": "value",
          "type": "any",
          "desc": "The value to deeply clone. Can be an object, array, Date, RegExp, or primitive."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "A deep copy of the input value where all nested structures are duplicated rather than referenced."
      },
      "examples": [
        "// Basic examples",
        "deepClone({ a: 1, b: { c: 2 } }) // => { a: 1, b: { c: 2 } }",
        "// Arrays and nested objects",
        "const arr = [1, { x: 10 }, [2, 3]]",
        "const copy = deepClone(arr)",
        "copy[1].x = 99",
        "// arr stays unchanged",
        "// Dates and RegExps",
        "const obj = { d: new Date('2020-01-01'), r: /abc/i }",
        "const clone = deepClone(obj)",
        "clone.d.setFullYear(2024)",
        "// obj.d still points to 2020"
      ]
    },
    "starterCode": "export default function deepClone(value) {\n  // TODO: Return a deep-cloned copy of the input value\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function deepClone<T>(value: T): T {\n  // TODO: Return a deep-cloned copy of the input value\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: create a fully independent copy of the input value — primitives, plain objects, arrays, Dates, or RegExps — so that later mutations do **not** affect the original. The base approach handles typical data structures (no circular references); the advanced version extends it to support circular graphs using a `WeakMap`.",
      "approaches": [
        {
          "title": "Approach 1: Recursive type-aware cloning (base version, no circular refs)",
          "prose": "Idea: detect the type of the input and handle each case appropriately — primitive, array, plain object, or special object type (Date / RegExp).\n\n### Steps\n1. If `value` is not an object (including `null`, numbers, strings, booleans, bigints, symbols), return it directly.\n2. If `value` is a `Date`, create a new `Date` with the same timestamp.\n3. If `value` is a `RegExp`, create a new `RegExp` with the same pattern, flags, and `lastIndex`.\n4. If `value` is an array, create a new array and recursively clone each element.\n5. Otherwise treat it as a plain object: create `{}`, iterate its own enumerable keys, and recursively clone each property.\n\nThis ensures deeply nested structures are copied without sharing references (as long as there are no circular references).",
          "codeJs": "export default function deepClone(value) {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (value instanceof Date) return new Date(value.getTime());\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClone(item));\n  }\n\n  const clonedObj = {};\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clonedObj[key] = deepClone(value[key]);\n    }\n  }\n  return clonedObj;\n}\n",
          "codeTs": "export default function deepClone<T>(value: T): T {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (value instanceof Date) return new Date(value.getTime()) as any;\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re as any;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClone(item)) as any;\n  }\n\n  const clonedObj: any = {};\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clonedObj[key] = deepClone((value as any)[key]);\n    }\n  }\n  return clonedObj;\n}\n"
        },
        {
          "title": "Approach 2: Handling circular references with WeakMap (advanced extension)",
          "prose": "Idea: build on the recursive approach but track already-cloned objects in a `WeakMap`. When you encounter the same object again, return the stored clone instead of recursing, which prevents infinite loops on cyclic graphs.\n\n### Steps\n1. Pass a `seen = new WeakMap()` through recursive calls.\n2. If `value` is primitive / `null`, return it directly (same as before).\n3. Before cloning an object/array, check `seen.has(value)` — if yes, return `seen.get(value)`.\n4. Otherwise, create the appropriate empty container (`[]` or `{}`), store it in `seen.set(value, clone)`, then recursively fill its properties.\n5. Keep the same Date/RegExp handling as in the base approach.\n\nThis version behaves like the base version on normal inputs, but also safely supports circular structures (objects that reference themselves or each other).",
          "codeJs": "export default function deepClone(value, seen = new WeakMap()) {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (seen.has(value)) return seen.get(value);\n\n  if (value instanceof Date) return new Date(value.getTime());\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re;\n  }\n\n  const clone = Array.isArray(value) ? [] : {};\n  seen.set(value, clone);\n\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clone[key] = deepClone(value[key], seen);\n    }\n  }\n  return clone;\n}\n",
          "codeTs": "export default function deepClone<T>(value: T, seen: WeakMap<any, any> = new WeakMap()): T {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (seen.has(value)) return seen.get(value);\n\n  if (value instanceof Date) return new Date(value.getTime()) as any;\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re as any;\n  }\n\n  const clone: any = Array.isArray(value) ? [] : {};\n  seen.set(value, clone);\n\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clone[key] = deepClone((value as any)[key], seen);\n    }\n  }\n  return clone;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Shallow copy methods like spread (`{ ...obj }`) or `Object.assign` only copy one level deep — nested objects will still share references.",
          "The base recursive version (Approach 1) will recurse forever on circular structures; use the WeakMap-based extension when cycles are possible.",
          "Functions, DOM nodes, Maps/Sets, and custom class instances are **not** truly cloned here — their references and/or plain enumerable properties are copied, but prototypes and special internal state are not preserved."
        ],
        "edgeCases": [
          "null or primitive → returned directly.",
          "Date → returns new Date with identical timestamp.",
          "RegExp → returns new RegExp with identical source, flags, and `lastIndex`.",
          "Array → deep-cloned recursively.",
          "Plain object → deep-cloned recursively by own enumerable properties."
        ],
        "techniques": [
          "Recursion for nested structures.",
          "Type detection using `instanceof` and `Array.isArray`.",
          "Reference tracking using WeakMap for circular safety.",
          "Differentiating deep vs shallow copying."
        ]
      },
      "followUpQuestions": [
        "js-flatten-depth"
      ],
      "resources": [
        {
          "title": "MDN – Object cloning basics",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy"
        },
        {
          "title": "JavaScript.info – Deep cloning",
          "url": "https://javascript.info/object-copy#structuredclone"
        }
      ]
    },
    "tests": "import deepClone from './deepClone';\n\ndescribe('deepClone', () => {\n  test('clones nested objects', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const clone = deepClone(obj);\n    expect(clone).toEqual(obj);\n    clone.b.c = 5;\n    expect(obj.b.c).toBe(2);\n  });\n\n  test('clones arrays correctly', () => {\n    const arr = [1, { x: 2 }, [3, 4]];\n    const clone = deepClone(arr);\n    expect(clone).toEqual(arr);\n    clone[1].x = 99;\n    expect(arr[1].x).toBe(2);\n  });\n\n  test('clones Date and RegExp instances', () => {\n    const obj = { d: new Date('2020-01-01T00:00:00Z'), r: /abc/i };\n    const clone = deepClone(obj);\n\n    expect(clone.d instanceof Date).toBe(true);\n    expect(clone.d === obj.d).toBe(false);\n    expect(clone.d.getTime()).toBe(obj.d.getTime());\n\n    const sameRegExp = (\n      clone.r instanceof RegExp &&\n      clone.r !== obj.r &&\n      clone.r.source === obj.r.source &&\n      (('flags' in clone.r && 'flags' in obj.r)\n        ? clone.r.flags === obj.r.flags\n        : String(clone.r) === String(obj.r)) &&\n      clone.r.lastIndex === obj.r.lastIndex\n    );\n    expect(sameRegExp).toBe(true);\n  });\n\n  test('returns primitives as-is', () => {\n    expect(deepClone(5)).toBe(5);\n    expect(deepClone('test')).toBe('test');\n    expect(deepClone(null)).toBe(null);\n  });\n});\n",
    "testsTs": "import deepClone from './deepClone';\n\ndescribe('deepClone (TypeScript)', () => {\n  it('deeply clones nested objects', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const clone = deepClone(obj);\n    expect(clone).toEqual(obj);\n    clone.b.c = 99;\n    expect(obj.b.c).toBe(2);\n  });\n\n  it('clones arrays correctly', () => {\n    const arr = [1, { x: 10 }, [2, 3]];\n    const clone = deepClone(arr);\n    expect(clone).toEqual(arr);\n    clone[1].x = 50;\n    expect(arr[1].x).toBe(10);\n  });\n\n  it('handles Dates and RegExps robustly', () => {\n    const obj = { d: new Date('2020-01-01T00:00:00Z'), r: /test/g };\n    const clone = deepClone(obj);\n\n    expect(clone.d instanceof Date).toBe(true);\n    expect(clone.d === obj.d).toBe(false);\n    expect(clone.d.getTime()).toBe(obj.d.getTime());\n\n    const sameRegExp = (\n      clone.r instanceof RegExp &&\n      clone.r !== obj.r &&\n      clone.r.source === obj.r.source &&\n      (('flags' in clone.r && 'flags' in obj.r)\n        ? clone.r.flags === obj.r.flags\n        : String(clone.r) === String(obj.r)) &&\n      clone.r.lastIndex === obj.r.lastIndex\n    );\n    expect(sameRegExp).toBe(true);\n  });\n\n  it('returns primitives unchanged', () => {\n    expect(deepClone('abc')).toBe('abc');\n    expect(deepClone(123)).toBe(123);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-deep-equal",
    "title": "Deep Equal",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "comparison",
      "equality",
      "objects",
      "recursion"
    ],
    "description": {
      "summary": "Implement a function `deepEqual(a, b)` that returns `true` when two values are deeply equal — primitives by value and objects/arrays by recursively comparing their properties. Handle Dates, RegExps, and `NaN`.",
      "arguments": [
        {
          "name": "a",
          "type": "any",
          "desc": "First value to compare."
        },
        {
          "name": "b",
          "type": "any",
          "desc": "Second value to compare."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if both inputs are deeply equal; otherwise `false`."
      },
      "examples": [
        "// Basic examples",
        "deepEqual(1, 1) // => true",
        "deepEqual(1, '1') // => false",
        "// Nested objects",
        "deepEqual({ a: 1, b: { c: 2 } }, { a: 1, b: { c: 2 } }) // => true",
        "// Arrays (order matters)",
        "deepEqual([1, 2, 3], [1, 2, 3]) // => true",
        "deepEqual([1, 2, 3], [3, 2, 1]) // => false",
        "// Dates and RegExp",
        "deepEqual(new Date('2020-01-01'), new Date('2020-01-01')) // => true",
        "deepEqual(/ab/i, new RegExp('ab', 'i')) // => true",
        "// Special values",
        "deepEqual(NaN, NaN) // => true",
        "deepEqual(null, undefined) // => false"
      ]
    },
    "starterCode": "export default function deepEqual(a, b) {\n  // TODO: Compare two values for deep equality\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function deepEqual<T = any>(a: T, b: T): boolean {\n  // TODO: Compare two values for deep equality\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: return `true` only when two inputs are the same **by value** (for primitives) or **by structure** (for arrays/objects). Must treat `NaN` as equal to `NaN`, compare `Date` by timestamp, and `RegExp` by pattern/flags/lastIndex. Approach 1 is the canonical solution that satisfies these requirements; Approach 2 shows a common shortcut that only works for plain JSON-like data and is not suitable for the full spec.",
      "approaches": [
        {
          "title": "Approach 1: Direct recursion (baseline, easiest to follow)",
          "prose": "Idea: handle the common cases with clear early exits, then recurse for arrays and plain objects.\n\n### Steps\n1. If `a === b`, return `true` (covers identical references and most primitives).\n2. If both are numbers and both are `NaN`, return `true`.\n3. If types differ or either is `null`, return `false`.\n4. Handle `Date` and `RegExp` specially.\n5. If either value is an array, both must be arrays; compare length, then pairwise recurse.\n6. Otherwise, treat as plain objects: compare own keys length, ensure the same keys exist, then recurse per key.\n\nWhy use it: readable flow with tight, predictable checks that pass typical interview test suites.",
          "codeJs": "export default function deepEqual(a, b) {\n  if (a === b) return true;\n  if (typeof a === 'number' && typeof b === 'number' && Number.isNaN(a) && Number.isNaN(b)) return true;\n  if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') return false;\n\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    const same = a.source === b.source && a.flags === b.flags;\n    return same && a.lastIndex === b.lastIndex;\n  }\n\n  const aIsArr = Array.isArray(a);\n  const bIsArr = Array.isArray(b);\n  if (aIsArr || bIsArr) {\n    if (!(aIsArr && bIsArr)) return false;\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const k of aKeys) {\n    if (!Object.prototype.hasOwnProperty.call(b, k)) return false;\n    if (!deepEqual(a[k], b[k])) return false;\n  }\n  return true;\n}\n",
          "codeTs": "export default function deepEqual<T = any>(a: T, b: T): boolean {\n  if (a === b) return true;\n  if (typeof a === 'number' && typeof b === 'number' && Number.isNaN(a as any) && Number.isNaN(b as any)) return true;\n  if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') return false;\n\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    const same = a.source === b.source && a.flags === b.flags;\n    return same && a.lastIndex === b.lastIndex;\n  }\n\n  const aIsArr = Array.isArray(a);\n  const bIsArr = Array.isArray(b);\n  if (aIsArr || bIsArr) {\n    if (!(aIsArr && bIsArr)) return false;\n    const aa = a as unknown as any[];\n    const bb = b as unknown as any[];\n    if (aa.length !== bb.length) return false;\n    for (let i = 0; i < aa.length; i++) {\n      if (!deepEqual(aa[i], bb[i])) return false;\n    }\n    return true;\n  }\n\n  const aObj = a as Record<string, unknown>;\n  const bObj = b as Record<string, unknown>;\n  const aKeys = Object.keys(aObj);\n  const bKeys = Object.keys(bObj);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const k of aKeys) {\n    if (!Object.prototype.hasOwnProperty.call(bObj, k)) return false;\n    if (!deepEqual((aObj as any)[k], (bObj as any)[k])) return false;\n  }\n  return true;\n}\n"
        },
        {
          "title": "Approach 2: JSON stringify (quick but limited)",
          "prose": "Idea: `JSON.stringify(a) === JSON.stringify(b)` as a one-liner for **plain** data (no functions, symbols, or `undefined` in objects; key order stable).\n\nThis does **not** correctly handle Dates, RegExps, `NaN`, or cyclic structures, so it cannot be used as the main solution for this exercise — it is only a shortcut for simple, JSON-serializable payloads.\n\nWhy use it: handy sanity check or pre-filter for simple objects; not reliable for general-purpose deep equality.",
          "codeJs": "export default function deepEqual(a, b) {\n  try {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } catch {\n    // cyclic structures throw errors\n    return false;\n  }\n}\n",
          "codeTs": "export default function deepEqual<T>(a: T, b: T): boolean {\n  try {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } catch {\n    return false;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Treat `NaN` as equal to `NaN` — `NaN === NaN` is false by default.",
          "Don’t rely on `JSON.stringify` for general deep equality (Dates/RegExps/NaN/undefined/functions differ).",
          "Only compare **own** enumerable string keys; symbol keys, non-enumerable properties, and prototypes are out of scope for this exercise."
        ],
        "edgeCases": [
          "Different types → immediately false.",
          "Arrays: order matters; lengths must match.",
          "RegExp: compare `source`, `flags`, and optionally `lastIndex`.",
          "Date: compare `getTime()`.",
          "Null vs undefined → false."
        ],
        "techniques": [
          "Short-circuit checks before recursion.",
          "Type-specific comparisons for Date/RegExp.",
          "Key set + recursive property comparison."
        ]
      },
      "followUpQuestions": [
        "js-deep-clone",
        "js-arrays-equal"
      ],
      "resources": [
        {
          "title": "MDN – Object.keys()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"
        },
        {
          "title": "MDN – Date",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"
        },
        {
          "title": "MDN – RegExp",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp"
        }
      ]
    },
    "tests": "import deepEqual from './deepEqual';\n\ndescribe('deepEqual', () => {\n  test('compares primitives', () => {\n    expect(deepEqual(1, 1)).toBe(true);\n    expect(deepEqual(1, '1')).toBe(false);\n    expect(deepEqual(NaN, NaN)).toBe(true);\n  });\n\n  test('compares nested objects', () => {\n    const a = { x: 1, y: { z: 2 } };\n    const b = { x: 1, y: { z: 2 } };\n    expect(deepEqual(a, b)).toBe(true);\n    const c = { x: 1, y: { z: 3 } };\n    expect(deepEqual(a, c)).toBe(false);\n  });\n\n  test('compares arrays (order matters)', () => {\n    expect(deepEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n    expect(deepEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  test('handles Date and RegExp', () => {\n    const d1 = new Date('2020-01-01T00:00:00Z');\n    const d2 = new Date('2020-01-01T00:00:00Z');\n    expect(deepEqual(d1, d2)).toBe(true);\n\n    const r1 = /ab/i;\n    const r2 = new RegExp('ab', 'i');\n    expect(deepEqual(r1, r2)).toBe(true);\n  });\n\n  test('null vs undefined', () => {\n    expect(deepEqual(null, undefined)).toBe(false);\n  });\n});\n",
    "testsTs": "import deepEqual from './deepEqual';\n\ndescribe('deepEqual (TypeScript)', () => {\n  it('compares primitives', () => {\n    expect(deepEqual(1, 1)).toBe(true);\n    expect(deepEqual(1 as any, '1' as any)).toBe(false);\n    expect(deepEqual(NaN, NaN)).toBe(true);\n  });\n\n  it('compares nested objects', () => {\n    const a = { x: 1, y: { z: 2 } };\n    const b = { x: 1, y: { z: 2 } };\n    expect(deepEqual(a, b)).toBe(true);\n    const c = { x: 1, y: { z: 3 } };\n    expect(deepEqual(a, c)).toBe(false);\n  });\n\n  it('compares arrays (order matters)', () => {\n    expect(deepEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n    expect(deepEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  it('handles Date and RegExp', () => {\n    const d1 = new Date('2020-01-01T00:00:00Z');\n    const d2 = new Date('2020-01-01T00:00:00Z');\n    expect(deepEqual(d1, d2)).toBe(true);\n\n    const r1 = /ab/i;\n    const r2 = new RegExp('ab', 'i');\n    expect(deepEqual(r1, r2)).toBe(true);\n  });\n\n  it('null vs undefined', () => {\n    expect(deepEqual(null as any, undefined as any)).toBe(false);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-flatten-depth",
    "title": "Flatten with Depth",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "bytedance"
    ],
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "arrays",
      "depth",
      "flatten",
      "recursion"
    ],
    "description": {
      "summary": "Implement flatten(arr, depth) that flattens nested arrays up to a specific depth. Depth controls how many nesting levels to remove: depth = 0 returns a shallow copy; depth = 1 flattens one level. Handle mixed primitives and arrays.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "Nested array to flatten."
        },
        {
          "name": "depth",
          "type": "number",
          "desc": "Number of levels to flatten (default 1). If depth ≤ 0, return a shallow copy; if depth exceeds the nesting level, flatten completely."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array flattened up to the given depth."
      },
      "examples": [
        "// Basic examples\nflatten([1, [2, [3, [4]]]], 1) // => [1, 2, [3, [4]]]",
        "flatten([1, [2, [3, [4]]]], 2) // => [1, 2, 3, [4]]",
        "flatten([1, [2, [3, [4]]]], 3) // => [1, 2, 3, 4]",
        "// Handles empty and non-nested arrays\nflatten([1, 2, 3], 2) // => [1, 2, 3]"
      ]
    },
    "starterCode": "export default function flatten(arr, depth = 1) {\n  // TODO: Flatten array up to given depth\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  // TODO: Flatten array up to given depth\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: flatten a nested array up to a given depth while preserving order. Each pass removes one level of nesting until depth hits 0. A recursive approach is most readable; an iterative stack avoids recursion limits.",
      "approaches": [
        {
          "title": "Approach 1: Recursive flattening (baseline, easiest to read)",
          "prose": "Idea: for each element, check if it’s an array. If yes, flatten it one level deeper (reducing `depth`), otherwise push directly.\n\nHow it works:\n1. Base case: if `depth === 0`, return a shallow copy of the array (`arr.slice()`).\n2. Loop through the elements of `arr`.\n3. For nested arrays and `depth > 0`, recurse with `flatten(el, depth - 1)` and spread the result into `result`.\n4. For non-array elements (or when `depth` is 0), push them directly into `result`.\n\nWhy use it: very readable, mirrors how you might reason about the problem on paper, and makes the `depth` behavior explicit.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  const result = [];\n  for (const el of arr) {\n    if (Array.isArray(el) && depth > 0) {\n      result.push(...flatten(el, depth - 1));\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  const result: any[] = [];\n  for (const el of arr) {\n    if (Array.isArray(el) && depth > 0) {\n      result.push(...flatten(el, depth - 1));\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using reduce (compact, functional style)",
          "prose": "Idea: use `Array.prototype.reduce` to build the flattened array recursively with accumulation.\n\nHow it works:\n1. If `depth === 0`, return a shallow copy of `arr`.\n2. Call `reduce` with an empty array accumulator.\n3. For each element, either concatenate a recursively flattened version (when it’s an array and depth > 0) or concatenate the element itself.\n\nThis mirrors Approach 1 but in a more functional, chain-friendly style.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  return arr.reduce((acc, el) => {\n    return acc.concat(Array.isArray(el) ? flatten(el, depth - 1) : el);\n  }, []);\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  return arr.reduce((acc: any[], el) => {\n    return acc.concat(Array.isArray(el) ? flatten(el, depth - 1) : el);\n  }, []);\n}\n"
        },
        {
          "title": "Approach 3: Using stack (iterative, avoids recursion)",
          "prose": "Idea: simulate recursion using a stack so we can flatten arrays iteratively. This approach is great for deeply nested arrays since it avoids call-stack overflows.\n\n### 🔍 How it works\n1. Seed a stack with each top-level element and the starting `depth` value, pushing them right-to-left.\n2. Pop elements from the stack one by one.\n3. If the element is an array and `depth > 0`, push its children **in reverse order**, each with `depth - 1`.\n4. If it’s not an array or `depth === 0`, append it to the result array.\n\n### 💡 Why reverse order?\nBecause the stack is LIFO — we want elements to be processed left-to-right. By seeding the stack in reverse and pushing children in reverse, the final order matches the original array.\n\n### ⚙️ When to use\n- When arrays are extremely deep and recursion may hit a call-stack limit.\n- When you need explicit control over traversal.\n\n### ✅ Complexity\nO(n) time and O(n) space — similar to the recursive approach, but stack-safe.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  const result = [];\n  const stack = [];\n  // Seed stack right-to-left so popping processes left-to-right\n  for (let i = arr.length - 1; i >= 0; i--) {\n    stack.push([arr[i], depth]);\n  }\n  while (stack.length) {\n    const [curr, d] = stack.pop();\n    if (Array.isArray(curr) && d > 0) {\n      for (let i = curr.length - 1; i >= 0; i--) {\n        stack.push([curr[i], d - 1]);\n      }\n    } else {\n      result.push(curr);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  const result: any[] = [];\n  const stack: Array<[any, number]> = [];\n  // Seed stack right-to-left so popping processes left-to-right\n  for (let i = arr.length - 1; i >= 0; i--) {\n    stack.push([arr[i], depth]);\n  }\n  while (stack.length) {\n    const [curr, d] = stack.pop() as [any, number];\n    if (Array.isArray(curr) && d > 0) {\n      for (let i = curr.length - 1; i >= 0; i--) {\n        stack.push([curr[i], d - 1]);\n      }\n    } else {\n      result.push(curr);\n    }\n  }\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Don’t mutate the input array — always return a new array.",
          "If `depth === 0`, return a shallow copy, not the original reference.",
          "`Array.flat()` is off-limits here (we’re reimplementing it)."
        ],
        "edgeCases": [
          "Empty arrays → return empty array.",
          "Depth larger than nesting → fully flatten.",
          "Depth 0 or below → return shallow copy."
        ],
        "techniques": [
          "Recursion and base case handling.",
          "Using spread / concat to merge flattened pieces.",
          "Iterative stack-based traversal to avoid recursion limits."
        ]
      },
      "followUpQuestions": [
        "js-flatten-once",
        "js-deep-clone"
      ]
    },
    "tests": "import flatten from './flatten';\n\ndescribe('flatten', () => {\n  test('flattens one level deep', () => {\n    expect(flatten([1, [2, [3, [4]]]], 1)).toEqual([1, 2, [3, [4]]]);\n  });\n\n  test('flattens two levels deep', () => {\n    expect(flatten([1, [2, [3, [4]]]], 2)).toEqual([1, 2, 3, [4]]);\n  });\n\n  test('flattens completely when depth is high', () => {\n    expect(flatten([1, [2, [3, [4]]]], 10)).toEqual([1, 2, 3, 4]);\n  });\n\n  test('handles empty and non-nested arrays', () => {\n    expect(flatten([], 2)).toEqual([]);\n    expect(flatten([1, 2, 3], 2)).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "import flatten from './flatten';\n\ndescribe('flatten (TypeScript)', () => {\n  it('flattens one level', () => {\n    expect(flatten([1, [2, [3, [4]]]], 1)).toEqual([1, 2, [3, [4]]]);\n  });\n\n  it('flattens up to given depth', () => {\n    expect(flatten([1, [2, [3, [4]]]], 2)).toEqual([1, 2, 3, [4]]);\n  });\n\n  it('fully flattens if depth is large', () => {\n    expect(flatten([1, [2, [3, [4]]]], 10)).toEqual([1, 2, 3, 4]);\n  });\n\n  it('returns array unchanged when already flat', () => {\n    expect(flatten([1, 2, 3], 2)).toEqual([1, 2, 3]);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-curry-function",
    "title": "Curry Function",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "closure",
      "currying",
      "functions",
      "higher-order"
    ],
    "description": {
      "summary": "Implement curry(fn) to transform a multi-argument function into chained calls. Collect arguments across invocations, allow partial application, and invoke the original function once enough args have been provided. Concepts: closure, currying, functions.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "A function that accepts multiple arguments."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A curried version of the input function that collects arguments across calls until it has at least `fn.length` arguments, then invokes `fn`."
      },
      "examples": [
        "// Basic example\nfunction add(a, b, c) { return a + b + c; }\nconst curriedAdd = curry(add);\ncurriedAdd(1)(2)(3) // => 6",
        "// Partial application\nconst add5 = curriedAdd(2)(3);\nadd5(10) // => 15",
        "// Works with different argument counts\nconst multiply = (a, b) => a * b;\ncurry(multiply)(4)(5) // => 20",
        "// Mixed grouping is fine too\ncurriedAdd(1, 2)(3) // => 6\ncurriedAdd(1)(2, 3) // => 6"
      ]
    },
    "starterCode": "export default function curry(fn) {\n  // TODO: Transform fn into a curried version\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function curry(fn: Function): Function {\n  // TODO: Transform fn into a curried version\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Curry returns a function that keeps gathering arguments until it has at least `fn.length`. Once enough arguments are collected, it calls the original function with all arguments in order. This enables partial application while keeping the API flexible. Key concepts: closure, currying, functions.",
      "approaches": [
        {
          "title": "Approach 1: Variadic accumulator using closures (simplest)",
          "prose": "Approach:\n- Store collected arguments in a closure.\n- Return a function that accepts more args and concatenates them.\n- If the total length is >= `fn.length`, call `fn` with all collected args.\n- Otherwise, return another function to keep collecting.\n\nThis supports calls like `curry(add)(1)(2)` and `curry(add)(1,2)`.",
          "codeJs": "export default function curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn(...args);\n    }\n    return (...next) => curried(...args, ...next);\n  };\n}\n",
          "codeTs": "export default function curry(fn: Function): Function {\n  const curried = (...args: any[]): any => {\n    return args.length >= fn.length\n      ? fn(...args)\n      : (...next: any[]) => curried(...args, ...next);\n  };\n  return curried;\n}\n"
        },
        {
          "title": "Approach 2: Same idea with concat (slightly different style)",
          "prose": "Idea: use the same `curried(...args)` pattern as Approach 1, but accumulate arguments using `concat` instead of spread. Behavior is the same; this is just a stylistic variation.\n\nHow it works:\n1. Define inner `curried(...args)` that represents the partially applied function.\n2. If `args.length >= fn.length`, immediately invoke `fn(...args)`.\n3. Otherwise, return a function that takes `...next` arguments and calls `curried(...args.concat(next))` to keep collecting.\n\nThis version highlights that you can implement currying with any mechanism that accumulates arguments (spread, concat, etc.).",
          "codeJs": "export default function curry(fn) {\n  const curried = (...args) => {\n    if (args.length >= fn.length) return fn(...args);\n    return (...next) => curried(...args.concat(next));\n  };\n  return curried;\n}\n",
          "codeTs": "export default function curry(fn: Function): Function {\n  const curried = (...args: any[]): any => {\n    if (args.length >= fn.length) return fn(...args);\n    return (...next: any[]) => curried(...args.concat(next));\n  };\n  return curried;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "`fn.length` ignores default/rest parameters; advanced typings for perfect TS inference are omitted for clarity.",
          "These simple versions don’t preserve the original `this` binding (they call `fn(...args)`); they’re intended for plain functions rather than methods."
        ],
        "edgeCases": [
          "Unary functions return immediately once called.",
          "Extra arguments beyond `fn.length` are still forwarded to `fn`.",
          "Functions with `length === 0` will be invoked on the first call, even if you pass no arguments."
        ],
        "techniques": [
          "Closures to capture partial arguments.",
          "Arity inspection via `fn.length`.",
          "Building higher-order functions that return other functions."
        ]
      },
      "followUpQuestions": [
        "js-compose",
        "js-memoize-function"
      ],
      "resources": [
        {
          "title": "MDN – Function.length",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length"
        },
        {
          "title": "MDN – Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        }
      ]
    },
    "tests": "import curry from './curry';\n\ndescribe('curry', () => {\n  test('curries a multi-argument function', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1)(2)(3)).toBe(6);\n  });\n\n  test('supports partial application', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    const add5 = curriedAdd(2)(3);\n    expect(add5(10)).toBe(15);\n  });\n\n  test('accepts mixed grouping of arguments', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1, 2)(3)).toBe(6);\n    expect(curriedAdd(1)(2, 3)).toBe(6);\n  });\n\n  test('works for 2-argument functions', () => {\n    const multiply = (a, b) => a * b;\n    const curried = curry(multiply);\n    expect(curried(4)(5)).toBe(20);\n    expect(curried(4, 5)).toBe(20);\n  });\n\n  test('handles single-argument functions', () => {\n    const square = x => x * x;\n    const curriedSquare = curry(square);\n    expect(curriedSquare(5)).toBe(25);\n  });\n});\n",
    "testsTs": "import curry from './curry';\n\ndescribe('curry (TypeScript)', () => {\n  it('curries a three-argument function', () => {\n    const add = (a: number, b: number, c: number) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1)(2)(3)).toBe(6);\n  });\n\n  it('supports partial application', () => {\n    const add = (a: number, b: number, c: number) => a + b + c;\n    const curriedAdd = curry(add);\n    const add5 = curriedAdd(2)(3);\n    expect(add5(10)).toBe(15);\n  });\n\n  it('works with binary functions and mixed grouping', () => {\n    const multiply = (a: number, b: number) => a * b;\n    const curriedMultiply = curry(multiply);\n    expect(curriedMultiply(4)(5)).toBe(20);\n    expect(curriedMultiply(4, 5)).toBe(20);\n  });\n\n  it('handles unary functions', () => {\n    const negate = (x: number) => -x;\n    const curriedNegate = curry(negate);\n    expect(curriedNegate(3)).toBe(-3);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-memoize-function",
    "title": "Memoization",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google",
      "meta"
    ],
    "importance": 5,
    "difficulty": "intermediate",
    "tags": [
      "caching",
      "functions",
      "optimization",
      "performance"
    ],
    "description": {
      "summary": "Implement memoize(fn) that caches results for repeated calls. Choose a cache key strategy, discuss memory growth/eviction, and clarify that memoization is safe mainly for pure functions with stable outputs.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "A pure function whose results can be safely cached based on input arguments."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A new function that returns cached results for previously computed arguments."
      },
      "examples": [
        "// Basic example\nconst slowAdd = (a, b) => { for (let i=0;i<1e6;i++); return a + b; };\nconst memoizedAdd = memoize(slowAdd);\nconsole.time('first'); memoizedAdd(3,4); console.timeEnd('first');\nconsole.time('second'); memoizedAdd(3,4); console.timeEnd('second'); // much faster",
        "// Works with multiple arguments\nconst multiply = (a, b, c) => a * b * c;\nconst fastMultiply = memoize(multiply);\nfastMultiply(2,3,4) // computed\nfastMultiply(2,3,4) // cached",
        "// Handles different input sets separately\nmemoizedAdd(5,5) // => 10 (new computation)"
      ]
    },
    "starterCode": "export default function memoize(fn) {\n  // TODO: Cache function results by input arguments\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  // TODO: Cache function results by input arguments\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: return a wrapped function that caches results by input arguments. Use a Map for the cache and serialize arguments into a key (or only support primitive args). A strong answer discusses cache key strategy, memory growth, and when memoization is safe.",
      "approaches": [
        {
          "title": "Approach 1: Using Map with JSON key (simple & effective)",
          "prose": "Idea: store previous results in a `Map`, where the key is a serialized version of the arguments.\n\nHow it works\n1. Create a `Map` to store results.\n2. Convert arguments to a cache key using `JSON.stringify`.\n3. If the key exists, return the cached value.\n4. Otherwise compute, store, and return the result.\n\nWhy use it: straightforward and effective for primitive and serializable arguments; different argument tuples (e.g. `(2, 3)` vs `(3, 2)`) get different cache entries.",
          "codeJs": "export default function memoize(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n",
          "codeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  const cache = new Map<string, ReturnType<F>>();\n  const memoized = (...args: Parameters<F>): ReturnType<F> => {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key)!;\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n  return memoized as F;\n}\n"
        },
        {
          "title": "Approach 2: Nested Map (advanced for deep argument types)",
          "prose": "Idea: instead of serializing arguments, use nested `Map`s — one per argument — to handle non-serializable inputs safely.\n\nHow it works\n1. Start with an empty root `Map`.\n2. For each argument, go one level deeper — each key in the chain is the argument value itself.\n3. On the final map node, store the computed result under a sentinel key (like `'result'`).\n\nWhy use it: avoids `JSON.stringify` limitations and keys by reference identity, which is useful for object or reference-based arguments.",
          "codeJs": "export default function memoize(fn) {\n  const root = new Map();\n  return function memoized(...args) {\n    let map = root;\n    for (const arg of args) {\n      if (!map.has(arg)) map.set(arg, new Map());\n      map = map.get(arg);\n    }\n    if (map.has('result')) return map.get('result');\n    const result = fn(...args);\n    map.set('result', result);\n    return result;\n  };\n}\n",
          "codeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  const root = new Map<any, any>();\n  const memoized = (...args: Parameters<F>): ReturnType<F> => {\n    let map = root;\n    for (const arg of args) {\n      if (!map.has(arg)) map.set(arg, new Map());\n      map = map.get(arg);\n    }\n    if (map.has('result')) return map.get('result');\n    const result = fn(...args);\n    map.set('result', result);\n    return result;\n  };\n  return memoized as F;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "JSON.stringify cannot handle functions, symbols, or circular structures and may behave unexpectedly for certain complex objects.",
          "Objects with the same JSON representation will share a cache entry in the JSON-based approach; if you care about reference identity, use the nested Map version.",
          "These simple versions call `fn(...args)` and do not preserve `this` for methods; memoize plain functions or bind the method first if needed."
        ],
        "edgeCases": [
          "Functions with no arguments still work — the same cache entry is reused because the argument list is always empty.",
          "Different argument order yields distinct cache entries.",
          "Arguments that are `NaN`, `Infinity`, or objects are cached according to how they are stringified (Approach 1) or by reference identity (Approach 2)."
        ],
        "techniques": [
          "Closure retains cache between invocations.",
          "Using `Map` prevents accidental key collisions from the prototype chain.",
          "Keying by serialized argument lists (JSON) vs. keying by reference identity (nested Maps)."
        ]
      },
      "followUpQuestions": [
        "js-throttle",
        "js-debounce"
      ],
      "resources": [
        {
          "title": "MDN – Map",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
        },
        {
          "title": "MDN – Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        }
      ]
    },
    "tests": "import memoize from './memoize';\n\ndescribe('memoize', () => {\n  test('caches results for repeated calls', () => {\n    let calls = 0;\n    const add = (a, b) => { calls++; return a + b; };\n    const memoAdd = memoize(add);\n    expect(memoAdd(1, 2)).toBe(3);\n    expect(memoAdd(1, 2)).toBe(3);\n    expect(calls).toBe(1);\n  });\n\n  test('handles different arguments separately', () => {\n    let calls = 0;\n    const multiply = (a, b) => { calls++; return a * b; };\n    const memoMult = memoize(multiply);\n    memoMult(2, 3);\n    memoMult(3, 4);\n    expect(calls).toBe(2);\n  });\n\n  test('works with multiple argument calls', () => {\n    const join = (...args) => args.join('-');\n    const memoJoin = memoize(join);\n    expect(memoJoin('a', 'b', 'c')).toBe('a-b-c');\n    expect(memoJoin('a', 'b', 'c')).toBe('a-b-c');\n  });\n});\n",
    "testsTs": "import memoize from './memoize';\n\ndescribe('memoize (TypeScript)', () => {\n  it('caches computed results', () => {\n    let count = 0;\n    const add = (a: number, b: number) => { count++; return a + b; };\n    const memoAdd = memoize(add);\n    expect(memoAdd(3, 4)).toBe(7);\n    expect(memoAdd(3, 4)).toBe(7);\n    expect(count).toBe(1);\n  });\n\n  it('treats unique argument sets separately', () => {\n    let count = 0;\n    const diff = (a: number, b: number) => { count++; return a - b; };\n    const memoDiff = memoize(diff);\n    memoDiff(10, 5);\n    memoDiff(8, 3);\n    expect(count).toBe(2);\n  });\n\n  it('works for multi-arg functions', () => {\n    const concat = (...args: string[]) => args.join('_');\n    const memoConcat = memoize(concat);\n    expect(memoConcat('a', 'b', 'c')).toBe('a_b_c');\n    expect(memoConcat('a', 'b', 'c')).toBe('a_b_c');\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-compose",
    "title": "Compose Function",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "composition",
      "functions",
      "higher-order",
      "utilities"
    ],
    "description": {
      "summary": "Implement `compose(...fns)` that returns a new function applying the provided functions from **right to left**. The rightmost function may accept multiple arguments; every other function is unary and receives the previous result. If no functions are provided, return an identity function `(x) =&gt; x`.",
      "arguments": [
        {
          "name": "fns",
          "type": "Function[]",
          "desc": "Functions to compose. The rightmost function can be variadic; the rest are unary."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A composed function that runs all provided functions in right-to-left order."
      },
      "examples": [
        "// Basic example",
        "const add1 = n => n + 1;",
        "const double = n => n * 2;",
        "const subtract10 = n => n - 10;",
        "const composedFn = compose(subtract10, double, add1);",
        "composedFn(3); // => -2",
        "",
        "// Identity function",
        "compose()(5); // => 5",
        "",
        "// Rightmost function with multiple arguments",
        "const add = (a, b) => a + b;",
        "const double2 = n => n * 2;",
        "const fn = compose(double2, add);",
        "fn(2, 3); // => 10",
        "",
        "// Pipeline can change types",
        "const toStr = n => String(n);",
        "const wrap = s => `#${s}`;",
        "const fn2 = compose(wrap, toStr, add);",
        "fn2(2, 3); // => \"#5\""
      ]
    },
    "starterCode": "export default function compose(...fns) {\n  // TODO: Implement function composition (right-to-left)\n  // Rightmost function may take multiple arguments; the rest should be unary.\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function compose(...fns: Function[]): Function {\n  // TODO: Implement function composition (right-to-left)\n  // Rightmost function may take multiple arguments; the rest should be unary.\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: build a composed function that runs several functions from right to left. The rightmost function can take multiple arguments; its return value is passed through the remaining functions one by one as a single argument. If no functions are given, return an identity function `(x) => x`.",
      "approaches": [
        {
          "title": "Approach 1: Explicit loop (clear + variadic rightmost)",
          "prose": "Idea: treat composition as a right-to-left chain.\n\nHow it works:\n1) If `fns.length === 0`, return identity.\n2) Call the rightmost function with all incoming args.\n3) Feed the result into each remaining function moving left.\n\nWhy use it: explicit, debuggable, and correctly supports a multi-argument rightmost function.",
          "codeJs": "export default function compose(...fns) {\n  if (fns.length === 0) return x => x;\n\n  return function (...args) {\n    let i = fns.length - 1;\n    let result = fns[i](...args);\n\n    for (i = i - 1; i >= 0; i--) {\n      result = fns[i](result);\n    }\n\n    return result;\n  };\n}\n",
          "codeTs": "export default function compose(...fns: Function[]): Function {\n  if (fns.length === 0) {\n    return (x: any) => x;\n  }\n\n  return function (...args: any[]): any {\n    let i = fns.length - 1;\n    let result = (fns[i] as any)(...args);\n\n    for (i = i - 1; i >= 0; i--) {\n      result = (fns[i] as any)(result);\n    }\n\n    return result;\n  };\n}\n"
        },
        {
          "title": "Approach 2: reduceRight (concise + functional)",
          "prose": "Idea: `reduceRight` naturally models right-to-left application.\n\nKey detail: only the rightmost function can be variadic. We handle that by calling it first with `...args`, then reduceRight over the remaining functions (unary).\n\nWhy use it: shorter implementation, still interview-grade if you keep the variadic-rightmost rule correct.",
          "codeJs": "export default function compose(...fns) {\n  if (fns.length === 0) return x => x;\n\n  return function (...args) {\n    const lastIndex = fns.length - 1;\n    const initial = fns[lastIndex](...args);\n\n    return fns\n      .slice(0, lastIndex)\n      .reduceRight((acc, fn) => fn(acc), initial);\n  };\n}\n",
          "codeTs": "export default function compose(...fns: Function[]): Function {\n  if (fns.length === 0) {\n    return (x: any) => x;\n  }\n\n  return function (...args: any[]): any {\n    const lastIndex = fns.length - 1;\n    const initial = (fns[lastIndex] as any)(...args);\n\n    return fns\n      .slice(0, lastIndex)\n      .reduceRight((acc: any, fn: any) => fn(acc), initial);\n  };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Only the rightmost function can take multiple arguments. All other functions are treated as unary and receive a single value.",
          "If you pass no functions at all, you must still return a callable function (the identity), not `undefined`.",
          "Composition is not type-safe in plain JS: if a function returns an unexpected type, the next function will receive it as-is."
        ],
        "edgeCases": [
          "No functions → `compose()` returns identity, so `compose()(value)` returns `value` unchanged.",
          "Single function → `compose(fn)` returns a wrapper that forwards its arguments to `fn`.",
          "Each composed call runs O(n) functions; each function is called exactly once."
        ],
        "techniques": [
          "Rest parameters (`...fns`, `...args`).",
          "Right-to-left iteration (manual loop) vs `reduceRight`.",
          "Identity function as the neutral element for composition."
        ]
      },
      "followUpQuestions": [
        "js-pipe",
        "js-curry"
      ],
      "resources": [
        {
          "title": "MDN – Rest parameters",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"
        },
        {
          "title": "MDN – Array.prototype.reduceRight()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight"
        }
      ]
    },
    "tests": "import compose from './compose';\n\ndescribe('compose', () => {\n  const add1 = n => n + 1;\n  const double = n => n * 2;\n  const subtract10 = n => n - 10;\n\n  test('applies functions right-to-left', () => {\n    const fn = compose(subtract10, double, add1);\n    expect(fn(3)).toBe(-2);\n  });\n\n  test('works with single function', () => {\n    const fn = compose(add1);\n    expect(fn(4)).toBe(5);\n  });\n\n  test('returns identity when empty', () => {\n    const fn = compose();\n    expect(fn(5)).toBe(5);\n  });\n\n  test('allows rightmost function to take multiple arguments', () => {\n    const add = (a, b) => a + b;\n    const double2 = n => n * 2;\n    const fn = compose(double2, add);\n    expect(fn(2, 3)).toBe(10);\n  });\n\n  test('supports type transformation in the middle of the pipeline', () => {\n    const add = (a, b) => a + b; // number\n    const toStr = n => String(n); // number -> string\n    const wrap = s => `#${s}`; // string -> string\n\n    const fn = compose(wrap, toStr, add);\n    expect(fn(2, 3)).toBe('#5');\n  });\n});\n",
    "testsTs": "import compose from './compose';\n\ndescribe('compose (TypeScript)', () => {\n  const add1 = (n: number) => n + 1;\n  const double = (n: number) => n * 2;\n  const subtract10 = (n: number) => n - 10;\n\n  it('applies functions right-to-left', () => {\n    const fn = compose(subtract10, double, add1);\n    expect(fn(3)).toBe(-2);\n  });\n\n  it('works with single function', () => {\n    const fn = compose(add1);\n    expect(fn(4)).toBe(5);\n  });\n\n  it('returns identity when empty', () => {\n    const fn = compose();\n    expect(fn(10)).toBe(10);\n  });\n\n  it('allows rightmost function to take multiple arguments', () => {\n    const add = (a: number, b: number) => a + b;\n    const double2 = (n: number) => n * 2;\n    const fn = compose(double2, add);\n    expect(fn(2, 3)).toBe(10);\n  });\n\n  it('supports type transformation in the middle of the pipeline', () => {\n    const add = (a: number, b: number) => a + b; // number\n    const toStr = (n: number) => String(n); // number -> string\n    const wrap = (s: string) => `#${s}`; // string -> string\n\n    const fn = compose(wrap, toStr, add);\n    expect(fn(2, 3)).toBe('#5');\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-group-by",
    "title": "Group By",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "arrays",
      "grouping",
      "objects",
      "reduction"
    ],
    "description": {
      "summary": "Group an array of items by a key (function or property). Build an object or Map where each key maps to an array of items, and preserve input order inside each group. Concepts: arrays, grouping, objects.",
      "arguments": [
        {
          "name": "arr",
          "type": "T[]",
          "desc": "The array of elements to group."
        },
        {
          "name": "keyFn",
          "type": "(item: T) => K",
          "desc": "A function that returns a key to group each element under."
        }
      ],
      "returns": {
        "type": "Record<K, T[]>",
        "desc": "An object whose keys are the computed group keys, and values are arrays of elements belonging to each group."
      },
      "examples": [
        "// Basic examples",
        "groupBy([6.1, 4.2, 6.3], Math.floor) // => { '4': [4.2], '6': [6.1, 6.3] }",
        "groupBy(['one', 'two', 'three'], str => str.length) // => { '3': ['one', 'two'], '5': ['three'] }",
        "groupBy([{type:'a'}, {type:'b'}, {type:'a'}], x => x.type) // => { a: [{type:'a'}, {type:'a'}], b: [{type:'b'}] }"
      ]
    },
    "starterCode": "export default function groupBy(arr, keyFn) {\n  // TODO: Group array elements by keyFn(item)\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  // TODO: Group array elements by keyFn(item)\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: convert a flat list into an object keyed by `keyFn(item)`, where each key stores an array of matching items. All approaches run in O(n) time and O(n) additional space. Key concepts: arrays, grouping, objects.",
      "approaches": [
        {
          "title": "Approach 1: Simple loop (clear baseline)",
          "prose": "Idea: iterate once over the array, compute a key for each item, initialize the bucket if it does not exist yet, and push the item into that bucket.\n\nHow it works – step by step:\n1. Create an empty object `result = {}`.\n2. Loop over each `item` in `arr` using a `for...of` loop.\n3. For each item, compute `const key = keyFn(item)`.\n4. Check whether `result` already has this key as its own property. If not, initialize it with an empty array: `result[key] = []`.\n5. Push the current `item` into `result[key]`.\n6. After the loop finishes, return `result`.\n\nThis gives you a single pass, easy-to-read implementation that makes the grouping logic very explicit.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  const result = {};\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = [];\n    }\n    result[key].push(item);\n  }\n  return result;\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  const result = {} as Record<K, T[]>;\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = [] as T[];\n    }\n    result[key].push(item);\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Array.reduce (concise)",
          "prose": "Idea: fold the array into an accumulator object with `reduce`, creating buckets lazily as you go.\n\nHow it works – step by step:\n1. Call `arr.reduce` with an initial accumulator of `{}`.\n2. For each `item` in the array, compute `const key = keyFn(item)`.\n3. Check whether `acc[key]` exists. If not, initialize it as an empty array (`acc[key] ||= []`).\n4. Push the current `item` into `acc[key]`.\n5. Return the accumulator from the reducer callback so it flows into the next iteration.\n6. After `reduce` completes, the final accumulator is the grouped object; return it.\n\nThis gives a shorter, functional-style implementation while keeping the same behavior as the simple loop.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  return arr.reduce((acc, item) => {\n    const key = keyFn(item);\n    (acc[key] ||= []).push(item);\n    return acc;\n  }, {});\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  return arr.reduce((acc, item) => {\n    const key = keyFn(item);\n    (acc[key] ||= [] as T[]).push(item);\n    return acc;\n  }, {} as Record<K, T[]>);\n}\n"
        },
        {
          "title": "Approach 3: Map-based grouping (avoids prototype issues, then to object)",
          "prose": "Idea: accumulate groups in a `Map` to avoid prototype collisions and allow any key type inside the map, then convert the result to a plain object for the final return value.\n\nHow it works – step by step:\n1. Create a root `const map = new Map()`.\n2. Loop over each `item` in `arr`.\n3. For each `item`, compute `const key = keyFn(item)`.\n4. If `map` does not have this key yet, create a new bucket: `map.set(key, [])`.\n5. Retrieve the bucket with `map.get(key)` and push the `item` into it.\n6. After processing all items, convert `map.entries()` to a plain object using `Object.fromEntries`, stringifying keys as needed: `Object.fromEntries([...map.entries()].map(([k, v]) => [String(k), v]))`.\n7. Return the resulting object.\n\nNote: the returned object’s keys are still strings (because object keys are string/symbol), so non-string keys will be stringified (for example, `undefined` becomes `'undefined'`). The `Map` stage mainly avoids prototype pollution and makes the grouping logic explicit.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  const map = new Map();\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!map.has(key)) map.set(key, []);\n    map.get(key).push(item);\n  }\n  // Convert to plain object with string keys\n  return Object.fromEntries(Array.from(map.entries(), ([k, v]) => [String(k), v]));\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  const map = new Map<K, T[]>();\n  for (const item of arr) {\n    const key = keyFn(item);\n    const bucket = map.get(key);\n    if (bucket) bucket.push(item); else map.set(key, [item]);\n  }\n  const out = {} as Record<K, T[]>;\n  for (const [k, v] of map.entries()) out[k] = v;\n  return out;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Plain object keys are strings/symbols — non-string keys will be stringified.",
          "Ensure `keyFn` is deterministic (same input → same key)."
        ],
        "edgeCases": [
          "Empty array → `{}`.",
          "Many items mapping to the same key → all coalesce into one bucket.",
          "`undefined` or `null` keys are valid but will become the string 'undefined'/'null' when used as object keys."
        ],
        "techniques": [
          "Reduction/folding patterns.",
          "Bucket initialization with nullish coalescing or `||=`.",
          "Using `Map` to avoid prototype collisions, then converting to an object."
        ]
      },
      "followUpQuestions": [
        "js-sum-numbers",
        "js-unique-array"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        },
        {
          "title": "MDN – Map",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
        }
      ]
    },
    "tests": "import groupBy from './groupBy';\n\ndescribe('groupBy', () => {\n  test('groups numbers by Math.floor', () => {\n    const result = groupBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: [4.2], 6: [6.1, 6.3] });\n  });\n\n  test('groups strings by length', () => {\n    const result = groupBy(['one', 'two', 'three'], str => str.length);\n    expect(result).toEqual({ 3: ['one', 'two'], 5: ['three'] });\n  });\n\n  test('groups objects by property', () => {\n    const data = [{ type: 'a' }, { type: 'b' }, { type: 'a' }];\n    const result = groupBy(data, x => x.type);\n    expect(result).toEqual({ a: [{ type: 'a' }, { type: 'a' }], b: [{ type: 'b' }] });\n  });\n\n  test('returns empty object for empty array', () => {\n    expect(groupBy([], Math.floor)).toEqual({});\n  });\n});\n",
    "testsTs": "import groupBy from './groupBy';\n\ndescribe('groupBy (TypeScript)', () => {\n  it('groups numbers by Math.floor', () => {\n    const result = groupBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: [4.2], 6: [6.1, 6.3] });\n  });\n\n  it('groups strings by length', () => {\n    const result = groupBy(['one', 'two', 'three'], str => str.length);\n    expect(result).toEqual({ 3: ['one', 'two'], 5: ['three'] });\n  });\n\n  it('groups objects by property', () => {\n    const data = [{ type: 'a' }, { type: 'b' }, { type: 'a' }];\n    const result = groupBy(data, x => x.type);\n    expect(result).toEqual({ a: [{ type: 'a' }, { type: 'a' }], b: [{ type: 'b' }] });\n  });\n\n  it('returns empty object for empty array', () => {\n    expect(groupBy([], Math.floor)).toEqual({});\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31",
    "companies": [
      "openai"
    ]
  },
  {
    "id": "js-event-emitter-mini",
    "title": "Event Emitter (Mini Implementation)",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "async",
      "design-patterns",
      "oop"
    ],
    "description": {
      "summary": "Build a tiny event emitter with on, off, and emit. Store listeners per event, allow multiple listeners, and ensure off removes only the specified handler without breaking others. This tests data structures and event flow. Concepts: async, design-patterns, oop.",
      "arguments": [],
      "returns": {
        "type": "Emitter",
        "desc": "An instance that supports registering, removing, and invoking event listeners."
      },
      "examples": [
        "// Basic example\nconst emitter = new Emitter()\nconst greet = name => console.log(`Hello, ${name}!`)\nemitter.on('greet', greet)\nemitter.emit('greet', 'Alice') // => Hello, Alice!\n\n// Remove listener\nemitter.off('greet', greet)\nemitter.emit('greet', 'Bob') // => (nothing happens)"
      ]
    },
    "starterCode": "export default class Emitter {\n  constructor() {\n    // TODO: Initialize event storage, e.g. this.events = {}\n  }\n\n  on(event, listener) {\n    // TODO: Add listener to event\n  }\n\n  off(event, listener) {\n    // TODO: Remove listener from event\n  }\n\n  emit(event, ...args) {\n    // TODO: Call all listeners for event\n  }\n}\n",
    "starterCodeTs": "export default class Emitter {\n  private events: Record<string, Array<(...args: any[]) => void>>\n\n  constructor() {\n    // TODO: Initialize event storage\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    // TODO: Add listener to event\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    // TODO: Remove listener from event\n  }\n\n  emit(event: string, ...args: any[]): void {\n    // TODO: Call all listeners for event\n  }\n}\n",
    "solutionBlock": {
      "overview": "Goal: implement a simple publish/subscribe system that allows components to communicate through events without tight coupling. The emitter is synchronous: when you call `emit`, all listeners run immediately in registration order (even if those listeners themselves return promises). Key concepts: async, design-patterns, oop.",
      "approaches": [
        {
          "title": "Approach 1: Object-based event registry (baseline)",
          "prose": "Idea: store listeners in a plain object where each key is an event name and the value is an array of listener functions.\n\nHow it works – step by step:\n1. In the constructor, initialize `this.events = {}` to hold event → listeners mapping.\n2. In `.on(event, listener)`, check if `this.events[event]` exists; if not, set it to an empty array, then `push` the `listener` into that array.\n3. In `.off(event, listener)`, read the listener list for that event. If there is no list, return early. Otherwise, replace it with a filtered copy that removes the exact `listener` reference (`l !== listener`).\n4. In `.emit(event, ...args)`, read the listener list for that event. If no listeners, return. Otherwise, clone the list with `.slice()` and iterate over the clone, calling each listener with `l(...args)` so all listeners receive the same arguments.\n5. Cloning before iteration avoids issues if a listener calls `.off` on itself or others while `emit` is still iterating.\n\nWhy use it: very readable, easy to implement in an interview, and closely mirrors the behavior of a minimal Node.js-style EventEmitter.",
          "codeJs": "export default class Emitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, listener) {\n    if (!this.events[event]) this.events[event] = [];\n    this.events[event].push(listener);\n  }\n\n  off(event, listener) {\n    const list = this.events[event];\n    if (!list) return;\n    this.events[event] = list.filter(l => l !== listener);\n  }\n\n  emit(event, ...args) {\n    const list = this.events[event];\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n",
          "codeTs": "export default class Emitter {\n  private events: Record<string, Array<(...args: any[]) => void>>;\n\n  constructor() {\n    this.events = {};\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    if (!this.events[event]) this.events[event] = [];\n    this.events[event].push(listener);\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    const list = this.events[event];\n    if (!list) return;\n    this.events[event] = list.filter(l => l !== listener);\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const list = this.events[event];\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n"
        },
        {
          "title": "Approach 2: Map-based storage (cleaner key isolation)",
          "prose": "Idea: use a `Map` instead of a plain object so you don’t inherit prototype keys and you keep the event registry separate from the instance’s other properties.\n\nHow it works – step by step:\n1. In the constructor, initialize `this.events = new Map()`; each key will be an event name and each value an array of listeners.\n2. In `.on(event, listener)`, check `this.events.has(event)`. If it’s missing, insert a new empty array for that key, then push the `listener` into the array for that event.\n3. In `.off(event, listener)`, read the current listener array via `this.events.get(event)`. If there is no entry, return early. Otherwise, create a new array by filtering out the `listener` and store it back with `this.events.set(event, filteredList)`.\n4. In `.emit(event, ...args)`, get the listeners array with `this.events.get(event)`. If none or empty, return. If present, clone it with `.slice()` and loop through the clone, calling each listener with the provided arguments: `l(...args)`.\n5. As with the object-based version, cloning the listeners array before iterating avoids bugs when listeners deregister themselves during emission.\n\nWhy use it: avoids prototype collisions (`toString`, `constructor`, etc.), keeps the registry nicely encapsulated, and is a clean, idiomatic use of `Map` for key → listeners collections.",
          "codeJs": "export default class Emitter {\n  constructor() {\n    this.events = new Map();\n  }\n\n  on(event, listener) {\n    if (!this.events.has(event)) this.events.set(event, []);\n    this.events.get(event).push(listener);\n  }\n\n  off(event, listener) {\n    const list = this.events.get(event);\n    if (!list) return;\n    this.events.set(event, list.filter(l => l !== listener));\n  }\n\n  emit(event, ...args) {\n    const list = this.events.get(event);\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n",
          "codeTs": "export default class Emitter {\n  private events: Map<string, Array<(...args: any[]) => void>>;\n\n  constructor() {\n    this.events = new Map();\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    if (!this.events.has(event)) this.events.set(event, []);\n    this.events.get(event)!.push(listener);\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    const list = this.events.get(event);\n    if (!list) return;\n    this.events.set(event, list.filter(l => l !== listener));\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const list = this.events.get(event);\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Removing a listener that doesn’t exist should do nothing (no error).",
          "Mutating a listener array while emitting may skip calls — cloning with `slice()` before iteration avoids this.",
          "Emitting is synchronous; if listeners are slow or throw errors, they will affect the caller unless you handle that explicitly."
        ],
        "edgeCases": [
          "Emitting an event that has no listeners → should be a no-op (no error).",
          "Removing all listeners for an event leaves an empty array or an empty `Map` entry.",
          "Multiple listeners on the same event should all be called in registration order."
        ],
        "techniques": [
          "Encapsulating internal state in a class field (`events`).",
          "Cloning arrays before iteration to avoid concurrent modification bugs.",
          "Using `Map` versus plain objects depending on how strict you want key isolation to be."
        ]
      },
      "followUpQuestions": [
        "js-throttle"
      ],
      "resources": [
        {
          "title": "Node.js EventEmitter Docs",
          "url": "https://nodejs.org/api/events.html"
        },
        {
          "title": "MDN – Observer Pattern",
          "url": "https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Code_snippets/Custom_events"
        }
      ]
    },
    "tests": "import Emitter from './Emitter';\n\nconst makeSpy = () => {\n  const fn = (...args) => { fn.calls.push(args); };\n  fn.calls = [];\n  return fn;\n};\n\ndescribe('Emitter', () => {\n  test('calls listener when event is emitted', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 'data');\n    expect(spy.calls.length).toBe(1);\n    expect(spy.calls[0]).toEqual(['data']);\n  });\n\n  test('removes listener correctly', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 1);\n    expect(spy.calls.length).toBe(1);\n    emitter.off('ping', spy);\n    emitter.emit('ping', 2);\n    expect(spy.calls.length).toBe(1);\n  });\n\n  test('handles multiple listeners for same event', () => {\n    const emitter = new Emitter();\n    const a = makeSpy();\n    const b = makeSpy();\n    emitter.on('ping', a);\n    emitter.on('ping', b);\n    emitter.emit('ping', 42);\n    expect(a.calls[0]).toEqual([42]);\n    expect(b.calls[0]).toEqual([42]);\n  });\n});\n",
    "testsTs": "import Emitter from './Emitter';\n\ntype Spy = ((...args: any[]) => void) & { calls: any[][] };\nconst makeSpy = (): Spy => {\n  const fn: any = (...args: any[]) => { fn.calls.push(args); };\n  fn.calls = [] as any[][];\n  return fn as Spy;\n};\n\ndescribe('Emitter (TypeScript)', () => {\n  it('calls listener when event is emitted', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 'data');\n    expect(spy.calls.length).toBe(1);\n    expect(spy.calls[0]).toEqual(['data']);\n  });\n\n  it('removes listener correctly', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 1);\n    expect(spy.calls.length).toBe(1);\n    emitter.off('ping', spy);\n    emitter.emit('ping', 2);\n    expect(spy.calls.length).toBe(1);\n  });\n\n  it('handles multiple listeners for same event', () => {\n    const emitter = new Emitter();\n    const a = makeSpy();\n    const b = makeSpy();\n    emitter.on('ping', a);\n    emitter.on('ping', b);\n    emitter.emit('ping', 42);\n    expect(a.calls[0]).toEqual([42]);\n    expect(b.calls[0]).toEqual([42]);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01",
    "companies": [
      "meta"
    ]
  },
  {
    "id": "js-concurrency-map-limit",
    "title": "Concurrency-Limited Map (order-preserving)",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "bytedance"
    ],
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "async",
      "concurrency",
      "promise",
      "control-flow"
    ],
    "teaches": [
      "Concurrency control with a worker pool",
      "Backpressure (don’t start new work until a slot frees)",
      "Order-preserving aggregation",
      "Configurable error handling: fail-fast vs all-settled"
    ],
    "description": {
      "summary": "Implement a concurrency-limited async map that preserves order. Run at most N promises at a time, resolve results in input order, and reject early on errors to avoid hanging work.",
      "arguments": [
        {
          "name": "items",
          "type": "T[]",
          "desc": "Inputs to process."
        },
        {
          "name": "limit",
          "type": "number",
          "desc": "Max number of concurrent worker calls. Must be ≥ 1."
        },
        {
          "name": "worker",
          "type": "(item: T, index: number) => Promise<R>",
          "desc": "Async mapper."
        },
        {
          "name": "strategy",
          "type": "'fail-fast' | 'all-settled'",
          "desc": "Optional error handling strategy (default `'fail-fast'`). On error: either reject immediately (`'fail-fast'`) or collect all outcomes (`'all-settled'`)."
        }
      ],
      "returns": {
        "type": "Promise<R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>>",
        "desc": "If `'fail-fast'`, resolves to `R[]` or rejects on the first error. If `'all-settled'`, always resolves to settled outcomes in input order."
      },
      "examples": [
        "// Basic (fail-fast)\nawait mapAsyncLimit([3,1,2], 2, async (n,i) => { await sleep(n*10); return n*n })\n// => [9,1,4]\n",
        "// All-settled\nawait mapAsyncLimit([1,2,3], 2, async (n) => { if(n===2) throw new Error('boom'); return n; }, 'all-settled')\n// => [\n//   { status: 'fulfilled', value: 1 },\n//   { status: 'rejected',  reason: Error('boom') },\n//   { status: 'fulfilled', value: 3 }\n// ]"
      ]
    },
    "starterCode": "export default async function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  // TODO:\n  // 1) Validate inputs (limit >= 1)\n  // 2) Launch up to `limit` concurrent runners\n  // 3) Each runner pulls the next index and writes its result at that index\n  // 4) 'fail-fast' rejects on first error, 'all-settled' aggregates statuses\n}\n\nexport const sleep = (ms) => new Promise(r => setTimeout(r, ms));\n",
    "solutionBlock": {
      "overview": "Goal: execute async work in parallel but never exceed a maximum number of concurrent tasks, while preserving input order and supporting different error-handling strategies (`'fail-fast'` vs `'all-settled'`).\n\nMental model:\n- Think of a **worker pool**: you have `limit` workers pulling jobs from a queue.\n- Each worker processes one item at a time and writes its result at the same index.\n- For `'fail-fast'`, as soon as any worker throws, the whole operation rejects.\n- For `'all-settled'`, every job produces a `{ status, value|reason }` entry, and the outer promise always resolves.",
      "approaches": [
        {
          "title": "Approach 1: Worker-pool with shared index (clean & readable)",
          "prose": "Idea: maintain a shared `next` index and spawn up to `limit` workers that each pull new tasks until none remain.\n\nSolving steps:\n1. Validate input: throw if `limit < 1` or `limit` is not finite.\n2. Preallocate results: create `results = new Array(items.length)` to preserve order and output indexing.\n3. Initialize shared state: `next` (index of the next item to assign), `done` (how many items have finished, fulfilled or rejected), `failed` (whether we've seen an error in 'fail-fast' mode), and `allSettled = strategy === 'all-settled'`.\n4. Define `runner`: inside a `while (true)` loop, grab `i = next++`. If `i >= n` or (`failed` and not `allSettled`), break. Call `await worker(items[i], i)`. On success, write either `v` or `{ status: 'fulfilled', value: v }` to `results[i]` depending on `strategy`. On error, if `allSettled` store `{ status: 'rejected', reason: err }` and continue; otherwise set `failed = true`, call `reject(err)`, and `return`. In `finally`, increment `done` and if `done === n` and (`!failed` or `allSettled`), resolve with `results`.\n5. Spawn the pool: compute `k = Math.min(limit, n)` and call `runner()` `k` times so the workers drain all remaining items.\n\nWhy use it: explicit and predictable concurrency control, clear error semantics, and stable result ordering.",
          "codeJs": "export default function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  if (!Number.isFinite(limit) || limit < 1) throw new Error('limit must be >= 1');\n  const n = items.length;\n  const allSettled = strategy === 'all-settled';\n  const results = new Array(n);\n  if (n === 0) return Promise.resolve(results);\n\n  let next = 0;\n  let done = 0;\n  let failed = false;\n\n  return new Promise((resolve, reject) => {\n    const runner = async () => {\n      while (true) {\n        const i = next++;\n        if (i >= n || (failed && !allSettled)) break;\n        try {\n          const v = await worker(items[i], i);\n          results[i] = allSettled\n            ? { status: 'fulfilled', value: v }\n            : v;\n        } catch (err) {\n          if (allSettled) {\n            results[i] = { status: 'rejected', reason: err };\n          } else {\n            failed = true;\n            reject(err);\n            return;\n          }\n        } finally {\n          if (++done === n && (!failed || allSettled)) {\n            resolve(results);\n          }\n        }\n      }\n    };\n\n    const k = Math.min(limit, n);\n    for (let j = 0; j < k; j++) {\n      runner();\n    }\n  });\n}\n",
          "codeTs": "export default function mapAsyncLimit<T, R>(\n  items: T[],\n  limit: number,\n  worker: (item: T, index: number) => Promise<R>,\n  strategy: 'fail-fast' | 'all-settled' = 'fail-fast'\n): Promise<R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>> {\n  if (!Number.isFinite(limit) || limit < 1) throw new Error('limit must be >= 1');\n\n  const n = items.length;\n  const allSettled = strategy === 'all-settled';\n  const results: any[] = new Array(n);\n  if (n === 0) return Promise.resolve(results);\n\n  let next = 0;\n  let done = 0;\n  let failed = false;\n\n  return new Promise((resolve, reject) => {\n    const runner = async () => {\n      while (true) {\n        const i = next++;\n        if (i >= n || (failed && !allSettled)) break;\n        try {\n          const v = await worker(items[i], i);\n          results[i] = allSettled\n            ? { status: 'fulfilled', value: v }\n            : v;\n        } catch (err) {\n          if (allSettled) {\n            results[i] = { status: 'rejected', reason: err };\n          } else {\n            failed = true;\n            reject(err);\n            return;\n          }\n        } finally {\n          if (++done === n && (!failed || allSettled)) {\n            resolve(results);\n          }\n        }\n      }\n    };\n\n    const k = Math.min(limit, n);\n    for (let j = 0; j < k; j++) {\n      runner();\n    }\n  });\n}\n"
        },
        {
          "title": "Approach 2: Queue-style control with recursive runners",
          "prose": "Idea: treat `items` as a queue and recursively chain `run()` so that each worker, when it finishes, immediately grabs the next item until the queue is empty.\n\nSolving steps:\n1. Validate `limit`: throw if `limit < 1` or `limit` is not finite.\n2. Preallocate `results` with length `items.length` so we can write outputs in input order.\n3. Set up shared state: `current = 0` to track the next index to hand out, and `allSettled = strategy === 'all-settled'`.\n4. Define async `run()`: read `i = current++`; if `i >= items.length`, return. Call `await worker(items[i], i)`. On success, store either the raw value (`results[i] = val`) or `{ status: 'fulfilled', value: val }` based on `strategy`. On error, if `strategy === 'fail-fast'` rethrow so the surrounding `Promise.all` rejects; if `'all-settled'`, store `{ status: 'rejected', reason: err }` in `results[i]` and continue. At the end of `run`, call `run()` again to refill this concurrency slot with the next index.\n5. Start the pool: compute `k = Math.min(limit, items.length)` and create `k` initial promises by calling `run()` and storing them in `runners`.\n6. Wait for completion: if `strategy === 'fail-fast'`, return `Promise.all(runners).then(() => results)` so the outer promise rejects on the first failure; otherwise return `Promise.allSettled(runners).then(() => results)` so all tasks finish and `results` contains settled outcomes.\n\nWhy use it: easy to reason about (\"when a worker finishes, it grabs the next job\") and makes refilling concurrency slots explicit without an inner `while` loop.",
          "codeJs": "export default function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  if (!Number.isFinite(limit) || limit < 1) throw new Error('limit must be >= 1');\n\n  const allSettled = strategy === 'all-settled';\n  const results = new Array(items.length);\n  let current = 0;\n\n  const run = async () => {\n    const i = current++;\n    if (i >= items.length) return;\n\n    try {\n      const val = await worker(items[i], i);\n      results[i] = allSettled\n        ? { status: 'fulfilled', value: val }\n        : val;\n    } catch (err) {\n      if (!allSettled) throw err;\n      results[i] = { status: 'rejected', reason: err };\n    }\n\n    return run(); // refill this slot with the next item\n  };\n\n  const k = Math.min(limit, items.length);\n  const runners = Array.from({ length: k }, () => run());\n\n  return allSettled\n    ? Promise.allSettled(runners).then(() => results)\n    : Promise.all(runners).then(() => results);\n}\n",
          "codeTs": "export default function mapAsyncLimit<T, R>(\n  items: T[],\n  limit: number,\n  worker: (item: T, index: number) => Promise<R>,\n  strategy: 'fail-fast' | 'all-settled' = 'fail-fast'\n): Promise<\n  R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>\n> {\n  if (!Number.isFinite(limit) || limit < 1) {\n    throw new Error('limit must be >= 1');\n  }\n\n  const results: any[] = new Array(items.length);\n  let current = 0;\n  const allSettled = strategy === 'all-settled';\n\n  const run = async (): Promise<void> => {\n    const i = current++;\n    if (i >= items.length) return;\n\n    try {\n      const val = await worker(items[i], i);\n      results[i] = allSettled\n        ? { status: 'fulfilled', value: val }\n        : val;\n    } catch (err) {\n      if (!allSettled) throw err;\n      results[i] = { status: 'rejected', reason: err };\n    }\n\n    return run();\n  };\n\n  const k = Math.min(limit, items.length);\n  const runners = Array.from({ length: k }, () => run());\n\n  return allSettled\n    ? Promise.allSettled(runners).then(() => results)\n    : Promise.all(runners).then(() => results);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to preserve order — storing results in completion order breaks determinism.",
          "Swallowing rejections when `'fail-fast'` should actually propagate the first error.",
          "Allowing `limit < 1` can lead to hangs or division-by-zero style bugs."
        ],
        "edgeCases": [
          "Empty input array resolves immediately.",
          "If `limit >= items.length`, all jobs run at once (like `Promise.all`)."
        ],
        "techniques": [
          "Shared index for task dispatch across workers.",
          "Pre-sized result array to preserve input order.",
          "Worker-pool pattern for explicit concurrency control.",
          "Strategy flag (`'fail-fast'` vs `'all-settled'`) to demonstrate configurable error policies."
        ]
      },
      "followUpQuestions": [
        "js-add-two-promises",
        "js-throttle"
      ],
      "resources": [
        {
          "title": "MDN – Using Promises",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises"
        },
        {
          "title": "Jake Archibald – In The Loop (Concurrency explained)",
          "url": "https://www.youtube.com/watch?v=cCOL7MC4Pl0"
        }
      ]
    },
    "tests": "import mapAsyncLimit from './mapAsyncLimit';\n\nconst sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\ndescribe('mapAsyncLimit', () => {\n  test('preserves order with mixed durations', async () => {\n    const items = [30, 10, 20];\n    const out = await mapAsyncLimit(items, 2, async (ms) => { await sleep(ms); return ms / 10; });\n    expect(out).toEqual([3, 1, 2]);\n  });\n\n  test('respects concurrency limit (no more than limit active)', async () => {\n    const items = [30, 30, 30, 30, 30];\n    let active = 0, maxActive = 0;\n    const out = await mapAsyncLimit(items, 2, async (ms) => {\n      active++; if (active > maxActive) maxActive = active;\n      await sleep(ms);\n      active--;\n      return ms;\n    });\n    expect(out).toEqual(items);\n    expect(maxActive <= 2).toEqual(true);\n  });\n\n  test('fail-fast rejects on first error', async () => {\n    const items = [5, 10, 5];\n    let threw = false;\n    try {\n      await mapAsyncLimit(items, 2, async (ms, idx) => {\n        await sleep(ms);\n        if (idx === 1) throw new Error('boom');\n        return idx;\n      }, 'fail-fast');\n    } catch (e) {\n      threw = true;\n      expect(e && e.message).toEqual('boom');\n    }\n    expect(threw).toEqual(true);\n  });\n\n  test('all-settled aggregates outcomes', async () => {\n    const res = await mapAsyncLimit([10, 5, 10, 5], 2, async (ms, idx) => {\n      await sleep(ms);\n      if (idx % 2 === 1) throw new Error('odd');\n      return idx * 10;\n    }, 'all-settled');\n\n    expect(res[0]).toEqual({ status: 'fulfilled', value: 0 });\n    expect(res[1].status).toEqual('rejected');\n    expect(res[2]).toEqual({ status: 'fulfilled', value: 20 });\n    expect(res[3].status).toEqual('rejected');\n  });\n\n  test('throws if limit < 1', () => {\n    let threw = false;\n    try { mapAsyncLimit([1], 0, async (x) => x); } catch (e) { threw = true; }\n    expect(threw).toEqual(true);\n  });\n});\n",
    "testsTs": "import mapAsyncLimit from './mapAsyncLimit';\n\nconst sleep = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\ndescribe('mapAsyncLimit (TS)', () => {\n  test('keeps output order', async () => {\n    const res = await mapAsyncLimit<number, number>([15, 5, 10], 2, async (ms) => { await sleep(ms); return ms / 5; });\n    expect(res).toEqual([3, 1, 2]);\n  });\n\n  test('caps concurrency', async () => {\n    const items = [20, 20, 20, 20];\n    let active = 0, maxActive = 0;\n    const res = await mapAsyncLimit<number, number>(items, 2, async (ms) => {\n      active++; if (active > maxActive) maxActive = active;\n      await sleep(ms);\n      active--; return ms;\n    });\n    expect(res).toEqual(items);\n    expect(maxActive <= 2).toEqual(true);\n  });\n\n  test('fail-fast rejects on first error', async () => {\n    let threw = false;\n    try {\n      await mapAsyncLimit<number, number>([5, 10, 5], 2, async (ms, idx) => {\n        await sleep(ms);\n        if (idx === 1) throw new Error('boom');\n        return idx;\n      }, 'fail-fast');\n    } catch (e: any) {\n      threw = true;\n      expect(e && e.message).toEqual('boom');\n    }\n    expect(threw).toEqual(true);\n  });\n\n  test('all-settled returns settled outcomes', async () => {\n    const res = await mapAsyncLimit<number, number>([5, 10, 5], 2, async (ms, idx) => {\n      await sleep(ms);\n      if (idx === 1) throw new Error('x');\n      return idx * 2;\n    }, 'all-settled') as Array<{ status: 'fulfilled' | 'rejected'; value?: number; reason?: any }>;\n\n    expect(res[0]).toEqual({ status: 'fulfilled', value: 0 });\n    expect(res[1].status).toEqual('rejected');\n    expect(typeof (res[1] as any).reason).toEqual('object');\n    expect(res[2]).toEqual({ status: 'fulfilled', value: 4 });\n  });\n\n  test('throws on invalid limit', () => {\n    let threw = false;\n    try { mapAsyncLimit<number, number>([1], 0, async (x) => x); } catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-abortable-helpers",
    "title": "Abortable Helpers (Timeout + Composed Abort)",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "abort-controller",
      "async",
      "cancellation",
      "promise",
      "utilities"
    ],
    "description": {
      "summary": "Provide utilities to combine timeouts with AbortController, and to compose multiple signals (abort if any fires). All helpers are exposed via a single default export function whose properties are the helpers.",
      "arguments": [
        {
          "name": "withTimeout<T>(p, ms, reason?)",
          "type": "Promise<T>, number, any",
          "desc": "Race a promise against a timeout. Reject with `reason` (or an Error) if the timeout fires; clear the timer if the promise settles first."
        },
        {
          "name": "withAbort<T>(factory, signal)",
          "type": "(signal: AbortSignal) => Promise<T>, AbortSignal",
          "desc": "Run `factory(signal)` and reject if `signal` aborts. If already aborted, reject immediately. Ensure listeners are cleaned up when done."
        },
        {
          "name": "composeAbort(...signals)",
          "type": "AbortSignal[]",
          "desc": "Return a new `AbortSignal` that aborts if ANY input signal aborts; if any is already aborted, the result aborts immediately with the same reason."
        },
        {
          "name": "sleep(ms)",
          "type": "number",
          "desc": "Utility helper that returns a promise resolved after `ms` milliseconds. Useful for tests and examples."
        }
      ],
      "returns": {
        "type": "Default export function with properties: { withTimeout, withAbort, composeAbort, sleep }",
        "desc": "Import the default and destructure its properties to use the helpers."
      },
      "examples": [
        "import helpers from './abortable-helpers';",
        "const { withTimeout, withAbort, composeAbort, sleep } = helpers;",
        "",
        "await withTimeout(fetch(url), 2000, new Error('Timeout'));",
        "const ac = new AbortController();",
        "await withAbort(doWork, ac.signal);",
        "const combined = composeAbort(ac.signal, new AbortController().signal);"
      ]
    },
    "starterCode": "function abortableHelpers() {}\n\nabortableHelpers.sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\nabortableHelpers.withTimeout = function withTimeout(p, ms, reason) {\n  // TODO: Start a timer; race with p. On settle, clear the timer. On timeout, reject with `reason` or Error('Timeout').\n};\n\nabortableHelpers.withAbort = function withAbort(factory, signal) {\n  // TODO: If signal.aborted -> reject immediately. Otherwise run factory(signal) and listen for 'abort'. Clean up listeners on settle.\n};\n\nabortableHelpers.composeAbort = function composeAbort(...signals) {\n  // TODO: New AbortController; if any input already aborted, abort immediately with its reason; otherwise forward first abort and detach listeners.\n};\n\nexport default abortableHelpers;\n",
    "starterCodeTs": "function abortableHelpers() {}\n\nabortableHelpers['sleep'] = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\nabortableHelpers['withTimeout'] = function withTimeout<T>(p: Promise<T>, ms: number, reason?: any): Promise<T> {\n  // TODO\n  return new Promise<T>((resolve, reject) => { /* impl */ });\n};\n\nabortableHelpers['withAbort'] = function withAbort<T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal): Promise<T> {\n  // TODO\n  return new Promise<T>((resolve, reject) => { /* impl */ });\n};\n\nabortableHelpers['composeAbort'] = function composeAbort(...signals: AbortSignal[]): AbortSignal {\n  // TODO\n  const ac = new AbortController();\n  return ac.signal;\n};\n\nexport default abortableHelpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n",
    "solutionBlock": {
      "overview": "Goal: enable cooperative cancellation and safe async composition using `AbortController`. Helpers simplify racing timeouts, making async functions abortable, and merging multiple signals cleanly.\n\nWe implement a single export `abortableHelpers` object with methods `withTimeout`, `withAbort`, `composeAbort`, and `sleep`.\n\n- `withTimeout(p, ms, reason)`: race a promise against a timer.\n- `withAbort(factory, signal)`: wrap async work so it can be cancelled by an `AbortSignal`.\n- `composeAbort(...signals)`: merge multiple signals into one that aborts when any source aborts.\n\nEach helper ensures proper cleanup of timers or listeners to prevent leaks and double resolution.",
      "approaches": [
        {
          "title": "Core idea and cleanup discipline",
          "prose": "We attach all helpers as properties on a single exported function `abortableHelpers`.\n\n**Solving steps – `withTimeout(p, ms, reason?)`**\n1. Create a new `Promise` that will resolve or reject based on the earlier of the inner promise or a timeout.\n2. Start a `setTimeout` for `ms` milliseconds. When it fires, if the wrapper hasn't settled yet, mark it as settled and `reject(reason ?? new Error('Timeout'))`.\n3. Wrap `p` with `Promise.resolve(p)` (so it can be a value or a promise) and hook `.then` / `.catch`. On fulfillment or rejection, if not already settled, mark as settled, `clearTimeout(id)`, and forward the value or error.\n4. Use a `settled` flag to ensure the outer promise resolves/rejects only once, and that the timer is always cleared when the inner promise wins.\n\n**Solving steps – `withAbort(factory, signal)`**\n1. If `signal.aborted` is already `true`, immediately reject with `signal.reason` (or `new Error('Aborted')`). No listeners are attached in this case.\n2. Inside a new `Promise`, create a `finished` flag and an `onAbort` handler. When `onAbort` runs, if not finished, mark finished and `reject(signal.reason ?? new Error('Aborted'))`.\n3. Register `onAbort` as a one-time listener: `signal.addEventListener('abort', onAbort, { once: true })`.\n4. Start the actual work by calling `factory(signal)` inside a resolved promise chain. On success, if not finished, mark finished, remove the abort listener, and `resolve(value)`.\n5. On error, if not finished, mark finished, remove the abort listener, and `reject(error)`.\n6. The combination of `finished` + `removeEventListener` guarantees no leaks and no double resolution.\n\n**Solving steps – `composeAbort(...signals)`**\n1. Create a new `AbortController` `ac` and return `ac.signal` to callers.\n2. If `signals` is empty, just return `ac.signal` (it will never abort unless someone aborts `ac` manually).\n3. Check whether any input signal is already aborted. If found, immediately `ac.abort(already.reason)` and return `ac.signal`.\n4. Otherwise, for each source signal `s`, attach a one-time `abort` listener that calls a shared `abortOnce(reason)` helper.\n5. `abortOnce` aborts the combined signal if not already aborted, then iterates over all stored listeners and removes them, clearing the `listeners` array to avoid leaks.\n6. When any input signal aborts, the combined signal aborts with the same `reason`, and all other listeners are detached.\n\nThis pattern gives you: (a) precise timeout control, (b) clean abort wiring for individual async tasks, and (c) a reusable way to merge cancellation sources.",
          "codeJs": "function abortableHelpers() {}\n\nabortableHelpers.sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\nabortableHelpers.withTimeout = function withTimeout(p, ms, reason) {\n  return new Promise((resolve, reject) => {\n    let settled = false;\n    const id = setTimeout(() => {\n      if (settled) return;\n      settled = true;\n      reject(reason ?? new Error('Timeout'));\n    }, ms);\n\n    Promise.resolve(p).then(\n      v => { if (!settled) { settled = true; clearTimeout(id); resolve(v); } },\n      e => { if (!settled) { settled = true; clearTimeout(id); reject(e); } }\n    );\n  });\n};\n\nabortableHelpers.withAbort = function withAbort(factory, signal) {\n  return new Promise((resolve, reject) => {\n    if (signal?.aborted) { reject(signal.reason ?? new Error('Aborted')); return; }\n\n    let finished = false;\n    const onAbort = () => {\n      if (finished) return;\n      finished = true;\n      reject(signal.reason ?? new Error('Aborted'));\n    };\n\n    signal?.addEventListener('abort', onAbort, { once: true });\n\n    Promise.resolve()\n      .then(() => factory(signal))\n      .then(v => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); resolve(v); } })\n      .catch(e => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); reject(e); } });\n  });\n};\n\nabortableHelpers.composeAbort = function composeAbort(...signals) {\n  const ac = new AbortController();\n  if (!signals || signals.length === 0) return ac.signal;\n\n  const already = signals.find(s => s?.aborted);\n  if (already) { ac.abort(already.reason); return ac.signal; }\n\n  const listeners = [];\n  const abortOnce = (reason) => {\n    if (!ac.signal.aborted) ac.abort(reason);\n    for (const { s, fn } of listeners) s.removeEventListener('abort', fn);\n    listeners.length = 0;\n  };\n\n  for (const s of signals) {\n    if (!s) continue;\n    const fn = () => abortOnce(s.reason);\n    s.addEventListener('abort', fn, { once: true });\n    listeners.push({ s, fn });\n  }\n\n  return ac.signal;\n};\n\nexport default abortableHelpers;\n",
          "codeTs": "function abortableHelpers() {}\n\nabortableHelpers['sleep'] = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\nabortableHelpers['withTimeout'] = function withTimeout<T>(p: Promise<T>, ms: number, reason?: any): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    let settled = false;\n    const id = setTimeout(() => {\n      if (settled) return;\n      settled = true;\n      reject(reason ?? new Error('Timeout'));\n    }, ms);\n\n    Promise.resolve(p).then(\n      v => { if (!settled) { settled = true; clearTimeout(id); resolve(v); } },\n      e => { if (!settled) { settled = true; clearTimeout(id); reject(e); } }\n    );\n  });\n};\n\nabortableHelpers['withAbort'] = function withAbort<T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    if (signal?.aborted) { reject((signal as any).reason ?? new Error('Aborted')); return; }\n\n    let finished = false;\n    const onAbort = () => {\n      if (finished) return;\n      finished = true;\n      reject((signal as any).reason ?? new Error('Aborted'));\n    };\n\n    signal?.addEventListener('abort', onAbort, { once: true });\n\n    Promise.resolve()\n      .then(() => factory(signal))\n      .then(v => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); resolve(v); } })\n      .catch(e => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); reject(e); } });\n  });\n};\n\nabortableHelpers['composeAbort'] = function composeAbort(...signals: AbortSignal[]): AbortSignal {\n  const ac = new AbortController();\n  if (!signals || signals.length === 0) return ac.signal;\n\n  const already = signals.find(s => s?.aborted);\n  if (already) { ac.abort((already as any).reason); return ac.signal; }\n\n  type L = { s: AbortSignal; fn: () => void };\n  const listeners: L[] = [];\n  const abortOnce = (reason: any) => {\n    if (!ac.signal.aborted) ac.abort(reason);\n    for (const { s, fn } of listeners) s.removeEventListener('abort', fn);\n    listeners.length = 0;\n  };\n\n  for (const s of signals) {\n    if (!s) continue;\n    const fn = () => abortOnce((s as any).reason);\n    s.addEventListener('abort', fn, { once: true });\n    listeners.push({ s, fn });\n  }\n\n  return ac.signal;\n};\n\nexport default abortableHelpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Always remove abort listeners and clear timers to avoid leaks.",
          "Avoid double resolution; track state with a `settled` / `finished` flag.",
          "If a signal is already aborted, reject immediately without attaching listeners.",
          "`withTimeout` does not automatically cancel the underlying work — it only rejects the wrapper promise. Combine with `withAbort` or an abort-aware API if you need real cancellation."
        ],
        "edgeCases": [
          "Zero-timeout case (ms = 0) → rejects immediately if the timer wins.",
          "Aborted signal passed to `withAbort` → immediate rejection.",
          "Composed signal with any already-aborted input → aborts instantly with that reason.",
          "No signals passed to `composeAbort` → returned signal never aborts on its own."
        ],
        "techniques": [
          "Use AbortController to coordinate cancellations.",
          "Use Promise.race-style logic for timeouts.",
          "Clean up listeners and timers explicitly.",
          "Model composed cancellation via a shared AbortController and mirrored abort events."
        ]
      },
      "followUpQuestions": [
        "js-add-two-promises"
      ],
      "resources": [
        {
          "title": "MDN – AbortController",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController"
        },
        {
          "title": "MDN – Promise.race()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"
        }
      ]
    },
    "tests": "import helpers from './abortable-helpers';\nconst { withTimeout, withAbort, composeAbort, sleep } = helpers as any;\nfunction _sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }\nconst nap = typeof sleep === 'function' ? sleep : _sleep;\n\ndescribe('Abortable Helpers', () => {\n  test('withTimeout resolves when promise is fast', async () => {\n    const res = await withTimeout(nap(30).then(()=>42), 200);\n    expect(res).toEqual(42);\n  });\n\n  test('withTimeout rejects when timeout wins', async () => {\n    let threw = false; let msg = '';\n    try { await withTimeout(nap(200), 30, new Error('Timeout')); }\n    catch(e){ threw = true; msg = e && e.message; }\n    expect(threw).toEqual(true);\n    expect(!!msg).toEqual(true);\n  });\n\n  test('withAbort resolves if not aborted', async () => {\n    const ac = new AbortController();\n    const val = await withAbort(async (signal) => { await nap(20); return signal.aborted ? -1 : 7; }, ac.signal);\n    expect(val).toEqual(7);\n  });\n\n  test('withAbort rejects when signal aborts', async () => {\n    const ac = new AbortController();\n    let threw = false;\n    try {\n      const p = withAbort(async () => { await nap(100); return 1; }, ac.signal);\n      setTimeout(()=>ac.abort(new Error('Cancelled')), 20);\n      await p;\n    } catch{ threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort aborts when any source aborts', async () => {\n    const a = new AbortController();\n    const b = new AbortController();\n    const c = composeAbort(a.signal, b.signal);\n    expect(c.aborted).toEqual(false);\n\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 'ok'; }, c);\n    setTimeout(()=> b.abort(new Error('Bailed')), 10);\n    try { await p; } catch{ threw = true; }\n    expect(threw).toEqual(true);\n    expect(c.aborted).toEqual(true);\n  });\n\n  test('composeAbort is already aborted if any input is aborted', () => {\n    const a = new AbortController();\n    a.abort(new Error('early'));\n    const c = composeAbort(a.signal, new AbortController().signal);\n    expect(c.aborted).toEqual(true);\n  });\n});\n",
    "testsTs": "import helpers from './abortable-helpers';\nconst { withTimeout, withAbort, composeAbort, sleep } = helpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n\nfunction _sleep(ms: number){ return new Promise<void>(r=>setTimeout(r, ms)); }\nconst nap = typeof sleep === 'function' ? sleep : _sleep;\n\ndescribe('Abortable Helpers (TS)', () => {\n  test('withTimeout resolves fast', async () => {\n    const res = await withTimeout(Promise.resolve(5), 100);\n    expect(res).toEqual(5);\n  });\n\n  test('withTimeout rejects on timeout', async () => {\n    let threw = false;\n    try { await withTimeout(nap(200).then(()=>42), 10, new Error('Timeout')); }\n    catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('withAbort resolves when not aborted', async () => {\n    const ac = new AbortController();\n    const v = await withAbort(async (signal) => { await nap(15); return signal.aborted ? -1 : 9; }, ac.signal);\n    expect(v).toEqual(9);\n  });\n\n  test('withAbort rejects when aborted', async () => {\n    const ac = new AbortController();\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 1; }, ac.signal);\n    setTimeout(()=>ac.abort(new Error('cancel')), 10);\n    try { await p; } catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort aborts if any input aborts', async () => {\n    const a = new AbortController();\n    const b = new AbortController();\n    const sig = composeAbort(a.signal, b.signal);\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 'ok'; }, sig);\n    setTimeout(()=>a.abort(new Error('stop')), 10);\n    try { await p; } catch { threw = true; }\n    expect(sig.aborted).toEqual(true);\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort reflects already-aborted inputs', () => {\n    const a = new AbortController(); a.abort(new Error('early'));\n    const sig = composeAbort(a.signal);\n    expect(sig.aborted).toEqual(true);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-streaming-ndjson-parser",
    "title": "Streaming NDJSON Parser (Web Streams)",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "backpressure",
      "ndjson",
      "parsing",
      "streams",
      "text-decoder"
    ],
    "description": {
      "summary": "Build an NDJSON streaming parser that reads chunked text and emits JSON objects line by line. Handle partial lines across chunks, ignore empty lines, and surface parse errors without crashing the stream. This mirrors real-time log ingestion and SSE pipelines.",
      "arguments": [
        {
          "name": "stream",
          "type": "ReadableStream<Uint8Array>",
          "desc": "Binary stream producing UTF-8 chunks of text containing one JSON object per line."
        },
        {
          "name": "onError",
          "type": "(line: string, err: any) => void (optional)",
          "desc": "Called when a line fails to parse. The parser must **continue** parsing subsequent lines."
        }
      ],
      "returns": {
        "type": "Promise<any[]>",
        "desc": "Resolves with an array of successfully parsed objects (malformed lines are skipped but reported via `onError`)."
      },
      "examples": [
        "// Given a Response with NDJSON body\nconst res = await fetch('/events.ndjson');\nconst objects = await parseNDJSON(res.body, (line, err) => console.warn('bad line:', line, err));\n// objects => an array of parsed items, in order"
      ]
    },
    "starterCode": "/*\n * parseNDJSON(stream, onError?)\n * - Consume a ReadableStream<Uint8Array> using a reader\n * - Use TextDecoder with { stream: true } to correctly handle UTF-8 boundaries\n * - Accumulate into a string buffer; split by \"\\n\" to get complete lines\n * - Keep the trailing partial line in the buffer and prepend the next chunk\n * - For each non-empty line, JSON.parse; on error, call onError(line, err) and continue\n * - After the stream ends, flush the decoder and process the final buffer\n */\nexport default async function parseNDJSON(stream, onError) {\n  // TODO: implement as described above\n}\n\n// CommonJS fallback for runners that require module.exports\ntry { if (typeof module !== 'undefined') module.exports = parseNDJSON; } catch (_) {}\n",
    "starterCodeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: any) => void\n): Promise<any[]> {\n  // TODO: implement\n  return []\n}\n\n// CommonJS fallback\n// @ts-ignore\ntry { if (typeof module !== 'undefined') (module as any).exports = parseNDJSON; } catch (_) {}\n",
    "solutionBlock": {
      "overview": "NDJSON streams require incremental parsing: buffer incomplete lines, split on newlines, and parse each full line into JSON. The key is to handle chunk boundaries gracefully so objects aren’t dropped or duplicated. This is a common pattern in streaming APIs and log ingestion.",
      "approaches": [
        {
          "title": "Approach 1: Built-ins pipeline (easiest)",
          "prose": "Maintain a string buffer. For each chunk, append to the buffer and split by '\n'. Parse all complete lines (except the last partial line) with JSON.parse and emit results. Keep the final partial line in the buffer for the next chunk. On stream end, parse any remaining non-empty line. Guard against empty lines and handle JSON.parse errors explicitly.",
          "codeJs": "export default async function parseNDJSON(stream, onError){\n  if (!stream?.pipeThrough) throw new Error('ReadableStream expected');\n  const lineSplitter = new TransformStream({\n    start(){ this.buf = ''; },\n    transform(chunk, controller){\n      this.buf += chunk; const parts = this.buf.split('\\n');\n      this.buf = parts.pop() ?? '';\n      for (const line of parts){ const t=line.trim(); if (t) controller.enqueue(t); }\n    },\n    flush(controller){ const t = this.buf.trim(); if (t) controller.enqueue(t); }\n  });\n\n  const out = [];\n  const reader = stream\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(lineSplitter)\n    .getReader();\n\n  while (true){\n    const { value, done } = await reader.read(); if (done) break;\n    try { out.push(JSON.parse(value)); } catch (e){ onError?.(value, e); }\n  }\n  try{ reader.releaseLock(); }catch{}\n  return out;\n}",
          "codeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: unknown) => void\n): Promise<any[]> {\n  if (!('pipeThrough' in stream)) throw new Error('ReadableStream expected');\n\n  const lineSplitter = new TransformStream<string, string>({\n    start() { (this as any).buf = ''; },\n    transform(chunk, controller) {\n      (this as any).buf += chunk;\n      const parts = (this as any).buf.split('\\n');\n      (this as any).buf = parts.pop() ?? '';\n      for (const line of parts) {\n        const t = line.trim();\n        if (t) controller.enqueue(t);\n      }\n    },\n    flush(controller) {\n      const t = ((this as any).buf as string).trim();\n      if (t) controller.enqueue(t);\n    }\n  });\n\n  const out: any[] = [];\n  const reader = stream\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(lineSplitter)\n    .getReader();\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    try { out.push(JSON.parse(value)); } catch (e) { onError?.(value, e); }\n  }\n  try { reader.releaseLock(); } catch {}\n  return out;\n}"
        },
        {
          "title": "Approach 2: Async iterator style (clean & concise)",
          "prose": "Consume bytes manually with a reader and `TextDecoder`, keeping a small buffer string.\n\nSolving steps:\n1. Create `const reader = stream.getReader()` and `const decoder = new TextDecoder()`.\n2. Maintain a `buf` string and an `out` array, and define a `drain()` helper that splits `buf` on `\"\\n\"`, keeps the last element as the new `buf` (the potential partial line), and for each full line: trims it and, if non-empty, tries `JSON.parse(line)` in a try/catch; on success pushes into `out`, on failure calls `onError?.(line, err)` and continues.\n3. In a `while (true)` loop, `await reader.read()`. For each chunk, append `decoder.decode(value, { stream: true })` to `buf` and call `drain()`.\n4. After `done` is true, flush any remaining bytes with `buf += decoder.decode()`, then call `drain()` again to handle any remaining full lines.\n5. If there's still a non-empty `buf` (final line without trailing newline), parse it with the same try/catch + `onError` logic, then release the reader lock in a `try/catch` and return `out`.\n\nWhy it works: incremental decoding plus a carry-over buffer ensures JSON objects are never split incorrectly across chunks, while keeping memory usage bounded and isolating malformed lines.",
          "codeJs": "export default async function parseNDJSON(stream, onError){\n  const reader = stream.getReader(); const dec = new TextDecoder();\n  let buf = '', out = [];\n  const drain = () => { const parts = buf.split('\\n'); buf = parts.pop() ?? '';\n    for (let l of parts){ l = l.trim(); if(!l) continue; try{ out.push(JSON.parse(l)); }catch(e){ onError?.(l,e); } }\n  };\n  while(true){ const {value,done}=await reader.read(); if(done) break;\n    buf += dec.decode(value,{stream:true}); drain(); }\n  buf += dec.decode(); drain(); const tail=buf.trim();\n  if(tail){ try{ out.push(JSON.parse(tail)); }catch(e){ onError?.(tail,e); } }\n  try{ reader.releaseLock(); }catch{}\n  return out;\n}",
          "codeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: unknown) => void\n): Promise<any[]> {\n  const reader = stream.getReader();\n  const dec = new TextDecoder();\n  let buf = '';\n  const out: any[] = [];\n\n  const drain = () => {\n    const parts = buf.split('\\n');\n    buf = parts.pop() ?? '';\n    for (let l of parts) {\n      const t = l.trim();\n      if (!t) continue;\n      try { out.push(JSON.parse(t)); }\n      catch (e) { onError?.(t, e); }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buf += dec.decode(value, { stream: true });\n    drain();\n  }\n\n  buf += dec.decode();\n  drain();\n  const tail = buf.trim();\n  if (tail) {\n    try { out.push(JSON.parse(tail)); }\n    catch (e) { onError?.(tail, e); }\n  }\n\n  try { reader.releaseLock(); } catch {}\n  return out;\n}"
        },
        {
          "title": "Approach 3: Backpressure-focused reader loop (most control)",
          "prose": "A more verbose, production-oriented variant that uses an explicit reader loop, `{ stream: true }` decoding, and careful cleanup.\n\nSolving steps:\n1. Validate that `stream` looks like a `ReadableStream<Uint8Array>`; if not, throw a clear error.\n2. Create `const reader = stream.getReader()` and `const decoder = new TextDecoder('utf-8')`. Maintain a `buffer` string and an `out` array, and define a `drainLines()` helper that splits `buffer` on `\"\\n\"`, keeps the last element as the new `buffer`, and for each full line: trims it, skips empty lines, and `JSON.parse`s it in a try/catch; on success pushes into `out`, on failure calls `onError(line, err)` if provided.\n3. In a `while (true)` loop, `await reader.read()`. For each chunk, append `decoder.decode(value, { stream: true })` to `buffer` and call `drainLines()` so lines are processed incrementally as data arrives.\n4. When `done` is true, flush any remaining bytes with `buffer += decoder.decode()`, then call `drainLines()` again to handle any final full lines.\n5. If there's still a non-empty `buffer` (final line without trailing newline), parse it with the same try/catch + `onError` logic, then release the reader lock in a `try/catch` and return the `out` array.\n\nWhy use it: when you need tight control over resource management, metrics, or instrumentation (for example logging per-chunk progress or enforcing custom backpressure policies), this pattern gives you full control while following the same buffer + split + parse strategy as the other approaches.",
          "codeJs": "/*\n * Streaming NDJSON parser\n * - Efficient: processes data chunk-by-chunk (low memory) and preserves order\n * - Robust: isolates malformed lines via onError callback and continues\n * - Correct decoding: uses TextDecoder(stream:true) for UTF-8 boundaries\n */\nexport default async function parseNDJSON(stream, onError) {\n  if (!stream || typeof stream.getReader !== 'function') {\n    throw new Error('parseNDJSON: expected a ReadableStream<Uint8Array>');\n  }\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n  const out = [];\n\n  const drainLines = () => {\n    const parts = buffer.split('\\n');\n    buffer = parts.pop() ?? '';\n    for (let line of parts) {\n      line = line.trim();\n      if (line === '') continue;\n      try {\n        out.push(JSON.parse(line));\n      } catch (err) {\n        if (typeof onError === 'function') onError(line, err);\n      }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, { stream: true });\n    drainLines();\n  }\n\n  buffer += decoder.decode();\n  drainLines();\n  const tail = buffer.trim();\n  if (tail !== '') {\n    try { out.push(JSON.parse(tail)); }\n    catch (err) { if (typeof onError === 'function') onError(tail, err); }\n  }\n\n  try { reader.releaseLock(); } catch (_) {}\n  return out;\n}\n\ntry { if (typeof module !== 'undefined') module.exports = parseNDJSON; } catch (_) {}\n",
          "codeTs": "/*\n * Streaming NDJSON parser (TypeScript)\n * Same logic, with typed signatures for clarity.\n */\nexport default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: any) => void\n): Promise<any[]> {\n  if (!stream || typeof (stream as any).getReader !== 'function') {\n    throw new Error('parseNDJSON: expected a ReadableStream<Uint8Array>');\n  }\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n  const out: any[] = [];\n\n  const drainLines = () => {\n    const parts = buffer.split('\\n');\n    buffer = parts.pop() ?? '';\n    for (let raw of parts) {\n      const line = raw.trim();\n      if (line === '') continue;\n      try { out.push(JSON.parse(line)); }\n      catch (err) { if (onError) onError(line, err); }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, { stream: true });\n    drainLines();\n  }\n\n  buffer += decoder.decode();\n  drainLines();\n  const tail = buffer.trim();\n  if (tail !== '') {\n    try { out.push(JSON.parse(tail)); }\n    catch (err) { if (onError) onError(tail, err); }\n  }\n\n  try { reader.releaseLock(); } catch {}\n  return out;\n}\n\n// CommonJS fallback\n// @ts-ignore\ntry { if (typeof module !== 'undefined') (module as any).exports = parseNDJSON; } catch {}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting `{ stream: true }` on `TextDecoder.decode` can corrupt multi-byte characters split across chunks.",
          "Dropping the trailing partial line between chunks leads to truncated/invalid JSON.",
          "Throwing on a single bad line halts the entire parse — prefer `onError` and continue."
        ],
        "edgeCases": [
          "CRLF endings: `\\r\\n` — use `trim()` before parsing to remove stray `\\r`.",
          "Empty lines: skip safely.",
          "Final line without trailing `\\n`: parse it after flushing the decoder."
        ],
        "techniques": [
          "Respect backpressure with `getReader()` and `await reader.read()`.",
          "Incremental decode using `TextDecoder` with stream mode.",
          "Carry-over buffer + split-on-newline to align record boundaries."
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "MDN – Streams API",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Streams_API"
        },
        {
          "title": "MDN – TextDecoder",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder"
        }
      ]
    },
    "tests": "import parseNDJSON from './ndjson-parser';\n\n// Helper: build a ReadableStream<Uint8Array> that emits given string chunks\nconst te = new TextEncoder();\nfunction streamFromStrings(chunks) {\n  return new ReadableStream({\n    start(controller) {\n      let i = 0;\n      const pump = () => {\n        if (i >= chunks.length) { controller.close(); return; }\n        controller.enqueue(te.encode(chunks[i++]));\n        setTimeout(pump, 0); // async to exercise the reader loop\n      };\n      pump();\n    }\n  });\n}\n\nfunction expectEqual(a, b){ expect(JSON.stringify(a)).toEqual(JSON.stringify(b)); }\n\ndescribe('Streaming NDJSON Parser', () => {\n  test('parses lines across arbitrary chunk boundaries', async () => {\n    const chunks = [\n      '{\"a\":1}\\n{\"b\"',\n      ':2}\\n{\"c\":3}\\n',\n    ];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{a:1},{b:2},{c:3}]);\n  });\n\n  test('handles last line without trailing newline', async () => {\n    const chunks = ['{\"x\":1}\\n{\"y\":2}'];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{x:1},{y:2}]);\n  });\n\n  test('skips blank lines and trims CRLF', async () => {\n    const chunks = ['\\r\\n', '{\"n\":1}\\r\\n', '\\n', '{\"m\":2}\\n'];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{n:1},{m:2}]);\n  });\n\n  test('reports malformed lines via onError and continues', async () => {\n    const bad = []; // collect bad lines\n    const chunks = ['{\"ok\":1}\\n', '{bad json}\\n', '{\"ok\":2}\\n'];\n    const res = await parseNDJSON(streamFromStrings(chunks), (line, err) => { bad.push(line); });\n    expectEqual(res, [{ok:1},{ok:2}]);\n    expectEqual(bad, ['{bad json}']);\n  });\n});\n",
    "testsTs": "import parseNDJSON from './ndjson-parser';\n\nconst te = new TextEncoder();\nfunction streamFromStrings(chunks: string[]): ReadableStream<Uint8Array> {\n  return new ReadableStream<Uint8Array>({\n    start(controller) {\n      let i = 0;\n      const pump = () => {\n        if (i >= chunks.length) { controller.close(); return; }\n        controller.enqueue(te.encode(chunks[i++]));\n        setTimeout(pump, 0);\n      };\n      pump();\n    }\n  });\n}\n\nfunction expectEqual(a: any, b: any){ expect(JSON.stringify(a)).toEqual(JSON.stringify(b)); }\n\ndescribe('Streaming NDJSON Parser (TS)', () => {\n  test('parses across chunk boundaries', async () => {\n    const res = await parseNDJSON(streamFromStrings(['{\"a\":1}\\n{\"b\"', ':2}\\n']));\n    expectEqual(res, [{a:1},{b:2}]);\n  });\n\n  test('no trailing newline', async () => {\n    const res = await parseNDJSON(streamFromStrings(['{\"x\":1}\\n{\"y\":2}']));\n    expectEqual(res, [{x:1},{y:2}]);\n  });\n\n  test('error isolation', async () => {\n    const errors: string[] = [];\n    const res = await parseNDJSON(streamFromStrings(['{\"ok\":1}\\n','{oops}\\n','{\"ok\":2}\\n']), (line) => errors.push(line));\n    expectEqual(res, [{ok:1},{ok:2}]);\n    expectEqual(errors, ['{oops}']);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-array-prototype-map",
    "title": "Implement Array.prototype.map",
    "type": "coding",
    "companies": [
      "amazon",
      "apple",
      "bytedance"
    ],
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "callbacks",
      "iteration",
      "polyfills"
    ],
    "teaches": [
      "How built-in array iteration works under the hood",
      "Correct callback invocation and thisArg binding",
      "Handling sparse arrays (holes) correctly",
      "Length snapshot + per-index existence checks"
    ],
    "description": {
      "summary": "Recreate the native `.map()` method **without using it**. Your `myMap` must call `callbackFn(value, index, array)` for each **existing** index, bind `thisArg`, and return a new array with the **same length** where holes stay holes (no callback for missing indices). It must snapshot the initial `length` and must not visit elements appended beyond that length during iteration (native behavior).",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "(currentValue: any, index: number, array: any[]) => any",
          "desc": "Function to execute on each existing element."
        },
        {
          "name": "thisArg",
          "type": "any (optional)",
          "desc": "Value to use as `this` when executing callback."
        }
      ],
      "returns": {
        "type": "Array",
        "desc": "A new array with the results of calling `callbackFn` on every existing element, preserving length and holes."
      },
      "examples": [
        "[1, 2, 3].myMap(x => x * 2) // => [2, 4, 6]",
        "[, 10, , 30].myMap((v,i) => i) // => [ , 1, , 3 ] (holes preserved)",
        "[1].myMap(function(x){ return this.add + x }, { add: 5 }) // => [6]"
      ]
    },
    "starterCode": "/* Boilerplate — replace the throw with a correct implementation */\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};\n",
    "starterCodeTs": "declare global {\n  interface Array<T> {\n    myMap<U>(\n      callbackFn: (value: T, index: number, array: Array<T>) => U,\n      thisArg?: any\n    ): Array<U>;\n  }\n}\n\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};\n",
    "solutionBlock": {
      "overview": "Goal: implement a `.map()`-like method that snapshots `length` once, iterates `0..len-1`, calls the callback with `(value, index, array)` for existing indices only, binds `thisArg`, and returns a new array of the same length where holes remain holes.",
      "approaches": [
        {
          "title": "Single approach: length snapshot + own-property check (chosen for clarity)",
          "prose": "We intentionally use an **own-property** check (`Object.prototype.hasOwnProperty.call`) to define “existing element” as an actual slot on the array object. This is the simplest mental model for learners and matches the key interview lesson: **holes are skipped**.\n\nSpec note (1 line): The ECMAScript spec uses `k in O` (includes inherited numeric keys). We avoid that here to keep the exercise focused on holes/length snapshot without prototype-chain surprises.",
          "codeJs": "Array.prototype.myMap = function (callbackFn, thisArg) {\n  if (this == null) throw new TypeError('Array.prototype.myMap called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n\n  const O = Object(this);\n  const len = O.length >>> 0; // snapshot length once\n  const out = new Array(len);\n\n  for (let k = 0; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      out[k] = callbackFn.call(thisArg, O[k], k, O);\n    }\n    // else: hole stays hole in out\n  }\n\n  return out;\n};\n",
          "codeTs": "declare global {\n  interface Array<T> {\n    myMap<U>(\n      callbackFn: (value: T, index: number, array: Array<T>) => U,\n      thisArg?: any\n    ): Array<U>;\n  }\n}\n\nArray.prototype.myMap = function <T, U>(\n  this: T[],\n  callbackFn: (value: T, index: number, array: T[]) => U,\n  thisArg?: any,\n): U[] {\n  if (this == null) throw new TypeError('Array.prototype.myMap called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n\n  const O = Object(this) as { [k: number]: T; length: number };\n  const len = O.length >>> 0; // snapshot length once\n  const out = new Array<U>(len);\n\n  for (let k = 0; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      out[k] = callbackFn.call(thisArg, O[k], k, O as any);\n    }\n  }\n\n  return out;\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Missing runtime guard: native `.map()` throws if `callbackFn` is not a function.",
          "Using `push` instead of writing by index will destroy hole positions and length alignment.",
          "`thisArg` is ignored by arrow functions by design—use a normal function if you need `this`."
        ],
        "edgeCases": [
          "Sparse arrays: callback is not called for missing indices; output preserves holes.",
          "Mutations during mapping can affect later indices (native behavior), but length is snapshotted at the start.",
          "Appended elements beyond the initial length are not visited."
        ],
        "techniques": [
          "Box receiver with `Object(this)` and snapshot `length` once (`>>> 0`).",
          "Use `Object.prototype.hasOwnProperty.call(O, k)` to skip holes (own slots only).",
          "Bind `thisArg` with `.call(thisArg, value, index, array)`.",
          "Preallocate the output array to keep indices aligned."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-filter",
        "js-array-prototype-reduce",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.map()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"
        },
        {
          "title": "ECMAScript Spec – Array.prototype.map",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.map"
        }
      ]
    },
    "tests": "describe('Array.prototype.myMap', () => {\n  const identity = (x) => x;\n  const square = (n) => n * n;\n\n  test('throws if callbackFn is not a function', () => {\n    expect(() => [1, 2].myMap(null)).toThrow(TypeError);\n  });\n\n  test('identity', () => {\n    expect([10].myMap(identity)).toEqual([10]);\n    expect([10, 20].myMap(identity)).toEqual([10, 20]);\n  });\n\n  test('square', () => {\n    expect([-4].myMap(square)).toEqual([16]);\n    expect([5].myMap(square)).toEqual([25]);\n  });\n\n  test('skips holes and preserves length/holes', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a = [, 10, , 30];\n    const r = a.myMap((v, i) => i);\n    expect(r.length).toBe(4);\n    expect(0 in r).toBe(false);\n    expect(1 in r).toBe(true);\n    expect(2 in r).toBe(false);\n    expect(3 in r).toBe(true);\n    expect(r[1]).toBe(1);\n    expect(r[3]).toBe(3);\n  });\n\n  test('binds thisArg', () => {\n    const ctx = { add: 5 };\n    const out = [1].myMap(function (x) { return this.add + x; }, ctx);\n    expect(out).toEqual([6]);\n  });\n\n  test('length snapshot: does not visit appended elements beyond initial length', () => {\n    const arr = [1, 2, 3];\n    const seen = [];\n    const out = arr.myMap((v, i, a) => {\n      seen.push(v);\n      if (i === 0) a.push(999);\n      return v;\n    });\n    expect(out).toEqual([1, 2, 3]);\n    expect(seen).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "// @ts-nocheck\n\ndescribe('Array.prototype.myMap (TypeScript)', () => {\n  it('throws if callbackFn is not a function', () => {\n    expect(() => ([1, 2] as any).myMap(null)).toThrow(TypeError);\n  });\n\n  it('maps values and preserves holes', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a: any[] = [, 10, , 30];\n    const r = (a as any).myMap((v: any, i: number) => i);\n    expect(r.length).toBe(4);\n    expect(0 in r).toBe(false);\n    expect(1 in r).toBe(true);\n    expect(2 in r).toBe(false);\n    expect(3 in r).toBe(true);\n  });\n\n  it('binds thisArg', () => {\n    const ctx = { add: 5 };\n    const out = ([1] as any).myMap(function (x: number) { return (this as any).add + x; }, ctx);\n    expect(out).toEqual([6]);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-array-prototype-reduce",
    "title": "Implement Array.prototype.reduce",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "amazon",
      "apple",
      "bytedance"
    ],
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "arrays",
      "callbacks",
      "iteration",
      "polyfills",
      "accumulators"
    ],
    "teaches": [
      "How array reduction works under the hood",
      "Accumulator initialization with or without an initial value",
      "Handling sparse arrays (holes) correctly",
      "Throwing on empty arrays without an initial value"
    ],
    "description": {
      "summary": "Recreate the native `.reduce()` method **without using it**. Your `myReduce` must call the reducer with `(accumulator, currentValue, index, array)` only for existing indices, handle an optional `initialValue`, and return the final accumulator. If no `initialValue` is provided, use the **first existing element** as the initial accumulator. If there is **no existing element** and no `initialValue`, throw a `TypeError`. Concepts: arrays, callbacks, iteration.",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "(accumulator: any, currentValue: any, index: number, array: any[]) => any",
          "desc": "Reducer function applied to each existing element."
        },
        {
          "name": "initialValue",
          "type": "any (optional)",
          "desc": "Value to use as the first accumulator. If omitted, the first existing element is used."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "The final accumulated value after iterating through the array."
      },
      "examples": [
        "[1, 2, 3].myReduce((acc, x) => acc + x, 0) // => 6",
        "[, 1, , 3].myReduce((acc, x) => acc + x)   // => 4 (skips holes; starts at 1)",
        "[].myReduce((a, x) => a + x, 10)           // => 10"
      ]
    },
    "starterCode": "/* Boilerplate — replace the throw with a correct implementation */\nArray.prototype.myReduce = function (callbackFn, initialValue) {\n  throw 'Not implemented!';\n};\n",
    "starterCodeTs": "declare global {\n  interface Array<T> {\n    myReduce<U>(\n      callbackFn: (accumulator: U, currentValue: T, index: number, array: Array<T>) => U,\n      initialValue: U\n    ): U;\n    myReduce(\n      callbackFn: (accumulator: T, currentValue: T, index: number, array: Array<T>) => T\n    ): T;\n  }\n}\n\nArray.prototype.myReduce = function (callbackFn: any, initialValue?: any) {\n  throw 'Not implemented!';\n};\n",
    "solutionBlock": {
      "overview": "What a correct `.reduce()` must do: (1) Work on the receiver and read its `length` directly. (2) If `initialValue` is provided, start with it; otherwise find the first existing element as the initial accumulator (skip holes) or throw on empty. (3) For each existing index, call `callbackFn(acc, value, index, array)` and store back to `acc`. (4) Skip holes using an own-property check (or `k in O` for spec-leaning behavior). (5) Return the final `acc`. Key concepts: arrays, callbacks, iteration.",
      "approaches": [
        {
          "title": "Approach 1: Simple for-loop (practical baseline)",
          "prose": "Iterate 0..length−1, seed the accumulator from `initialValue` or the first present element, and skip holes with an own-property check. Clear, fast, and mirrors everyday expectations.\n\nSolving steps:\n1. Coerce the receiver: `const O = Object(this)`.\n2. Coerce `length`: `const len = O.length >>> 0` (uint32, like the spec).\n3. Decide whether an `initialValue` was provided: `const initProvided = arguments.length > 1`.\n4. If `initProvided` is true, set `acc = initialValue` and start from `k = 0`. Otherwise, scan from `k = 0` until you find the first own property; if none exists, throw `TypeError('Reduce of empty array with no initial value')`; otherwise use that element as `acc` and start after it.\n5. From the current `k` up to `len − 1`, if `O` has own property `k`, call `callbackFn(acc, O[k], k, O)` and store the result back into `acc`.\n6. Return `acc`.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = O.length >>> 0; // coerce to uint32\n  let k = 0;\n  let acc;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(O, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      acc = callbackFn(acc, O[k], k, O);\n    }\n  }\n  return acc;\n};\n",
          "codeTs": "declare global {\n  interface Array<T> {\n    myReduce<U>(cb: (acc: U, cur: T, idx: number, arr: T[]) => U, initialValue: U): U;\n    myReduce(cb: (acc: T, cur: T, idx: number, arr: T[]) => T): T;\n  }\n}\n\nArray.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as T[] & { length: number };\n  const len: number = O.length >>> 0;\n  let k = 0;\n  let acc: any;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue as U;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(O, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = (O as any)[k++];\n  }\n  for (; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      acc = (callbackFn as any)(acc, (O as any)[k], k, O);\n    }\n  }\n  return acc as any;\n};\n"
        },
        {
          "title": "Approach 2: Spec-leaning (`ToObject`, length coercion, `k in O`)",
          "prose": "Closer to native semantics: coerce `this` with `Object(this)`, coerce `length` via `Number` + `Math.floor`, and use `k in O` to honor inherited index accessors (native `.reduce` does this).\n\nSolving steps:\n1. Box the receiver: `const O = Object(this)` so it works on array-like values.\n2. Coerce `length`: `const len = Math.max(0, Math.floor(Number(O.length) || 0))`.\n3. Compute `const initProvided = arguments.length > 1` to distinguish the two call forms.\n4. If `initProvided`, set `acc = initialValue` and start from `k = 0`; otherwise scan `k` upwards while `!(k in O)`. If you reach `k >= len`, throw the same `TypeError`; otherwise seed `acc = O[k]` and increment `k`.\n5. For `k` from current value up to `len − 1`, if `k in O`, call `callbackFn(acc, O[k], k, O)` and store the result.\n6. Return `acc`.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = Math.max(0, Math.floor(Number(O.length) || 0));\n  let k = 0;\n  let acc;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue;\n  } else {\n    while (k < len && !(k in O)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) {\n    if (k in O) acc = callbackFn(acc, O[k], k, O);\n  }\n  return acc;\n};\n",
          "codeTs": "Array.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as Record<number, T> & { length: number };\n  const len: number = Math.max(0, Math.floor(Number(O.length) || 0));\n  let k = 0;\n  let acc: any;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue as U;\n  } else {\n    while (k < len && !(k in O)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) {\n    if (k in O) acc = (callbackFn as any)(acc, O[k], k, O as any);\n  }\n  return acc as any;\n};\n"
        },
        {
          "title": "Approach 3: Helper-driven (readability: `nextPresentIndex`)",
          "prose": "Extract the \"find next present element\" logic into a tiny helper. This makes the seeding + iteration steps very explicit and easy to reason about for sparse arrays.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = O.length >>> 0;\n  const nextPresentIndex = (start) => {\n    let i = start;\n    while (i < len && !Object.prototype.hasOwnProperty.call(O, i)) i++;\n    return i;\n  };\n  let k = 0;\n  let acc;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue;\n    k = nextPresentIndex(0);\n  } else {\n    k = nextPresentIndex(0);\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (k = nextPresentIndex(k); k < len; k = nextPresentIndex(k + 1)) {\n    acc = callbackFn(acc, O[k], k, O);\n  }\n  return acc;\n};\n",
          "codeTs": "Array.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as T[] & { length: number };\n  const len: number = O.length >>> 0;\n  const hasOwn = Object.prototype.hasOwnProperty;\n  const nextPresentIndex = (start: number): number => {\n    let i = start;\n    while (i < len && !hasOwn.call(O, i)) i++;\n    return i;\n  };\n  let k = 0;\n  let acc: any;\n  const initProvided = arguments.length > 1;\n  if (initProvided) {\n    acc = initialValue as U;\n    k = nextPresentIndex(0);\n  } else {\n    k = nextPresentIndex(0);\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = (O as any)[k++];\n  }\n  for (k = nextPresentIndex(k); k < len; k = nextPresentIndex(k + 1)) {\n    acc = (callbackFn as any)(acc, (O as any)[k], k, O);\n  }\n  return acc as any;\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using `this[0]` as the seed even when index 0 is a hole — must scan for the **first present** element.",
          "Forgetting to skip holes (use own-property checks or `k in O` as appropriate).",
          "Not throwing on an empty array when `initialValue` is omitted.",
          "Real `.reduce()` also throws if `callbackFn` is not a function; these implementations assume a valid function and skip that check (good interview talking point)."
        ],
        "edgeCases": [
          "All holes (e.g., `[,,,]`) with no `initialValue` → throw `TypeError`.",
          "Arrays with leading holes (e.g., `[,1,,3]`) → seed from `1` when `initialValue` is omitted.",
          "Arrays with getters on inherited indices: if you use `k in O`, inherited accessors may participate."
        ],
        "techniques": [
          "Coerce the receiver with `Object(this)` before reading `length`.",
          "Seed from `initialValue` when provided; otherwise scan for the first present element.",
          "Use `hasOwnProperty.call(O, k)` to skip holes consistently, or `k in O` when you want inherited index behavior."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-map",
        "js-array-prototype-filter",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        },
        {
          "title": "ECMAScript Spec (Reduce)",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.reduce"
        }
      ]
    },
    "notes": {
      "pitfalls": [
        "Using `this[0]` as the seed even when index 0 is a hole — must scan for the **first present** element.",
        "Forgetting to skip holes (use own-property checks or `k in O` as appropriate).",
        "Not throwing on an empty array when `initialValue` is omitted."
      ],
      "edgeCases": [
        "All holes (e.g., `[,,,]`) with no `initialValue` → throw `TypeError`.",
        "Arrays with leading holes (e.g., `[,1,,3]`) → seed from `1` when `initialValue` is omitted.",
        "Arrays with getters on inherited indices: if you use `k in O`, inherited accessors may participate."
      ],
      "techniques": [
        "Coerce the receiver with `Object(this)` before reading `length`.",
        "Seed from `initialValue` when provided; otherwise scan for the first present element.",
        "Use `hasOwnProperty.call(O, k)` to skip holes consistently."
      ]
    },
    "followUpQuestions": [
      "js-array-prototype-map",
      "js-array-prototype-filter",
      "js-array-prototype-some"
    ],
    "resources": [
      {
        "title": "MDN – Array.prototype.reduce()",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
      },
      {
        "title": "ECMAScript Spec (Reduce)",
        "url": "https://tc39.es/ecma262/#sec-array.prototype.reduce"
      }
    ],
    "tests": "const sum = (a, x) => a + x;\nconst pair = (a, x, i) => a.concat([[i, x]]);\n\n// helper for throw assertions (no toThrow in this runner)\nconst expectThrowsTypeError = (fn) => {\n  let ok = false;\n  try { fn(); } catch (e) { ok = e instanceof TypeError; }\n  expect(ok).toBe(true);\n};\n\ndescribe('Array.prototype.myReduce', () => {\n  test('with initialValue on dense arrays', () => {\n    expect([1, 2, 3].myReduce(sum, 0)).toBe(6);\n    expect([5].myReduce(sum, 10)).toBe(15);\n  });\n\n  test('without initialValue uses first existing element (handles leading holes)', () => {\n    const a = [, 1, , 3];\n    expect(a.myReduce(sum)).toBe(4);\n  });\n\n  test('skips holes (sparse arrays) with initialValue', () => {\n    const a = [, 1, , 3];\n    expect(a.myReduce(sum, 0)).toBe(4);\n  });\n\n  test('passes index and array correctly', () => {\n    const out = [10, 20].myReduce(pair, []);\n    expect(out).toEqual([[0, 10], [1, 20]]);\n  });\n\n  test('empty array with initialValue returns initialValue', () => {\n    expect([].myReduce(sum, 42)).toBe(42);\n  });\n\n  test('empty array without initialValue throws TypeError', () => {\n    expectThrowsTypeError(() => [].myReduce(sum));\n  });\n});\n",
    "testsTs": "// @ts-nocheck\nconst _shimReduce = (arr, cb, initProvided, initVal) => {\n  const len = arr.length;\n  let k = 0;\n  let acc;\n  if (initProvided) {\n    acc = initVal;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(arr, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = arr[k++];\n  }\n  for (; k < len; k++) if (Object.prototype.hasOwnProperty.call(arr, k)) acc = cb(acc, arr[k], k, arr);\n  return acc;\n};\n\nconst callReduce = (arr, cb, ...rest) =>\n  typeof arr.myReduce === 'function'\n    ? arr.myReduce(cb, ...rest)\n    : _shimReduce(arr, cb, rest.length > 0, rest[0]);\n\nconst sum = (a, x) => a + x;\n\nconst expectThrowsTypeError = (fn) => {\n  let ok = false; try { fn(); } catch (e) { ok = e instanceof TypeError; } expect(ok).toBe(true);\n};\n\ndescribe('Array.prototype.myReduce (TS)', () => {\n  test('sum with initialValue', () => {\n    expect(callReduce([1, 2, 3], sum, 0)).toBe(6);\n  });\n  test('sum without initialValue (holes at start)', () => {\n    expect(callReduce([,1,,3], sum)).toBe(4);\n  });\n  test('sparse array skipping with initialValue', () => {\n    expect(callReduce([,1,,3], sum, 0)).toBe(4);\n  });\n  test('empty + initial returns initial', () => {\n    expect(callReduce([], sum, 7)).toBe(7);\n  });\n  test('empty without initial throws', () => {\n    expectThrowsTypeError(() => callReduce([], sum));\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-array-prototype-filter",
    "title": "Implement Array.prototype.filter",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "amazon",
      "apple"
    ],
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "callbacks",
      "iteration",
      "polyfills",
      "core-js"
    ],
    "description": {
      "summary": "Recreate the native `Array.prototype.filter()` method as `myFilter`. It should call a provided callback once for each existing element in the array, include the element in the new array if the callback returns a truthy value, **skip holes** in sparse arrays, and support an optional `thisArg` for context. Your implementation must snapshot the initial `length` and must not visit elements appended beyond that length during iteration (native behavior).",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "function",
          "desc": "Predicate function called as `(element, index, array)`."
        },
        {
          "name": "thisArg",
          "type": "any",
          "desc": "Value to use as `this` when executing `callbackFn`."
        }
      ],
      "returns": {
        "type": "Array",
        "desc": "A new array with elements that passed the test implemented by `callbackFn`."
      },
      "examples": [
        "// Filter even numbers\n[1, 2, 3, 4, 5].myFilter(n => n % 2 === 0) // => [2, 4]",
        "// Filter by context\n[1, 2, 3, 4, 5].myFilter(function(n) { return n > this.min; }, { min: 3 }) // => [4, 5]"
      ]
    },
    "starterCode": "Array.prototype.myFilter = function(callbackFn, thisArg) {\n  // TODO: Implement Array.prototype.filter behavior.\n  // Requirements:\n  // - Skip holes in sparse arrays\n  // - Support thisArg\n  // - Snapshot initial length (do not iterate appended elements beyond the initial length)\n  throw new Error('Not implemented');\n};\n",
    "starterCodeTs": "interface Array<T> {\n  myFilter(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];\n}\n\nArray.prototype.myFilter = function<T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[] {\n  // TODO: Implement Array.prototype.filter behavior.\n  // Requirements:\n  // - Skip holes in sparse arrays\n  // - Support thisArg\n  // - Snapshot initial length (do not iterate appended elements beyond the initial length)\n  throw new Error('Not implemented');\n};\n",
    "solutionBlock": {
      "overview": "Goal: implement a `.filter()`-like method that iterates indices `0..len-1` where `len` is snapshotted once, calls the predicate with `(value, index, array)`, **skips holes**, respects `thisArg`, and returns a **new** array of values for which the predicate is truthy.",
      "approaches": [
        {
          "title": "Single approach: for-loop + own-property check (skip holes + length snapshot)",
          "prose": "Core rules to match native behavior:\n- Snapshot `len` once at the start.\n- Only call the predicate for indices that exist (skip holes).\n- Do not visit elements appended beyond the initial `len`.\n- Pass `(value, index, array)` and bind `thisArg`.\n\nSpec note (1 line): Native `filter` conceptually uses `k in O` (includes inherited numeric keys). For interview/polyfill practice we use own-property checks to focus on holes + length snapshot behavior.",
          "codeJs": "Array.prototype.myFilter = function(callbackFn, thisArg) {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n\n  const arr = Object(this);\n  const len = arr.length >>> 0; // snapshot length once\n  const result = [];\n\n  for (let i = 0; i < len; i++) {\n    // skip holes (and skip indices that were never present)\n    if (Object.prototype.hasOwnProperty.call(arr, i)) {\n      const val = arr[i];\n      if (callbackFn.call(thisArg, val, i, arr)) {\n        result.push(val);\n      }\n    }\n  }\n\n  return result;\n};\n",
          "codeTs": "interface Array<T> {\n  myFilter(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];\n}\n\nArray.prototype.myFilter = function<T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[] {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n\n  const arr = Object(this) as { [k: number]: T; length: number };\n  const len = arr.length >>> 0; // snapshot length once\n  const result: T[] = [];\n\n  for (let i = 0; i < len; i++) {\n    if (Object.prototype.hasOwnProperty.call(arr, i)) {\n      const val = arr[i];\n      if (callbackFn.call(thisArg, val, i, arr as any)) {\n        result.push(val);\n      }\n    }\n  }\n\n  return result;\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to snapshot `length` can cause your loop to visit appended elements (native `filter` does not).",
          "Calling the predicate for holes — use an existence check (`Object.prototype.hasOwnProperty.call`) before reading/calling.",
          "`thisArg` does not affect arrow functions because arrows don’t have their own `this`."
        ],
        "edgeCases": [
          "Sparse arrays: `[1, , 3]` should not call the predicate for the missing index and should return `[1, 3]` when predicate is always true.",
          "Mutations during iteration: deleted elements should not be visited if they become holes before the index is reached; appended elements beyond the initial length should not be visited."
        ],
        "techniques": [
          "`Object(this)` to safely handle array-like receivers.",
          "`len = arr.length >>> 0` to coerce and snapshot length once.",
          "Existence check with `Object.prototype.hasOwnProperty.call(arr, i)` to skip holes.",
          "`.call(thisArg, value, index, array)` for context binding."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-map",
        "js-array-prototype-reduce",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        },
        {
          "title": "ECMAScript Spec (Filter)",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.filter"
        }
      ]
    },
    "tests": "describe('Array.prototype.myFilter', () => {\n  test('filters even numbers', () => {\n    const res = [1, 2, 3, 4, 5].myFilter(x => x % 2 === 0);\n    expect(res).toEqual([2, 4]);\n  });\n\n  test('returns empty array when nothing matches', () => {\n    const res = [1, 3, 5].myFilter(x => x % 2 === 0);\n    expect(res).toEqual([]);\n  });\n\n  test('does not mutate original array', () => {\n    const arr = [1, 2, 3];\n    arr.myFilter(x => x > 1);\n    expect(arr).toEqual([1, 2, 3]);\n  });\n\n  test('uses thisArg correctly', () => {\n    const ctx = { min: 3 };\n    const res = [1, 2, 3, 4, 5].myFilter(function(x) { return x > this.min; }, ctx);\n    expect(res).toEqual([4, 5]);\n  });\n\n  test('skips holes in sparse arrays', () => {\n    const arr = [1, , 3];\n    const res = arr.myFilter(() => true);\n    expect(res).toEqual([1, 3]);\n  });\n\n  test('snapshots length (does not visit appended elements beyond initial length)', () => {\n    const arr = [1, 2, 3];\n    const seen = [];\n\n    const res = arr.myFilter((v, i, a) => {\n      seen.push(v);\n      if (i === 0) a.push(999); // appended beyond initial length\n      return true;\n    });\n\n    expect(res).toEqual([1, 2, 3]);\n    expect(seen).toEqual([1, 2, 3]);\n  });\n\n  test('skips elements deleted before their turn (becomes a hole)', () => {\n    const arr = [1, 2, 3];\n    const seen = [];\n\n    const res = arr.myFilter((v, i, a) => {\n      if (i === 0) delete a[1];\n      seen.push(v);\n      return true;\n    });\n\n    // index 1 was deleted before iteration reached it => skip it\n    expect(res).toEqual([1, 3]);\n    expect(seen).toEqual([1, 3]);\n  });\n});\n",
    "testsTs": "describe('Array.prototype.myFilter (TypeScript)', () => {\n  it('should filter even numbers', () => {\n    const result = [1, 2, 3, 4, 5].myFilter(n => n % 2 === 0);\n    expect(result).toEqual([2, 4]);\n  });\n\n  it('should handle empty results correctly', () => {\n    const result = [1, 3, 5].myFilter(n => n % 2 === 0);\n    expect(result).toEqual([]);\n  });\n\n  it('should use thisArg for context', () => {\n    const ctx = { min: 3 };\n    const result = [1, 2, 3, 4, 5].myFilter(function(x) { return x > this.min; }, ctx);\n    expect(result).toEqual([4, 5]);\n  });\n\n  it('snapshots length (does not visit appended elements)', () => {\n    const arr = [1, 2, 3];\n    const seen: number[] = [];\n\n    const res = arr.myFilter((v, i, a) => {\n      seen.push(v);\n      if (i === 0) (a as any).push(999);\n      return true;\n    });\n\n    expect(res).toEqual([1, 2, 3]);\n    expect(seen).toEqual([1, 2, 3]);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-array-foreach",
    "title": "Implement arrayForEach (no prototype mutation)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "iteration",
      "callbacks",
      "edge-cases"
    ],
    "description": {
      "summary": "You should also ensure the callback is invoked with the correct thisArg and that the method returns undefined like the native API. Edge cases include sparse arrays and thisArg binding; test callback order and performance with large arrays.",
      "arguments": [
        {
          "name": "arr",
          "type": "Array<any>",
          "desc": "Source array to iterate. Sparse slots must be skipped."
        },
        {
          "name": "callbackFn",
          "type": "(value:any, index:number, array:any[]) => void",
          "desc": "Function to invoke for each present element."
        },
        {
          "name": "thisArg",
          "type": "any (optional)",
          "desc": "Value of `this` inside `callbackFn`."
        }
      ],
      "returns": {
        "type": "void",
        "desc": "No return value (returns `undefined`)."
      },
      "examples": [
        "// Sum values\nlet sum = 0; arrayForEach([1,2,3], v => { sum += v; }); // sum = 6",
        "// Respect thisArg\nconst ctx = { seen: [] }; arrayForEach(['a','b'], function (v) { this.seen.push(v); }, ctx); // ctx.seen = ['a','b']",
        "// Skip holes\nconst a = [1, , 3]; arrayForEach(a, (v, i) => { /* called for i=0 and i=2 only */ });"
      ]
    },
    "starterCode": "export default function arrayForEach(arr, callbackFn, thisArg) {\n  // Requirements:\n  // - Snapshot initial length (do not visit appended elements beyond initial length)\n  // - Skip holes (sparse slots)\n  // - Skip elements deleted before their index is reached\n  // - Bind thisArg using .call\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function arrayForEach<T>(\n  arr: (T | undefined)[],\n  callbackFn: (value: T, index: number, array: (T | undefined)[]) => void,\n  thisArg?: any,\n): void {\n  // Requirements:\n  // - Snapshot initial length (do not visit appended elements beyond initial length)\n  // - Skip holes (sparse slots)\n  // - Skip elements deleted before their index is reached\n  // - Bind thisArg using .call\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "A correct polyfill mirrors the ECMAScript behavior: skip holes, use length snapshotting, and validate the callback before iterating.",
      "approaches": [
        {
          "title": "Single approach: length snapshot + own-property check (recommended)",
          "prose": "If length changes during iteration, native forEach uses the original length; you can mention this even if the simplified solution doesn’t implement it fully. Include a note about converting array-like values with Object(this).",
          "codeJs": "export default function arrayForEach(arr, callbackFn, thisArg) {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n\n  const len = arr.length; // snapshot once\n  const hasOwn = Object.prototype.hasOwnProperty;\n\n  for (let i = 0; i < len; i++) {\n    if (hasOwn.call(arr, i)) {\n      callbackFn.call(thisArg, arr[i], i, arr);\n    }\n  }\n\n  return undefined;\n}\n",
          "codeTs": "export default function arrayForEach<T>(\n  arr: (T | undefined)[],\n  callbackFn: (value: T, index: number, array: (T | undefined)[]) => void,\n  thisArg?: any,\n): void {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n\n  const len = arr.length; // snapshot once\n  const hasOwn = Object.prototype.hasOwnProperty;\n\n  for (let i = 0; i < len; i++) {\n    if (hasOwn.call(arr, i)) {\n      callbackFn.call(thisArg, arr[i] as T, i, arr);\n    }\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "If you use `for (let i = 0; i < arr.length; i++)`, you may accidentally iterate elements appended during iteration.",
          "If you don’t check for existence, you’ll call the callback on holes (native forEach skips them).",
          "`thisArg` won’t affect arrow functions (they don’t bind `this`)."
        ],
        "edgeCases": [
          "Sparse arrays like `[1, , 3]`: callback runs for indices 0 and 2 only.",
          "Delete-before-visit: if index 1 is deleted while processing index 0, index 1 must be skipped.",
          "Push-during-iteration: elements appended after the call starts must not be visited."
        ],
        "techniques": [
          "Snapshot length once.",
          "Use `hasOwnProperty.call(arr, i)` to skip holes and to respect delete-before-visit.",
          "Use `.call(thisArg, value, index, array)` to bind context."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-map",
        "js-array-prototype-filter",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.forEach()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"
        },
        {
          "title": "ECMAScript Spec – Array.prototype.forEach",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.foreach"
        }
      ]
    },
    "tests": "import arrayForEach from './file';\n\ndescribe('arrayForEach', () => {\n  test('iterates in order', () => {\n    const seen = [];\n    arrayForEach([3, 1, 2], (v) => seen.push(v));\n    expect(seen).toEqual([3, 1, 2]);\n  });\n\n  test('binds thisArg', () => {\n    const ctx = { out: '' };\n    arrayForEach(['a', 'b'], function (v) { this.out += v; }, ctx);\n    expect(ctx.out).toBe('ab');\n  });\n\n  test('skips holes (sparse arrays)', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a = [1, , 3];\n    const seen = [];\n    arrayForEach(a, (v, i) => seen.push([v, i]));\n    expect(seen).toEqual([[1, 0], [3, 2]]);\n  });\n\n  test('snapshots length (push during iteration not visited)', () => {\n    const arr = [1, 2, 3];\n    const seen = [];\n\n    arrayForEach(arr, (v, i, a) => {\n      seen.push(v);\n      if (i === 0) a.push(999);\n    });\n\n    expect(seen).toEqual([1, 2, 3]);\n  });\n\n  test('skips elements deleted before their turn (hole check)', () => {\n    const arr = [1, 2, 3];\n    const seen = [];\n\n    arrayForEach(arr, (v, i, a) => {\n      if (i === 0) delete a[1];\n      seen.push(v);\n    });\n\n    // index 1 was deleted before iteration reached it => skip it\n    expect(seen).toEqual([1, 3]);\n  });\n});\n",
    "testsTs": "import arrayForEach from './file';\n\ndescribe('arrayForEach (TypeScript)', () => {\n  it('iterates in order', () => {\n    const a = [3, 1, 2];\n    const seen: number[] = [];\n    arrayForEach(a, (v) => { seen.push(v as number); });\n    expect(seen).toEqual([3, 1, 2]);\n  });\n\n  it('binds thisArg', () => {\n    const ctx = { out: '' };\n    arrayForEach(['a', 'b'], function(v) { this.out += v; }, ctx);\n    expect(ctx.out).toBe('ab');\n  });\n\n  it('skips holes (sparse arrays)', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a = [1, , 3];\n    const seen: Array<[number, number]> = [];\n    arrayForEach(a, (v, i) => { if (v !== undefined) seen.push([v as number, i]); });\n    expect(seen).toEqual([[1, 0], [3, 2]]);\n  });\n\n  it('snapshots length (push during iteration not visited)', () => {\n    const arr = [1, 2, 3];\n    const seen: number[] = [];\n\n    arrayForEach(arr, (v, i, a) => {\n      seen.push(v as number);\n      if (i === 0) (a as any).push(999);\n    });\n\n    expect(seen).toEqual([1, 2, 3]);\n  });\n\n  it('skips elements deleted before their turn (hole check)', () => {\n    const arr = [1, 2, 3];\n    const seen: number[] = [];\n\n    arrayForEach(arr, (v, i, a) => {\n      if (i === 0) delete (a as any)[1];\n      seen.push(v as number);\n    });\n\n    expect(seen).toEqual([1, 3]);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-array-sort",
    "title": "Sort Numbers with Array.prototype.sort",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "amazon",
      "meta"
    ],
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "sorting"
    ],
    "description": {
      "summary": "Implement a function `sortNumbers(arr, ascending = true)` that returns a **new array** of numbers sorted numerically in ascending or descending order. The original array must not be mutated, and you should use `Array.prototype.sort()` correctly with a compare function. Concepts: arrays, sorting.",
      "arguments": [
        {
          "name": "arr",
          "type": "number[]",
          "desc": "An array of numbers to sort."
        },
        {
          "name": "ascending",
          "type": "boolean",
          "desc": "If `true` (default), sort in ascending order; if `false`, sort in descending order."
        }
      ],
      "returns": {
        "type": "number[]",
        "desc": "A new array containing the sorted numbers."
      },
      "examples": [
        "// Basic ascending sort\nsortNumbers([3, 1, 10]) // => [1, 3, 10]",
        "// Descending sort\nsortNumbers([3, 1, 10], false) // => [10, 3, 1]",
        "// Handles negative numbers\nsortNumbers([-2, 5, 0, -10]) // => [-10, -2, 0, 5]",
        "// Original array is not mutated\nconst nums = [5, 2, 11]\nconst sorted = sortNumbers(nums)\n// nums is still [5, 2, 11]"
      ]
    },
    "starterCode": "export default function sortNumbers(arr, ascending = true) {\n  // TODO:\n  // 1. Do NOT mutate the original array.\n  // 2. Use Array.prototype.sort() with a numeric compare function.\n  // 3. Respect the `ascending` flag.\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function sortNumbers(arr: number[], ascending = true): number[] {\n  // TODO:\n  // 1. Do NOT mutate the original array.\n  // 2. Use Array.prototype.sort() with a numeric compare function.\n  // 3. Respect the `ascending` flag.\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: sort an array of numbers **numerically**, not lexicographically, using `Array.prototype.sort()` — and return a **new** sorted array without mutating the original.\n\nThis tests understanding of:\n- How `.sort()` works by default (string/lexicographic behavior).\n- Writing a numeric compare function (`(a, b) => a - b`).\n- Avoiding mutation by cloning the input first. Key concepts: arrays, sorting.",
      "approaches": [
        {
          "title": "Approach 1: Clone + numeric compare function (canonical)",
          "prose": "Idea: make a shallow copy of the array, then call `.sort()` with a numeric compare function that respects the `ascending` flag.\n\nHow it works\n1) Clone the input: `const copy = [...arr]` (or `arr.slice()`) so the original is never mutated.\n2) Choose the compare function based on `ascending`:\n   - If `ascending` is `true`, return `a - b`.\n   - If `ascending` is `false`, return `b - a`.\n3) Call `copy.sort(compareFn)` and return `copy`.\n\nWhy it works\n- Explicit numeric comparison avoids the default lexicographic sort like `[10, 2].sort()`.\n- The `ascending` flag is handled in one place, inside the compare function.\n- Sorting the cloned array keeps the original array intact.\n\nComplexity\n- Time: typically O(n log n) for the sort.\n- Space: O(n) for the cloned array (plus whatever the engine uses internally for sorting).",
          "codeJs": "export default function sortNumbers(arr, ascending = true) {\n  // Clone to avoid mutating the original\n  const copy = [...arr];\n\n  copy.sort((a, b) => {\n    if (ascending) {\n      return a - b; // negative if a < b, positive if a > b\n    }\n    return b - a;   // flipped for descending\n  });\n\n  return copy;\n}\n",
          "codeTs": "export default function sortNumbers(arr: number[], ascending = true): number[] {\n  // Clone to avoid mutating the original\n  const copy = [...arr];\n\n  copy.sort((a, b) => {\n    if (ascending) {\n      return a - b; // negative if a < b, positive if a > b\n    }\n    return b - a;   // flipped for descending\n  });\n\n  return copy;\n}\n"
        },
        {
          "title": "Approach 2: Always sort ascending, then reverse if needed",
          "prose": "Idea: keep the compare function minimal by always sorting ascending, then reverse the array when `ascending` is `false`.\n\nHow it works\n1) Clone the input: `const copy = [...arr]`.\n2) Sort numerically ascending: `copy.sort((a, b) => a - b)`.\n3) If `ascending` is `false`, call `copy.reverse()`.\n4) Return `copy`.\n\nWhy it works\n- The compare function is fixed and easy to read.\n- The ascending/descending choice is expressed directly via `reverse()`.\n\nComplexity\n- Time: O(n log n) for `sort` + O(n) for `reverse()`.\n- Space: O(n) for the cloned array.",
          "codeJs": "export default function sortNumbers(arr, ascending = true) {\n  const copy = [...arr];\n  copy.sort((a, b) => a - b); // numeric ascending\n  if (!ascending) {\n    copy.reverse();\n  }\n  return copy;\n}\n",
          "codeTs": "export default function sortNumbers(arr: number[], ascending = true): number[] {\n  const copy = [...arr];\n  copy.sort((a, b) => a - b); // numeric ascending\n  if (!ascending) {\n    copy.reverse();\n  }\n  return copy;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Default `.sort()` casts values to strings and sorts lexicographically: `[10, 2].sort()` → `[10, 2]`, not `[2, 10]`.",
          "`.sort()` **mutates** the array it’s called on — always clone when you must not change the input.",
          "Compare functions must return a negative value if `a` comes before `b`, positive if `a` comes after `b`, and `0` if their relative order doesn’t matter.",
          "If `arr` contains non-numbers (`NaN`, strings, etc.), numeric comparison can produce surprising results. In this kata we assume valid numbers."
        ],
        "edgeCases": [
          "Empty array → returns `[]`.",
          "Single-element array → unchanged.",
          "Already sorted array → returns a sorted copy; original is still intact.",
          "All equal numbers → order is effectively unchanged."
        ],
        "techniques": [
          "Using spread syntax (`[...]`) or `.slice()` to clone arrays.",
          "Writing numeric compare functions for `.sort()`.",
          "Controlling sort direction with a flag.",
          "Understanding mutation vs. immutability when working with arrays."
        ]
      },
      "followUpQuestions": [
        "js-unique-array",
        "js-flatten-once"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.sort()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"
        },
        {
          "title": "MDN – Array.prototype.reverse()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse"
        }
      ]
    },
    "tests": "import sortNumbers from './sortNumbers';\n\ndescribe('sortNumbers', () => {\n  test('sorts numbers ascending by default', () => {\n    expect(sortNumbers([3, 1, 10])).toEqual([1, 3, 10]);\n    expect(sortNumbers([-2, 5, 0, -10])).toEqual([-10, -2, 0, 5]);\n  });\n\n  test('sorts numbers descending when ascending is false', () => {\n    expect(sortNumbers([3, 1, 10], false)).toEqual([10, 3, 1]);\n    expect(sortNumbers([-2, 5, 0, -10], false)).toEqual([5, 0, -2, -10]);\n  });\n\n  test('does not mutate the original array', () => {\n    const nums = [5, 2, 11];\n    const copy = [...nums];\n    const sorted = sortNumbers(nums);\n\n    expect(sorted).toEqual([2, 5, 11]);\n    expect(nums).toEqual(copy); // original remains unchanged\n  });\n\n  test('handles empty and single-element arrays', () => {\n    expect(sortNumbers([])).toEqual([]);\n    expect(sortNumbers([42])).toEqual([42]);\n  });\n});\n",
    "testsTs": "import sortNumbers from './sortNumbers';\n\ndescribe('sortNumbers (TypeScript)', () => {\n  it('sorts numbers ascending by default', () => {\n    expect(sortNumbers([3, 1, 10])).toEqual([1, 3, 10]);\n    expect(sortNumbers([-2, 5, 0, -10])).toEqual([-10, -2, 0, 5]);\n  });\n\n  it('sorts numbers descending when ascending is false', () => {\n    expect(sortNumbers([3, 1, 10], false)).toEqual([10, 3, 1]);\n    expect(sortNumbers([-2, 5, 0, -10], false)).toEqual([5, 0, -2, -10]);\n  });\n\n  it('does not mutate the original array', () => {\n    const nums = [5, 2, 11];\n    const copy = [...nums];\n    const sorted = sortNumbers(nums);\n\n    expect(sorted).toEqual([2, 5, 11]);\n    expect(nums).toEqual(copy);\n  });\n\n  it('handles empty and single-element arrays', () => {\n    expect(sortNumbers([])).toEqual([]);\n    expect(sortNumbers([42])).toEqual([42]);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-create-counter",
    "title": "Create a Counter Function",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "closure",
      "functions",
      "increment",
      "state"
    ],
    "description": {
      "summary": "Support an optional initial value and keep the API simple so consumers can call inc/dec/get without exposing the internal state. Mention closure behavior, edge cases like negative increments, and tests for independent counters and performance.",
      "arguments": [
        {
          "name": "n",
          "type": "number",
          "desc": "The starting integer for the counter."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A function that returns the current integer and then increments its internal state for the next call."
      },
      "examples": [
        "// Example 1\nconst counter = createCounter(10);\ncounter(); // => 10\ncounter(); // => 11\ncounter(); // => 12",
        "// Example 2\nconst counter = createCounter(-2);\ncounter(); // => -2\ncounter(); // => -1\ncounter(); // => 0"
      ]
    },
    "starterCode": "export default function createCounter(n) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function createCounter(n: number): () => number {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "This is a classic closure exercise: the state lives in the outer scope, and only the returned functions can mutate or read it.",
      "approaches": [
        {
          "title": "Approach: Closure-based counter (recommended)",
          "prose": "Optionally allow a reset method if the prompt mentions it. Emphasize that the counter is deterministic: the same sequence of calls always produces the same values. Complexity is O(1) per call.",
          "codeJs": "export default function createCounter(n) {\n  return function() {\n    const current = n;\n    n += 1;\n    return current;\n  };\n}\n",
          "codeTs": "export default function createCounter(n: number): () => number {\n  return function(): number {\n    const current = n;\n    n += 1;\n    return current;\n  };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using a global variable will share state across all counters — use a closure per instance.",
          "Returning `++n` vs. current value changes behavior (off-by-one). This task expects returning the current and then incrementing.",
          "Mutating objects captured in closures can cause shared state; here we keep only a primitive number."
        ],
        "edgeCases": [
          "Negative starts (e.g., `-2`) should count upward correctly.",
          "Large numbers work until you hit `Number.MAX_SAFE_INTEGER` (then precision issues can appear).",
          "Multiple counters created from separate calls must not interfere with each other."
        ],
        "techniques": [
          "Leverage lexical scoping: inner function closes over `n`.",
          "Prefer returning a function over exposing mutable objects to keep encapsulation tight."
        ]
      },
      "followUpQuestions": [
        "js-memoize-function"
      ],
      "resources": [
        {
          "title": "MDN – Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        },
        {
          "title": "You Don’t Know JS Yet – Scope & Closures (free book)",
          "url": "https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures"
        }
      ]
    },
    "tests": "import createCounter from './file';\n\ndescribe('createCounter', () => {\n  test('increments sequentially', () => {\n    const counter = createCounter(10);\n    expect(counter()).toBe(10);\n    expect(counter()).toBe(11);\n    expect(counter()).toBe(12);\n  });\n\n  test('works with negative numbers', () => {\n    const counter = createCounter(-2);\n    expect(counter()).toBe(-2);\n    expect(counter()).toBe(-1);\n    expect(counter()).toBe(0);\n  });\n\n  test('separate counters maintain independent state', () => {\n    const c1 = createCounter(0);\n    const c2 = createCounter(100);\n    expect(c1()).toBe(0);\n    expect(c2()).toBe(100);\n    expect(c1()).toBe(1);\n    expect(c2()).toBe(101);\n  });\n});\n",
    "testsTs": "import createCounter from './file';\n\ndescribe('createCounter (TypeScript)', () => {\n  it('increments sequentially', () => {\n    const counter = createCounter(5);\n    expect(counter()).toBe(5);\n    expect(counter()).toBe(6);\n    expect(counter()).toBe(7);\n  });\n\n  it('works with negative numbers', () => {\n    const counter = createCounter(-2);\n    expect(counter()).toBe(-2);\n    expect(counter()).toBe(-1);\n    expect(counter()).toBe(0);\n  });\n\n  it('independent counters maintain separate state', () => {\n    const c1 = createCounter(1);\n    const c2 = createCounter(50);\n    expect(c1()).toBe(1);\n    expect(c2()).toBe(50);\n    expect(c1()).toBe(2);\n    expect(c2()).toBe(51);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-is-object-empty",
    "title": "Check if an Object or Array is Empty",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "objects",
      "arrays",
      "basics",
      "validation"
    ],
    "description": {
      "summary": "Implement `isEmpty(obj)` that returns `true` only if the input is an object or array with no own keys/elements, and `false` otherwise. For non-object/array inputs (like numbers or strings), the function should throw a `TypeError`. Concepts: objects, arrays, validation.",
      "arguments": [
        {
          "name": "obj",
          "type": "Object | Array",
          "desc": "An object or array parsed from JSON."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "Returns `true` if the object/array is empty; otherwise `false`."
      },
      "examples": [
        "// Example 1\nisEmpty({ x: 5, y: 42 }); // => false",
        "// Example 2\nisEmpty({}); // => true",
        "// Example 3\nisEmpty([null, false, 0]); // => false",
        "// Example 4\nisEmpty([]); // => true"
      ]
    },
    "starterCode": "export default function isEmpty(obj) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function isEmpty(obj: Record<string, any> | any[]): boolean {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: implement `isEmpty(obj)` so that it returns `true` only when the input is an array with length 0 or an object whose own enumerable keys list is empty, and throws a `TypeError` for non-object/array inputs. Key concepts: objects, arrays, validation.",
      "approaches": [
        {
          "title": "Approach: Handle arrays and objects separately",
          "prose": "1. **Array check:** If `Array.isArray(obj)` is true, simply return whether `obj.length === 0`.\n2. **Object check:** If `obj` is non-null and `typeof obj === 'object'`, get its own enumerable keys with `Object.keys(obj)` and check if that list is empty.\n3. **Invalid input:** For any other type (number, string, boolean, etc.), throw a `TypeError` to signal misuse.\n4. **Return result:** Return a boolean indicating emptiness for arrays/objects.",
          "codeJs": "export default function isEmpty(obj) {\n  if (Array.isArray(obj)) return obj.length === 0;\n  if (obj && typeof obj === 'object') return Object.keys(obj).length === 0;\n  throw new TypeError('Expected object or array');\n}\n",
          "codeTs": "export default function isEmpty(obj: Record<string, any> | any[]): boolean {\n  if (Array.isArray(obj)) return obj.length === 0;\n  if (obj && typeof obj === 'object') return Object.keys(obj).length === 0;\n  throw new TypeError('Expected object or array');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Checking `Object.keys()` on `null` or `undefined` will throw — always guard with `obj && typeof obj === 'object'`.",
          "Strings also have `.length`, but should not be considered valid inputs here (this implementation throws `TypeError` for them).",
          "Prototype-inherited properties are ignored by `Object.keys()`, which is correct for this task."
        ],
        "edgeCases": [
          "`[]` → true (no elements).",
          "`{}` → true (no keys).",
          "`[null, false, 0]` → false (contains items even if falsy).",
          "`Object.create(null)` → true (no enumerable keys).",
          "Non-object/array inputs like `42` or `'hi'` → `TypeError`."
        ],
        "techniques": [
          "Use `Array.isArray()` for accurate array detection.",
          "Prefer `Object.keys()` over `for...in` to ignore prototype properties."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN – Object.keys()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"
        },
        {
          "title": "MDN – Array.isArray()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
        }
      ]
    },
    "tests": "import isEmpty from './file';\n\ndescribe('isEmpty', () => {\n  test('returns false for non-empty object', () => {\n    expect(isEmpty({ x: 5, y: 42 })).toBe(false);\n  });\n\n  test('returns true for empty object', () => {\n    expect(isEmpty({})).toBe(true);\n  });\n\n  test('returns false for non-empty array', () => {\n    expect(isEmpty([null, false, 0])).toBe(false);\n  });\n\n  test('returns true for empty array', () => {\n    expect(isEmpty([])).toBe(true);\n  });\n\n  test('throws TypeError for non-object/array inputs', () => {\n    expect(() => isEmpty(42)).toThrow(TypeError);\n    expect(() => isEmpty('foo')).toThrow(TypeError);\n  });\n});\n",
    "testsTs": "import isEmpty from './file';\n\ndescribe('isEmpty (TypeScript)', () => {\n  it('returns false for non-empty object', () => {\n    expect(isEmpty({ x: 5, y: 42 })).toBe(false);\n  });\n\n  it('returns true for empty object', () => {\n    expect(isEmpty({})).toBe(true);\n  });\n\n  it('returns false for non-empty array', () => {\n    expect(isEmpty([1, 2, 3])).toBe(false);\n  });\n\n  it('returns true for empty array', () => {\n    expect(isEmpty([])).toBe(true);\n  });\n\n  it('throws TypeError for non-object/array inputs', () => {\n    expect(() => isEmpty(42 as any)).toThrow(TypeError);\n    expect(() => isEmpty('foo' as any)).toThrow(TypeError);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-add-two-promises",
    "title": "Add Two Promises",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "promise",
      "async",
      "functions",
      "basics",
      "async-await"
    ],
    "description": {
      "summary": "This is a small async composition task and should return a Promise that resolves to the numeric sum once both inputs settle successfully.",
      "arguments": [
        {
          "name": "promise1",
          "type": "Promise<number>",
          "desc": "A promise that resolves with a number."
        },
        {
          "name": "promise2",
          "type": "Promise<number>",
          "desc": "Another promise that resolves with a number."
        }
      ],
      "returns": {
        "type": "Promise<number>",
        "desc": "A promise resolving with the sum of the two resolved values."
      },
      "examples": [
        "// Example 1\nconst p1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\nconst p2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\nawait addTwoPromises(p1, p2); // => 7",
        "// Example 2\nconst p1 = new Promise(resolve => setTimeout(() => resolve(10), 50));\nconst p2 = new Promise(resolve => setTimeout(() => resolve(-12), 30));\nawait addTwoPromises(p1, p2); // => -2"
      ]
    },
    "starterCode": "export default async function addTwoPromises(promise1, promise2) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Promise.all keeps both requests in flight and avoids unnecessary latency compared to awaiting sequentially.",
      "approaches": [
        {
          "title": "Approach: Resolve both concurrently using Promise.all",
          "prose": "If you prefer, you can show an alternate sequential version to explain the trade-off, but keep the final implementation parallel. Make sure to return the Promise so callers can await it in async functions or chain .then.",
          "codeJs": "export default async function addTwoPromises(promise1, promise2) {\n  const [a, b] = await Promise.all([promise1, promise2]);\n  return a + b;\n}\n",
          "codeTs": "export default async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\n  const [a, b] = await Promise.all([promise1, promise2]);\n  return a + b;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid chaining with nested `.then()` — it's harder to read and may resolve sequentially.",
          "If either promise rejects, `Promise.all` rejects immediately (propagating the error).",
          "Always `await` or return the result — otherwise it won’t resolve properly."
        ],
        "edgeCases": [
          "Both promises resolve instantly → works fine (microtask scheduling).",
          "One promise resolves slower → result waits for the slower one.",
          "If any promise rejects → the function rejects too (like native Promise.all)."
        ],
        "techniques": [
          "`Promise.all()` for concurrent resolution.",
          "`async/await` for clean and readable syntax.",
          "Destructuring arrays to extract resolved results."
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "MDN – Promise.all()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
        },
        {
          "title": "JavaScript.info – Promises, async/await",
          "url": "https://javascript.info/async-await"
        }
      ]
    },
    "tests": "import addTwoPromises from './file';\n\ndescribe('addTwoPromises', () => {\n  test('resolves with sum of positive numbers', async () => {\n    const p1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\n    const p2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(7);\n  });\n\n  test('handles negative and positive mix', async () => {\n    const p1 = new Promise(resolve => setTimeout(() => resolve(10), 50));\n    const p2 = new Promise(resolve => setTimeout(() => resolve(-12), 30));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(-2);\n  });\n\n  test('works with zero values (edge)', async () => {\n    const result = await addTwoPromises(Promise.resolve(0), Promise.resolve(0));\n    expect(result).toBe(0);\n  });\n});\n",
    "testsTs": "import addTwoPromises from './file';\n\ndescribe('addTwoPromises (TypeScript)', () => {\n  test('resolves with sum of positive numbers', async () => {\n    const p1 = new Promise<number>(resolve => setTimeout(() => resolve(2), 20));\n    const p2 = new Promise<number>(resolve => setTimeout(() => resolve(5), 60));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(7);\n  });\n\n  test('handles mix of negative and positive', async () => {\n    const p1 = new Promise<number>(resolve => setTimeout(() => resolve(10), 50));\n    const p2 = new Promise<number>(resolve => setTimeout(() => resolve(-12), 30));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(-2);\n  });\n\n  test('works with immediately resolved promises (edge)', async () => {\n    const result = await addTwoPromises(Promise.resolve(3), Promise.resolve(4));\n    expect(result).toBe(7);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-promise-all",
    "title": "Implement Promise.all",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "intermediate",
    "tags": [
      "promise",
      "async",
      "concurrency"
    ],
    "description": {
      "summary": "Implement a function `promiseAll(promises)` that behaves like `Promise.all`. It should take an array of values or promises and return a single promise that resolves to an array of results, preserving order, or rejects as soon as one promise rejects.",
      "arguments": [
        {
          "name": "promises",
          "type": "Array<any | Promise<any>>",
          "desc": "An array of values and/or promises to be resolved."
        }
      ],
      "returns": {
        "type": "Promise<any[]>",
        "desc": "A promise that resolves to an array of resolved values in the same order as the input, or rejects with the first rejection reason."
      },
      "examples": [
        "// All fulfilled\npromiseAll([Promise.resolve(1), Promise.resolve(2), 3])\n  .then(result => {\n    // result => [1, 2, 3]\n  });",
        "// One rejects\npromiseAll([\n  Promise.resolve('ok'),\n  Promise.reject(new Error('fail'))\n])\n  .then(() => {\n    // not called\n  })\n  .catch(err => {\n    // err.message === 'fail'\n  });",
        "// Empty array resolves immediately\npromiseAll([])\n  .then(result => {\n    // result => []\n  });"
      ]
    },
    "starterCode": "export default function promiseAll(promises) {\n  // TODO: Return a Promise that resolves when all inputs resolve, or rejects on the first error\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function promiseAll<T>(promises: Array<T | Promise<T>>): Promise<T[]> {\n  // TODO: Return a Promise that resolves when all inputs resolve, or rejects on the first error\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: reimplement the core behavior of `Promise.all`.\n\n- Accept an array of values/promises.\n- Resolve with an array of results in the **same order**.\n- Reject **immediately** when any input rejects (fail-fast).\n- If the array is empty, resolve to `[]` right away.\n\nThis tests understanding of promises, async coordination, and ordering.",
      "approaches": [
        {
          "title": "Approach 1: Manual aggregation with counter (parallel, spec-like)",
          "prose": "Idea: create a wrapper promise that subscribes to all input values (wrapped via `Promise.resolve`). Track how many results are still pending, and resolve when all have completed.\n\nHow it works\n1. Validate the argument is an array; if not, reject with `TypeError`.\n2. If input length is 0, resolve `[]` immediately.\n3. Initialize `results = new Array(len)` and `remaining = len`.\n4. For each element `p` at index `i`:\n   - Wrap with `Promise.resolve(p)` so non-promises work.\n   - On `then(value)`, store `results[i] = value`, decrement `remaining`.\n   - When `remaining` hits `0`, resolve with `results`.\n   - On `catch(error)`, reject the outer promise once (fail-fast).\n\nWhy use it: matches how `Promise.all` behaves (parallel waiting, order preserved, fail-fast) and is a very common interview solution.",
          "codeJs": "export default function promiseAll(promises) {\n  return new Promise((resolve, reject) => {\n    if (!Array.isArray(promises)) {\n      return reject(new TypeError('Argument must be an array'));\n    }\n\n    const length = promises.length;\n    const results = new Array(length);\n    let remaining = length;\n\n    if (length === 0) {\n      resolve([]);\n      return;\n    }\n\n    promises.forEach((p, index) => {\n      Promise.resolve(p)\n        .then(value => {\n          results[index] = value;\n          remaining -= 1;\n          if (remaining === 0) {\n            resolve(results);\n          }\n        })\n        .catch(reject);\n    });\n  });\n}\n",
          "codeTs": "export default function promiseAll<T>(promises: Array<T | Promise<T>>): Promise<T[]> {\n  return new Promise<T[]>((resolve, reject) => {\n    if (!Array.isArray(promises)) {\n      return reject(new TypeError('Argument must be an array'));\n    }\n\n    const length = promises.length;\n    const results: T[] = new Array(length);\n    let remaining = length;\n\n    if (length === 0) {\n      resolve([]);\n      return;\n    }\n\n    promises.forEach((p, index) => {\n      Promise.resolve(p)\n        .then(value => {\n          results[index] = value as T;\n          remaining -= 1;\n          if (remaining === 0) {\n            resolve(results);\n          }\n        })\n        .catch(reject);\n    });\n  });\n}\n"
        },
        {
          "title": "Approach 2: Sequential `async/await` (simpler but not parallel)",
          "prose": "Idea: as a teaching alternative, resolve each item **one by one** in an `async` function using `await`. This is easier to read but does **not** preserve the parallel behavior of `Promise.all`.\n\nHow it works\n1. Loop over indices `i` from 0 to `promises.length - 1`.\n2. For each element `p`, do `results[i] = await Promise.resolve(p)`.\n3. If any await throws, the whole `promiseAll` rejects (like built-in).\n\nWhy use it: good to reason about success/failure flow with `try/catch`, but real `Promise.all` runs all promises in parallel, while this one runs them serially.",
          "codeJs": "export default async function promiseAllSequential(promises) {\n  if (!Array.isArray(promises)) {\n    throw new TypeError('Argument must be an array');\n  }\n  const results = [];\n  for (let i = 0; i < promises.length; i++) {\n    results[i] = await Promise.resolve(promises[i]);\n  }\n  return results;\n}\n",
          "codeTs": "export default async function promiseAllSequential<T>(promises: Array<T | Promise<T>>): Promise<T[]> {\n  if (!Array.isArray(promises)) {\n    throw new TypeError('Argument must be an array');\n  }\n  const results: T[] = [];\n  for (let i = 0; i < promises.length; i++) {\n    results[i] = await Promise.resolve(promises[i]);\n  }\n  return results;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to handle the **empty array** case (the returned promise should resolve immediately with `[]`).",
          "Not preserving **input order** in the results; you must write into `results[index]`, not just `results.push`.",
          "Calling `resolve` or `reject` multiple times — only the first call has effect, but your logic should naturally avoid extra calls.",
          "Not wrapping values with `Promise.resolve`, which breaks support for non-promise values."
        ],
        "edgeCases": [
          "Empty array → resolves immediately with `[]`.",
          "Array with only non-promise values → resolves immediately with those values.",
          "First element rejects after some others resolve → final result must still be a rejection.",
          "Non-array input → typically throws or rejects with `TypeError` (this implementation rejects)."
        ],
        "techniques": [
          "Using a **wrapper promise** to aggregate multiple async operations.",
          "Using a **counter** (`remaining`) to know when all async tasks have finished.",
          "Using `Promise.resolve` to normalize values and promises.",
          "Fail-fast error propagation via `catch(reject)`."
        ]
      },
      "followUpQuestions": [
        "js-compact",
        "js-unique-array"
      ],
      "resources": [
        {
          "title": "MDN – Promise.all()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
        },
        {
          "title": "MDN – Using Promises",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises"
        }
      ]
    },
    "tests": "import promiseAll from './promiseAll';\n\ndescribe('promiseAll', () => {\n  test('resolves array of values in order when all succeed', async () => {\n    const p1 = Promise.resolve(1);\n    const p2 = new Promise(resolve => setTimeout(() => resolve(2), 5));\n    const p3 = 3; // non-promise value\n\n    await expect(promiseAll([p1, p2, p3])).resolves.toEqual([1, 2, 3]);\n  });\n\n  test('resolves immediately for empty array', async () => {\n    await expect(promiseAll([])).resolves.toEqual([]);\n  });\n\n  test('rejects when any promise rejects', async () => {\n    const error = new Error('fail');\n    const p1 = Promise.resolve('ok');\n    const p2 = Promise.reject(error);\n\n    await expect(promiseAll([p1, p2])).rejects.toThrow('fail');\n  });\n\n  test('rejects with TypeError when input is not an array', async () => {\n    // @ts-expect-error runtime guard only\n    await expect(promiseAll(null)).rejects.toThrow(TypeError);\n  });\n});\n",
    "testsTs": "import promiseAll from './promiseAll';\n\ndescribe('promiseAll (TypeScript)', () => {\n  it('resolves array of values in order when all succeed', async () => {\n    const p1 = Promise.resolve(1);\n    const p2 = new Promise<number>(resolve => setTimeout(() => resolve(2), 5));\n    const p3 = 3;\n\n    await expect(promiseAll([p1, p2, p3])).resolves.toEqual([1, 2, 3]);\n  });\n\n  it('resolves immediately for empty array', async () => {\n    await expect(promiseAll<number>([])).resolves.toEqual([]);\n  });\n\n  it('rejects when any promise rejects', async () => {\n    const error = new Error('fail');\n    const p1 = Promise.resolve('ok');\n    const p2 = Promise.reject(error);\n\n    await expect(promiseAll([p1, p2])).rejects.toThrow('fail');\n  });\n\n  it('rejects with TypeError when input is not an array', async () => {\n    // @ts-expect-error runtime guard only\n    await expect(promiseAll(null as any)).rejects.toThrow(TypeError);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-implement-bind",
    "title": "Implement Function.prototype.bind",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "hard",
    "tags": [
      "this",
      "prototypes",
      "call-apply-bind",
      "polyfills",
      "functions",
      "object-creation"
    ],
    "description": {
      "summary": "Implement `myBind(fn, thisArg, ...boundArgs)` that behaves like `Function.prototype.bind`. It must:\n1) Bind `this` to `thisArg` for normal calls.\n2) Support partial application (pre-filling arguments).\n3) Work with `new`: when the bound function is used as a constructor, it must ignore `thisArg` and use the newly created instance as `this`.\n4) Preserve prototype behavior so instances created via `new boundFn()` are instances of the original function.\n\nThis tests `this` binding rules, function objects, prototype chains, and constructor behavior.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The target function to bind."
        },
        {
          "name": "thisArg",
          "type": "any",
          "desc": "The `this` value to bind for normal calls (ignored when called with `new`)."
        },
        {
          "name": "boundArgs",
          "type": "any[]",
          "desc": "Arguments to pre-apply to the function (partial application)."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A new bound function that applies `fn` with bound `this` and pre-filled args, and supports constructor usage."
      },
      "examples": [
        "// Example 1: bind `this`\nfunction getX() { return this.x; }\nconst obj = { x: 42 };\nconst bound = myBind(getX, obj);\nbound(); // => 42",
        "// Example 2: partial application\nfunction add(a, b, c) { return a + b + c; }\nconst add5 = myBind(add, null, 2, 3);\nadd5(10); // => 15",
        "// Example 3: `new` must ignore thisArg\nfunction Person(name) { this.name = name; }\nPerson.prototype.say = function() { return this.name; };\nconst BoundPerson = myBind(Person, { name: 'SHOULD_NOT_USE' });\nconst p = new BoundPerson('Ada');\np.name; // => 'Ada'\np.say(); // => 'Ada'\np instanceof Person; // => true\np instanceof BoundPerson; // => true"
      ]
    },
    "starterCode": "export default function myBind(fn, thisArg, ...boundArgs) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function myBind<T extends (...args: any[]) => any>(\n  fn: T,\n  thisArg: any,\n  ...boundArgs: any[]\n): (...callArgs: any[]) => ReturnType<T> {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: create a bind polyfill that handles normal calls, partial args, and constructor calls.\n\nKey rule: if the bound function is called with `new`, the bound `thisArg` must be ignored and `this` must be the newly created instance.\n\nPrototype rule: instances created by `new boundFn()` should be instances of the original `fn` (and of `boundFn`).",
      "approaches": [
        {
          "title": "Approach: Bound wrapper with constructor detection (recommended)",
          "prose": "Idea\nReturn a wrapper function `boundFn` that:\n- Merges `boundArgs` with `callArgs`.\n- Detects constructor calls via `this instanceof boundFn`.\n- Uses `fn.apply(thisToUse, allArgs)`.\n\nHandling `new`\nWhen called with `new`, JavaScript creates `this` as a fresh object whose prototype is `boundFn.prototype`. For correct behavior, we should forward that `this` into `fn` instead of using `thisArg`.\n\nPrototype preservation\nTo keep `instanceof fn` working, set `boundFn.prototype` to an object that delegates to `fn.prototype`.\n\nComplexity\n- Time: O(k) where k is total args merged.\n- Space: O(1) besides stored args.",
          "codeJs": "export default function myBind(fn, thisArg, ...boundArgs) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('myBind: fn must be a function');\n  }\n\n  function boundFn(...callArgs) {\n    const isConstructorCall = this instanceof boundFn;\n    const thisToUse = isConstructorCall ? this : thisArg;\n    return fn.apply(thisToUse, [...boundArgs, ...callArgs]);\n  }\n\n  // Preserve prototype chain so `new boundFn()` instances are also `instanceof fn`.\n  if (fn.prototype) {\n    boundFn.prototype = Object.create(fn.prototype);\n    // (Optional) keep constructor reference tidy\n    Object.defineProperty(boundFn.prototype, 'constructor', {\n      value: boundFn,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  return boundFn;\n}\n",
          "codeTs": "export default function myBind<T extends (...args: any[]) => any>(\n  fn: T,\n  thisArg: any,\n  ...boundArgs: any[]\n): (...callArgs: any[]) => ReturnType<T> {\n  if (typeof fn !== 'function') {\n    throw new TypeError('myBind: fn must be a function');\n  }\n\n  function boundFn(this: any, ...callArgs: any[]): ReturnType<T> {\n    const isConstructorCall = this instanceof (boundFn as any);\n    const thisToUse = isConstructorCall ? this : thisArg;\n    return fn.apply(thisToUse, [...boundArgs, ...callArgs]) as ReturnType<T>;\n  }\n\n  // Preserve prototype chain\n  if ((fn as any).prototype) {\n    (boundFn as any).prototype = Object.create((fn as any).prototype);\n    Object.defineProperty((boundFn as any).prototype, 'constructor', {\n      value: boundFn,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  return boundFn as any;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "`thisArg` must be ignored when the bound function is used with `new`.",
          "If you set `boundFn.prototype = fn.prototype`, you will mutate/alias the original prototype; use `Object.create(fn.prototype)` instead.",
          "`instanceof` behavior depends on the prototype chain; missing prototype wiring makes `p instanceof Person` fail.",
          "Real native `bind` has edge cases around `length`/`name` and return values from constructors; not required here unless explicitly tested."
        ],
        "edgeCases": [
          "`thisArg` can be `null`/`undefined` (non-strict functions will default `this` to global; strict keeps it as provided).",
          "Binding a function that has no prototype (e.g., arrow functions) — constructor behavior won't apply; still bind for normal calls.",
          "Constructor functions that explicitly return an object: `new` should return that object (native JS behavior)."
        ],
        "techniques": [
          "Detect constructor calls via `this instanceof boundFn`.",
          "Preserve prototype chain via `Object.create(fn.prototype)`.",
          "Apply partial args by concatenating `[...boundArgs, ...callArgs]`."
        ]
      },
      "followUpQuestions": [
        "js-implement-call",
        "js-implement-apply",
        "js-implement-new",
        "js-implement-instanceof"
      ],
      "resources": [
        {
          "title": "MDN – Function.prototype.bind",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"
        },
        {
          "title": "MDN – Object.create",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
        }
      ]
    },
    "tests": "import myBind from './file';\n\ndescribe('myBind', () => {\n  test('binds this for normal calls', () => {\n    function getX() { return this.x; }\n    const obj = { x: 42 };\n    const bound = myBind(getX, obj);\n    expect(bound()).toBe(42);\n  });\n\n  test('supports partial application', () => {\n    function add(a, b, c) { return a + b + c; }\n    const add5 = myBind(add, null, 2, 3);\n    expect(add5(10)).toBe(15);\n  });\n\n  test('when called with new, ignores thisArg and uses the new instance', () => {\n    function Person(name) { this.name = name; }\n    Person.prototype.say = function() { return this.name; };\n\n    const BoundPerson = myBind(Person, { name: 'SHOULD_NOT_USE' });\n    const p = new BoundPerson('Ada');\n\n    expect(p.name).toBe('Ada');\n    expect(p.say()).toBe('Ada');\n  });\n\n  test('instances created via new boundFn() are instanceof original fn', () => {\n    function Person(name) { this.name = name; }\n    const BoundPerson = myBind(Person, { name: 'X' });\n    const p = new BoundPerson('Ada');\n\n    expect(p instanceof Person).toBe(true);\n    expect(p instanceof BoundPerson).toBe(true);\n  });\n\n  test('constructor return object behavior is preserved', () => {\n    function Factory(name) { this.name = name; return { ok: true, name }; }\n    const BoundFactory = myBind(Factory, { name: 'X' });\n    const res = new BoundFactory('Ada');\n\n    expect(res).toEqual({ ok: true, name: 'Ada' });\n  });\n});\n",
    "testsTs": "import myBind from './file';\n\ndescribe('myBind (TypeScript)', () => {\n  it('binds this for normal calls', () => {\n    function getX(this: any) { return this.x; }\n    const obj = { x: 42 };\n    const bound = myBind(getX as any, obj);\n    expect(bound()).toBe(42);\n  });\n\n  it('supports partial application', () => {\n    function add(a: number, b: number, c: number) { return a + b + c; }\n    const add5 = myBind(add, null, 2, 3);\n    expect(add5(10)).toBe(15);\n  });\n\n  it('supports new and preserves prototype chain', () => {\n    function Person(this: any, name: string) { this.name = name; }\n    (Person as any).prototype.say = function() { return this.name; };\n\n    const BoundPerson: any = myBind(Person as any, { name: 'NOPE' });\n    const p = new BoundPerson('Ada');\n\n    expect(p.name).toBe('Ada');\n    expect(p.say()).toBe('Ada');\n    expect(p instanceof (Person as any)).toBe(true);\n    expect(p instanceof BoundPerson).toBe(true);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-implement-new",
    "title": "Implement the `new` Operator",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "hard",
    "tags": [
      "prototypes",
      "object-creation",
      "functions",
      "objects"
    ],
    "description": {
      "summary": "Implement a myNew helper that mimics the new operator. Create an object linked to the constructor prototype, call the constructor with this, and return the constructor’s object result if provided. This tests prototype linkage and constructor behavior. Concepts: prototypes, object-creation, functions.",
      "arguments": [
        {
          "name": "Constructor",
          "type": "Function",
          "desc": "A constructor function to be invoked with `new` semantics."
        },
        {
          "name": "args",
          "type": "any[]",
          "desc": "Arguments to pass to the constructor."
        }
      ],
      "returns": {
        "type": "object",
        "desc": "An instance created with `new`-like semantics, respecting constructor return rules."
      },
      "examples": [
        "// Example 1: normal constructor\nfunction Person(name) { this.name = name; }\nPerson.prototype.say = function() { return `hi ${this.name}`; };\n\nconst p = myNew(Person, 'Ada');\np.name; // => 'Ada'\np.say(); // => 'hi Ada'\n(p instanceof Person); // => true",
        "// Example 2: constructor returns an object (must return that)\nfunction Factory(name) {\n  this.name = name;\n  return { ok: true, name };\n}\n\nconst f = myNew(Factory, 'Ada');\nf; // => { ok: true, name: 'Ada' }",
        "// Example 3: constructor returns primitive (ignore it)\nfunction Weird(name) {\n  this.name = name;\n  return 123;\n}\n\nconst w = myNew(Weird, 'Ada');\nw.name; // => 'Ada'\n(w instanceof Weird); // => true"
      ]
    },
    "starterCode": "export default function myNew(Constructor, ...args) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function myNew<T extends new (...args: any[]) => any>(\n  Constructor: T,\n  ...args: ConstructorParameters<T>\n): InstanceType<T> {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Recreating new clarifies how constructor functions work: an object is created, its prototype is set to Constructor.prototype, the constructor is called with that object as this, and an explicit object return overrides the created object. This mirrors the built-in operator’s contract exactly. Key concepts: prototypes, object-creation, functions.",
      "approaches": [
        {
          "title": "Approach: Object.create + apply (recommended)",
          "prose": "Create obj with Object.create(Constructor.prototype). Call Constructor.apply(obj, args). If the return value is an object or function, return it; otherwise return obj. This handles both typical constructors and ones that return their own object, matching native behavior in all cases.",
          "codeJs": "export default function myNew(Constructor, ...args) {\n  if (typeof Constructor !== 'function') {\n    throw new TypeError('myNew: Constructor must be a function');\n  }\n\n  const instance = Object.create(Constructor.prototype);\n  const result = Constructor.apply(instance, args);\n\n  const isObject = result !== null && (typeof result === 'object' || typeof result === 'function');\n  return isObject ? result : instance;\n}\n",
          "codeTs": "export default function myNew<T extends new (...args: any[]) => any>(\n  Constructor: T,\n  ...args: ConstructorParameters<T>\n): InstanceType<T> {\n  const instance = Object.create((Constructor as any).prototype);\n  const result = (Constructor as any).apply(instance, args);\n\n  const isObject = result !== null && (typeof result === 'object' || typeof result === 'function');\n  return (isObject ? result : instance) as InstanceType<T>;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to link the prototype will make `instanceof Constructor` fail.",
          "Using `{}` instead of `Object.create(Constructor.prototype)` breaks prototype inheritance.",
          "Constructor return rule: only objects/functions override the created instance; primitives are ignored.",
          "Arrow functions cannot be used as constructors with native `new` (they have no `prototype`); you may ignore this nuance unless you choose to validate it."
        ],
        "edgeCases": [
          "Constructor returns `null` (treat as not an object; return the created instance).",
          "Constructor has `prototype = null` (rare): `Object.create(null)` is valid but yields an object without Object.prototype.",
          "Constructor returns a function (should return that function)."
        ],
        "techniques": [
          "Use `Object.create` to set [[Prototype]] correctly.",
          "Use `apply` to invoke constructor with dynamic args.",
          "Use a strict object/function check for the return override."
        ]
      },
      "followUpQuestions": [
        "js-implement-instanceof",
        "js-object-create-polyfill"
      ],
      "resources": [
        {
          "title": "MDN – new operator",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new"
        },
        {
          "title": "MDN – Object.create",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
        }
      ]
    },
    "tests": "import myNew from './file';\n\ndescribe('myNew', () => {\n  test('creates an instance with correct prototype and runs constructor', () => {\n    function Person(name) { this.name = name; }\n    Person.prototype.say = function() { return `hi ${this.name}`; };\n\n    const p = myNew(Person, 'Ada');\n    expect(p.name).toBe('Ada');\n    expect(p.say()).toBe('hi Ada');\n    expect(p instanceof Person).toBe(true);\n  });\n\n  test('returns object returned by constructor (override rule)', () => {\n    function Factory(name) {\n      this.name = name;\n      return { ok: true, name };\n    }\n\n    const f = myNew(Factory, 'Ada');\n    expect(f).toEqual({ ok: true, name: 'Ada' });\n  });\n\n  test('ignores primitive returned by constructor', () => {\n    function Weird(name) {\n      this.name = name;\n      return 123;\n    }\n\n    const w = myNew(Weird, 'Ada');\n    expect(w.name).toBe('Ada');\n    expect(w instanceof Weird).toBe(true);\n  });\n\n  test('treats null return as no override', () => {\n    function NullReturn(name) {\n      this.name = name;\n      return null;\n    }\n\n    const n = myNew(NullReturn, 'Ada');\n    expect(n.name).toBe('Ada');\n    expect(n instanceof NullReturn).toBe(true);\n  });\n});\n",
    "testsTs": "import myNew from './file';\n\ndescribe('myNew (TypeScript)', () => {\n  it('creates an instance with correct prototype and runs constructor', () => {\n    function Person(this: any, name: string) { this.name = name; }\n    (Person as any).prototype.say = function() { return `hi ${this.name}`; };\n\n    const p: any = myNew(Person as any, 'Ada');\n    expect(p.name).toBe('Ada');\n    expect(p.say()).toBe('hi Ada');\n    expect(p instanceof (Person as any)).toBe(true);\n  });\n\n  it('returns object returned by constructor', () => {\n    function Factory(this: any, name: string) {\n      this.name = name;\n      return { ok: true, name } as any;\n    }\n\n    const f: any = myNew(Factory as any, 'Ada');\n    expect(f).toEqual({ ok: true, name: 'Ada' });\n  });\n\n  it('ignores primitive returned by constructor', () => {\n    function Weird(this: any, name: string) {\n      this.name = name;\n      return 123 as any;\n    }\n\n    const w: any = myNew(Weird as any, 'Ada');\n    expect(w.name).toBe('Ada');\n    expect(w instanceof (Weird as any)).toBe(true);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-implement-instanceof",
    "title": "Implement `instanceof`",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "intermediate",
    "tags": [
      "prototypes",
      "objects",
      "inheritance",
      "basics",
      "runtime"
    ],
    "description": {
      "summary": "Recreate `instanceof` by walking the prototype chain and checking if it reaches `Constructor.prototype`. Handle null/primitive inputs safely and stop when the chain ends. This tests knowledge of prototypes and runtime inheritance.",
      "arguments": [
        {
          "name": "obj",
          "type": "any",
          "desc": "The value to check (may be an object or a primitive)."
        },
        {
          "name": "Constructor",
          "type": "Function",
          "desc": "The constructor function whose `.prototype` should be searched in the prototype chain."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if `Constructor.prototype` is in `obj`'s prototype chain; otherwise `false`."
      },
      "examples": [
        "// Example 1\nfunction Person() {}\nconst p = new Person();\nmyInstanceOf(p, Person); // => true",
        "// Example 2\nmyInstanceOf({}, Array); // => false\nmyInstanceOf([], Array); // => true",
        "// Example 3: primitives\nmyInstanceOf(1, Number); // => false\nmyInstanceOf('a', String); // => false\nmyInstanceOf(null, Object); // => false"
      ]
    },
    "starterCode": "export default function myInstanceOf(obj, Constructor) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function myInstanceOf(\n  obj: any,\n  Constructor: Function\n): boolean {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "`instanceof` works by checking whether the constructor’s prototype appears in the object’s prototype chain. Implement this by repeatedly calling `Object.getPrototypeOf` until you either hit the target prototype or reach `null`. This keeps the logic explicit, avoids mutation, and mirrors the engine’s behavior.",
      "approaches": [
        {
          "title": "Approach: Prototype chain traversal (recommended)",
          "prose": "Validate that the left value is an object/function and that `Constructor.prototype` is truthy. Set `target = Constructor.prototype`. Loop upward with `cur = Object.getPrototypeOf(obj)`; if `cur === target` return true; if `cur` becomes null return false. This runs in O(depth) time and O(1) space, with predictable behavior for edge cases.",
          "codeJs": "export default function myInstanceOf(obj, Constructor) {\n  if (obj === null || obj === undefined) return false;\n\n  const t = typeof obj;\n  if (t !== 'object' && t !== 'function') return false;\n\n  if (typeof Constructor !== 'function') {\n    throw new TypeError('myInstanceOf: Constructor must be a function');\n  }\n\n  const targetProto = Constructor.prototype;\n  if (targetProto === null || (typeof targetProto !== 'object' && typeof targetProto !== 'function')) {\n    // Very rare, but keep behavior predictable.\n    return false;\n  }\n\n  let current = Object.getPrototypeOf(obj);\n  while (current !== null) {\n    if (current === targetProto) return true;\n    current = Object.getPrototypeOf(current);\n  }\n\n  return false;\n}\n",
          "codeTs": "export default function myInstanceOf(obj: any, Constructor: Function): boolean {\n  if (obj === null || obj === undefined) return false;\n\n  const t = typeof obj;\n  if (t !== 'object' && t !== 'function') return false;\n\n  if (typeof Constructor !== 'function') {\n    throw new TypeError('myInstanceOf: Constructor must be a function');\n  }\n\n  const targetProto: any = (Constructor as any).prototype;\n  if (targetProto === null || (typeof targetProto !== 'object' && typeof targetProto !== 'function')) {\n    return false;\n  }\n\n  let current: any = Object.getPrototypeOf(obj);\n  while (current !== null) {\n    if (current === targetProto) return true;\n    current = Object.getPrototypeOf(current);\n  }\n\n  return false;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Checking `obj.__proto__` directly is non-standard and can be missing; use `Object.getPrototypeOf`.",
          "Primitives must return `false` (even though `1 instanceof Number` is `false` in JS).",
          "If `Constructor` is not a function, native `instanceof` throws; we do the same for clarity.",
          "This does not implement custom `Symbol.hasInstance` behavior (native `instanceof` can be overridden)."
        ],
        "edgeCases": [
          "Functions are objects too: `myInstanceOf(function(){}, Function)` should be `true`.",
          "Objects created with `Object.create(null)` have a `null` prototype chain; should generally return `false` for most constructors.",
          "`Constructor.prototype` can be replaced after object creation; `instanceof` checks the current prototype reference."
        ],
        "techniques": [
          "Prototype chain traversal with `Object.getPrototypeOf`.",
          "Guard against `null` and primitives early.",
          "Compare by reference equality (`===`) on prototypes."
        ]
      },
      "followUpQuestions": [
        "js-object-create-polyfill"
      ],
      "resources": [
        {
          "title": "MDN – instanceof",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof"
        },
        {
          "title": "MDN – Object.getPrototypeOf",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"
        }
      ]
    },
    "tests": "import myInstanceOf from './file';\n\ndescribe('myInstanceOf', () => {\n  test('returns true when Constructor.prototype is in the prototype chain', () => {\n    function Person() {}\n    const p = new Person();\n    expect(myInstanceOf(p, Person)).toBe(true);\n  });\n\n  test('works for arrays', () => {\n    expect(myInstanceOf([], Array)).toBe(true);\n    expect(myInstanceOf({}, Array)).toBe(false);\n  });\n\n  test('works for functions', () => {\n    function f() {}\n    expect(myInstanceOf(f, Function)).toBe(true);\n  });\n\n  test('returns false for primitives and null/undefined', () => {\n    expect(myInstanceOf(1, Number)).toBe(false);\n    expect(myInstanceOf('a', String)).toBe(false);\n    expect(myInstanceOf(true, Boolean)).toBe(false);\n    expect(myInstanceOf(null, Object)).toBe(false);\n    expect(myInstanceOf(undefined, Object)).toBe(false);\n  });\n\n  test('handles Object.create(null) correctly (null prototype chain)', () => {\n    const o = Object.create(null);\n    expect(myInstanceOf(o, Object)).toBe(false);\n  });\n\n  test('throws if Constructor is not a function', () => {\n    try {\n      myInstanceOf({}, 123);\n      expect(true).toBe(false);\n    } catch (e) {\n      expect(!!e).toBe(true);\n      expect(e.name).toBe('TypeError');\n    }\n  });\n});\n",
    "testsTs": "import myInstanceOf from './file';\n\ndescribe('myInstanceOf (TypeScript)', () => {\n  it('returns true when Constructor.prototype is in the prototype chain', () => {\n    function Person(this: any) {}\n    const p = new (Person as any)();\n    expect(myInstanceOf(p, Person)).toBe(true);\n  });\n\n  it('works for arrays', () => {\n    expect(myInstanceOf([], Array)).toBe(true);\n    expect(myInstanceOf({}, Array)).toBe(false);\n  });\n\n  it('returns false for primitives and null/undefined', () => {\n    expect(myInstanceOf(1, Number)).toBe(false);\n    expect(myInstanceOf('a', String)).toBe(false);\n    expect(myInstanceOf(null, Object)).toBe(false);\n    expect(myInstanceOf(undefined, Object)).toBe(false);\n  });\n\n  it('throws if Constructor is not a function', () => {\n    try {\n      myInstanceOf({}, 123 as any);\n      expect(true).toBe(false);\n    } catch (e: any) {\n      expect(!!e).toBe(true);\n      expect(e.name).toBe('TypeError');\n    }\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-delegated-events-1",
    "title": "Delegated Event Handler (E)",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "dom",
      "events",
      "event-delegation",
      "bubbling",
      "selectors"
    ],
    "description": {
      "summary": "Implement `delegate(root, eventType, selector, handler)` for **event delegation**.\n\nRequirements:\n1) Attach **one** event listener to `root`.\n2) When an event fires, if `event.target` (or one of its ancestors up to `root`) matches `selector`, call `handler(event, matchedElement)`.\n3) Return a **cleanup** function that removes the listener.\n\nNotes:\n- You may use `Element.closest()` and `Element.matches()`.\n- Assume `eventType` is a bubbling event (e.g. `click`, `input`).\n\nThis is one of the most common DOM interview utilities because it tests real-world UI patterns and understanding of event bubbling.",
      "arguments": [
        {
          "name": "root",
          "type": "Element",
          "desc": "Container element where the single delegated listener is attached."
        },
        {
          "name": "eventType",
          "type": "string",
          "desc": "Event type to listen for (e.g. `'click'`)."
        },
        {
          "name": "selector",
          "type": "string",
          "desc": "CSS selector used to find the matching target within `root`."
        },
        {
          "name": "handler",
          "type": "(event: Event, matchedEl: Element) => void",
          "desc": "Callback invoked when a matching element is found for the event."
        }
      ],
      "returns": {
        "type": "() => void",
        "desc": "A function that removes the delegated listener from `root`."
      },
      "examples": [
        "// Example\nconst root = document.querySelector('#list');\nconst cleanup = delegate(root, 'click', 'button.remove', (e, btn) => {\n  const li = btn.closest('li');\n  if (li) li.remove();\n});\n\n// later\ncleanup();"
      ]
    },
    "starterCode": "export default function delegate(root, eventType, selector, handler) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function delegate(\n  root: Element,\n  eventType: string,\n  selector: string,\n  handler: (event: Event, matchedEl: Element) => void\n): () => void {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: attach a single listener to `root`, then on each event, locate the closest ancestor of `event.target` that matches `selector` and is still inside `root`. If found, call `handler` and return a cleanup function to remove the listener.",
      "approaches": [
        {
          "title": "Approach: `closest()` + containment check (recommended)",
          "prose": "Idea\n- On event: convert `event.target` to an `Element`.\n- Find `matched = target.closest(selector)`.\n- Ensure the match is inside `root` (important when `closest` climbs outside the container).\n- Call `handler(event, matched)`.\n- Return cleanup that removes the listener.\n\nComplexity\n- Time: O(h) per event where h is DOM height from target to root.\n- Space: O(1).",
          "codeJs": "export default function delegate(root, eventType, selector, handler) {\n  if (!root || typeof root.addEventListener !== 'function') {\n    throw new TypeError('delegate: root must be an Element');\n  }\n  if (typeof eventType !== 'string') {\n    throw new TypeError('delegate: eventType must be a string');\n  }\n  if (typeof selector !== 'string') {\n    throw new TypeError('delegate: selector must be a string');\n  }\n  if (typeof handler !== 'function') {\n    throw new TypeError('delegate: handler must be a function');\n  }\n\n  const listener = (event) => {\n    const target = event && event.target;\n    if (!target || target.nodeType !== 1) return;\n\n    const el = target;\n    const matched = el.closest(selector);\n    if (!matched) return;\n\n    if (matched === root || root.contains(matched)) {\n      handler(event, matched);\n    }\n  };\n\n  root.addEventListener(eventType, listener);\n\n  return function cleanup() {\n    root.removeEventListener(eventType, listener);\n  };\n}\n",
          "codeTs": "export default function delegate(\n  root: Element,\n  eventType: string,\n  selector: string,\n  handler: (event: Event, matchedEl: Element) => void\n): () => void {\n  const anyRoot: any = root as any;\n  if (!root || typeof anyRoot.addEventListener !== 'function') {\n    throw new TypeError('delegate: root must be an Element');\n  }\n  if (typeof eventType !== 'string') {\n    throw new TypeError('delegate: eventType must be a string');\n  }\n  if (typeof selector !== 'string') {\n    throw new TypeError('delegate: selector must be a string');\n  }\n  if (typeof handler !== 'function') {\n    throw new TypeError('delegate: handler must be a function');\n  }\n\n  const listener = (event: Event) => {\n    const target = (event as any)?.target;\n    if (!target || target.nodeType !== 1) return;\n\n    const el = target as Element;\n    const matched = el.closest(selector);\n    if (!matched) return;\n\n    if (matched === root || root.contains(matched)) {\n      handler(event, matched);\n    }\n  };\n\n  root.addEventListener(eventType, listener as any);\n\n  return function cleanup() {\n    root.removeEventListener(eventType, listener as any);\n  };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Calling `handler` for matches outside `root` (fix: `root.contains(matched)`).",
          "Assuming `event.target` is always an Element (it can be a text node).",
          "For non-bubbling events (e.g. `focus`), delegation won’t work unless you use capture; not required here."
        ],
        "edgeCases": [
          "Clicking a nested element inside the matching element should still match via `closest`.",
          "If `matched` is the root itself, it should be allowed if it matches `selector`.",
          "Cleanup should truly stop future calls."
        ],
        "techniques": [
          "Use `closest()` to climb ancestors efficiently.",
          "Use `contains()` to enforce the delegation boundary.",
          "Return cleanup to avoid leaks."
        ]
      },
      "followUpQuestions": [
        "js-delegated-events-2",
        "js-delegated-events-3"
      ],
      "resources": [
        {
          "title": "MDN – Event bubbling",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling"
        },
        {
          "title": "MDN – Element.closest",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/closest"
        }
      ]
    },
    "tests": "import delegate from './file';\n\nfunction makeNode(tag, className = '') {\n  return {\n    nodeType: 1,\n    tagName: String(tag || '').toUpperCase(),\n    className,\n    parentElement: null,\n    matches(selector) {\n      // minimal matcher for this test suite: 'tag.class'\n      const [selTag, selClass] = selector.split('.');\n      if (selTag && selTag.length > 0) {\n        if (this.tagName !== selTag.toUpperCase()) return false;\n      }\n      if (selClass) {\n        const classes = String(this.className || '').split(/\\s+/).filter(Boolean);\n        return classes.includes(selClass);\n      }\n      return true;\n    },\n    closest(selector) {\n      let cur = this;\n      while (cur) {\n        if (cur.matches && cur.matches(selector)) return cur;\n        cur = cur.parentElement;\n      }\n      return null;\n    }\n  };\n}\n\nfunction makeRoot() {\n  const root = {\n    _listeners: {},\n    addEventListener(type, fn) {\n      this._listeners[type] = fn;\n    },\n    removeEventListener(type, fn) {\n      if (this._listeners[type] === fn) delete this._listeners[type];\n    },\n    contains(node) {\n      let cur = node;\n      while (cur) {\n        if (cur === this) return true;\n        cur = cur.parentElement;\n      }\n      return false;\n    },\n    fire(type, target) {\n      const fn = this._listeners[type];\n      if (fn) fn({ type, target });\n    }\n  };\n  // Make root look like an Element enough for our solution's checks\n  root.nodeType = 1;\n  root.tagName = 'DIV';\n  root.parentElement = null;\n  return root;\n}\n\ndescribe('delegate (DOM-less)', () => {\n  test('calls handler when event target matches selector', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'remove');\n    btn.parentElement = root;\n\n    let calls = 0;\n    let lastMatched = null;\n\n    const cleanup = delegate(root, 'click', 'button.remove', (e, matched) => {\n      calls++;\n      lastMatched = matched;\n    });\n\n    root.fire('click', btn);\n\n    expect(calls).toBe(1);\n    expect(lastMatched).toBe(btn);\n\n    cleanup();\n  });\n\n  test('supports nested targets via closest()', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'remove');\n    const span = makeNode('span');\n    span.parentElement = btn;\n    btn.parentElement = root;\n\n    let matchedEl = null;\n    const cleanup = delegate(root, 'click', 'button.remove', (e, matched) => {\n      matchedEl = matched;\n    });\n\n    root.fire('click', span);\n    expect(matchedEl).toBe(btn);\n\n    cleanup();\n  });\n\n  test('does not call handler when no match', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'keep');\n    btn.parentElement = root;\n\n    let calls = 0;\n    const cleanup = delegate(root, 'click', 'button.remove', () => {\n      calls++;\n    });\n\n    root.fire('click', btn);\n    expect(calls).toBe(0);\n\n    cleanup();\n  });\n\n  test('cleanup removes the listener', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'remove');\n    btn.parentElement = root;\n\n    let calls = 0;\n    const cleanup = delegate(root, 'click', 'button.remove', () => {\n      calls++;\n    });\n\n    root.fire('click', btn);\n    expect(calls).toBe(1);\n\n    cleanup();\n    root.fire('click', btn);\n    expect(calls).toBe(1);\n  });\n\n  test('throws on invalid args (runner-agnostic)', () => {\n    try {\n      delegate(null, 'click', 'button', () => {});\n      expect(true).toBe(false);\n    } catch (e) {\n      expect(!!e).toBe(true);\n      expect(e.name).toBe('TypeError');\n    }\n  });\n});\n",
    "testsTs": "import delegate from './file';\n\ntype AnyFn = (...args: any[]) => any;\n\nfunction makeNode(tag: string, className = ''): any {\n  return {\n    nodeType: 1,\n    tagName: String(tag || '').toUpperCase(),\n    className,\n    parentElement: null as any,\n    matches(selector: string) {\n      const [selTag, selClass] = selector.split('.');\n      if (selTag && selTag.length > 0) {\n        if (this.tagName !== selTag.toUpperCase()) return false;\n      }\n      if (selClass) {\n        const classes = String(this.className || '').split(/\\s+/).filter(Boolean);\n        return classes.includes(selClass);\n      }\n      return true;\n    },\n    closest(selector: string) {\n      let cur: any = this;\n      while (cur) {\n        if (cur.matches && cur.matches(selector)) return cur;\n        cur = cur.parentElement;\n      }\n      return null;\n    }\n  };\n}\n\nfunction makeRoot(): any {\n  const root: any = {\n    _listeners: {} as Record<string, AnyFn>,\n    addEventListener(type: string, fn: AnyFn) {\n      this._listeners[type] = fn;\n    },\n    removeEventListener(type: string, fn: AnyFn) {\n      if (this._listeners[type] === fn) delete this._listeners[type];\n    },\n    contains(node: any) {\n      let cur: any = node;\n      while (cur) {\n        if (cur === this) return true;\n        cur = cur.parentElement;\n      }\n      return false;\n    },\n    fire(type: string, target: any) {\n      const fn = this._listeners[type];\n      if (fn) fn({ type, target } as any);\n    }\n  };\n  root.nodeType = 1;\n  root.tagName = 'DIV';\n  root.parentElement = null;\n  return root;\n}\n\ndescribe('delegate (TypeScript, DOM-less)', () => {\n  it('calls handler when match is found', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'remove');\n    btn.parentElement = root;\n\n    let calls = 0;\n    const cleanup = delegate(root as any, 'click', 'button.remove', (e, matched) => {\n      calls++;\n      expect(matched).toBe(btn);\n    });\n\n    root.fire('click', btn);\n    expect(calls).toBe(1);\n\n    cleanup();\n  });\n\n  it('supports nested targets via closest()', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'remove');\n    const span = makeNode('span');\n    span.parentElement = btn;\n    btn.parentElement = root;\n\n    let matchedEl: any = null;\n    const cleanup = delegate(root as any, 'click', 'button.remove', (e, matched) => {\n      matchedEl = matched;\n    });\n\n    root.fire('click', span);\n    expect(matchedEl).toBe(btn);\n\n    cleanup();\n  });\n\n  it('throws on invalid args (runner-agnostic)', () => {\n    try {\n      delegate(null as any, 'click', 'button', (() => {}) as any);\n      expect(true).toBe(false);\n    } catch (e: any) {\n      expect(!!e).toBe(true);\n      expect(e.name).toBe('TypeError');\n    }\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ]
  },
  {
    "id": "js-delegated-events-2",
    "title": "Delegated Event Handler (M)",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "intermediate",
    "tags": [
      "dom",
      "events",
      "event-delegation",
      "bubbling",
      "capturing",
      "selectors"
    ],
    "description": {
      "summary": "Implement `delegate(root, eventType, selector, handler, options?)` with **advanced event delegation**.\n\nRequirements:\n1) Attach **one** event listener to `root`.\n2) When an event fires, find the closest ancestor of `event.target` (including itself) that matches `selector`.\n3) Only call `handler(event, matchedElement)` if the match is within `root`.\n4) Support a `capture` option:\n   - If `options.capture === true`, register the listener in capture phase.\n   - Otherwise default to bubbling.\n5) Support a `once` option:\n   - If `options.once === true`, after the **first successful match+handler call**, automatically remove the listener.\n6) Return a cleanup function that removes the listener.\n\nNotes:\n- You may use `closest()`/`matches()`.\n- This is common in real codebases because delegated listeners often need `{ capture, once }` for correctness and leak-free behavior.",
      "arguments": [
        {
          "name": "root",
          "type": "Element",
          "desc": "Container element where the single delegated listener is attached."
        },
        {
          "name": "eventType",
          "type": "string",
          "desc": "Event type to listen for (e.g. `'click'`, `'focus'`)."
        },
        {
          "name": "selector",
          "type": "string",
          "desc": "CSS selector used to find the matching target within `root`."
        },
        {
          "name": "handler",
          "type": "(event: Event, matchedEl: Element) => void",
          "desc": "Callback invoked when a matching element is found for the event."
        },
        {
          "name": "options",
          "type": "{ capture?: boolean; once?: boolean } | undefined",
          "desc": "Optional options. `capture` controls the phase; `once` removes after first successful match."
        }
      ],
      "returns": {
        "type": "() => void",
        "desc": "A function that removes the delegated listener from `root`."
      },
      "examples": [
        "// Example 1: capture for focus (non-bubbling in many cases)\nconst cleanup = delegate(formEl, 'focus', 'input', (e, input) => {\n  input.classList.add('focused');\n}, { capture: true });\n\n// Example 2: once\ndelegate(root, 'click', 'button.buy', (e, btn) => {\n  btn.disabled = true;\n}, { once: true });"
      ]
    },
    "starterCode": "export default function delegate(root, eventType, selector, handler, options) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function delegate(\n  root: Element,\n  eventType: string,\n  selector: string,\n  handler: (event: Event, matchedEl: Element) => void,\n  options?: { capture?: boolean; once?: boolean }\n): () => void {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Extend basic event delegation to support capture and once behavior. The delegated listener should look for the closest matching element, ensure it is within the root boundary, invoke the handler with the matched element, and optionally auto-unregister after the first successful match.",
      "approaches": [
        {
          "title": "Approach: Single listener + options-aware cleanup (recommended)",
          "prose": "Implementation plan:\n- Normalize the options and compute `capture` and `once` flags.\n- Register a single listener on `root`.\n- In the listener, compute `matched = target.closest(selector)` and verify it’s within `root`.\n- If matched, call `handler(event, matched)`. If `once` is true, remove the listener immediately.\n- Return a cleanup function that always removes the listener (idempotent).\n\nComplexity: O(h) per event, where h is DOM depth to the root.",
          "codeJs": "export default function delegate(root, eventType, selector, handler, options) {\n  if (!root || typeof root.addEventListener !== 'function') {\n    throw new TypeError('delegate: root must be an Element');\n  }\n  if (typeof eventType !== 'string') {\n    throw new TypeError('delegate: eventType must be a string');\n  }\n  if (typeof selector !== 'string') {\n    throw new TypeError('delegate: selector must be a string');\n  }\n  if (typeof handler !== 'function') {\n    throw new TypeError('delegate: handler must be a function');\n  }\n\n  const capture = !!(options && options.capture);\n  const once = !!(options && options.once);\n\n  let removed = false;\n  const cleanup = () => {\n    if (removed) return;\n    removed = true;\n    root.removeEventListener(eventType, listener, capture);\n  };\n\n  const listener = (event) => {\n    const target = event && event.target;\n    if (!target || target.nodeType !== 1) return;\n\n    const matched = target.closest(selector);\n    if (!matched) return;\n\n    if (matched === root || root.contains(matched)) {\n      handler(event, matched);\n      if (once) cleanup();\n    }\n  };\n\n  root.addEventListener(eventType, listener, capture);\n  return cleanup;\n}\n",
          "codeTs": "export default function delegate(\n  root: Element,\n  eventType: string,\n  selector: string,\n  handler: (event: Event, matchedEl: Element) => void,\n  options?: { capture?: boolean; once?: boolean }\n): () => void {\n  const anyRoot: any = root as any;\n  if (!root || typeof anyRoot.addEventListener !== 'function') {\n    throw new TypeError('delegate: root must be an Element');\n  }\n  if (typeof eventType !== 'string') {\n    throw new TypeError('delegate: eventType must be a string');\n  }\n  if (typeof selector !== 'string') {\n    throw new TypeError('delegate: selector must be a string');\n  }\n  if (typeof handler !== 'function') {\n    throw new TypeError('delegate: handler must be a function');\n  }\n\n  const capture = !!options?.capture;\n  const once = !!options?.once;\n\n  let removed = false;\n  const cleanup = () => {\n    if (removed) return;\n    removed = true;\n    root.removeEventListener(eventType, listener as any, capture as any);\n  };\n\n  const listener = (event: Event) => {\n    const target = (event as any)?.target;\n    if (!target || target.nodeType !== 1) return;\n\n    const matched = (target as Element).closest(selector);\n    if (!matched) return;\n\n    if (matched === root || root.contains(matched)) {\n      handler(event, matched);\n      if (once) cleanup();\n    }\n  };\n\n  root.addEventListener(eventType, listener as any, capture as any);\n  return cleanup;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "`once` should remove only after a **successful match** (not after any event).",
          "Cleanup should be idempotent (safe to call multiple times).",
          "Capture option must be included consistently in both add/remove calls."
        ],
        "edgeCases": [
          "If target is a text node, ignore (nodeType !== 1).",
          "If `closest` returns a match outside `root`, ignore using boundary check.",
          "Calling cleanup before any events should prevent handler from ever firing."
        ],
        "techniques": [
          "Track a `removed` flag for idempotent cleanup.",
          "Use `closest` for ancestor matching.",
          "Use capture for non-bubbling events (interview follow-up)."
        ]
      },
      "followUpQuestions": [
        "js-delegated-events-3"
      ],
      "resources": [
        {
          "title": "MDN – addEventListener options",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters"
        },
        {
          "title": "MDN – Event capturing",
          "url": "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_capture"
        }
      ]
    },
    "tests": "import delegate from './file';\n\nfunction makeNode(tag, className = '') {\n  return {\n    nodeType: 1,\n    tagName: String(tag || '').toUpperCase(),\n    className,\n    parentElement: null,\n    matches(selector) {\n      const [selTag, selClass] = selector.split('.');\n      if (selTag && selTag.length > 0) {\n        if (this.tagName !== selTag.toUpperCase()) return false;\n      }\n      if (selClass) {\n        const classes = String(this.className || '').split(/\\s+/).filter(Boolean);\n        return classes.includes(selClass);\n      }\n      return true;\n    },\n    closest(selector) {\n      let cur = this;\n      while (cur) {\n        if (cur.matches && cur.matches(selector)) return cur;\n        cur = cur.parentElement;\n      }\n      return null;\n    }\n  };\n}\n\nfunction makeRoot() {\n  const root = {\n    _listeners: {},\n    addEventListener(type, fn, capture) {\n      this._listeners[type] = { fn, capture: !!capture };\n    },\n    removeEventListener(type, fn, capture) {\n      const entry = this._listeners[type];\n      if (!entry) return;\n      if (entry.fn === fn && entry.capture === !!capture) delete this._listeners[type];\n    },\n    contains(node) {\n      let cur = node;\n      while (cur) {\n        if (cur === this) return true;\n        cur = cur.parentElement;\n      }\n      return false;\n    },\n    fire(type, target) {\n      const entry = this._listeners[type];\n      if (entry) entry.fn({ type, target });\n    },\n    hasListener(type) {\n      return !!this._listeners[type];\n    },\n    listenerCapture(type) {\n      return this._listeners[type]?.capture;\n    }\n  };\n  root.nodeType = 1;\n  root.tagName = 'DIV';\n  root.parentElement = null;\n  return root;\n}\n\ndescribe('delegate (Medium, DOM-less)', () => {\n  test('registers listener with capture when options.capture is true', () => {\n    const root = makeRoot();\n    const cleanup = delegate(root, 'focus', 'input', () => {}, { capture: true });\n    expect(root.hasListener('focus')).toBe(true);\n    expect(root.listenerCapture('focus')).toBe(true);\n    cleanup();\n    expect(root.hasListener('focus')).toBe(false);\n  });\n\n  test('once: removes only after first successful match', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'buy');\n    btn.parentElement = root;\n\n    let calls = 0;\n    delegate(root, 'click', 'button.buy', () => {\n      calls++;\n    }, { once: true });\n\n    expect(root.hasListener('click')).toBe(true);\n\n    root.fire('click', btn);\n    expect(calls).toBe(1);\n    expect(root.hasListener('click')).toBe(false);\n\n    // second event should do nothing (listener removed)\n    root.fire('click', btn);\n    expect(calls).toBe(1);\n  });\n\n  test('once: does not remove if event does not match selector', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'other');\n    btn.parentElement = root;\n\n    let calls = 0;\n    delegate(root, 'click', 'button.buy', () => {\n      calls++;\n    }, { once: true });\n\n    root.fire('click', btn); // no match\n    expect(calls).toBe(0);\n    expect(root.hasListener('click')).toBe(true);\n  });\n\n  test('cleanup is idempotent', () => {\n    const root = makeRoot();\n    const cleanup = delegate(root, 'click', 'button.buy', () => {});\n    expect(root.hasListener('click')).toBe(true);\n    cleanup();\n    cleanup();\n    expect(root.hasListener('click')).toBe(false);\n  });\n\n  test('throws on invalid args (runner-agnostic)', () => {\n    try {\n      delegate(null, 'click', 'button', () => {}, {});\n      expect(true).toBe(false);\n    } catch (e) {\n      expect(!!e).toBe(true);\n      expect(e.name).toBe('TypeError');\n    }\n  });\n});\n",
    "testsTs": "import delegate from './file';\n\ntype AnyFn = (...args: any[]) => any;\n\nfunction makeNode(tag: string, className = ''): any {\n  return {\n    nodeType: 1,\n    tagName: String(tag || '').toUpperCase(),\n    className,\n    parentElement: null as any,\n    matches(selector: string) {\n      const [selTag, selClass] = selector.split('.');\n      if (selTag && selTag.length > 0) {\n        if (this.tagName !== selTag.toUpperCase()) return false;\n      }\n      if (selClass) {\n        const classes = String(this.className || '').split(/\\s+/).filter(Boolean);\n        return classes.includes(selClass);\n      }\n      return true;\n    },\n    closest(selector: string) {\n      let cur: any = this;\n      while (cur) {\n        if (cur.matches && cur.matches(selector)) return cur;\n        cur = cur.parentElement;\n      }\n      return null;\n    }\n  };\n}\n\nfunction makeRoot(): any {\n  const root: any = {\n    _listeners: {} as Record<string, { fn: AnyFn; capture: boolean }>,\n    addEventListener(type: string, fn: AnyFn, capture?: any) {\n      this._listeners[type] = { fn, capture: !!capture };\n    },\n    removeEventListener(type: string, fn: AnyFn, capture?: any) {\n      const entry = this._listeners[type];\n      if (!entry) return;\n      if (entry.fn === fn && entry.capture === !!capture) delete this._listeners[type];\n    },\n    contains(node: any) {\n      let cur: any = node;\n      while (cur) {\n        if (cur === this) return true;\n        cur = cur.parentElement;\n      }\n      return false;\n    },\n    fire(type: string, target: any) {\n      const entry = this._listeners[type];\n      if (entry) entry.fn({ type, target } as any);\n    },\n    hasListener(type: string) {\n      return !!this._listeners[type];\n    },\n    listenerCapture(type: string) {\n      return this._listeners[type]?.capture;\n    }\n  };\n  root.nodeType = 1;\n  root.tagName = 'DIV';\n  root.parentElement = null;\n  return root;\n}\n\ndescribe('delegate (Medium, TypeScript, DOM-less)', () => {\n  it('registers capture listener when options.capture is true', () => {\n    const root = makeRoot();\n    const cleanup = delegate(root as any, 'focus', 'input', (() => {}) as any, { capture: true });\n    expect(root.hasListener('focus')).toBe(true);\n    expect(root.listenerCapture('focus')).toBe(true);\n    cleanup();\n    expect(root.hasListener('focus')).toBe(false);\n  });\n\n  it('once removes after first successful match', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'buy');\n    btn.parentElement = root;\n\n    let calls = 0;\n    delegate(root as any, 'click', 'button.buy', (() => { calls++; }) as any, { once: true });\n\n    root.fire('click', btn);\n    expect(calls).toBe(1);\n    expect(root.hasListener('click')).toBe(false);\n  });\n\n  it('throws on invalid args (runner-agnostic)', () => {\n    try {\n      delegate(null as any, 'click', 'button', (() => {}) as any, {} as any);\n      expect(true).toBe(false);\n    } catch (e: any) {\n      expect(!!e).toBe(true);\n      expect(e.name).toBe('TypeError');\n    }\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ]
  },
  {
    "id": "js-delegated-events-3",
    "title": "Delegated Event Handler (H)",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "hard",
    "tags": [
      "dom",
      "events",
      "event-delegation",
      "bubbling",
      "capturing",
      "event-propagation",
      "selectors"
    ],
    "description": {
      "summary": "Implement delegated event handling: attach one listener to a parent, match events by selector, and call the handler with the matched element. Ensure boundary checks so events outside the root don’t trigger callbacks.",
      "arguments": [
        {
          "name": "root",
          "type": "Element",
          "desc": "Container element where the single delegated listener is attached."
        },
        {
          "name": "eventType",
          "type": "string",
          "desc": "Event type to listen for (e.g. `'click'`, `'focus'`)."
        },
        {
          "name": "selector",
          "type": "string",
          "desc": "Selector used to find the matching target (closest match wins)."
        },
        {
          "name": "handler",
          "type": "(event: Event, matchedEl: Element) => void",
          "desc": "Callback invoked when a matching element is found."
        },
        {
          "name": "options",
          "type": "{ capture?: boolean; once?: boolean; ignore?: string; until?: string; stop?: boolean } | undefined",
          "desc": "`ignore`: blocks if any ancestor up to root matches. `until`: traversal stop-boundary (wins over matches). `stop`: calls stopPropagation() on successful match."
        }
      ],
      "returns": {
        "type": "() => void",
        "desc": "Cleanup function that removes the delegated listener (idempotent)."
      },
      "examples": [
        "// Example: ignore clicks coming from inside a modal, and don't cross a list boundary\nconst cleanup = delegate(\n  root,\n  'click',\n  'button.remove',\n  (e, btn) => {\n    // remove item\n  },\n  { ignore: '.modal', until: '.list', stop: true }\n);\n\ncleanup();"
      ]
    },
    "starterCode": "export default function delegate(root, eventType, selector, handler, options) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function delegate(\n  root: Element,\n  eventType: string,\n  selector: string,\n  handler: (event: Event, matchedEl: Element) => void,\n  options?: { capture?: boolean; once?: boolean; ignore?: string; until?: string; stop?: boolean }\n): () => void {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Event delegation attaches one listener to a parent and handles events for many children. The logic is: find the closest matching element, ensure it is within the root boundary, then call the handler. This saves memory, supports dynamic DOM, and is common in front-end interview tasks.",
      "approaches": [
        {
          "title": "Approach: Manual ancestor walk with deterministic boundaries (recommended)",
          "prose": "Attach root.addEventListener(eventType, listener). Inside the listener, compute matched = target.closest(selector). If matched exists and root.contains(matched), call handler(event, matched). Return a cleanup function that removes the listener to prevent leaks. The matching step is O(h) where h is the DOM depth.",
          "codeJs": "function startFromTarget(target) {\n  if (!target) return null;\n  if (target.nodeType === 1) return target;\n  if (target.nodeType === 3) return target.parentElement || null; // Text\n  return null;\n}\n\nfunction closestWithin(start, selector, root, until) {\n  let cur = start;\n  while (cur) {\n    if (until && cur.matches && cur.matches(until)) return null;\n    if (cur.matches && cur.matches(selector)) return cur;\n    if (cur === root) break;\n    cur = cur.parentElement;\n  }\n  return null;\n}\n\nfunction isIgnored(start, ignoreSelector, root, until) {\n  let cur = start;\n  while (cur) {\n    if (until && cur.matches && cur.matches(until)) return false;\n    if (cur.matches && cur.matches(ignoreSelector)) return true;\n    if (cur === root) break;\n    cur = cur.parentElement;\n  }\n  return false;\n}\n\nexport default function delegate(root, eventType, selector, handler, options) {\n  if (!root || typeof root.addEventListener !== 'function') {\n    throw new TypeError('delegate: root must be an Element');\n  }\n  if (typeof eventType !== 'string') {\n    throw new TypeError('delegate: eventType must be a string');\n  }\n  if (typeof selector !== 'string') {\n    throw new TypeError('delegate: selector must be a string');\n  }\n  if (typeof handler !== 'function') {\n    throw new TypeError('delegate: handler must be a function');\n  }\n\n  const capture = !!options?.capture;\n  const once = !!options?.once;\n  const ignore = options?.ignore;\n  const until = options?.until;\n  const stop = !!options?.stop;\n\n  let removed = false;\n  const cleanup = () => {\n    if (removed) return;\n    removed = true;\n    root.removeEventListener(eventType, listener, capture);\n  };\n\n  const listener = (event) => {\n    const start = startFromTarget(event && event.target);\n    if (!start) return;\n\n    if (ignore && isIgnored(start, ignore, root, until)) return;\n\n    const matched = closestWithin(start, selector, root, until);\n    if (!matched) return;\n\n    if (stop && event && typeof event.stopPropagation === 'function') {\n      event.stopPropagation();\n    }\n\n    handler(event, matched);\n    if (once) cleanup();\n  };\n\n  root.addEventListener(eventType, listener, capture);\n  return cleanup;\n}\n",
          "codeTs": "function startFromTarget(target: any): any {\n  if (!target) return null;\n  if (target.nodeType === 1) return target;\n  if (target.nodeType === 3) return target.parentElement || null;\n  return null;\n}\n\nfunction closestWithin(start: any, selector: string, root: any, until?: string): any {\n  let cur: any = start;\n  while (cur) {\n    if (until && cur.matches && cur.matches(until)) return null;\n    if (cur.matches && cur.matches(selector)) return cur;\n    if (cur === root) break;\n    cur = cur.parentElement;\n  }\n  return null;\n}\n\nfunction isIgnored(start: any, ignoreSelector: string, root: any, until?: string): boolean {\n  let cur: any = start;\n  while (cur) {\n    if (until && cur.matches && cur.matches(until)) return false;\n    if (cur.matches && cur.matches(ignoreSelector)) return true;\n    if (cur === root) break;\n    cur = cur.parentElement;\n  }\n  return false;\n}\n\nexport default function delegate(\n  root: Element,\n  eventType: string,\n  selector: string,\n  handler: (event: Event, matchedEl: Element) => void,\n  options?: { capture?: boolean; once?: boolean; ignore?: string; until?: string; stop?: boolean }\n): () => void {\n  const anyRoot: any = root as any;\n  if (!root || typeof anyRoot.addEventListener !== 'function') {\n    throw new TypeError('delegate: root must be an Element');\n  }\n  if (typeof eventType !== 'string') {\n    throw new TypeError('delegate: eventType must be a string');\n  }\n  if (typeof selector !== 'string') {\n    throw new TypeError('delegate: selector must be a string');\n  }\n  if (typeof handler !== 'function') {\n    throw new TypeError('delegate: handler must be a function');\n  }\n\n  const capture = !!options?.capture;\n  const once = !!options?.once;\n  const ignore = options?.ignore;\n  const until = options?.until;\n  const stop = !!options?.stop;\n\n  let removed = false;\n  const cleanup = () => {\n    if (removed) return;\n    removed = true;\n    root.removeEventListener(eventType, listener as any, capture as any);\n  };\n\n  const listener = (event: Event) => {\n    const start = startFromTarget((event as any)?.target);\n    if (!start) return;\n\n    if (ignore && isIgnored(start, ignore, root as any, until)) return;\n\n    const matched = closestWithin(start, selector, root as any, until);\n    if (!matched) return;\n\n    if (stop && (event as any) && typeof (event as any).stopPropagation === 'function') {\n      (event as any).stopPropagation();\n    }\n\n    handler(event, matched);\n    if (once) cleanup();\n  };\n\n  root.addEventListener(eventType, listener as any, capture as any);\n  return cleanup;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "`until` must stop traversal even if a match exists above it (until wins).",
          "`ignore` is ancestor-inclusive and must not cross `until`.",
          "`once` must remove only after a successful match (not on every event).",
          "`capture` must be passed consistently to add/remove.",
          "Text node targets require starting from `target.parentElement`."
        ],
        "edgeCases": [
          "If `until` matches the start element, traversal stops immediately and no match is returned.",
          "If both an inner and outer element match `selector`, the inner (closest) must be chosen.",
          "Cleanup should be safe to call multiple times."
        ],
        "techniques": [
          "Manual ancestor traversal with `parentElement`",
          "Selector matching via `matches()`",
          "Deterministic boundary precedence (`until` before `selector`)",
          "Text node normalization",
          "Idempotent cleanup"
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "MDN – Element.matches",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/matches"
        },
        {
          "title": "MDN – Event.stopPropagation",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation"
        }
      ]
    },
    "tests": "import delegate from './file';\n\nfunction makeNode(tag, className = '') {\n  return {\n    nodeType: 1,\n    tagName: String(tag || '').toUpperCase(),\n    className,\n    parentElement: null,\n    matches(selector) {\n      // minimal matcher supporting: '.cls' and 'tag.cls'\n      if (!selector) return false;\n      const s = selector.trim();\n      if (s.startsWith('.')) {\n        const cls = s.slice(1);\n        const classes = String(this.className || '').split(/\\s+/).filter(Boolean);\n        return classes.includes(cls);\n      }\n      const [selTag, selClass] = s.split('.');\n      if (selTag && this.tagName !== selTag.toUpperCase()) return false;\n      if (selClass) {\n        const classes = String(this.className || '').split(/\\s+/).filter(Boolean);\n        return classes.includes(selClass);\n      }\n      return true;\n    }\n  };\n}\n\nfunction makeTextNode(parent) {\n  return {\n    nodeType: 3,\n    parentElement: parent\n  };\n}\n\nfunction makeRoot() {\n  const root = {\n    _listeners: {},\n    addEventListener(type, fn, capture) {\n      this._listeners[type] = { fn, capture: !!capture };\n    },\n    removeEventListener(type, fn, capture) {\n      const entry = this._listeners[type];\n      if (!entry) return;\n      if (entry.fn === fn && entry.capture === !!capture) delete this._listeners[type];\n    },\n    fire(type, target, extraEvent = {}) {\n      const entry = this._listeners[type];\n      if (entry) entry.fn({ type, target, ...extraEvent });\n    },\n    hasListener(type) {\n      return !!this._listeners[type];\n    },\n    listenerCapture(type) {\n      return this._listeners[type]?.capture;\n    }\n  };\n  root.nodeType = 1;\n  root.tagName = 'DIV';\n  root.className = '';\n  root.parentElement = null;\n  root.matches = () => false;\n  return root;\n}\n\ndescribe('delegate (Hard, DOM-less)', () => {\n  test('ignore (ancestor-inclusive): does not fire when an ancestor is ignored', () => {\n    const root = makeRoot();\n\n    const modal = makeNode('div', 'modal');\n    const btn = makeNode('button', 'remove');\n    btn.parentElement = modal;\n    modal.parentElement = root;\n\n    let calls = 0;\n    const cleanup = delegate(root, 'click', 'button.remove', () => { calls++; }, { ignore: '.modal' });\n\n    root.fire('click', btn);\n    expect(calls).toBe(0);\n\n    cleanup();\n  });\n\n  test('until: stops traversal at boundary even if match exists above it', () => {\n    const root = makeRoot();\n\n    const list = makeNode('div', 'list');\n    const wrapper = makeNode('div', 'wrapper');\n    const span = makeNode('span'); // target does NOT match selector\n\n    // chain: span -> wrapper -> list -> matchAbove\n    span.parentElement = wrapper;\n    wrapper.parentElement = list;\n\n    const matchAbove = makeNode('button', 'remove'); // matches selector but is above boundary\n    list.parentElement = matchAbove;\n    matchAbove.parentElement = root;\n\n    let calls = 0;\n    const cleanup = delegate(root, 'click', 'button.remove', () => { calls++; }, { until: '.list' });\n\n    root.fire('click', span);\n    expect(calls).toBe(0);\n\n    cleanup();\n  });\n\n  test('closest match wins when multiple ancestors match selector', () => {\n    const root = makeRoot();\n    const outer = makeNode('button', 'remove');\n    const inner = makeNode('button', 'remove');\n    inner.parentElement = outer;\n    outer.parentElement = root;\n\n    let matchedEl = null;\n    const cleanup = delegate(root, 'click', 'button.remove', (e, matched) => {\n      matchedEl = matched;\n    });\n\n    root.fire('click', inner);\n    expect(matchedEl).toBe(inner);\n\n    cleanup();\n  });\n\n  test('text node target: starts from parentElement', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'remove');\n    btn.parentElement = root;\n    const text = makeTextNode(btn);\n\n    let calls = 0;\n    const cleanup = delegate(root, 'click', 'button.remove', () => { calls++; });\n\n    root.fire('click', text);\n    expect(calls).toBe(1);\n\n    cleanup();\n  });\n\n  test('stop: calls stopPropagation before handler on successful match', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'remove');\n    btn.parentElement = root;\n\n    const order = [];\n    const cleanup = delegate(\n      root,\n      'click',\n      'button.remove',\n      () => { order.push('handler'); },\n      { stop: true }\n    );\n\n    root.fire('click', btn, {\n      stopPropagation: () => order.push('stop')\n    });\n\n    expect(order).toEqual(['stop', 'handler']);\n    cleanup();\n  });\n\n  test('capture option is used for add/remove', () => {\n    const root = makeRoot();\n    const cleanup = delegate(root, 'click', 'button.remove', () => {}, { capture: true });\n    expect(root.listenerCapture('click')).toBe(true);\n    cleanup();\n    expect(root.hasListener('click')).toBe(false);\n  });\n\n  test('once removes after first successful match only', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'remove');\n    btn.parentElement = root;\n\n    let calls = 0;\n    delegate(root, 'click', 'button.remove', () => { calls++; }, { once: true });\n\n    root.fire('click', btn);\n    expect(calls).toBe(1);\n    expect(root.hasListener('click')).toBe(false);\n\n    root.fire('click', btn);\n    expect(calls).toBe(1);\n  });\n\n  test('throws on invalid args (runner-agnostic)', () => {\n    try {\n      delegate(null, 'click', 'button', () => {}, { once: true });\n      expect(true).toBe(false);\n    } catch (e) {\n      expect(!!e).toBe(true);\n      expect(e.name).toBe('TypeError');\n    }\n  });\n});\n",
    "testsTs": "import delegate from './file';\n\ntype AnyFn = (...args: any[]) => any;\n\nfunction makeNode(tag: string, className = ''): any {\n  return {\n    nodeType: 1,\n    tagName: String(tag || '').toUpperCase(),\n    className,\n    parentElement: null as any,\n    matches(selector: string) {\n      const s = (selector || '').trim();\n      if (!s) return false;\n      if (s.startsWith('.')) {\n        const cls = s.slice(1);\n        const classes = String(this.className || '').split(/\\s+/).filter(Boolean);\n        return classes.includes(cls);\n      }\n      const [selTag, selClass] = s.split('.');\n      if (selTag && this.tagName !== selTag.toUpperCase()) return false;\n      if (selClass) {\n        const classes = String(this.className || '').split(/\\s+/).filter(Boolean);\n        return classes.includes(selClass);\n      }\n      return true;\n    }\n  };\n}\n\nfunction makeTextNode(parent: any): any {\n  return {\n    nodeType: 3,\n    parentElement: parent\n  };\n}\n\nfunction makeRoot(): any {\n  const root: any = {\n    _listeners: {} as Record<string, { fn: AnyFn; capture: boolean }>,\n    addEventListener(type: string, fn: AnyFn, capture?: any) {\n      this._listeners[type] = { fn, capture: !!capture };\n    },\n    removeEventListener(type: string, fn: AnyFn, capture?: any) {\n      const entry = this._listeners[type];\n      if (!entry) return;\n      if (entry.fn === fn && entry.capture === !!capture) delete this._listeners[type];\n    },\n    fire(type: string, target: any, extraEvent: any = {}) {\n      const entry = this._listeners[type];\n      if (entry) entry.fn({ type, target, ...extraEvent } as any);\n    },\n    hasListener(type: string) {\n      return !!this._listeners[type];\n    },\n    listenerCapture(type: string) {\n      return this._listeners[type]?.capture;\n    }\n  };\n  root.nodeType = 1;\n  root.tagName = 'DIV';\n  root.className = '';\n  root.parentElement = null;\n  root.matches = () => false;\n  return root;\n}\n\ndescribe('delegate (Hard, TypeScript, DOM-less)', () => {\n  it('ignore (ancestor-inclusive): does not fire when an ancestor is ignored', () => {\n    const root = makeRoot();\n\n    const modal = makeNode('div', 'modal');\n    const btn = makeNode('button', 'remove');\n    btn.parentElement = modal;\n    modal.parentElement = root;\n\n    let calls = 0;\n    const cleanup = delegate(root as any, 'click', 'button.remove', (() => { calls++; }) as any, { ignore: '.modal' });\n\n    root.fire('click', btn);\n    expect(calls).toBe(0);\n\n    cleanup();\n  });\n\n  it('text node target: starts from parentElement', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'remove');\n    btn.parentElement = root;\n    const text = makeTextNode(btn);\n\n    let calls = 0;\n    const cleanup = delegate(root as any, 'click', 'button.remove', (() => { calls++; }) as any);\n\n    root.fire('click', text);\n    expect(calls).toBe(1);\n\n    cleanup();\n  });\n\n  it('stop: calls stopPropagation before handler on successful match', () => {\n    const root = makeRoot();\n    const btn = makeNode('button', 'remove');\n    btn.parentElement = root;\n\n    const order: string[] = [];\n    const cleanup = delegate(\n      root as any,\n      'click',\n      'button.remove',\n      (() => { order.push('handler'); }) as any,\n      { stop: true }\n    );\n\n    root.fire('click', btn, {\n      stopPropagation: () => order.push('stop')\n    });\n\n    expect(order).toEqual(['stop', 'handler']);\n    cleanup();\n  });\n\n  it('until: stops traversal at boundary even if match exists above it', () => {\n    const root = makeRoot();\n\n    const list = makeNode('div', 'list');\n    const wrapper = makeNode('div', 'wrapper');\n    const span = makeNode('span');\n\n    span.parentElement = wrapper;\n    wrapper.parentElement = list;\n\n    const matchAbove = makeNode('button', 'remove');\n    list.parentElement = matchAbove;\n    matchAbove.parentElement = root;\n\n    let calls = 0;\n    const cleanup = delegate(root as any, 'click', 'button.remove', (() => { calls++; }) as any, { until: '.list' });\n\n    root.fire('click', span);\n    expect(calls).toBe(0);\n\n    cleanup();\n  });\n\n  it('throws on invalid args (runner-agnostic)', () => {\n    try {\n      delegate(null as any, 'click', 'button', (() => {}) as any, { once: true });\n      expect(true).toBe(false);\n    } catch (e: any) {\n      expect(!!e).toBe(true);\n      expect(e.name).toBe('TypeError');\n    }\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ]
  },
  {
    "id": "js-dom-walk-text-content-1",
    "title": "DOM Tree Walk 1: Collect Text Nodes",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "dom",
      "tree",
      "recursion",
      "iteration",
      "edge-cases"
    ],
    "description": {
      "summary": "Implement `collectText(node)` that traverses a **DOM-like** tree and returns **all text content** (nodeType `3`) in **document order**.\n\nWhy this matters in real FE work:\n- This is the core idea behind utilities like `textContent`, DOM sanitizers, custom renderers, and “walk the tree and extract something” tasks.\n- It trains **document-order DFS** + defensive handling of inconsistent node shapes.\n\nRequirements:\n1) Input is a **DOM-like** node object (not real browser DOM).\n2) Node shape:\n   - `nodeType`: `1` for element, `3` for text\n   - `childNodes?: any[]` (optional)\n   - `nodeValue?: string | null` for text nodes\n3) Return a **string** made by concatenating all descendant text node values in **document order**.\n4) Ignore non-text nodes except for traversing their children.\n\nCorrectness rules (explicit):\n- Treat `null`/`undefined` input as empty string.\n- Treat missing/`null`/`undefined` `nodeValue` as empty string.\n- Children must be visited **left-to-right**.\n\nStretch (still easy): provide an implementation that avoids recursion depth issues by using an explicit stack.\n\nThis tests:\n- DFS traversal order\n- Defensive coding\n- Choosing recursion vs iterative stack",
      "arguments": [
        {
          "name": "node",
          "type": "any",
          "desc": "Root DOM-like node to traverse. Can be element, text, nullish, or have missing childNodes."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "Concatenated text content from all descendant text nodes in document order."
      },
      "examples": [
        "// Example\nconst tree = {\n  nodeType: 1,\n  childNodes: [\n    { nodeType: 3, nodeValue: 'Hello ' },\n    {\n      nodeType: 1,\n      childNodes: [\n        { nodeType: 3, nodeValue: 'World' },\n        { nodeType: 3, nodeValue: '!' }\n      ]\n    }\n  ]\n};\n\ncollectText(tree); // => 'Hello World!'",
        "// Text node root\ncollectText({ nodeType: 3, nodeValue: 'X' }); // => 'X'",
        "// Defensive: nullish input\ncollectText(null); // => ''",
        "// Defensive: text with null nodeValue\ncollectText({ nodeType: 3, nodeValue: null }); // => ''"
      ]
    },
    "starterCode": "export default function collectText(node) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type DomLikeNode = {\n  nodeType: number;\n  nodeValue?: string | null;\n  childNodes?: DomLikeNode[];\n};\n\nexport default function collectText(node: DomLikeNode | null | undefined): string {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: produce the same result as a real DOM `textContent`-style traversal: visit nodes in document order, concatenate text node values, and be defensive about missing fields.\n\nKey concept: **document order** means DFS pre-order over children left-to-right.",
      "approaches": [
        {
          "title": "Approach A: Recursive DFS (simplest)",
          "prose": "When to use\n- Interview-scale trees, shallow depth.\n\nSteps\n- If node is nullish => ''\n- If text node => nodeValue or ''\n- Else iterate children left-to-right and concatenate results\n\nComplexity\n- Time: O(N)\n- Space: O(H) due to recursion depth",
          "codeJs": "export default function collectText(node) {\n  if (!node) return '';\n\n  if (node.nodeType === 3) {\n    return node.nodeValue == null ? '' : String(node.nodeValue);\n  }\n\n  const children = Array.isArray(node.childNodes) ? node.childNodes : [];\n  let out = '';\n  for (const child of children) {\n    out += collectText(child);\n  }\n  return out;\n}\n",
          "codeTs": "type DomLikeNode = {\n  nodeType: number;\n  nodeValue?: string | null;\n  childNodes?: DomLikeNode[];\n};\n\nexport default function collectText(node: DomLikeNode | null | undefined): string {\n  if (!node) return '';\n\n  if (node.nodeType === 3) {\n    return node.nodeValue == null ? '' : String(node.nodeValue);\n  }\n\n  const children = Array.isArray(node.childNodes) ? node.childNodes : [];\n  let out = '';\n  for (const child of children) {\n    out += collectText(child);\n  }\n  return out;\n}\n"
        },
        {
          "title": "Approach B: Iterative DFS with explicit stack (preferred for robustness)",
          "prose": "Why this is valuable\n- Avoids call stack overflow on very deep trees.\n- Still preserves **document order** by pushing children in reverse.\n\nAlgorithm\n- Use a stack initialized with [node]\n- Pop current:\n  - If text node => append nodeValue\n  - Else push children onto stack in reverse order so they are processed left-to-right\n\nComplexity\n- Time: O(N)\n- Space: O(H) in stack (worst-case), but safe vs recursion depth",
          "codeJs": "export default function collectText(node) {\n  if (!node) return '';\n\n  let out = '';\n  const stack = [node];\n\n  while (stack.length) {\n    const cur = stack.pop();\n    if (!cur) continue;\n\n    if (cur.nodeType === 3) {\n      if (cur.nodeValue != null) out += String(cur.nodeValue);\n      continue;\n    }\n\n    const children = Array.isArray(cur.childNodes) ? cur.childNodes : [];\n    // push right-to-left so we process left-to-right\n    for (let i = children.length - 1; i >= 0; i--) {\n      stack.push(children[i]);\n    }\n  }\n\n  return out;\n}\n",
          "codeTs": "type DomLikeNode = {\n  nodeType: number;\n  nodeValue?: string | null;\n  childNodes?: DomLikeNode[];\n};\n\nexport default function collectText(node: DomLikeNode | null | undefined): string {\n  if (!node) return '';\n\n  let out = '';\n  const stack: (DomLikeNode | null | undefined)[] = [node];\n\n  while (stack.length) {\n    const cur = stack.pop();\n    if (!cur) continue;\n\n    if (cur.nodeType === 3) {\n      if (cur.nodeValue != null) out += String(cur.nodeValue);\n      continue;\n    }\n\n    const children = Array.isArray(cur.childNodes) ? cur.childNodes : [];\n    for (let i = children.length - 1; i >= 0; i--) {\n      stack.push(children[i]);\n    }\n  }\n\n  return out;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Not preserving document order (iterative solution must push children in reverse).",
          "Assuming childNodes always exists (it may be missing).",
          "Forgetting to treat null/undefined nodeValue as empty.",
          "Using array join incorrectly (can change order if not careful)."
        ],
        "edgeCases": [
          "Root is a text node.",
          "Deeply nested tree (recursion may overflow; iterative is safe).",
          "childNodes contains null/undefined entries (skip safely)."
        ],
        "techniques": [
          "Recursive DFS traversal",
          "Iterative DFS using a stack",
          "Document-order preservation via reverse push"
        ]
      },
      "followUpQuestions": [
        "js-dom-walk-text-content-2"
      ],
      "resources": [
        {
          "title": "MDN – Node.nodeType",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType"
        }
      ]
    },
    "tests": "import collectText from './file';\n\ndescribe('collectText', () => {\n  test('collects text in document order', () => {\n    const tree = {\n      nodeType: 1,\n      childNodes: [\n        { nodeType: 3, nodeValue: 'Hello ' },\n        {\n          nodeType: 1,\n          childNodes: [\n            { nodeType: 3, nodeValue: 'World' },\n            { nodeType: 3, nodeValue: '!' }\n          ]\n        }\n      ]\n    };\n    expect(collectText(tree)).toBe('Hello World!');\n  });\n\n  test('returns empty string for nullish input', () => {\n    expect(collectText(null)).toBe('');\n    expect(collectText(undefined)).toBe('');\n  });\n\n  test('handles text node root', () => {\n    expect(collectText({ nodeType: 3, nodeValue: 'X' })).toBe('X');\n  });\n\n  test('treats null/undefined nodeValue as empty for text nodes', () => {\n    expect(collectText({ nodeType: 3, nodeValue: null })).toBe('');\n    expect(collectText({ nodeType: 3 })).toBe('');\n  });\n\n  test('ignores missing childNodes', () => {\n    expect(collectText({ nodeType: 1 })).toBe('');\n  });\n\n  test('iterative-safety style case: deeply nested chain does not rely on call stack assumptions', () => {\n    // Build a deep tree; this test mainly ensures correctness on deep shapes.\n    // (We keep it moderate to avoid test runner recursion limits in implementations that stay recursive.)\n    let root = { nodeType: 1, childNodes: [] };\n    let cur = root;\n    for (let i = 0; i < 200; i++) {\n      const next = { nodeType: 1, childNodes: [] };\n      cur.childNodes.push(next);\n      cur = next;\n    }\n    cur.childNodes.push({ nodeType: 3, nodeValue: 'Z' });\n\n    expect(collectText(root)).toBe('Z');\n  });\n\n  test('skips nullish children defensively', () => {\n    const tree = {\n      nodeType: 1,\n      childNodes: [\n        null,\n        { nodeType: 3, nodeValue: 'A' },\n        undefined,\n        { nodeType: 1, childNodes: [null, { nodeType: 3, nodeValue: 'B' }] }\n      ]\n    };\n    expect(collectText(tree)).toBe('AB');\n  });\n});\n",
    "testsTs": "import collectText from './file';\n\ndescribe('collectText (TypeScript)', () => {\n  it('collects text in document order', () => {\n    const tree: any = {\n      nodeType: 1,\n      childNodes: [\n        { nodeType: 3, nodeValue: 'A' },\n        { nodeType: 1, childNodes: [{ nodeType: 3, nodeValue: 'B' }] }\n      ]\n    };\n    expect(collectText(tree)).toBe('AB');\n  });\n\n  it('returns empty string for nullish input', () => {\n    expect(collectText(null as any)).toBe('');\n    expect(collectText(undefined as any)).toBe('');\n  });\n\n  it('handles text node root', () => {\n    expect(collectText({ nodeType: 3, nodeValue: 'X' } as any)).toBe('X');\n  });\n\n  it('skips nullish children defensively', () => {\n    const tree: any = {\n      nodeType: 1,\n      childNodes: [null, { nodeType: 3, nodeValue: 'A' }, undefined]\n    };\n    expect(collectText(tree)).toBe('A');\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ]
  },
  {
    "id": "js-dom-walk-text-content-2",
    "title": "DOM Tree Walk 2: Find Closest Ancestor",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "intermediate",
    "tags": [
      "dom",
      "tree",
      "selectors"
    ],
    "description": {
      "summary": "Implement `closestWithin(node, selector, boundary)` for a **DOM-like** tree.\n\nThis is a simplified `.closest()` used constantly in UI code (event delegation, component boundaries).\n\nRequirements:\n1) Walk up using `parentNode` starting from `node`.\n2) Return the first node that matches `selector`.\n3) Do **not** walk above `boundary` (inclusive):\n   - If `boundary` is reached and it doesn't match, stop and return `null`.\n4) If `node` is `null`/`undefined`, return `null`.\n5) Selector support (minimal):\n   - Tag selectors: `'div'`, `'button'`\n   - Class selectors: `'.item'`\n   - Tag + class: `'button.primary'`\n\nInput node shape:\n- `{ tagName: string, className?: string, parentNode?: Node | null }`\n\nReturn:\n- The matched node object, or `null` if not found.\n\nNo real DOM. Do NOT reference `document`.",
      "arguments": [
        {
          "name": "node",
          "type": "any",
          "desc": "Starting DOM-like node."
        },
        {
          "name": "selector",
          "type": "string",
          "desc": "Selector to match: tag, .class, or tag.class."
        },
        {
          "name": "boundary",
          "type": "any",
          "desc": "Stop walking when this node is reached (inclusive)."
        }
      ],
      "returns": {
        "type": "any | null",
        "desc": "Closest matching ancestor (including the node itself) within the boundary, otherwise `null`."
      },
      "examples": [
        "// Setup: span -> button.primary -> div.container -> root\nconst root = { tagName: 'div', className: 'root', parentNode: null };\nconst container = { tagName: 'div', className: 'container', parentNode: root };\nconst btn = { tagName: 'button', className: 'primary', parentNode: container };\nconst span = { tagName: 'span', parentNode: btn };\n\nclosestWithin(span, 'button.primary', root) === btn; // true\nclosestWithin(span, '.container', root) === container; // true\nclosestWithin(span, 'a', root); // => null"
      ]
    },
    "starterCode": "export default function closestWithin(node, selector, boundary) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type DomLikeNode = {\n  tagName: string;\n  className?: string;\n  parentNode?: DomLikeNode | null;\n};\n\nexport default function closestWithin(\n  node: DomLikeNode | null | undefined,\n  selector: string,\n  boundary: DomLikeNode | null | undefined\n): DomLikeNode | null {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Implement a boundary-aware `.closest()` for a DOM-like tree. Walk up the `parentNode` chain, returning the first node that matches a simple selector, but stop when you reach the boundary (inclusive). This is a common UI pattern for scoping event delegation within a component subtree.",
      "approaches": [
        {
          "title": "Approach: Ancestor walk with a small selector matcher (recommended)",
          "prose": "Step-by-step:\n- Build `matchesSimple(node, selector)` for tag, `.class`, and `tag.class` selectors.\n- If `node` is nullish, return `null`.\n- Loop upward: if current matches, return it. If current is the boundary and doesn’t match, stop. Otherwise move to `current.parentNode`.\n\nWhy it works: it mirrors native `.closest()` but with an explicit stopping point so you don’t leak outside a component.\n\nComplexity: O(h * c) time, O(1) space.",
          "codeJs": "function hasClass(node, cls) {\n  const list = String(node.className || '').split(/\\s+/).filter(Boolean);\n  return list.includes(cls);\n}\n\nfunction matchesSimple(node, selector) {\n  const s = String(selector || '').trim();\n  if (!s) return false;\n\n  // .class\n  if (s.startsWith('.')) {\n    return hasClass(node, s.slice(1));\n  }\n\n  // tag or tag.class\n  const parts = s.split('.');\n  const tag = parts[0];\n  const cls = parts[1];\n\n  if (tag) {\n    if (String(node.tagName || '').toLowerCase() !== tag.toLowerCase()) return false;\n  }\n  if (cls) {\n    if (!hasClass(node, cls)) return false;\n  }\n  return true;\n}\n\nexport default function closestWithin(node, selector, boundary) {\n  if (!node) return null;\n\n  let cur = node;\n  while (cur) {\n    if (matchesSimple(cur, selector)) return cur;\n    if (boundary && cur === boundary) return null;\n    cur = cur.parentNode || null;\n  }\n  return null;\n}\n",
          "codeTs": "type DomLikeNode = {\n  tagName: string;\n  className?: string;\n  parentNode?: DomLikeNode | null;\n};\n\nfunction hasClass(node: DomLikeNode, cls: string): boolean {\n  const list = String(node.className || '').split(/\\s+/).filter(Boolean);\n  return list.includes(cls);\n}\n\nfunction matchesSimple(node: DomLikeNode, selector: string): boolean {\n  const s = String(selector || '').trim();\n  if (!s) return false;\n\n  if (s.startsWith('.')) {\n    return hasClass(node, s.slice(1));\n  }\n\n  const parts = s.split('.');\n  const tag = parts[0];\n  const cls = parts[1];\n\n  if (tag) {\n    if (String(node.tagName || '').toLowerCase() !== tag.toLowerCase()) return false;\n  }\n  if (cls) {\n    if (!hasClass(node, cls)) return false;\n  }\n  return true;\n}\n\nexport default function closestWithin(\n  node: DomLikeNode | null | undefined,\n  selector: string,\n  boundary: DomLikeNode | null | undefined\n): DomLikeNode | null {\n  if (!node) return null;\n\n  let cur: DomLikeNode | null = node;\n  while (cur) {\n    if (matchesSimple(cur, selector)) return cur;\n    if (boundary && cur === boundary) return null;\n    cur = cur.parentNode || null;\n  }\n  return null;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting that the starting node itself may match.",
          "Walking past the boundary (boundary is inclusive stop).",
          "Not normalizing tagName (case-insensitive).",
          "Class parsing must handle multiple classes separated by spaces."
        ],
        "edgeCases": [
          "Boundary is null/undefined (walk until root).",
          "Selector is empty/whitespace (should return null).",
          "Nodes missing `className` or `parentNode`."
        ],
        "techniques": [
          "Ancestor traversal via parent pointers",
          "Small selector parser (tag / .class / tag.class)"
        ]
      },
      "followUpQuestions": [
        "js-dom-walk-text-content-3"
      ],
      "resources": [
        {
          "title": "MDN – Element.closest",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/closest"
        }
      ]
    },
    "tests": "import closestWithin from './file';\n\ndescribe('closestWithin', () => {\n  function node(tagName, className, parentNode) {\n    return { tagName, className, parentNode };\n  }\n\n  test('finds the node itself if it matches', () => {\n    const root = node('div', 'root', null);\n    const btn = node('button', 'primary', root);\n    expect(closestWithin(btn, 'button.primary', root)).toBe(btn);\n  });\n\n  test('finds closest matching ancestor', () => {\n    const root = node('div', 'root', null);\n    const container = node('div', 'container', root);\n    const btn = node('button', 'primary', container);\n    const span = node('span', '', btn);\n\n    expect(closestWithin(span, 'button.primary', root)).toBe(btn);\n    expect(closestWithin(span, '.container', root)).toBe(container);\n  });\n\n  test('does not walk above boundary (inclusive)', () => {\n    const root = node('div', 'root', null);\n    const container = node('div', 'container', root);\n    const btn = node('button', 'primary', container);\n    const span = node('span', '', btn);\n\n    // boundary is container, selector matches root, but should not reach it\n    expect(closestWithin(span, '.root', container)).toBe(null);\n  });\n\n  test('returns null when not found', () => {\n    const root = node('div', 'root', null);\n    const a = node('a', '', root);\n    expect(closestWithin(a, 'button', root)).toBe(null);\n  });\n\n  test('handles nullish node', () => {\n    expect(closestWithin(null, 'div', null)).toBe(null);\n    expect(closestWithin(undefined, 'div', null)).toBe(null);\n  });\n\n  test('tag matching is case-insensitive', () => {\n    const root = node('DIV', 'root', null);\n    const child = node('Button', 'primary', root);\n    expect(closestWithin(child, 'button.primary', root)).toBe(child);\n  });\n\n  test('class matching supports multiple classes', () => {\n    const root = node('div', 'root', null);\n    const child = node('button', 'primary big', root);\n    expect(closestWithin(child, '.big', root)).toBe(child);\n    expect(closestWithin(child, 'button.primary', root)).toBe(child);\n  });\n});\n",
    "testsTs": "import closestWithin from './file';\n\ndescribe('closestWithin (TypeScript)', () => {\n  const node = (tagName: string, className?: string, parentNode?: any) => ({\n    tagName,\n    className,\n    parentNode: parentNode ?? null\n  });\n\n  it('finds closest matching ancestor', () => {\n    const root = node('div', 'root');\n    const container = node('div', 'container', root);\n    const btn = node('button', 'primary', container);\n    const span = node('span', '', btn);\n\n    expect(closestWithin(span as any, 'button.primary', root as any)).toBe(btn);\n  });\n\n  it('does not walk above boundary', () => {\n    const root = node('div', 'root');\n    const container = node('div', 'container', root);\n    const leaf = node('span', '', container);\n\n    expect(closestWithin(leaf as any, '.root', container as any)).toBe(null);\n  });\n\n  it('returns null for nullish node', () => {\n    expect(closestWithin(null as any, 'div', null as any)).toBe(null);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ]
  },
  {
    "id": "js-dom-walk-text-content-3",
    "title": "DOM Tree Walk 3: Basic Selector Engine (Hard)",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "hard",
    "tags": [
      "dom",
      "tree",
      "selectors",
      "polyfills"
    ],
    "description": {
      "summary": "Implement a small selector engine: `queryAll(root, selector)` that returns all matching nodes in **document order** from a **DOM-like** tree.\n\nThis is a classic \"build a tiny `querySelectorAll`\" interview task.\n\nDOM-like node shape:\n- `nodeType`: `1` for element, `3` for text\n- `tagName`: string for elements (case-insensitive)\n- `id?`: string\n- `className?`: string with space-separated classes\n- `childNodes?`: array of children\n\nSelector support (single selector, no commas):\n1) Tag: `div`\n2) Class: `.item`\n3) Id: `#main`\n4) Tag + class: `button.primary`\n5) Descendant combinator (one or more spaces): `div .item` or `#main button.primary`\n\nRequirements:\n1) Only element nodes (`nodeType === 1`) can match.\n2) Traverse the tree without using real DOM (`document` not allowed).\n3) Return matches as an array in document order.\n4) Throw `TypeError` if `root` is missing/invalid or selector is not a non-empty string.\n\nNotes:\n- Ignore pseudo-classes, attributes, `&gt;`, `+`, `~`, `:not`, `,`.\n- Input is controlled; you can assume `tagName` exists for element nodes.\n\nThis tests traversal + selector parsing + ancestor reasoning.",
      "arguments": [
        {
          "name": "root",
          "type": "any",
          "desc": "Root element node of the DOM-like tree."
        },
        {
          "name": "selector",
          "type": "string",
          "desc": "Selector string supporting tag/.class/#id/tag.class and descendant chains."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "Array of matching element nodes in document order."
      },
      "examples": [
        "// Tree: <div id=\"main\"><button class=\"primary\"></button><div class=\"item\"></div></div>\nqueryAll(root, '#main button.primary'); // => [button]\nqueryAll(root, 'div .item'); // => [div.item]"
      ]
    },
    "starterCode": "export default function queryAll(root, selector) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type DomLikeNode = {\n  nodeType: number;\n  tagName?: string;\n  id?: string;\n  className?: string;\n  childNodes?: DomLikeNode[];\n  parentNode?: DomLikeNode | null;\n};\n\nexport default function queryAll(root: DomLikeNode, selector: string): DomLikeNode[] {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: build a tiny `querySelectorAll` for a DOM-like tree. Parse the selector into simple tokens, traverse all nodes in document order, and for each node check whether it matches the selector chain via ancestor walking.",
      "approaches": [
        {
          "title": "Approach: Parse into descendant steps + match by walking ancestors (recommended)",
          "prose": "High-level plan\n1) Parse selector into steps split by whitespace: e.g. `'#main button.primary'` => [`#main`, `button.primary`].\n2) DFS traverse all element nodes in document order.\n3) For each candidate element, check if it matches the last step.\n4) If yes, walk ancestors to satisfy previous steps in reverse order.\n\nWhy it works\nA descendant selector chain is satisfied if you can find matching ancestors for each step in order.\n\nComplexity\n- Traversal: O(N)\n- For each candidate, ancestor checks: O(H * K)\nTotal worst-case: O(N * H), acceptable for interview scale.",
          "codeJs": "function classes(node) {\n  return String(node.className || '').split(/\\s+/).filter(Boolean);\n}\n\nfunction hasClass(node, cls) {\n  return classes(node).includes(cls);\n}\n\nfunction parseStep(step) {\n  // supports: tag, .cls, #id, tag.cls\n  const s = step.trim();\n  if (!s) return null;\n\n  if (s.startsWith('#')) return { kind: 'id', id: s.slice(1) };\n  if (s.startsWith('.')) return { kind: 'class', cls: s.slice(1) };\n\n  const [tag, cls] = s.split('.');\n  if (cls) return { kind: 'tagClass', tag, cls };\n  return { kind: 'tag', tag: s };\n}\n\nfunction matchesStep(node, stepObj) {\n  if (!node || node.nodeType !== 1) return false;\n\n  switch (stepObj.kind) {\n    case 'id':\n      return String(node.id || '') === stepObj.id;\n    case 'class':\n      return hasClass(node, stepObj.cls);\n    case 'tag':\n      return String(node.tagName || '').toLowerCase() === String(stepObj.tag).toLowerCase();\n    case 'tagClass':\n      return (\n        String(node.tagName || '').toLowerCase() === String(stepObj.tag).toLowerCase() &&\n        hasClass(node, stepObj.cls)\n      );\n    default:\n      return false;\n  }\n}\n\nfunction parseSelector(selector) {\n  // collapse whitespace, split by spaces (descendant combinator)\n  const parts = String(selector).trim().split(/\\s+/).filter(Boolean);\n  if (parts.length === 0) return [];\n\n  const steps = [];\n  for (const p of parts) {\n    const step = parseStep(p);\n    if (!step) return [];\n    steps.push(step);\n  }\n  return steps;\n}\n\nfunction matchesChain(el, steps) {\n  // steps are descendant chain, e.g. [#main, button.primary]\n  // match from last step, then find ancestors for previous steps\n  let cur = el;\n  if (!matchesStep(cur, steps[steps.length - 1])) return false;\n\n  for (let i = steps.length - 2; i >= 0; i--) {\n    const needed = steps[i];\n    let anc = cur.parentNode || null;\n    let found = null;\n    while (anc) {\n      if (matchesStep(anc, needed)) {\n        found = anc;\n        break;\n      }\n      anc = anc.parentNode || null;\n    }\n    if (!found) return false;\n    cur = found;\n  }\n  return true;\n}\n\nfunction dfs(root, visit) {\n  const children = Array.isArray(root.childNodes) ? root.childNodes : [];\n  for (const child of children) {\n    if (child && child.nodeType === 1) visit(child);\n    dfs(child || {}, visit);\n  }\n}\n\nexport default function queryAll(root, selector) {\n  if (!root || root.nodeType !== 1) {\n    throw new TypeError('queryAll: root must be an element node');\n  }\n  if (typeof selector !== 'string' || selector.trim() === '') {\n    throw new TypeError('queryAll: selector must be a non-empty string');\n  }\n\n  const steps = parseSelector(selector);\n  if (steps.length === 0) return [];\n\n  const out = [];\n\n  // consider root itself as candidate too\n  if (matchesChain(root, steps)) out.push(root);\n\n  dfs(root, (el) => {\n    if (matchesChain(el, steps)) out.push(el);\n  });\n\n  return out;\n}\n",
          "codeTs": "type DomLikeNode = {\n  nodeType: number;\n  tagName?: string;\n  id?: string;\n  className?: string;\n  childNodes?: DomLikeNode[];\n  parentNode?: DomLikeNode | null;\n};\n\ntype Step =\n  | { kind: 'id'; id: string }\n  | { kind: 'class'; cls: string }\n  | { kind: 'tag'; tag: string }\n  | { kind: 'tagClass'; tag: string; cls: string };\n\nfunction classes(node: DomLikeNode): string[] {\n  return String(node.className || '').split(/\\s+/).filter(Boolean);\n}\n\nfunction hasClass(node: DomLikeNode, cls: string): boolean {\n  return classes(node).includes(cls);\n}\n\nfunction parseStep(step: string): Step | null {\n  const s = step.trim();\n  if (!s) return null;\n\n  if (s.startsWith('#')) return { kind: 'id', id: s.slice(1) };\n  if (s.startsWith('.')) return { kind: 'class', cls: s.slice(1) };\n\n  const parts = s.split('.');\n  const tag = parts[0];\n  const cls = parts[1];\n\n  if (cls) return { kind: 'tagClass', tag, cls };\n  return { kind: 'tag', tag: s };\n}\n\nfunction matchesStep(node: DomLikeNode | null | undefined, stepObj: Step): boolean {\n  if (!node || node.nodeType !== 1) return false;\n\n  switch (stepObj.kind) {\n    case 'id':\n      return String(node.id || '') === stepObj.id;\n    case 'class':\n      return hasClass(node, stepObj.cls);\n    case 'tag':\n      return String(node.tagName || '').toLowerCase() === String(stepObj.tag).toLowerCase();\n    case 'tagClass':\n      return (\n        String(node.tagName || '').toLowerCase() === String(stepObj.tag).toLowerCase() &&\n        hasClass(node, stepObj.cls)\n      );\n    default:\n      return false;\n  }\n}\n\nfunction parseSelector(selector: string): Step[] {\n  const parts = String(selector).trim().split(/\\s+/).filter(Boolean);\n  const steps: Step[] = [];\n  for (const p of parts) {\n    const step = parseStep(p);\n    if (!step) return [];\n    steps.push(step);\n  }\n  return steps;\n}\n\nfunction matchesChain(el: DomLikeNode, steps: Step[]): boolean {\n  let cur: DomLikeNode | null = el;\n  if (!matchesStep(cur, steps[steps.length - 1])) return false;\n\n  for (let i = steps.length - 2; i >= 0; i--) {\n    const needed = steps[i];\n    let anc: DomLikeNode | null = cur.parentNode || null;\n    let found: DomLikeNode | null = null;\n    while (anc) {\n      if (matchesStep(anc, needed)) {\n        found = anc;\n        break;\n      }\n      anc = anc.parentNode || null;\n    }\n    if (!found) return false;\n    cur = found;\n  }\n  return true;\n}\n\nfunction dfs(root: DomLikeNode, visit: (el: DomLikeNode) => void): void {\n  const children = Array.isArray(root.childNodes) ? root.childNodes : [];\n  for (const child of children) {\n    if (child && child.nodeType === 1) visit(child);\n    if (child) dfs(child, visit);\n  }\n}\n\nexport default function queryAll(root: DomLikeNode, selector: string): DomLikeNode[] {\n  if (!root || root.nodeType !== 1) {\n    throw new TypeError('queryAll: root must be an element node');\n  }\n  if (typeof selector !== 'string' || selector.trim() === '') {\n    throw new TypeError('queryAll: selector must be a non-empty string');\n  }\n\n  const steps = parseSelector(selector);\n  if (steps.length === 0) return [];\n\n  const out: DomLikeNode[] = [];\n\n  if (matchesChain(root, steps)) out.push(root);\n\n  dfs(root, (el) => {\n    if (matchesChain(el, steps)) out.push(el);\n  });\n\n  return out;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to include `root` as a candidate match.",
          "Not ensuring `parentNode` exists on input nodes (tests provide it; mention in docs).",
          "Incorrect document order (must traverse children left-to-right).",
          "Treating text nodes as match candidates (only nodeType 1 can match).",
          "Selector parsing: multiple spaces should behave like one."
        ],
        "edgeCases": [
          "Selector with extra whitespace: `'  #main   button.primary  '`.",
          "No matches returns empty array.",
          "Root matches the selector (single-step) and should be included."
        ],
        "techniques": [
          "DFS traversal in document order",
          "Parsing simple selector tokens",
          "Ancestor chain matching for descendant selectors"
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "MDN – Document.querySelectorAll",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll"
        }
      ]
    },
    "tests": "import queryAll from './file';\n\nfunction el(tagName, opts = {}) {\n  return {\n    nodeType: 1,\n    tagName,\n    id: opts.id,\n    className: opts.className || '',\n    childNodes: [],\n    parentNode: null\n  };\n}\n\nfunction text(value) {\n  return { nodeType: 3, nodeValue: value, childNodes: [], parentNode: null };\n}\n\nfunction append(parent, child) {\n  parent.childNodes.push(child);\n  child.parentNode = parent;\n  return child;\n}\n\ndescribe('queryAll (Basic selector polyfill, DOM-like)', () => {\n  test('throws on invalid args', () => {\n    expect(() => queryAll(null, 'div')).toThrow(TypeError);\n    expect(() => queryAll({ nodeType: 3 }, 'div')).toThrow(TypeError);\n    expect(() => queryAll(el('div'), '')).toThrow(TypeError);\n    expect(() => queryAll(el('div'), '   ')).toThrow(TypeError);\n  });\n\n  test('matches tag selector', () => {\n    const root = el('div');\n    const a = append(root, el('div'));\n    const b = append(root, el('span'));\n    const c = append(b, el('div'));\n\n    expect(queryAll(root, 'div')).toEqual([root, a, c]);\n  });\n\n  test('matches class selector', () => {\n    const root = el('div', { className: 'root' });\n    const a = append(root, el('div', { className: 'item' }));\n    const b = append(root, el('div', { className: 'item big' }));\n    append(root, el('div', { className: 'nope' }));\n\n    expect(queryAll(root, '.item')).toEqual([a, b]);\n  });\n\n  test('matches id selector', () => {\n    const root = el('div');\n    const a = append(root, el('div', { id: 'main' }));\n    append(root, el('div', { id: 'other' }));\n\n    expect(queryAll(root, '#main')).toEqual([a]);\n  });\n\n  test('matches tag.class selector', () => {\n    const root = el('div');\n    const a = append(root, el('button', { className: 'primary' }));\n    append(root, el('button', { className: 'secondary' }));\n    append(root, el('div', { className: 'primary' }));\n\n    expect(queryAll(root, 'button.primary')).toEqual([a]);\n  });\n\n  test('supports descendant selector chains', () => {\n    const root = el('div');\n    const main = append(root, el('div', { id: 'main' }));\n    const btn1 = append(main, el('button', { className: 'primary' }));\n    const other = append(root, el('div', { id: 'other' }));\n    append(other, el('button', { className: 'primary' }));\n\n    expect(queryAll(root, '#main button.primary')).toEqual([btn1]);\n  });\n\n  test('ignores text nodes and keeps document order', () => {\n    const root = el('div');\n    append(root, text('hello'));\n    const a = append(root, el('div', { className: 'item' }));\n    append(a, text('x'));\n    const b = append(root, el('div', { className: 'item' }));\n\n    expect(queryAll(root, '.item')).toEqual([a, b]);\n  });\n\n  test('handles extra whitespace in selector', () => {\n    const root = el('div');\n    const main = append(root, el('div', { id: 'main' }));\n    const btn1 = append(main, el('button', { className: 'primary' }));\n\n    expect(queryAll(root, '   #main    button.primary   ')).toEqual([btn1]);\n  });\n\n  test('returns empty array when no match', () => {\n    const root = el('div');\n    append(root, el('span'));\n    expect(queryAll(root, 'button')).toEqual([]);\n  });\n});\n",
    "testsTs": "import queryAll from './file';\n\ntype DomLikeNode = any;\n\nfunction el(tagName: string, opts: { id?: string; className?: string } = {}): DomLikeNode {\n  return {\n    nodeType: 1,\n    tagName,\n    id: opts.id,\n    className: opts.className || '',\n    childNodes: [] as DomLikeNode[],\n    parentNode: null as DomLikeNode | null\n  };\n}\n\nfunction append(parent: DomLikeNode, child: DomLikeNode): DomLikeNode {\n  parent.childNodes.push(child);\n  child.parentNode = parent;\n  return child;\n}\n\ndescribe('queryAll (TypeScript)', () => {\n  it('supports descendant selector chains', () => {\n    const root = el('div');\n    const main = append(root, el('div', { id: 'main' }));\n    const btn = append(main, el('button', { className: 'primary' }));\n\n    expect(queryAll(root, '#main button.primary')).toEqual([btn]);\n  });\n\n  it('returns matches in document order', () => {\n    const root = el('div');\n    const a = append(root, el('div', { className: 'item' }));\n    const b = append(root, el('div', { className: 'item' }));\n    expect(queryAll(root, '.item')).toEqual([a, b]);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ]
  },
  {
    "id": "js-selector-polyfill-matches-1",
    "title": "Selector Polyfill 1: Implement `matchesSimple`",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "dom",
      "selectors",
      "polyfills"
    ],
    "description": {
      "summary": "Implement `matchesSimple(node, selector)` — a tiny subset of `Element.matches()`.\n\nThis is extremely common in frontend interviews because it underpins event delegation and DOM utilities.\n\nNode shape (DOM-like, not real DOM):\n- `tagName: string` (case-insensitive)\n- `id?: string`\n- `className?: string` (space-separated classes)\n\nSelector support (single selector only):\n1) Tag: `div`\n2) Id: `#main`\n3) Class: `.item`\n4) Tag + class: `button.primary`\n\nRequirements:\n- Return `true` if the node matches the selector, else `false`.\n- Must be defensive: nullish node or invalid selector =&gt; `false`.\n- No `document`, no real DOM.\n\nThis tests CSS selector basics and practical matching logic.",
      "arguments": [
        {
          "name": "node",
          "type": "any",
          "desc": "DOM-like element node."
        },
        {
          "name": "selector",
          "type": "string",
          "desc": "Selector string: tag, #id, .class, or tag.class."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if the node matches the selector; otherwise `false`."
      },
      "examples": [
        "const el = { tagName: 'button', id: 'save', className: 'primary big' };\n\nmatchesSimple(el, 'button'); // => true\nmatchesSimple(el, '#save'); // => true\nmatchesSimple(el, '.big'); // => true\nmatchesSimple(el, 'button.primary'); // => true\nmatchesSimple(el, 'div'); // => false"
      ]
    },
    "starterCode": "export default function matchesSimple(node, selector) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type DomLikeNode = {\n  tagName: string;\n  id?: string;\n  className?: string;\n};\n\nexport default function matchesSimple(node: DomLikeNode | null | undefined, selector: string): boolean {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Implement a tiny `matches()` for a DOM-like node. Parse a single selector that can be a tag (`div`), id (`#main`), class (`.item`), or tag+class (`button.primary`). Normalize tag casing, split `className` on whitespace, and return false for invalid input. This powers event delegation and small DOM utilities.",
      "approaches": [
        {
          "title": "Approach: Minimal parsing + defensive checks (recommended)",
          "prose": "Parsing strategy:\n- Trim the selector and short-circuit on empty/null input.\n- If it starts with `#`, compare `node.id` to the selector without the hash.\n- If it starts with `.`, split `node.className` by whitespace and check for inclusion.\n- Otherwise, if it contains a `.`, split into `tag` and `class` and require both to match.\n- Otherwise treat it as a plain tag selector.\n\nImplementation details:\n- Compare tags in lowercase so `DIV` matches `div`.\n- Guard against missing `className` or `id`.\n\nComplexity: O(c) for class tokens, O(1) extra space.",
          "codeJs": "function hasClass(node, cls) {\n  const list = String(node.className || '').split(/\\s+/).filter(Boolean);\n  return list.includes(cls);\n}\n\nexport default function matchesSimple(node, selector) {\n  if (!node || typeof selector !== 'string') return false;\n\n  const s = selector.trim();\n  if (!s) return false;\n\n  // #id\n  if (s.startsWith('#')) {\n    const id = s.slice(1);\n    if (!id) return false;\n    return String(node.id || '') === id;\n  }\n\n  // .class\n  if (s.startsWith('.')) {\n    const cls = s.slice(1);\n    if (!cls) return false;\n    return hasClass(node, cls);\n  }\n\n  // tag or tag.class\n  const parts = s.split('.');\n  const tag = parts[0];\n  const cls = parts[1];\n\n  if (!tag) return false;\n  if (String(node.tagName || '').toLowerCase() !== tag.toLowerCase()) return false;\n\n  if (cls) return hasClass(node, cls);\n  return true;\n}\n",
          "codeTs": "type DomLikeNode = {\n  tagName: string;\n  id?: string;\n  className?: string;\n};\n\nfunction hasClass(node: DomLikeNode, cls: string): boolean {\n  const list = String(node.className || '').split(/\\s+/).filter(Boolean);\n  return list.includes(cls);\n}\n\nexport default function matchesSimple(node: DomLikeNode | null | undefined, selector: string): boolean {\n  if (!node || typeof selector !== 'string') return false;\n\n  const s = selector.trim();\n  if (!s) return false;\n\n  if (s.startsWith('#')) {\n    const id = s.slice(1);\n    if (!id) return false;\n    return String(node.id || '') === id;\n  }\n\n  if (s.startsWith('.')) {\n    const cls = s.slice(1);\n    if (!cls) return false;\n    return hasClass(node, cls);\n  }\n\n  const parts = s.split('.');\n  const tag = parts[0];\n  const cls = parts[1];\n\n  if (!tag) return false;\n  if (String(node.tagName || '').toLowerCase() !== tag.toLowerCase()) return false;\n\n  if (cls) return hasClass(node, cls);\n  return true;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Not handling multiple classes in `className` (space-separated).",
          "Case-sensitive tag comparisons (HTML tag names should be treated case-insensitively).",
          "Treating empty selector like a match (should be false).",
          "Assuming `id` or `className` always exist."
        ],
        "edgeCases": [
          "Selector is whitespace or invalid like '#', '.' => false.",
          "Node has empty className, selector is '.x' => false.",
          "Node tagName is 'DIV' and selector 'div' => true."
        ],
        "techniques": [
          "String parsing (prefix checks and split)",
          "Whitespace class tokenization"
        ]
      },
      "followUpQuestions": [
        "js-selector-polyfill-closest-2"
      ],
      "resources": [
        {
          "title": "MDN – Element.matches()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/matches"
        }
      ]
    },
    "tests": "import matchesSimple from './file';\n\ndescribe('matchesSimple', () => {\n  test('matches tag', () => {\n    expect(matchesSimple({ tagName: 'div' }, 'div')).toBe(true);\n    expect(matchesSimple({ tagName: 'DIV' }, 'div')).toBe(true);\n    expect(matchesSimple({ tagName: 'span' }, 'div')).toBe(false);\n  });\n\n  test('matches id', () => {\n    expect(matchesSimple({ tagName: 'div', id: 'main' }, '#main')).toBe(true);\n    expect(matchesSimple({ tagName: 'div', id: 'x' }, '#main')).toBe(false);\n  });\n\n  test('matches class', () => {\n    expect(matchesSimple({ tagName: 'div', className: 'item' }, '.item')).toBe(true);\n    expect(matchesSimple({ tagName: 'div', className: 'item big' }, '.big')).toBe(true);\n    expect(matchesSimple({ tagName: 'div', className: 'item big' }, '.nope')).toBe(false);\n  });\n\n  test('matches tag.class', () => {\n    expect(matchesSimple({ tagName: 'button', className: 'primary' }, 'button.primary')).toBe(true);\n    expect(matchesSimple({ tagName: 'button', className: 'secondary' }, 'button.primary')).toBe(false);\n    expect(matchesSimple({ tagName: 'div', className: 'primary' }, 'button.primary')).toBe(false);\n  });\n\n  test('defensive: invalid inputs return false', () => {\n    expect(matchesSimple(null, 'div')).toBe(false);\n    expect(matchesSimple(undefined, 'div')).toBe(false);\n    expect(matchesSimple({ tagName: 'div' }, '')).toBe(false);\n    expect(matchesSimple({ tagName: 'div' }, '   ')).toBe(false);\n    expect(matchesSimple({ tagName: 'div' }, '#')).toBe(false);\n    expect(matchesSimple({ tagName: 'div' }, '.')).toBe(false);\n  });\n});\n",
    "testsTs": "import matchesSimple from './file';\n\ndescribe('matchesSimple (TypeScript)', () => {\n  it('matches tag/class/id basics', () => {\n    expect(matchesSimple({ tagName: 'DIV', className: 'a b', id: 'x' } as any, 'div')).toBe(true);\n    expect(matchesSimple({ tagName: 'div', className: 'a b' } as any, '.b')).toBe(true);\n    expect(matchesSimple({ tagName: 'div', id: 'x' } as any, '#x')).toBe(true);\n    expect(matchesSimple({ tagName: 'button', className: 'primary' } as any, 'button.primary')).toBe(true);\n  });\n\n  it('is defensive', () => {\n    expect(matchesSimple(null as any, 'div')).toBe(false);\n    expect(matchesSimple({ tagName: 'div' } as any, '   ')).toBe(false);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ]
  },
  {
    "id": "js-recover-bst-swapped-nodes",
    "title": "Recover a BST with Two Swapped Nodes",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "tree",
      "bst",
      "algorithms",
      "traversal",
      "recursion"
    ],
    "description": {
      "summary": "Two nodes in a Binary Search Tree were swapped by mistake. Implement `recoverBST(root)` to fix the tree **in-place** (swap the two values back) and return the original root.\n\nThis is a classic medium algorithm problem (often seen in interviews). A common follow-up is: how would you apply the same idea to a real system when a \"sorted\" data structure gets corrupted (e.g., a ranking list or cached order)?",
      "arguments": [
        {
          "name": "root",
          "type": "TreeNode | null",
          "desc": "Root of a BST where exactly two nodes have their values swapped."
        }
      ],
      "returns": {
        "type": "TreeNode | null",
        "desc": "The same root reference, after fixing the swapped values."
      },
      "examples": [
        "// Tree (BST) inorder should be sorted: [1,2,3,4]\n// Suppose values 2 and 4 are swapped:\n// inorder becomes [1,4,3,2]\n// After recoverBST(root), inorder is [1,2,3,4]"
      ]
    },
    "starterCode": "export default function recoverBST(root) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type TreeNode = {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n};\n\nexport default function recoverBST(root: TreeNode | null): TreeNode | null {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "In a valid BST, an inorder traversal yields a sorted sequence. If two nodes are swapped, the inorder sequence will have **two inversions** (or one inversion if the swapped nodes are adjacent in inorder). Track the previous node during inorder traversal and record the two nodes that violate sorted order. Then swap their values.\n\n**Complexity**\n- Time: O(n)\n- Space: O(h) recursion stack (or O(1) with Morris traversal, optional)\n\n**Follow-up (Netflix-style)**\nDiscuss how you’d detect and repair a swapped order in a production list: find the two out-of-order entries in a nearly-sorted ranking and fix them without a full re-sort.",
      "approaches": [
        {
          "title": "Inorder traversal with two-pointer fix",
          "prose": "Walk the tree in-order, keeping a `prev` pointer. When `prev.val > curr.val`, it’s an inversion. The first time this happens, mark `first = prev` and `second = curr`. If it happens again, update `second = curr`. After traversal, swap `first.val` and `second.val`.",
          "codeJs": "export default function recoverBST(root) {\n  if (!root) return root;\n\n  let first = null;\n  let second = null;\n  let prev = null;\n\n  const dfs = (node) => {\n    if (!node) return;\n    dfs(node.left);\n\n    if (prev && prev.val > node.val) {\n      if (!first) first = prev;\n      second = node;\n    }\n    prev = node;\n\n    dfs(node.right);\n  };\n\n  dfs(root);\n\n  if (first && second) {\n    const tmp = first.val;\n    first.val = second.val;\n    second.val = tmp;\n  }\n\n  return root;\n}\n",
          "codeTs": "type TreeNode = {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n};\n\nexport default function recoverBST(root: TreeNode | null): TreeNode | null {\n  if (!root) return root;\n\n  let first: TreeNode | null = null;\n  let second: TreeNode | null = null;\n  let prev: TreeNode | null = null;\n\n  const dfs = (node: TreeNode | null) => {\n    if (!node) return;\n    dfs(node.left);\n\n    if (prev && prev.val > node.val) {\n      if (!first) first = prev;\n      second = node;\n    }\n    prev = node;\n\n    dfs(node.right);\n  };\n\n  dfs(root);\n\n  if (first && second) {\n    const tmp = first.val;\n    first.val = second.val;\n    second.val = tmp;\n  }\n\n  return root;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Only capturing the first inversion and forgetting the second (non-adjacent swap).",
          "Swapping nodes instead of values (unnecessary for this task).",
          "Assuming the tree is balanced (it may be skewed)."
        ],
        "edgeCases": [
          "Swapped nodes are adjacent in inorder (only one inversion).",
          "Swapped node includes the root.",
          "Tree has 0 or 1 node (no-op)."
        ],
        "techniques": [
          "Inorder traversal and inversion detection",
          "Tracking `prev` node to detect order breaks"
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "BST inorder traversal (Wikipedia)",
          "url": "https://en.wikipedia.org/wiki/Tree_traversal"
        }
      ]
    },
    "tests": "import recoverBST from './file';\n\nclass TreeNode {\n  constructor(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction inorderVals(root, out = []) {\n  if (!root) return out;\n  inorderVals(root.left, out);\n  out.push(root.val);\n  inorderVals(root.right, out);\n  return out;\n}\n\nfunction buildSampleBST() {\n  // Perfect BST with values 1..7\n  const n1 = new TreeNode(1);\n  const n2 = new TreeNode(2);\n  const n3 = new TreeNode(3);\n  const n4 = new TreeNode(4);\n  const n5 = new TreeNode(5);\n  const n6 = new TreeNode(6);\n  const n7 = new TreeNode(7);\n  n4.left = n2; n4.right = n6;\n  n2.left = n1; n2.right = n3;\n  n6.left = n5; n6.right = n7;\n  return { root: n4, nodes: { n1, n2, n3, n4, n5, n6, n7 } };\n}\n\ndescribe('recoverBST', () => {\n  test('fixes non-adjacent swapped nodes', () => {\n    const { root, nodes } = buildSampleBST();\n    // Swap 3 and 6 (non-adjacent in inorder)\n    const tmp = nodes.n3.val;\n    nodes.n3.val = nodes.n6.val;\n    nodes.n6.val = tmp;\n\n    const out = recoverBST(root);\n    expect(out).toBe(root);\n    expect(inorderVals(root)).toEqual([1, 2, 3, 4, 5, 6, 7]);\n  });\n\n  test('fixes adjacent swapped nodes', () => {\n    const { root, nodes } = buildSampleBST();\n    // Swap 2 and 3 (adjacent in inorder)\n    const tmp = nodes.n2.val;\n    nodes.n2.val = nodes.n3.val;\n    nodes.n3.val = tmp;\n\n    recoverBST(root);\n    expect(inorderVals(root)).toEqual([1, 2, 3, 4, 5, 6, 7]);\n  });\n\n  test('handles swap involving root', () => {\n    const { root, nodes } = buildSampleBST();\n    // Swap root (4) with leaf (1)\n    const tmp = nodes.n4.val;\n    nodes.n4.val = nodes.n1.val;\n    nodes.n1.val = tmp;\n\n    recoverBST(root);\n    expect(inorderVals(root)).toEqual([1, 2, 3, 4, 5, 6, 7]);\n  });\n\n  test('handles null or single-node trees', () => {\n    expect(recoverBST(null)).toBe(null);\n    const solo = new TreeNode(5);\n    recoverBST(solo);\n    expect(inorderVals(solo)).toEqual([5]);\n  });\n});\n",
    "testsTs": "import recoverBST from './file';\n\ntype TreeNode = {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n};\n\nfunction makeNode(val: number, left: TreeNode | null = null, right: TreeNode | null = null): TreeNode {\n  return { val, left, right };\n}\n\nfunction inorderVals(root: TreeNode | null, out: number[] = []): number[] {\n  if (!root) return out;\n  inorderVals(root.left, out);\n  out.push(root.val);\n  inorderVals(root.right, out);\n  return out;\n}\n\nfunction buildSampleBST() {\n  const n1 = makeNode(1);\n  const n2 = makeNode(2);\n  const n3 = makeNode(3);\n  const n4 = makeNode(4);\n  const n5 = makeNode(5);\n  const n6 = makeNode(6);\n  const n7 = makeNode(7);\n  n4.left = n2; n4.right = n6;\n  n2.left = n1; n2.right = n3;\n  n6.left = n5; n6.right = n7;\n  return { root: n4, nodes: { n1, n2, n3, n4, n5, n6, n7 } };\n}\n\ndescribe('recoverBST (TypeScript)', () => {\n  it('fixes non-adjacent swapped nodes', () => {\n    const { root, nodes } = buildSampleBST();\n    const tmp = nodes.n3.val;\n    nodes.n3.val = nodes.n6.val;\n    nodes.n6.val = tmp;\n\n    recoverBST(root);\n    expect(inorderVals(root)).toEqual([1, 2, 3, 4, 5, 6, 7]);\n  });\n\n  it('fixes adjacent swapped nodes', () => {\n    const { root, nodes } = buildSampleBST();\n    const tmp = nodes.n2.val;\n    nodes.n2.val = nodes.n3.val;\n    nodes.n3.val = tmp;\n\n    recoverBST(root);\n    expect(inorderVals(root)).toEqual([1, 2, 3, 4, 5, 6, 7]);\n  });\n\n  it('handles null tree', () => {\n    expect(recoverBST(null)).toBe(null);\n  });\n});\n",
    "companies": [
      "netflix"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-selector-polyfill-closest-2",
    "title": "Selector Polyfill 2: Implement `closestSimple`",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "intermediate",
    "tags": [
      "dom",
      "selectors",
      "polyfills",
      "tree"
    ],
    "description": {
      "summary": "Implement `closestSimple(node, selector)` — a DOM-like polyfill for `Element.closest()` using **only** `parentNode` traversal.\n\nWhy this is common: closest() is used constantly in event delegation and component boundary checks.\n\nNode shape (DOM-like, not real DOM):\n- `tagName: string` (case-insensitive)\n- `id?: string`\n- `className?: string` (space-separated classes)\n- `parentNode?: Node | null`\n\nSelector support (single selector only):\n1) Tag: `div`\n2) Id: `#main`\n3) Class: `.item`\n4) Tag + class: `button.primary`\n\nRequirements:\n1) Start at `node` itself; if it matches, return it.\n2) Otherwise, walk up via `parentNode` and return the first matching ancestor.\n3) If nothing matches, return `null`.\n4) Defensive: if `node` is nullish or selector is invalid/empty =&gt; return `null`.\n5) No real DOM usage (`document` forbidden).\n\nThis tests selector matching + ancestor traversal.",
      "arguments": [
        {
          "name": "node",
          "type": "any",
          "desc": "Starting DOM-like node."
        },
        {
          "name": "selector",
          "type": "string",
          "desc": "Selector string: tag, #id, .class, or tag.class."
        }
      ],
      "returns": {
        "type": "any | null",
        "desc": "The closest matching node (including itself), otherwise `null`."
      },
      "examples": [
        "const root = { tagName: 'div', className: 'root', parentNode: null };\nconst container = { tagName: 'div', className: 'container', parentNode: root };\nconst btn = { tagName: 'button', className: 'primary', parentNode: container };\nconst span = { tagName: 'span', parentNode: btn };\n\nclosestSimple(span, 'button.primary') === btn; // true\nclosestSimple(span, '.container') === container; // true\nclosestSimple(span, '#missing'); // => null"
      ]
    },
    "starterCode": "export default function closestSimple(node, selector) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type DomLikeNode = {\n  tagName: string;\n  id?: string;\n  className?: string;\n  parentNode?: DomLikeNode | null;\n};\n\nexport default function closestSimple(\n  node: DomLikeNode | null | undefined,\n  selector: string\n): DomLikeNode | null {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Recreate `Element.closest()` using only `parentNode` traversal and a simple selector matcher. Start at the current node (inclusive), check if it matches, and walk up until you either find a match or hit the root. This pattern is core to delegated event handling and component boundary checks.",
      "approaches": [
        {
          "title": "Approach: Reuse `matchesSimple` + ancestor loop (recommended)",
          "prose": "Implementation outline:\n1) Reuse a `matchesSimple(node, selector)` helper for tag/#id/.class/tag.class.\n2) If `node` or `selector` is invalid, return `null`.\n3) Set `cur = node` and loop while `cur` is truthy.\n4) If `matchesSimple(cur, selector)` return `cur`; otherwise move to `cur.parentNode`.\n5) If you reach `null`, return `null`.\n\nComplexity: O(h * c) where h is ancestor height and c is number of classes; space is O(1).",
          "codeJs": "function hasClass(node, cls) {\n  const list = String(node.className || '').split(/\\s+/).filter(Boolean);\n  return list.includes(cls);\n}\n\nfunction matchesSimple(node, selector) {\n  if (!node || typeof selector !== 'string') return false;\n  const s = selector.trim();\n  if (!s) return false;\n\n  if (s.startsWith('#')) {\n    const id = s.slice(1);\n    if (!id) return false;\n    return String(node.id || '') === id;\n  }\n\n  if (s.startsWith('.')) {\n    const cls = s.slice(1);\n    if (!cls) return false;\n    return hasClass(node, cls);\n  }\n\n  const parts = s.split('.');\n  const tag = parts[0];\n  const cls = parts[1];\n  if (!tag) return false;\n\n  if (String(node.tagName || '').toLowerCase() !== tag.toLowerCase()) return false;\n  if (cls) return hasClass(node, cls);\n  return true;\n}\n\nexport default function closestSimple(node, selector) {\n  if (!node || typeof selector !== 'string' || selector.trim() === '') return null;\n\n  let cur = node;\n  while (cur) {\n    if (matchesSimple(cur, selector)) return cur;\n    cur = cur.parentNode || null;\n  }\n  return null;\n}\n",
          "codeTs": "type DomLikeNode = {\n  tagName: string;\n  id?: string;\n  className?: string;\n  parentNode?: DomLikeNode | null;\n};\n\nfunction hasClass(node: DomLikeNode, cls: string): boolean {\n  const list = String(node.className || '').split(/\\s+/).filter(Boolean);\n  return list.includes(cls);\n}\n\nfunction matchesSimple(node: DomLikeNode, selector: string): boolean {\n  const s = selector.trim();\n  if (!s) return false;\n\n  if (s.startsWith('#')) {\n    const id = s.slice(1);\n    if (!id) return false;\n    return String(node.id || '') === id;\n  }\n\n  if (s.startsWith('.')) {\n    const cls = s.slice(1);\n    if (!cls) return false;\n    return hasClass(node, cls);\n  }\n\n  const parts = s.split('.');\n  const tag = parts[0];\n  const cls = parts[1];\n  if (!tag) return false;\n\n  if (String(node.tagName || '').toLowerCase() !== tag.toLowerCase()) return false;\n  if (cls) return hasClass(node, cls);\n  return true;\n}\n\nexport default function closestSimple(\n  node: DomLikeNode | null | undefined,\n  selector: string\n): DomLikeNode | null {\n  if (!node || typeof selector !== 'string' || selector.trim() === '') return null;\n\n  let cur: DomLikeNode | null = node;\n  while (cur) {\n    if (matchesSimple(cur, selector)) return cur;\n    cur = cur.parentNode || null;\n  }\n  return null;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to test the starting node itself.",
          "Selector empty or whitespace should return null (not throw).",
          "Tag comparisons should be case-insensitive.",
          "Class matching must handle multiple classes separated by spaces."
        ],
        "edgeCases": [
          "Node without `parentNode` should be treated as top/root.",
          "Selector '#id' when node.id is undefined => false.",
          "Selector 'tag.class' when className has multiple tokens."
        ],
        "techniques": [
          "Ancestor traversal via `parentNode`",
          "Reusable selector matcher"
        ]
      },
      "followUpQuestions": [
        "js-selector-polyfill-qsa-3"
      ],
      "resources": [
        {
          "title": "MDN – Element.closest()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/closest"
        }
      ]
    },
    "tests": "import closestSimple from './file';\n\ndescribe('closestSimple', () => {\n  const n = (tagName, className, id, parentNode) => ({\n    tagName,\n    className: className || '',\n    id,\n    parentNode: parentNode ?? null\n  });\n\n  test('returns itself when it matches', () => {\n    const root = n('div', 'root');\n    const btn = n('button', 'primary', null, root);\n    expect(closestSimple(btn, 'button.primary')).toBe(btn);\n  });\n\n  test('finds closest matching ancestor', () => {\n    const root = n('div', 'root');\n    const container = n('div', 'container', null, root);\n    const btn = n('button', 'primary', null, container);\n    const span = n('span', '', null, btn);\n\n    expect(closestSimple(span, 'button.primary')).toBe(btn);\n    expect(closestSimple(span, '.container')).toBe(container);\n    expect(closestSimple(span, '#root')).toBe(null);\n  });\n\n  test('matches id selector', () => {\n    const root = n('div', 'root', 'main');\n    const child = n('span', '', null, root);\n    expect(closestSimple(child, '#main')).toBe(root);\n  });\n\n  test('returns null when not found', () => {\n    const root = n('div', 'root');\n    const child = n('span', '', null, root);\n    expect(closestSimple(child, 'button')).toBe(null);\n  });\n\n  test('tag matching is case-insensitive', () => {\n    const root = n('DIV', 'root');\n    const child = n('Button', 'primary', null, root);\n    expect(closestSimple(child, 'button.primary')).toBe(child);\n  });\n\n  test('class matching supports multiple classes', () => {\n    const root = n('div', 'root');\n    const child = n('button', 'primary big', null, root);\n    expect(closestSimple(child, '.big')).toBe(child);\n  });\n\n  test('defensive: invalid inputs return null', () => {\n    const root = n('div', 'root');\n    expect(closestSimple(null, 'div')).toBe(null);\n    expect(closestSimple(undefined, 'div')).toBe(null);\n    expect(closestSimple(root, '')).toBe(null);\n    expect(closestSimple(root, '   ')).toBe(null);\n    expect(closestSimple(root, '#')).toBe(null);\n    expect(closestSimple(root, '.')).toBe(null);\n  });\n});\n",
    "testsTs": "import closestSimple from './file';\n\ndescribe('closestSimple (TypeScript)', () => {\n  const n = (tagName: string, className?: string, id?: string, parentNode?: any) => ({\n    tagName,\n    className: className || '',\n    id,\n    parentNode: parentNode ?? null\n  });\n\n  it('finds closest ancestor', () => {\n    const root = n('div', 'root', 'main');\n    const btn = n('button', 'primary', undefined, root);\n    const leaf = n('span', '', undefined, btn);\n\n    expect(closestSimple(leaf as any, 'button.primary')).toBe(btn);\n    expect(closestSimple(leaf as any, '#main')).toBe(root);\n  });\n\n  it('returns null for invalid inputs', () => {\n    expect(closestSimple(null as any, 'div')).toBe(null);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ]
  },
  {
    "id": "js-selector-polyfill-qsa-3",
    "title": "Selector Polyfill 3: Implement `queryAllSimple` (Hard)",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "hard",
    "tags": [
      "dom",
      "selectors",
      "polyfills",
      "tree",
      "recursion"
    ],
    "description": {
      "summary": "Implement `queryAllSimple(root, selector)` — a DOM-like polyfill for `querySelectorAll`.\n\nThis is a high-likelihood frontend interview task because it combines traversal + selector matching + descendant chain logic.\n\nDOM-like node shape (NOT real DOM):\n- `nodeType`: `1` for element, `3` for text\n- `tagName`: string (case-insensitive) for elements\n- `id?`: string\n- `className?`: string with space-separated classes\n- `childNodes?`: array of children (elements or text)\n\nSelector support (single selector, no commas):\n1) Tag: `div`\n2) Class: `.item`\n3) Id: `#main`\n4) Tag + class: `button.primary`\n5) Descendant combinator (whitespace): `div .item`, `#main button.primary`, `.a .b`\n\nRequirements:\n1) Return matching **element** nodes (nodeType === 1) in **document order**.\n2) Must include `root` itself if it matches.\n3) Must be DOM-less: no `document`, no real DOM APIs.\n4) Throw `TypeError` if `root` is not an element node or selector is not a non-empty string.\n5) Ignore unsupported syntax (`&gt;`, `+`, `~`, `:`, `[attr]`, `,`). You may treat them as invalid and throw.\n\nThis tests: parsing, DFS traversal, and ancestor reasoning for descendant selectors.",
      "arguments": [
        {
          "name": "root",
          "type": "any",
          "desc": "Root DOM-like element node to search within."
        },
        {
          "name": "selector",
          "type": "string",
          "desc": "Selector string supporting simple selectors and descendant chains."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "Array of matching element nodes in document order."
      },
      "examples": [
        "// Tree: <div id=\"main\"><button class=\"primary\"></button><div class=\"item\"></div></div>\nqueryAllSimple(root, '#main button.primary'); // => [button]\nqueryAllSimple(root, 'div .item'); // => [div.item]"
      ]
    },
    "starterCode": "export default function queryAllSimple(root, selector) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type DomLikeNode = {\n  nodeType: number;\n  tagName?: string;\n  id?: string;\n  className?: string;\n  childNodes?: DomLikeNode[];\n};\n\nexport default function queryAllSimple(root: DomLikeNode, selector: string): DomLikeNode[] {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: implement a minimal `querySelectorAll` by (1) parsing a descendant selector chain into steps, (2) DFS traversing the tree in document order, and (3) checking for each element whether it satisfies the chain using an ancestor scan computed from the DFS path (no parent pointers needed).",
      "approaches": [
        {
          "title": "Approach: DFS with ancestor stack (no parentNode needed) (recommended)",
          "prose": "Key idea\nWe avoid `parentNode` entirely by keeping a stack of ancestors during DFS.\n\nAlgorithm\n1) Validate inputs; reject unsupported tokens like `> + ~ [ ] : ,`.\n2) Parse selector into steps split by whitespace.\n3) DFS from root, maintaining `ancestors` stack (root..parent).\n4) For each element, check if it matches the last step.\n5) If yes, try to satisfy previous steps by scanning ancestors backwards (descendant combinator).\n\nWhy it works\nA descendant chain `A B C` matches an element `C` if you can find an ancestor matching `B`, and above that one matching `A`.\n\nComplexity\n- DFS: O(N)\n- Matching each candidate: O(H*K)\nOverall worst-case O(N*H), fine for interview constraints.",
          "codeJs": "function isElement(n) {\n  return !!n && n.nodeType === 1;\n}\n\nfunction classList(node) {\n  return String(node.className || '').split(/\\s+/).filter(Boolean);\n}\n\nfunction hasClass(node, cls) {\n  return classList(node).includes(cls);\n}\n\nfunction parseStep(step) {\n  const s = step.trim();\n  if (!s) return null;\n\n  if (s.startsWith('#')) return { kind: 'id', id: s.slice(1) };\n  if (s.startsWith('.')) return { kind: 'class', cls: s.slice(1) };\n\n  const parts = s.split('.');\n  const tag = parts[0];\n  const cls = parts[1];\n\n  if (!tag) return null;\n  if (cls) return { kind: 'tagClass', tag, cls };\n  return { kind: 'tag', tag: s };\n}\n\nfunction matchesStep(node, stepObj) {\n  if (!isElement(node)) return false;\n\n  switch (stepObj.kind) {\n    case 'id':\n      return String(node.id || '') === stepObj.id;\n    case 'class':\n      return hasClass(node, stepObj.cls);\n    case 'tag':\n      return String(node.tagName || '').toLowerCase() === String(stepObj.tag).toLowerCase();\n    case 'tagClass':\n      return (\n        String(node.tagName || '').toLowerCase() === String(stepObj.tag).toLowerCase() &&\n        hasClass(node, stepObj.cls)\n      );\n    default:\n      return false;\n  }\n}\n\nfunction validateSelector(selector) {\n  // keep easy + predictable: reject common unsupported syntax\n  // (you can expand later)\n  if (/[>+~,:\\[\\]]/.test(selector)) {\n    throw new TypeError('queryAllSimple: unsupported selector syntax');\n  }\n}\n\nfunction parseSelector(selector) {\n  const parts = String(selector).trim().split(/\\s+/).filter(Boolean);\n  const steps = parts.map(parseStep);\n  if (steps.some((x) => !x)) throw new TypeError('queryAllSimple: invalid selector');\n\n  // reject empty id/class\n  for (const st of steps) {\n    if (st.kind === 'id' && !st.id) throw new TypeError('queryAllSimple: invalid selector');\n    if (st.kind === 'class' && !st.cls) throw new TypeError('queryAllSimple: invalid selector');\n    if (st.kind === 'tagClass' && !st.cls) throw new TypeError('queryAllSimple: invalid selector');\n  }\n\n  return steps;\n}\n\nfunction matchesChain(node, ancestors, steps) {\n  // ancestors excludes node itself; order: root..parent\n  const lastIdx = steps.length - 1;\n  if (!matchesStep(node, steps[lastIdx])) return false;\n\n  // satisfy earlier steps by scanning ancestors backwards\n  let need = lastIdx - 1;\n  let i = ancestors.length - 1;\n\n  while (need >= 0) {\n    let found = false;\n    while (i >= 0) {\n      if (matchesStep(ancestors[i], steps[need])) {\n        found = true;\n        i -= 1;\n        break;\n      }\n      i -= 1;\n    }\n    if (!found) return false;\n    need -= 1;\n  }\n\n  return true;\n}\n\nfunction dfs(node, ancestors, visit) {\n  if (!node) return;\n\n  if (isElement(node)) {\n    visit(node, ancestors);\n    ancestors.push(node);\n  }\n\n  const children = Array.isArray(node.childNodes) ? node.childNodes : [];\n  for (const child of children) {\n    dfs(child, ancestors, visit);\n  }\n\n  if (isElement(node)) {\n    ancestors.pop();\n  }\n}\n\nexport default function queryAllSimple(root, selector) {\n  if (!isElement(root)) {\n    throw new TypeError('queryAllSimple: root must be an element node');\n  }\n  if (typeof selector !== 'string' || selector.trim() === '') {\n    throw new TypeError('queryAllSimple: selector must be a non-empty string');\n  }\n\n  validateSelector(selector);\n  const steps = parseSelector(selector);\n\n  const out = [];\n  const ancestors = [];\n\n  dfs(root, ancestors, (node, anc) => {\n    // anc is the current ancestors stack BEFORE pushing `node`\n    if (matchesChain(node, anc, steps)) out.push(node);\n  });\n\n  return out;\n}\n",
          "codeTs": "type DomLikeNode = {\n  nodeType: number;\n  tagName?: string;\n  id?: string;\n  className?: string;\n  childNodes?: DomLikeNode[];\n};\n\ntype Step =\n  | { kind: 'id'; id: string }\n  | { kind: 'class'; cls: string }\n  | { kind: 'tag'; tag: string }\n  | { kind: 'tagClass'; tag: string; cls: string };\n\nfunction isElement(n: DomLikeNode | null | undefined): n is DomLikeNode {\n  return !!n && n.nodeType === 1;\n}\n\nfunction classList(node: DomLikeNode): string[] {\n  return String(node.className || '').split(/\\s+/).filter(Boolean);\n}\n\nfunction hasClass(node: DomLikeNode, cls: string): boolean {\n  return classList(node).includes(cls);\n}\n\nfunction parseStep(step: string): Step | null {\n  const s = step.trim();\n  if (!s) return null;\n\n  if (s.startsWith('#')) return { kind: 'id', id: s.slice(1) };\n  if (s.startsWith('.')) return { kind: 'class', cls: s.slice(1) };\n\n  const parts = s.split('.');\n  const tag = parts[0];\n  const cls = parts[1];\n\n  if (!tag) return null;\n  if (cls) return { kind: 'tagClass', tag, cls };\n  return { kind: 'tag', tag: s };\n}\n\nfunction matchesStep(node: DomLikeNode, stepObj: Step): boolean {\n  switch (stepObj.kind) {\n    case 'id':\n      return String(node.id || '') === stepObj.id;\n    case 'class':\n      return hasClass(node, stepObj.cls);\n    case 'tag':\n      return String(node.tagName || '').toLowerCase() === String(stepObj.tag).toLowerCase();\n    case 'tagClass':\n      return (\n        String(node.tagName || '').toLowerCase() === String(stepObj.tag).toLowerCase() &&\n        hasClass(node, stepObj.cls)\n      );\n    default:\n      return false;\n  }\n}\n\nfunction validateSelector(selector: string): void {\n  if (/[>+~,:\\[\\]]/.test(selector)) {\n    throw new TypeError('queryAllSimple: unsupported selector syntax');\n  }\n}\n\nfunction parseSelector(selector: string): Step[] {\n  const parts = String(selector).trim().split(/\\s+/).filter(Boolean);\n  const steps = parts.map(parseStep);\n  if (steps.some((x) => !x)) throw new TypeError('queryAllSimple: invalid selector');\n\n  for (const st of steps as Step[]) {\n    if (st.kind === 'id' && !st.id) throw new TypeError('queryAllSimple: invalid selector');\n    if (st.kind === 'class' && !st.cls) throw new TypeError('queryAllSimple: invalid selector');\n    if (st.kind === 'tagClass' && !st.cls) throw new TypeError('queryAllSimple: invalid selector');\n  }\n\n  return steps as Step[];\n}\n\nfunction matchesChain(node: DomLikeNode, ancestors: DomLikeNode[], steps: Step[]): boolean {\n  const lastIdx = steps.length - 1;\n  if (!matchesStep(node, steps[lastIdx])) return false;\n\n  let need = lastIdx - 1;\n  let i = ancestors.length - 1;\n\n  while (need >= 0) {\n    let found = false;\n    while (i >= 0) {\n      if (matchesStep(ancestors[i], steps[need])) {\n        found = true;\n        i -= 1;\n        break;\n      }\n      i -= 1;\n    }\n    if (!found) return false;\n    need -= 1;\n  }\n\n  return true;\n}\n\nfunction dfs(\n  node: DomLikeNode,\n  ancestors: DomLikeNode[],\n  visit: (node: DomLikeNode, ancestors: DomLikeNode[]) => void\n): void {\n  if (!node) return;\n\n  if (isElement(node)) {\n    visit(node, ancestors);\n    ancestors.push(node);\n  }\n\n  const children = Array.isArray(node.childNodes) ? node.childNodes : [];\n  for (const child of children) {\n    if (child) dfs(child, ancestors, visit);\n  }\n\n  if (isElement(node)) {\n    ancestors.pop();\n  }\n}\n\nexport default function queryAllSimple(root: DomLikeNode, selector: string): DomLikeNode[] {\n  if (!isElement(root)) {\n    throw new TypeError('queryAllSimple: root must be an element node');\n  }\n  if (typeof selector !== 'string' || selector.trim() === '') {\n    throw new TypeError('queryAllSimple: selector must be a non-empty string');\n  }\n\n  validateSelector(selector);\n  const steps = parseSelector(selector);\n\n  const out: DomLikeNode[] = [];\n  const ancestors: DomLikeNode[] = [];\n\n  dfs(root, ancestors, (node, anc) => {\n    if (matchesChain(node, anc, steps)) out.push(node);\n  });\n\n  return out;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Wrong order: must be document order (DFS left-to-right).",
          "Including text nodes as matches (only nodeType 1).",
          "For descendant chains, using only the direct parent (should allow any ancestor).",
          "Depending on `parentNode` (not provided here).",
          "Not handling extra whitespace in selector correctly."
        ],
        "edgeCases": [
          "Root matches single-step selector and must be included.",
          "Selector has multiple spaces: `'  #main   button.primary  '`.",
          "Nodes missing `childNodes` should be treated as leaf nodes."
        ],
        "techniques": [
          "DFS with an ancestor stack to avoid parent pointers",
          "Simple selector parsing",
          "Ancestor back-scan for descendant combinator"
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "MDN – Document.querySelectorAll",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll"
        },
        {
          "title": "MDN – Element.matches",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/matches"
        }
      ]
    },
    "tests": "import queryAllSimple from './file';\n\nfunction el(tagName, opts = {}) {\n  return {\n    nodeType: 1,\n    tagName,\n    id: opts.id,\n    className: opts.className || '',\n    childNodes: []\n  };\n}\n\nfunction text(value) {\n  return { nodeType: 3, nodeValue: value, childNodes: [] };\n}\n\nfunction append(parent, child) {\n  parent.childNodes.push(child);\n  return child;\n}\n\ndescribe('queryAllSimple (Hard, DOM-less selector polyfill)', () => {\n  test('throws on invalid args', () => {\n    expect(() => queryAllSimple(null, 'div')).toThrow(TypeError);\n    expect(() => queryAllSimple({ nodeType: 3 }, 'div')).toThrow(TypeError);\n    expect(() => queryAllSimple(el('div'), '')).toThrow(TypeError);\n    expect(() => queryAllSimple(el('div'), '   ')).toThrow(TypeError);\n  });\n\n  test('throws on unsupported selector syntax', () => {\n    const root = el('div');\n    expect(() => queryAllSimple(root, 'div>span')).toThrow(TypeError);\n    expect(() => queryAllSimple(root, 'div,span')).toThrow(TypeError);\n    expect(() => queryAllSimple(root, 'div:hover')).toThrow(TypeError);\n    expect(() => queryAllSimple(root, 'div[a=b]')).toThrow(TypeError);\n  });\n\n  test('matches tag and includes root if it matches', () => {\n    const root = el('div');\n    const a = append(root, el('div'));\n    const b = append(root, el('span'));\n    const c = append(b, el('div'));\n\n    expect(queryAllSimple(root, 'div')).toEqual([root, a, c]);\n  });\n\n  test('matches .class and #id', () => {\n    const root = el('div');\n    const a = append(root, el('div', { className: 'item' }));\n    const b = append(root, el('div', { className: 'item big' }));\n    const c = append(root, el('div', { id: 'main' }));\n\n    expect(queryAllSimple(root, '.item')).toEqual([a, b]);\n    expect(queryAllSimple(root, '#main')).toEqual([c]);\n  });\n\n  test('matches tag.class', () => {\n    const root = el('div');\n    const a = append(root, el('button', { className: 'primary' }));\n    append(root, el('button', { className: 'secondary' }));\n    append(root, el('div', { className: 'primary' }));\n\n    expect(queryAllSimple(root, 'button.primary')).toEqual([a]);\n  });\n\n  test('supports descendant chains using ancestor logic', () => {\n    const root = el('div');\n    const main = append(root, el('div', { id: 'main' }));\n    const btn1 = append(main, el('button', { className: 'primary' }));\n    const wrap = append(main, el('div', { className: 'wrap' }));\n    const btn2 = append(wrap, el('button', { className: 'primary' }));\n    const other = append(root, el('div', { id: 'other' }));\n    append(other, el('button', { className: 'primary' }));\n\n    expect(queryAllSimple(root, '#main button.primary')).toEqual([btn1, btn2]);\n  });\n\n  test('ignores text nodes and keeps document order', () => {\n    const root = el('div');\n    append(root, text('hello'));\n    const a = append(root, el('div', { className: 'item' }));\n    append(a, text('x'));\n    const b = append(root, el('div', { className: 'item' }));\n\n    expect(queryAllSimple(root, '.item')).toEqual([a, b]);\n  });\n\n  test('handles extra whitespace in selector', () => {\n    const root = el('div');\n    const main = append(root, el('div', { id: 'main' }));\n    const btn = append(main, el('button', { className: 'primary' }));\n\n    expect(queryAllSimple(root, '   #main    button.primary   ')).toEqual([btn]);\n  });\n\n  test('returns empty when no match', () => {\n    const root = el('div');\n    append(root, el('span'));\n    expect(queryAllSimple(root, 'button')).toEqual([]);\n  });\n});\n",
    "testsTs": "import queryAllSimple from './file';\n\ntype DomLikeNode = any;\n\nfunction el(tagName: string, opts: { id?: string; className?: string } = {}): DomLikeNode {\n  return {\n    nodeType: 1,\n    tagName,\n    id: opts.id,\n    className: opts.className || '',\n    childNodes: [] as DomLikeNode[]\n  };\n}\n\nfunction append(parent: DomLikeNode, child: DomLikeNode): DomLikeNode {\n  parent.childNodes.push(child);\n  return child;\n}\n\ndescribe('queryAllSimple (TypeScript)', () => {\n  it('supports descendant chains', () => {\n    const root = el('div');\n    const main = append(root, el('div', { id: 'main' }));\n    const btn1 = append(main, el('button', { className: 'primary' }));\n\n    expect(queryAllSimple(root, '#main button.primary')).toEqual([btn1]);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31",
    "companies": [
      "apple"
    ]
  },
  {
    "id": "js-get-by-path-1",
    "title": "Data Helper 1: Get Value by Path",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "objects",
      "arrays",
      "utilities",
      "edge-cases"
    ],
    "description": {
      "summary": "Implement `getByPath(obj, path, fallback?)` that safely reads a nested value from an object.\n\nThis is extremely common in frontend screens (reading deep API responses, feature flags, form state) and shows up often in interviews.\n\nPath rules:\n- `path` can be a dot string: `\"a.b.c\"`\n- or an array of keys: `[\"a\", \"b\", \"c\"]`\n- Numeric segments should work for arrays: `\"items.0.name\"`.\n\nRequirements:\n1) If the full path exists, return the value (even if it is `null`, `false`, or `0`).\n2) If any segment is missing, return `fallback` (or `undefined` if not provided).\n3) Must not throw for nullish intermediate values.\n4) No eval, no JSON stringify tricks.\n\nThis tests safe traversal + edge-case correctness.",
      "arguments": [
        {
          "name": "obj",
          "type": "any",
          "desc": "The object/array to read from."
        },
        {
          "name": "path",
          "type": "string | (string | number)[]",
          "desc": "Path as dot string or array of segments."
        },
        {
          "name": "fallback",
          "type": "any",
          "desc": "Optional value to return when the path does not exist."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "The found value, or `fallback`/`undefined` when missing."
      },
      "examples": [
        "const data = { user: { profile: { name: 'Ada' }, flags: { pro: false } }, items: [{ name: 'x' }] };\n\ngetByPath(data, 'user.profile.name'); // => 'Ada'\ngetByPath(data, ['user', 'flags', 'pro']); // => false\ngetByPath(data, 'items.0.name'); // => 'x'\ngetByPath(data, 'user.profile.age', 18); // => 18\ngetByPath(data, 'missing.anything'); // => undefined"
      ]
    },
    "starterCode": "export default function getByPath(obj, path, fallback) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function getByPath(\n  obj: any,\n  path: string | Array<string | number>,\n  fallback?: any\n): any {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Traverse an object safely by path segments and return either the value or a fallback. The crucial detail is to distinguish missing properties from valid falsy values like `0`, `false`, or `''`. This makes the helper reliable for real-world API data and UI state.",
      "approaches": [
        {
          "title": "Approach: Iterative traversal with \"missing\" detection (recommended)",
          "prose": "Algorithm:\n- Normalize the path to an array of segments (split dots if needed).\n- Start with `cur = obj` and iterate through segments.\n- If `cur` is nullish at any point, return the fallback.\n- Use `Object.prototype.hasOwnProperty.call(cur, seg)` (or `seg in cur`) to check existence. If missing, return fallback.\n- Otherwise set `cur = cur[seg]` and continue.\n- If all segments resolve, return `cur` even if it is falsy.\n\nComplexity: O(k) time, O(k) space for path normalization.",
          "codeJs": "function toSegments(path) {\n  if (Array.isArray(path)) return path;\n  if (typeof path !== 'string') return null;\n  const s = path.trim();\n  if (!s) return [];\n  return s.split('.');\n}\n\nexport default function getByPath(obj, path, fallback) {\n  const segs = toSegments(path);\n  if (!segs) return fallback;\n\n  let cur = obj;\n\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i];\n\n    if (cur === null || cur === undefined) {\n      return fallback;\n    }\n\n    // allow numeric indexing when segment is number or numeric string\n    const key = typeof seg === 'number' ? seg : seg;\n\n    // Only treat as missing when key is not present\n    if (typeof cur === 'object' || typeof cur === 'function') {\n      if (!(key in cur)) return fallback;\n      cur = cur[key];\n    } else {\n      return fallback;\n    }\n  }\n\n  return cur;\n}\n",
          "codeTs": "function toSegments(path: string | Array<string | number>): Array<string | number> | null {\n  if (Array.isArray(path)) return path;\n  if (typeof path !== 'string') return null;\n  const s = path.trim();\n  if (!s) return [];\n  return s.split('.');\n}\n\nexport default function getByPath(\n  obj: any,\n  path: string | Array<string | number>,\n  fallback?: any\n): any {\n  const segs = toSegments(path);\n  if (!segs) return fallback;\n\n  let cur: any = obj;\n\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i];\n\n    if (cur === null || cur === undefined) {\n      return fallback;\n    }\n\n    const key: any = seg;\n\n    if (typeof cur === 'object' || typeof cur === 'function') {\n      if (!(key in cur)) return fallback;\n      cur = cur[key];\n    } else {\n      return fallback;\n    }\n  }\n\n  return cur;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using `|| fallback` which incorrectly replaces valid values like `false`/`0`/`''`.",
          "Not handling arrays (`items.0.name`).",
          "Throwing when a mid-level object is `null`/`undefined`."
        ],
        "edgeCases": [
          "Empty path (`''` or `[]`) should return the object itself.",
          "Value exists but is `undefined` (property present with value undefined). This should return `undefined`, not fallback (because it exists).",
          "Path passed as array with numeric segments."
        ],
        "techniques": [
          "Path normalization (string -> segments)",
          "Safe iterative traversal",
          "Use `in` to distinguish missing vs falsy"
        ]
      },
      "followUpQuestions": [
        "js-set-by-path-2"
      ],
      "resources": [
        {
          "title": "MDN – Optional chaining (related concept)",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining"
        }
      ]
    },
    "tests": "import getByPath from './file';\n\ndescribe('getByPath', () => {\n  test('reads nested values by dot path', () => {\n    const data = { user: { profile: { name: 'Ada' } } };\n    expect(getByPath(data, 'user.profile.name')).toBe('Ada');\n  });\n\n  test('reads nested values by array path', () => {\n    const data = { user: { flags: { pro: false } } };\n    expect(getByPath(data, ['user', 'flags', 'pro'])).toBe(false);\n  });\n\n  test('supports array indexing via numeric segment', () => {\n    const data = { items: [{ name: 'x' }, { name: 'y' }] };\n    expect(getByPath(data, 'items.0.name')).toBe('x');\n    expect(getByPath(data, ['items', 1, 'name'])).toBe('y');\n  });\n\n  test('returns fallback only when missing', () => {\n    const data = { a: { b: 0, c: '', d: null } };\n    expect(getByPath(data, 'a.b', 123)).toBe(0);\n    expect(getByPath(data, 'a.c', 'fb')).toBe('');\n    expect(getByPath(data, 'a.d', 'fb')).toBe(null);\n    expect(getByPath(data, 'a.missing', 'fb')).toBe('fb');\n  });\n\n  test('returns undefined when missing and no fallback provided', () => {\n    const data = { a: {} };\n    expect(getByPath(data, 'a.nope')).toBe(undefined);\n  });\n\n  test('empty path returns the input object', () => {\n    const data = { a: 1 };\n    expect(getByPath(data, '', 'fb')).toBe(data);\n    expect(getByPath(data, [], 'fb')).toBe(data);\n  });\n\n  test('does not throw on nullish intermediates', () => {\n    const data = { a: null };\n    expect(getByPath(data, 'a.b.c', 'fb')).toBe('fb');\n  });\n\n  test('treats present-but-undefined as present (returns undefined)', () => {\n    const data = { a: { b: undefined } };\n    expect(getByPath(data, 'a.b', 'fb')).toBe(undefined);\n  });\n});\n",
    "testsTs": "import getByPath from './file';\n\ndescribe('getByPath (TypeScript)', () => {\n  it('works with common cases', () => {\n    const data: any = { user: { profile: { name: 'Ada' } }, items: [{ name: 'x' }] };\n    expect(getByPath(data, 'user.profile.name')).toBe('Ada');\n    expect(getByPath(data, 'items.0.name')).toBe('x');\n    expect(getByPath(data, 'missing', 1)).toBe(1);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-set-by-path-2",
    "title": "Data Helper 2: Set Value by Path",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "intermediate",
    "tags": [
      "objects",
      "arrays",
      "immutability",
      "utilities"
    ],
    "description": {
      "summary": "Implement setByPath(obj, path, value) that returns a new object/array tree with the value written at the nested path. Normalize dot or segment paths, create missing containers based on numeric segments, and never mutate the original input. Empty paths should return the value directly, and primitives along the way should be replaced with the correct container type. Concepts: objects, arrays, immutability.",
      "arguments": [
        {
          "name": "obj",
          "type": "any",
          "desc": "The original root object/array."
        },
        {
          "name": "path",
          "type": "string | (string | number)[]",
          "desc": "Dot path or array of segments."
        },
        {
          "name": "value",
          "type": "any",
          "desc": "Value to set at the given path."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "A new object/array with the value written at the path."
      },
      "examples": [
        "const state = { user: { profile: { name: 'Ada' } }, items: [{ name: 'x' }] };\n\nconst next1 = setByPath(state, 'user.profile.name', 'Bob');\n// next1.user.profile.name === 'Bob'\n// state.user.profile.name still 'Ada'\n\nconst next2 = setByPath(state, 'items.0.name', 'z');\n// next2.items[0].name === 'z'\n\nconst next3 = setByPath({}, 'a.b.0.c', 123);\n// next3 => { a: { b: [ { c: 123 } ] } }"
      ]
    },
    "starterCode": "export default function setByPath(obj, path, value) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function setByPath(\n  obj: any,\n  path: string | Array<string | number>,\n  value: any\n): any {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Build an immutable path setter that updates only the branch you touch. Normalize the path into segments, then clone-on-write through objects/arrays while creating missing containers (array for numeric segment, object otherwise). This mirrors how state updates work in Redux/React: untouched branches keep their references, the updated branch is new, and an empty path just becomes the value. Key concepts: objects, arrays, immutability.",
      "approaches": [
        {
          "title": "Approach: Clone-on-write along the path (recommended)",
          "prose": "Step-by-step:\n1) Normalize `path` into an array of segments (split on dots if given a string). If the path is empty, return `value` immediately.\n2) Walk the path from root to leaf. For each segment, decide the container type you need next: numeric segment → array, otherwise object.\n3) Clone the current container (array via `slice`, object via spread). If the current value is null/primitive, replace it with a fresh container.\n4) Recurse/iterate into the next level and assign the updated child into the clone.\n5) Return the top-level clone so only the path is rebuilt.\n\nComplexity: O(k) time and O(k) new allocations where k is the path length.",
          "codeJs": "function toSegments(path) {\n  if (Array.isArray(path)) return path;\n  if (typeof path !== 'string') return null;\n  const s = path.trim();\n  if (!s) return [];\n  return s.split('.');\n}\n\nfunction isIndex(seg) {\n  if (typeof seg === 'number') return Number.isInteger(seg) && seg >= 0;\n  if (typeof seg !== 'string') return false;\n  return /^(0|[1-9]\\d*)$/.test(seg);\n}\n\nfunction cloneShallow(x) {\n  if (Array.isArray(x)) return x.slice();\n  if (x && typeof x === 'object') return { ...x };\n  return null;\n}\n\nexport default function setByPath(obj, path, value) {\n  const segs = toSegments(path);\n  if (!segs) throw new TypeError('setByPath: path must be a string or array');\n  if (segs.length === 0) return value;\n\n  function setRec(current, idx) {\n    const seg = segs[idx];\n    const last = idx === segs.length - 1;\n\n    const shouldBeArray = isIndex(seg);\n\n    let base;\n    if (Array.isArray(current)) base = current;\n    else if (current && typeof current === 'object') base = current;\n    else base = shouldBeArray ? [] : {};\n\n    const copy = cloneShallow(base);\n    const key = isIndex(seg) ? +seg : seg;\n\n    if (last) {\n      copy[key] = value;\n      return copy;\n    }\n\n    const child = base[key];\n    copy[key] = setRec(child, idx + 1);\n    return copy;\n  }\n\n  return setRec(obj, 0);\n}\n",
          "codeTs": "function toSegments(path: string | Array<string | number>): Array<string | number> | null {\n  if (Array.isArray(path)) return path;\n  if (typeof path !== 'string') return null;\n  const s = path.trim();\n  if (!s) return [];\n  return s.split('.');\n}\n\nfunction isIndex(seg: string | number): boolean {\n  if (typeof seg === 'number') return Number.isInteger(seg) && seg >= 0;\n  if (typeof seg !== 'string') return false;\n  return /^(0|[1-9]\\d*)$/.test(seg);\n}\n\nfunction cloneShallow(x: any): any {\n  if (Array.isArray(x)) return x.slice();\n  if (x && typeof x === 'object') return { ...x };\n  return null;\n}\n\nexport default function setByPath(\n  obj: any,\n  path: string | Array<string | number>,\n  value: any\n): any {\n  const segs = toSegments(path);\n  if (!segs) throw new TypeError('setByPath: path must be a string or array');\n  if (segs.length === 0) return value;\n\n  function setRec(current: any, idx: number): any {\n    const seg = segs[idx];\n    const last = idx === segs.length - 1;\n\n    const shouldBeArray = isIndex(seg as any);\n\n    let base: any;\n    if (Array.isArray(current)) base = current;\n    else if (current && typeof current === 'object') base = current;\n    else base = shouldBeArray ? [] : {};\n\n    const copy: any = cloneShallow(base);\n    const key: any = isIndex(seg as any) ? Number(seg) : seg;\n\n    if (last) {\n      copy[key] = value;\n      return copy;\n    }\n\n    const child = base[key];\n    copy[key] = setRec(child, idx + 1);\n    return copy;\n  }\n\n  return setRec(obj, 0);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating the input object/array.",
          "Treating numeric segments like '0' as object keys instead of array indices.",
          "Choosing container type from the next segment (breaks `a.b.0.c`)."
        ],
        "edgeCases": [
          "Empty path replaces root.",
          "Intermediate primitives are replaced with containers.",
          "Array gaps allowed when setting higher indices."
        ],
        "techniques": [
          "Clone-on-write updates",
          "Path normalization",
          "Index detection via regex"
        ]
      },
      "followUpQuestions": [
        "js-deep-merge-3"
      ],
      "resources": [
        {
          "title": "Redux – Immutable Update Patterns (conceptually related)",
          "url": "https://redux.js.org/usage/structuring-reducers/immutable-update-patterns"
        }
      ]
    },
    "tests": "import setByPath from './file';\n\ndescribe('setByPath', () => {\n  test('updates deep object path immutably', () => {\n    const state = { user: { profile: { name: 'Ada' } }, other: { x: 1 } };\n    const next = setByPath(state, 'user.profile.name', 'Bob');\n\n    expect(next.user.profile.name).toEqual('Bob');\n    expect(state.user.profile.name).toEqual('Ada');\n\n    // ensure original object not mutated\n    expect(state).toEqual({ user: { profile: { name: 'Ada' } }, other: { x: 1 } });\n  });\n\n  test('updates array index path immutably', () => {\n    const state = { items: [{ name: 'x' }, { name: 'y' }], keep: { k: 1 } };\n    const next = setByPath(state, 'items.0.name', 'z');\n\n    expect(next.items[0].name).toEqual('z');\n    expect(state.items[0].name).toEqual('x');\n\n    // ensure original object not mutated\n    expect(state).toEqual({ items: [{ name: 'x' }, { name: 'y' }], keep: { k: 1 } });\n  });\n\n  test('creates missing containers (object + array) along the path', () => {\n    const next = setByPath({}, 'a.b.0.c', 123);\n    expect(next).toEqual({ a: { b: [{ c: 123 }] } });\n  });\n\n  test('empty path replaces root', () => {\n    expect(setByPath({ a: 1 }, '', 99)).toBe(99);\n    expect(setByPath({ a: 1 }, [], 99)).toBe(99);\n  });\n\n  test('replaces primitive intermediates with containers when needed', () => {\n    const state = { a: 1 };\n    const next = setByPath(state, 'a.b.c', 2);\n    expect(next).toEqual({ a: { b: { c: 2 } } });\n  });\n\n  test('supports array path input', () => {\n    const state = { items: [{ name: 'x' }] };\n    const next = setByPath(state, ['items', 0, 'name'], 'y');\n    expect(next.items[0].name).toEqual('y');\n  });\n});\n",
    "testsTs": "import setByPath from './file';\n\ndescribe('setByPath (TypeScript)', () => {\n  it('updates deep path', () => {\n    const state: any = { user: { profile: { name: 'Ada' } }, other: { x: 1 } };\n    const next = setByPath(state, 'user.profile.name', 'Bob');\n\n    expect(next.user.profile.name).toEqual('Bob');\n    expect(state.user.profile.name).toEqual('Ada');\n    expect(state).toEqual({ user: { profile: { name: 'Ada' } }, other: { x: 1 } });\n  });\n\n  it('creates missing containers', () => {\n    const next = setByPath({}, 'a.b.0.c', 1);\n    expect(next).toEqual({ a: { b: [{ c: 1 }] } });\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-deep-clone-cycles-3",
    "title": "Data Helper 3: Deep Clone with Cycles",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "hard",
    "tags": [
      "clone",
      "deep-copy",
      "objects",
      "recursion",
      "immutability",
      "edge-cases"
    ],
    "description": {
      "summary": "Implement `deepClone(value)` that returns a **deep copy** of the input while correctly handling **circular references**.\n\nRequirements:\n1) Must deeply clone objects and arrays.\n2) Must correctly handle **cyclic references** (no infinite recursion).\n3) Must preserve **shared references**:\n   - If two properties point to the same object, the clone must point to the same cloned object.\n4) Must not mutate the input.\n5) Primitive values should be returned as-is.\n\nYou do NOT need to support:\n- DOM nodes\n- Map, Set, Date, RegExp, Function, class instances\n\nAssume input contains only:\n- Objects\n- Arrays\n- Primitives\n\nThis problem tests graph traversal, memoization, and reference identity preservation.",
      "arguments": [
        {
          "name": "value",
          "type": "any",
          "desc": "Any value (object, array, or primitive), possibly containing cycles."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "A deep cloned copy of the input, with cycles handled correctly."
      },
      "examples": [
        "// Example 1: simple object\nconst a = { x: 1, y: { z: 2 } };\nconst b = deepClone(a);\n// b deep-equals a but b !== a and b.y !== a.y\n\n// Example 2: circular reference\nconst a = {};\na.self = a;\nconst b = deepClone(a);\n// b.self === b\n\n// Example 3: shared reference\nconst shared = { x: 1 };\nconst a = { p: shared, q: shared };\nconst b = deepClone(a);\n// b.p === b.q and b.p !== shared"
      ]
    },
    "starterCode": "export default function deepClone(value) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function deepClone(value: any): any {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Deep-clone an object graph that may contain cycles and shared references. Use a `Map` to remember already-cloned objects so you can return the cached clone when you encounter the same reference again. This preserves object identity relationships and avoids infinite recursion.",
      "approaches": [
        {
          "title": "Approach: DFS with memoization (recommended)",
          "prose": "Approach with memoization:\n- Primitives return as-is.\n- For arrays/objects, check the memo map. If seen, return the cached clone.\n- Otherwise create an empty container of the same type, store it in the map, and then recursively clone each property/element into it.\n\nThis preserves cycles and shared references (e.g., two fields pointing to the same child stay pointing to the same clone).\n\nComplexity: O(N) time and space for N nodes in the object graph.",
          "codeJs": "export default function deepClone(value) {\n  const seen = new Map();\n\n  function cloneRec(v) {\n    if (v === null || typeof v !== 'object') return v;\n\n    if (seen.has(v)) return seen.get(v);\n\n    const out = Array.isArray(v) ? [] : {};\n    seen.set(v, out);\n\n    for (const key in v) {\n      out[key] = cloneRec(v[key]);\n    }\n\n    return out;\n  }\n\n  return cloneRec(value);\n}\n",
          "codeTs": "export default function deepClone(value: any): any {\n  const seen = new Map<any, any>();\n\n  function cloneRec(v: any): any {\n    if (v === null || typeof v !== 'object') return v;\n\n    if (seen.has(v)) return seen.get(v);\n\n    const out: any = Array.isArray(v) ? [] : {};\n    seen.set(v, out);\n\n    for (const key in v) {\n      out[key] = cloneRec(v[key]);\n    }\n\n    return out;\n  }\n\n  return cloneRec(value);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "JSON cloning breaks cycles and shared references.",
          "Memoizing after recursion causes infinite recursion on self-references.",
          "Not preserving shared references changes graph identity."
        ],
        "edgeCases": [
          "Self-referencing object.",
          "Two branches pointing to the same object.",
          "Array containing itself."
        ],
        "techniques": [
          "Graph traversal",
          "Memoization Map",
          "Reference identity preservation"
        ]
      },
      "followUpQuestions": [
        "js-deep-merge-3"
      ],
      "resources": [
        {
          "title": "MDN – Working with Objects",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects"
        }
      ]
    },
    "tests": "import deepClone from './file';\n\nfunction assert(condition, message) {\n  if (!condition) throw new Error(message);\n}\n\ndescribe('deepClone', () => {\n  test('clones simple objects deeply', () => {\n    const a = { x: 1, y: { z: 2 } };\n    const b = deepClone(a);\n\n    expect(b).toEqual(a);\n    assert(b !== a, 'Expected cloned root to be a different reference');\n    assert(b.y !== a.y, 'Expected nested object to be a different reference');\n  });\n\n  test('handles circular references', () => {\n    const a = { x: 1 };\n    a.self = a;\n\n    const b = deepClone(a);\n\n    expect(b.x).toEqual(1);\n    assert(b !== a, 'Expected cloned root to be a different reference');\n    assert(b.self === b, 'Expected b.self to point to b (cycle preserved)');\n  });\n\n  test('preserves shared references', () => {\n    const shared = { v: 1 };\n    const a = { p: shared, q: shared };\n\n    const b = deepClone(a);\n\n    expect(b).toEqual({ p: { v: 1 }, q: { v: 1 } });\n    assert(b.p === b.q, 'Expected shared reference to be preserved (b.p === b.q)');\n    assert(b.p !== shared, 'Expected cloned shared object to differ from original');\n  });\n\n  test('handles arrays with cycles', () => {\n    const a = [];\n    a.push(a);\n\n    const b = deepClone(a);\n\n    expect(Array.isArray(b)).toEqual(true);\n    assert(b !== a, 'Expected cloned array to be a different reference');\n    assert(b[0] === b, 'Expected b[0] to point to b (cycle preserved)');\n  });\n\n  test('returns primitives as-is', () => {\n    expect(deepClone(1)).toEqual(1);\n    expect(deepClone('a')).toEqual('a');\n    expect(deepClone(null)).toEqual(null);\n    expect(deepClone(undefined)).toEqual(undefined);\n  });\n});\n",
    "testsTs": "import deepClone from './file';\n\nfunction assert(condition: any, message: string) {\n  if (!condition) throw new Error(message);\n}\n\ndescribe('deepClone (TypeScript)', () => {\n  it('clones cycles correctly', () => {\n    const a: any = { x: 1 };\n    a.self = a;\n\n    const b = deepClone(a);\n\n    expect(b.x).toEqual(1);\n    assert(b !== a, 'Expected cloned root to be a different reference');\n    assert(b.self === b, 'Expected b.self === b');\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-querystring-parse-1",
    "title": "Querystring Helper 1: Implement `parseQueryString`",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "parsing",
      "string",
      "objects",
      "web-apis"
    ],
    "description": {
      "summary": "Implement `parseQueryString(qs)` that converts a URL querystring into a plain object.\n\nThis is very common in frontend work (filters, pagination, deep links) and shows up in interviews.\n\nRules (Easy version):\n1) Input may start with `?`.\n2) Pairs are separated by `&`.\n3) Each pair is `key=value`.\n4) Decode percent-encoding with `decodeURIComponent`.\n5) `+` should be treated as a space.\n6) If a key appears multiple times, keep the **last** value.\n7) If a pair is missing `=`, treat value as empty string.\n8) Empty keys should be ignored.\n\nNo arrays, no nested objects in this version.",
      "arguments": [
        {
          "name": "qs",
          "type": "string",
          "desc": "Querystring like `\"?a=1&b=two\"` or `\"a=1\"`."
        }
      ],
      "returns": {
        "type": "Record<string, string>",
        "desc": "An object mapping each key to its decoded string value."
      },
      "examples": [
        "parseQueryString('?a=1&b=two'); // => { a: '1', b: 'two' }",
        "parseQueryString('q=hello+world'); // => { q: 'hello world' }",
        "parseQueryString('a=1&a=2'); // => { a: '2' }",
        "parseQueryString('flag'); // => { flag: '' }"
      ]
    },
    "starterCode": "export default function parseQueryString(qs) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function parseQueryString(qs: string): Record<string, string> {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Normalize a querystring into key/value pairs, decode each piece, and build an object where later keys overwrite earlier ones. Handle leading `?`, treat `+` as space, ignore empty keys, and treat missing `=` as an empty string. This is a realistic parsing task used for filters, pagination, and deep links.",
      "approaches": [
        {
          "title": "Approach: Split + decode (recommended)",
          "prose": "Detailed steps:\n1) Strip a leading `?` and return `{}` for an empty string.\n2) Split the string by `&` into raw pairs.\n3) For each pair, split on the first `=` only (so values can contain `=`). If no `=`, use `''` as the value.\n4) Replace `+` with spaces in both key and value, then decode with `decodeURIComponent`.\n5) Skip empty keys; otherwise assign into the result object (overwriting any previous value).\n\nComplexity: O(n) in the query length, O(k) for the number of keys.",
          "codeJs": "function safeDecode(s) {\n  // Keep it predictable: if decode fails, return the raw string\n  try {\n    return decodeURIComponent(s);\n  } catch {\n    return s;\n  }\n}\n\nexport default function parseQueryString(qs) {\n  if (typeof qs !== 'string') return {};\n\n  const raw = qs.startsWith('?') ? qs.slice(1) : qs;\n  if (!raw) return {};\n\n  const out = {};\n\n  for (const part of raw.split('&')) {\n    if (!part) continue;\n\n    const eq = part.indexOf('=');\n    const kRaw = eq === -1 ? part : part.slice(0, eq);\n    const vRaw = eq === -1 ? '' : part.slice(eq + 1);\n\n    const k = safeDecode(kRaw.replace(/\\+/g, ' ')).trim();\n    if (!k) continue;\n\n    const v = safeDecode(vRaw.replace(/\\+/g, ' '));\n    out[k] = v;\n  }\n\n  return out;\n}\n",
          "codeTs": "function safeDecode(s: string): string {\n  try {\n    return decodeURIComponent(s);\n  } catch {\n    return s;\n  }\n}\n\nexport default function parseQueryString(qs: string): Record<string, string> {\n  if (typeof qs !== 'string') return {};\n\n  const raw = qs.startsWith('?') ? qs.slice(1) : qs;\n  if (!raw) return {};\n\n  const out: Record<string, string> = {};\n\n  for (const part of raw.split('&')) {\n    if (!part) continue;\n\n    const eq = part.indexOf('=');\n    const kRaw = eq === -1 ? part : part.slice(0, eq);\n    const vRaw = eq === -1 ? '' : part.slice(eq + 1);\n\n    const k = safeDecode(kRaw.replace(/\\+/g, ' ')).trim();\n    if (!k) continue;\n\n    const v = safeDecode(vRaw.replace(/\\+/g, ' '));\n    out[k] = v;\n  }\n\n  return out;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to treat `+` as space (common in querystrings).",
          "Using `split('=')` without limiting to first `=` (values may contain `=`).",
          "Not handling keys without `=` (should map to empty string).",
          "Crashing on malformed percent-encoding (e.g. `%E0%A4`)."
        ],
        "edgeCases": [
          "`''` or `'?'` => `{}`",
          "`'&&a=1&&'` => `{ a: '1' }`",
          "`'=x&y=1'` => `{ y: '1' }` (empty key ignored)",
          "`'a=%26'` => `{ a: '&' }`"
        ],
        "techniques": [
          "Index-based split to preserve `=` in values",
          "Defensive decoding"
        ]
      },
      "followUpQuestions": [
        "js-querystring-stringify-2"
      ],
      "resources": [
        {
          "title": "MDN – decodeURIComponent",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent"
        }
      ]
    },
    "tests": "import parseQueryString from './file';\n\ndescribe('parseQueryString', () => {\n  test('parses basic key-value pairs', () => {\n    expect(parseQueryString('?a=1&b=two')).toEqual({ a: '1', b: 'two' });\n  });\n\n  test('treats + as space and decodes percent-encoding', () => {\n    expect(parseQueryString('q=hello+world')).toEqual({ q: 'hello world' });\n    expect(parseQueryString('a=%26')).toEqual({ a: '&' });\n  });\n\n  test('keeps the last value when keys repeat', () => {\n    expect(parseQueryString('a=1&a=2&a=3')).toEqual({ a: '3' });\n  });\n\n  test('missing = means empty string value', () => {\n    expect(parseQueryString('flag')).toEqual({ flag: '' });\n    expect(parseQueryString('flag&x=1')).toEqual({ flag: '', x: '1' });\n  });\n\n  test('ignores empty keys and empty parts', () => {\n    expect(parseQueryString('=x&&y=1&')).toEqual({ y: '1' });\n  });\n\n  test('does not break on malformed encoding (keeps raw)', () => {\n    expect(parseQueryString('a=%E0%A4')).toEqual({ a: '%E0%A4' });\n  });\n\n  test('empty input returns {}', () => {\n    expect(parseQueryString('')).toEqual({});\n    expect(parseQueryString('?')).toEqual({});\n  });\n});\n",
    "testsTs": "import parseQueryString from './file';\n\ndescribe('parseQueryString (TypeScript)', () => {\n  it('parses and decodes', () => {\n    expect(parseQueryString('?a=1&b=two')).toEqual({ a: '1', b: 'two' });\n    expect(parseQueryString('q=hello+world')).toEqual({ q: 'hello world' });\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-querystring-stringify-2",
    "title": "Querystring Helper 2: Implement `stringifyQueryString`",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "intermediate",
    "tags": [
      "string",
      "objects",
      "arrays",
      "web-apis"
    ],
    "description": {
      "summary": "Implement `stringifyQueryString(params)` that converts an object into a URL querystring.\n\nThis is common in FE screens (building filter URLs, pagination links, deep links).\n\nRules (Medium version):\n1) `params` is a plain object with values of type `string | number | boolean | null | undefined | (string|number|boolean)[]`.\n2) Skip keys whose value is `undefined`.\n3) Include keys whose value is `null` as `key=` (empty value).\n4) For arrays: repeat the key for each item in order (e.g. `{ tag: ['a','b'] }` -&gt; `tag=a&tag=b`).\n5) Encode with `encodeURIComponent`.\n6) Use `=` always (even for empty string): `{ flag: '' }` -&gt; `flag=`.\n7) Stable output: keys should be serialized in **lexicographic order**.\n8) Return the querystring **without** leading `?`.\n\nNo nested objects in this version.",
      "arguments": [
        {
          "name": "params",
          "type": "Record<string, any>",
          "desc": "Plain object of query parameters (strings/numbers/booleans/null/undefined or arrays of primitives)."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "Encoded querystring (no leading `?`)."
      },
      "examples": [
        "stringifyQueryString({ q: 'hello world', page: 2 }); // => \"page=2&q=hello%20world\"",
        "stringifyQueryString({ tag: ['a', 'b'], sort: 'new' }); // => \"sort=new&tag=a&tag=b\"",
        "stringifyQueryString({ a: undefined, b: null, c: '' }); // => \"b=&c=\"",
        "stringifyQueryString({ ok: true, off: false }); // => \"off=false&ok=true\""
      ]
    },
    "starterCode": "export default function stringifyQueryString(params) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type QueryValue = string | number | boolean | null | undefined | Array<string | number | boolean>;\n\nexport default function stringifyQueryString(params: Record<string, QueryValue>): string {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Serialize a plain object into a querystring by walking keys in sorted order, expanding arrays into repeated pairs, and encoding each key/value. Skip undefined, convert null to an empty value, and always include `=` so the output is stable and predictable for URLs.",
      "approaches": [
        {
          "title": "Approach: Sorted keys + pair builder (recommended)",
          "prose": "Implementation detail:\n- Sort keys lexicographically for stable output.\n- For each key, skip undefined. If the value is an array, emit one pair per element in order. Otherwise emit one pair.\n- Convert values to strings: null -> '', booleans/numbers -> String(value), strings as-is.\n- Encode with `encodeURIComponent` and join pairs with `&`.\n\nComplexity: O(k log k + m) where k is keys and m is emitted pairs.",
          "codeJs": "function isPlainObject(x) {\n  return x !== null && typeof x === 'object' && !Array.isArray(x);\n}\n\nfunction encode(s) {\n  return encodeURIComponent(s);\n}\n\nfunction toValueString(v) {\n  if (v === null) return '';\n  return String(v);\n}\n\nexport default function stringifyQueryString(params) {\n  if (!isPlainObject(params)) {\n    throw new TypeError('stringifyQueryString: params must be a plain object');\n  }\n\n  const keys = Object.keys(params).sort();\n  const pairs = [];\n\n  for (const key of keys) {\n    const value = params[key];\n    if (value === undefined) continue;\n\n    const k = encode(String(key));\n\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        // item: string|number|boolean (per spec)\n        const v = encode(toValueString(item));\n        pairs.push(`${k}=${v}`);\n      }\n      continue;\n    }\n\n    const v = encode(toValueString(value));\n    pairs.push(`${k}=${v}`);\n  }\n\n  return pairs.join('&');\n}\n",
          "codeTs": "type QueryPrimitive = string | number | boolean;\nexport type QueryValue = QueryPrimitive | null | undefined | QueryPrimitive[];\n\nfunction isPlainObject(x: any): x is Record<string, any> {\n  return x !== null && typeof x === 'object' && !Array.isArray(x);\n}\n\nfunction toValueString(v: QueryPrimitive | null): string {\n  if (v === null) return '';\n  return String(v);\n}\n\nexport default function stringifyQueryString(params: Record<string, QueryValue>): string {\n  if (!isPlainObject(params)) {\n    throw new TypeError('stringifyQueryString: params must be a plain object');\n  }\n\n  const keys = Object.keys(params).sort();\n  const pairs: string[] = [];\n\n  for (const key of keys) {\n    const value = params[key];\n    if (value === undefined) continue;\n\n    const k = encodeURIComponent(String(key));\n\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        const v = encodeURIComponent(toValueString(item));\n        pairs.push(`${k}=${v}`);\n      }\n      continue;\n    }\n\n    const v = encodeURIComponent(toValueString(value as any));\n    pairs.push(`${k}=${v}`);\n  }\n\n  return pairs.join('&');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting stable key ordering makes tests flaky and URLs harder to diff.",
          "Incorrectly skipping null (null should become `key=`).",
          "Not repeating keys for arrays (common convention in many apps).",
          "Forgetting to encode keys as well as values."
        ],
        "edgeCases": [
          "Empty object => ''",
          "{ a: '' } => 'a='",
          "{ a: [ ] } => '' (emits no pairs)",
          "{ a: ['x y'] } => 'a=x%20y'"
        ],
        "techniques": [
          "Key sort for deterministic output",
          "Pairs array then join (avoids trailing & issues)"
        ]
      },
      "followUpQuestions": [
        "js-deep-clone-cycles-3"
      ],
      "resources": [
        {
          "title": "MDN – encodeURIComponent",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent"
        }
      ]
    },
    "tests": "import stringifyQueryString from './file';\n\ndescribe('stringifyQueryString', () => {\n  test('stringifies basic params with stable key ordering', () => {\n    expect(stringifyQueryString({ q: 'hello world', page: 2 })).toBe('page=2&q=hello%20world');\n  });\n\n  test('encodes keys and values', () => {\n    expect(stringifyQueryString({ 'a b': 'x&y' })).toBe('a%20b=x%26y');\n  });\n\n  test('skips undefined, includes null as empty', () => {\n    expect(stringifyQueryString({ a: undefined, b: null, c: '' })).toBe('b=&c=');\n  });\n\n  test('repeats key for array values in order', () => {\n    expect(stringifyQueryString({ tag: ['a', 'b'], sort: 'new' })).toBe('sort=new&tag=a&tag=b');\n  });\n\n  test('handles booleans', () => {\n    expect(stringifyQueryString({ ok: true, off: false })).toBe('off=false&ok=true');\n  });\n\n  test('empty object returns empty string', () => {\n    expect(stringifyQueryString({})).toBe('');\n  });\n\n  test('empty array emits no pairs', () => {\n    expect(stringifyQueryString({ a: [] })).toBe('');\n  });\n\n  test('throws on non-object input', () => {\n    expect(() => stringifyQueryString(null)).toThrow(TypeError);\n    expect(() => stringifyQueryString([])).toThrow(TypeError);\n  });\n});\n",
    "testsTs": "import stringifyQueryString from './file';\n\ndescribe('stringifyQueryString (TypeScript)', () => {\n  it('repeats keys for arrays', () => {\n    expect(stringifyQueryString({ tag: ['a', 'b'], page: 1 })).toBe('page=1&tag=a&tag=b');\n  });\n\n  it('skips undefined and keeps null', () => {\n    expect(stringifyQueryString({ a: undefined, b: null })).toBe('b=');\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-querystring-parse-3",
    "title": "Querystring Helper 3: Implement `parseQueryStringAdvanced`",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "hard",
    "tags": [
      "parsing",
      "arrays",
      "objects",
      "web-apis"
    ],
    "description": {
      "summary": "Implement `parseQueryStringAdvanced(qs)` that converts a URL querystring into a **nested** object structure.\n\nThis mirrors real-world FE usage (filters, search forms, pagination state) and is a classic hard interview question.\n\nSupported syntax:\n1) Basic: `a=1` =&gt; { a: '1' }\n2) Repeated keys become arrays: `a=1&a=2` =&gt; { a: ['1','2'] }\n3) Bracket arrays: `a[]=1&a[]=2` =&gt; { a: ['1','2'] }\n4) Nested objects: `user[name]=john&user[age]=30` =&gt; { user: { name: 'john', age: '30' } }\n5) Nested + arrays: `filters[tag][]=a&filters[tag][]=b` =&gt; { filters: { tag: ['a','b'] } }\n6) Mixed forms accumulate: `a=1&a=2&a[]=3` =&gt; { a: ['1','2','3'] }\n\nGeneral rules:\n- Leading `?` is optional.\n- Decode with `decodeURIComponent` and treat `+` as space.\n- Missing `=` means empty string.\n- Empty keys are ignored.\n- If structure conflicts (primitive vs object), convert to object or array to preserve all data.\n\nNo usage of `URLSearchParams`.",
      "arguments": [
        {
          "name": "qs",
          "type": "string",
          "desc": "Querystring like `\"?a=1&b[x]=2\"`."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "A nested object/array structure representing the querystring."
      },
      "examples": [
        "parseQueryStringAdvanced('a=1&a=2'); // => { a: ['1','2'] }",
        "parseQueryStringAdvanced('user[name]=john&user[age]=30'); // => { user: { name: 'john', age: '30' } }",
        "parseQueryStringAdvanced('filters[tag][]=a&filters[tag][]=b'); // => { filters: { tag: ['a','b'] } }",
        "parseQueryStringAdvanced('a=1&a[]=2'); // => { a: ['1','2'] }"
      ]
    },
    "starterCode": "export default function parseQueryStringAdvanced(qs) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function parseQueryStringAdvanced(qs: string): any {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Parse a querystring into nested objects and arrays by tokenizing bracket notation into path segments. Handle repeated keys by accumulating into arrays, treat `[]` as push, and gracefully resolve collisions between primitives, arrays, and objects. This mimics how popular parsers like `qs` behave.",
      "approaches": [
        {
          "title": "Approach: Key-path parsing + iterative assign (recommended)",
          "prose": "High-level approach:\n1) Normalize the string (strip `?`, split by `&`).\n2) For each pair, decode key/value and replace `+` with spaces.\n3) Parse the key into path segments (e.g., `a[b][]` -> ['a','b','']).\n4) Walk/construct the output object following the path. Empty segment means array push.\n5) If a slot already holds a primitive, convert it to an array to preserve all values.\n\nComplexity: O(n * d) where d is nesting depth.",
          "codeJs": "function safeDecode(s) {\n  try {\n    return decodeURIComponent(s);\n  } catch {\n    return s;\n  }\n}\n\nfunction parseKeyPath(key) {\n  // Examples:\n  // \"a\" -> [\"a\"]\n  // \"a[b][c]\" -> [\"a\",\"b\",\"c\"]\n  // \"filters[tag][]\" -> [\"filters\",\"tag\",\"\"]\n  const parts = [];\n  const re = /([^\\[\\]]+)|\\[(.*?)\\]/g;\n  let m;\n\n  while ((m = re.exec(key)) !== null) {\n    const part = m[1] !== undefined ? m[1] : (m[2] !== undefined ? m[2] : '');\n    parts.push(part);\n  }\n\n  if (parts.length > 0 && parts[0] === '') parts.shift();\n  return parts;\n}\n\nfunction assignPath(obj, path, value) {\n  let cur = obj;\n\n  for (let i = 0; i < path.length; i++) {\n    const key = path[i];\n    const isLast = i === path.length - 1;\n\n    if (key === '') {\n      // array push\n      if (!Array.isArray(cur)) {\n        // convert to array if needed\n        cur = [];\n      }\n      if (isLast) {\n        cur.push(value);\n        return;\n      } else {\n        if (cur.length === 0 || typeof cur[cur.length - 1] !== 'object') {\n          cur.push({});\n        }\n        cur = cur[cur.length - 1];\n        continue;\n      }\n    }\n\n    if (isLast) {\n      if (cur[key] === undefined) {\n        cur[key] = value;\n      } else if (Array.isArray(cur[key])) {\n        cur[key].push(value);\n      } else {\n        cur[key] = [cur[key], value];\n      }\n    } else {\n      if (cur[key] === undefined || typeof cur[key] !== 'object') {\n        // decide next container: array if next is '', else object\n        cur[key] = path[i + 1] === '' ? [] : {};\n      }\n      cur = cur[key];\n    }\n  }\n}\n\nexport default function parseQueryStringAdvanced(qs) {\n  if (typeof qs !== 'string') return {};\n\n  const raw = qs.startsWith('?') ? qs.slice(1) : qs;\n  if (!raw) return {};\n\n  const out = {};\n\n  for (const part of raw.split('&')) {\n    if (!part) continue;\n\n    const eq = part.indexOf('=');\n    const kRaw = eq === -1 ? part : part.slice(0, eq);\n    const vRaw = eq === -1 ? '' : part.slice(eq + 1);\n\n    const key = safeDecode(kRaw.replace(/\\+/g, ' '));\n    if (!key) continue;\n\n    const val = safeDecode(vRaw.replace(/\\+/g, ' '));\n\n    const path = parseKeyPath(key);\n    if (path.length === 0) continue;\n\n    assignPath(out, path, val);\n  }\n\n  return out;\n}\n",
          "codeTs": "function safeDecode(s: string): string {\n  try {\n    return decodeURIComponent(s);\n  } catch {\n    return s;\n  }\n}\n\nfunction parseKeyPath(key: string): string[] {\n  // Examples:\n  // \"a\" -> [\"a\"]\n  // \"a[b][c]\" -> [\"a\",\"b\",\"c\"]\n  // \"filters[tag][]\" -> [\"filters\",\"tag\",\"\"]\n  const parts: string[] = [];\n  const re = /([^\\[\\]]+)|\\[(.*?)\\]/g;\n  let m: RegExpExecArray | null;\n\n  while ((m = re.exec(key)) !== null) {\n    const part = m[1] !== undefined ? m[1] : (m[2] !== undefined ? m[2] : '');\n    parts.push(part);\n  }\n\n  if (parts.length > 0 && parts[0] === '') parts.shift();\n  return parts;\n}\n\nfunction assignPath(obj: any, path: string[], value: any): void {\n  let cur: any = obj;\n\n  for (let i = 0; i < path.length; i++) {\n    const key = path[i];\n    const isLast = i === path.length - 1;\n\n    if (key === '') {\n      if (!Array.isArray(cur)) {\n        // cannot rebind parent reference here; assume structure is created correctly upstream\n        // in practice, this branch will only be hit when parent was already an array\n      }\n      if (isLast) {\n        cur.push(value);\n        return;\n      } else {\n        if (cur.length === 0 || typeof cur[cur.length - 1] !== 'object') {\n          cur.push({});\n        }\n        cur = cur[cur.length - 1];\n        continue;\n      }\n    }\n\n    if (isLast) {\n      if (cur[key] === undefined) {\n        cur[key] = value;\n      } else if (Array.isArray(cur[key])) {\n        cur[key].push(value);\n      } else {\n        cur[key] = [cur[key], value];\n      }\n    } else {\n      if (cur[key] === undefined || typeof cur[key] !== 'object') {\n        cur[key] = path[i + 1] === '' ? [] : {};\n      }\n      cur = cur[key];\n    }\n  }\n}\n\nexport default function parseQueryStringAdvanced(qs: string): any {\n  if (typeof qs !== 'string') return {};\n\n  const raw = qs.startsWith('?') ? qs.slice(1) : qs;\n  if (!raw) return {};\n\n  const out: any = {};\n\n  for (const part of raw.split('&')) {\n    if (!part) continue;\n\n    const eq = part.indexOf('=');\n    const kRaw = eq === -1 ? part : part.slice(0, eq);\n    const vRaw = eq === -1 ? '' : part.slice(eq + 1);\n\n    const key = safeDecode(kRaw.replace(/\\+/g, ' '));\n    if (!key) continue;\n\n    const val = safeDecode(vRaw.replace(/\\+/g, ' '));\n\n    const path = parseKeyPath(key);\n    if (path.length === 0) continue;\n\n    assignPath(out, path, val);\n  }\n\n  return out;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Overwriting previous values instead of accumulating into arrays.",
          "Not handling `[]` syntax for arrays.",
          "Breaking when object/array shapes conflict (need to preserve all values).",
          "Using naive bracket parsing that creates extra empty segments (e.g., turning `[]` into two empties)."
        ],
        "edgeCases": [
          "`a[b][c]=1` => { a: { b: { c: '1' } } }",
          "`a=1&a[b]=2` => { a: ['1', { b: '2' }] } (implementation-dependent, but should not lose data)",
          "`arr[][]=1&arr[][]=2` => { arr: [ [ '1' ], [ '2' ] ] }"
        ],
        "techniques": [
          "Path tokenization",
          "Progressive object/array materialization",
          "Collision handling"
        ]
      },
      "followUpQuestions": [
        "js-deep-clone-cycles-3"
      ],
      "resources": [
        {
          "title": "qs library (reference implementation)",
          "url": "https://github.com/ljharb/qs"
        }
      ]
    },
    "tests": "import parseQueryStringAdvanced from './file';\n\ndescribe('parseQueryStringAdvanced', () => {\n  test('parses repeated keys into arrays', () => {\n    expect(parseQueryStringAdvanced('a=1&a=2')).toEqual({ a: ['1','2'] });\n  });\n\n  test('parses bracket arrays', () => {\n    expect(parseQueryStringAdvanced('a[]=1&a[]=2')).toEqual({ a: ['1','2'] });\n  });\n\n  test('parses nested objects', () => {\n    expect(parseQueryStringAdvanced('user[name]=john&user[age]=30')).toEqual({ user: { name: 'john', age: '30' } });\n  });\n\n  test('parses nested arrays', () => {\n    expect(parseQueryStringAdvanced('filters[tag][]=a&filters[tag][]=b')).toEqual({ filters: { tag: ['a','b'] } });\n  });\n\n  test('mixes forms without losing data', () => {\n    expect(parseQueryStringAdvanced('a=1&a=2&a[]=3')).toEqual({ a: ['1','2','3'] });\n  });\n\n  test('decodes + and percent encoding', () => {\n    expect(parseQueryStringAdvanced('q=hello+world&x=%26')).toEqual({ q: 'hello world', x: '&' });\n  });\n\n  test('missing = means empty string', () => {\n    expect(parseQueryStringAdvanced('flag')).toEqual({ flag: '' });\n  });\n\n  test('empty input returns {}', () => {\n    expect(parseQueryStringAdvanced('')).toEqual({});\n    expect(parseQueryStringAdvanced('?')).toEqual({});\n  });\n});\n",
    "testsTs": "import parseQueryStringAdvanced from './file';\n\ndescribe('parseQueryStringAdvanced (TypeScript)', () => {\n  it('parses nested objects', () => {\n    expect(parseQueryStringAdvanced('a[b]=1')).toEqual({ a: { b: '1' } });\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-add-strings",
    "title": "Add Large Integers as Strings",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "bytedance"
    ],
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "strings",
      "numbers",
      "math",
      "iteration",
      "algorithms"
    ],
    "description": {
      "summary": "Add two non-negative integers represented as strings and return the sum as a string. You may not convert the entire string to a number or use BigInt — simulate grade-school addition with carry.",
      "arguments": [
        {
          "name": "a",
          "type": "string",
          "desc": "First non-negative integer string."
        },
        {
          "name": "b",
          "type": "string",
          "desc": "Second non-negative integer string."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "The sum of the two numbers, as a string."
      },
      "examples": [
        "addStrings('123', '4567') // => '4690'",
        "addStrings('9', '1') // => '10'",
        "addStrings('999', '1') // => '1000'"
      ]
    },
    "starterCode": "export default function addStrings(a, b) {\n  // TODO: add two numeric strings without converting to Number/BigInt\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function addStrings(a: string, b: string): string {\n  // TODO: add two numeric strings without converting to Number/BigInt\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Walk both strings from right to left, add digits plus carry, and build the result in reverse. This mirrors manual addition and avoids numeric overflow.",
      "approaches": [
        {
          "title": "Approach 1: Two-pointer addition with carry",
          "prose": "Steps:\n1) Set `i` to the last index of `a`, `j` to the last index of `b`, and `carry = 0`.\n2) While `i >= 0` or `j >= 0` or `carry > 0`, read digits (0 if pointer is past start).\n3) Compute `sum = da + db + carry`, push `sum % 10` to an output array, and update `carry = Math.floor(sum / 10)`.\n4) Reverse the output array and join into a string.\n\nComplexity: O(n) time, O(n) space.",
          "codeJs": "export default function addStrings(a, b) {\n  let i = a.length - 1;\n  let j = b.length - 1;\n  let carry = 0;\n  const out = [];\n\n  while (i >= 0 || j >= 0 || carry) {\n    const da = i >= 0 ? a.charCodeAt(i) - 48 : 0;\n    const db = j >= 0 ? b.charCodeAt(j) - 48 : 0;\n    const sum = da + db + carry;\n    out.push(String(sum % 10));\n    carry = Math.floor(sum / 10);\n    i--;\n    j--;\n  }\n\n  return out.reverse().join('');\n}\n",
          "codeTs": "export default function addStrings(a: string, b: string): string {\n  let i = a.length - 1;\n  let j = b.length - 1;\n  let carry = 0;\n  const out: string[] = [];\n\n  while (i >= 0 || j >= 0 || carry) {\n    const da = i >= 0 ? a.charCodeAt(i) - 48 : 0;\n    const db = j >= 0 ? b.charCodeAt(j) - 48 : 0;\n    const sum = da + db + carry;\n    out.push(String(sum % 10));\n    carry = Math.floor(sum / 10);\n    i--;\n    j--;\n  }\n\n  return out.reverse().join('');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Converting the whole string to Number will overflow for large inputs.",
          "Forgetting to append the final carry.",
          "Building strings by concatenation in a loop can be slower than using an array."
        ],
        "edgeCases": [
          "'0' + '0' => '0'",
          "Different lengths (e.g., '1' + '9999').",
          "Very long inputs (thousands of digits)."
        ],
        "techniques": [
          "Two-pointer traversal from the end.",
          "Carry handling.",
          "Character-to-digit conversion."
        ]
      }
    },
    "tests": "import addStrings from './addStrings';\n\ndescribe('addStrings', () => {\n  test('adds small numbers', () => {\n    expect(addStrings('123', '4567')).toBe('4690');\n  });\n\n  test('handles carry across digits', () => {\n    expect(addStrings('9', '1')).toBe('10');\n    expect(addStrings('999', '1')).toBe('1000');\n  });\n\n  test('handles different lengths', () => {\n    expect(addStrings('1', '9999')).toBe('10000');\n  });\n\n  test('handles very large numbers', () => {\n    const a = '999999999999999999999999999999';\n    const b = '1';\n    expect(addStrings(a, b)).toBe('1000000000000000000000000000000');\n  });\n});\n",
    "testsTs": "import addStrings from './addStrings';\n\ndescribe('addStrings (TypeScript)', () => {\n  it('adds numbers as strings', () => {\n    expect(addStrings('500', '500')).toBe('1000');\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-lodash-get",
    "title": "Implement lodash.get",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "bytedance"
    ],
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "objects",
      "parsing",
      "iteration"
    ],
    "description": {
      "summary": "Implement `get(obj, path, defaultValue)` where `path` is a string like `user.profile.name` or `a[0].b`. Return `defaultValue` when the path does not exist.",
      "arguments": [
        {
          "name": "obj",
          "type": "any",
          "desc": "Object to query."
        },
        {
          "name": "path",
          "type": "string | string[]",
          "desc": "Path string (dot/bracket notation) or array of path segments."
        },
        {
          "name": "defaultValue",
          "type": "any (optional)",
          "desc": "Value to return if the path is missing."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "Resolved value or the default."
      },
      "examples": [
        "get({ a: { b: 2 } }, 'a.b') // => 2",
        "get({ a: [{ b: 3 }] }, 'a[0].b') // => 3",
        "get({}, 'a.b', 'fallback') // => 'fallback'"
      ]
    },
    "starterCode": "export default function get(obj, path, defaultValue) {\n  // TODO: Implement lodash.get\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function get(obj: any, path: string | string[], defaultValue?: any): any {\n  // TODO: Implement lodash.get\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Parse the path into segments and walk the object step by step. If any segment is missing, return the default.",
      "approaches": [
        {
          "title": "Approach 1: Regex tokenization + iterative walk",
          "prose": "Steps:\n1) Normalize path: if it's an array, use it; if it's a string, extract segments with a regex.\n2) Walk the object: for each segment, if `cur == null` or segment not in `cur`, return `defaultValue`.\n3) Return the final value (or default if it's `undefined`).",
          "codeJs": "export default function get(obj, path, defaultValue) {\n  if (path == null || path === '') return obj;\n  const parts = Array.isArray(path)\n    ? path\n    : String(path).match(/[^.[\\]]+/g) || [];\n\n  let cur = obj;\n  for (const key of parts) {\n    if (cur == null || !(key in Object(cur))) return defaultValue;\n    cur = cur[key];\n  }\n\n  return cur === undefined ? defaultValue : cur;\n}\n",
          "codeTs": "export default function get(obj: any, path: string | string[], defaultValue?: any): any {\n  if (path == null || path === '') return obj;\n  const parts = Array.isArray(path)\n    ? path\n    : String(path).match(/[^.[\\]]+/g) || [];\n\n  let cur: any = obj;\n  for (const key of parts) {\n    if (cur == null || !(key in Object(cur))) return defaultValue;\n    cur = cur[key as any];\n  }\n\n  return cur === undefined ? defaultValue : cur;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Not handling bracket notation (e.g., `a[0].b`).",
          "Throwing when encountering `null`/`undefined` along the path.",
          "Confusing missing paths with existing values that are `undefined`."
        ],
        "edgeCases": [
          "Empty path returns the original object.",
          "Missing path returns default.",
          "Array indexing like `items[2]`."
        ],
        "techniques": [
          "Regex-based path parsing.",
          "Iterative traversal with early exit."
        ]
      }
    },
    "tests": "import get from './get';\n\ndescribe('get', () => {\n  test('reads nested values', () => {\n    const obj = { user: { profile: { name: 'Ada' } } };\n    expect(get(obj, 'user.profile.name')).toBe('Ada');\n  });\n\n  test('supports bracket notation', () => {\n    const obj = { a: [{ b: 3 }] };\n    expect(get(obj, 'a[0].b')).toBe(3);\n  });\n\n  test('returns default when missing', () => {\n    expect(get({ a: 1 }, 'a.b', 'x')).toBe('x');\n  });\n\n  test('returns default for null root', () => {\n    expect(get(null, 'a.b', 5)).toBe(5);\n  });\n});\n",
    "testsTs": "import get from './get';\n\ndescribe('get (TypeScript)', () => {\n  it('returns value or default', () => {\n    const obj = { a: { b: 2 } };\n    expect(get(obj, 'a.b', 0)).toBe(2);\n    expect(get(obj, 'a.c', 0)).toBe(0);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-three-sum",
    "title": "3Sum (find unique triplets that sum to zero)",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "bytedance"
    ],
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "arrays",
      "algorithms",
      "sorting",
      "math"
    ],
    "description": {
      "summary": "Given an array of integers, return all unique triplets `[a, b, c]` such that `a + b + c = 0`. Triplets should be unique, and each triplet should be in non-decreasing order.",
      "arguments": [
        {
          "name": "nums",
          "type": "number[]",
          "desc": "Input array of integers."
        }
      ],
      "returns": {
        "type": "number[][]",
        "desc": "Array of unique triplets that sum to zero."
      },
      "examples": [
        "threeSum([-1, 0, 1, 2, -1, -4]) // => [[-1, -1, 2], [-1, 0, 1]]",
        "threeSum([0, 0, 0, 0]) // => [[0, 0, 0]]",
        "threeSum([1, 2, -2, -1]) // => []"
      ]
    },
    "starterCode": "export default function threeSum(nums) {\n  // TODO: Return all unique triplets that sum to zero\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function threeSum(nums: number[]): number[][] {\n  // TODO: Return all unique triplets that sum to zero\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Sort the array, then fix one index and use a two-pointer scan for the remaining pair. Skip duplicates at each step to keep triplets unique.",
      "approaches": [
        {
          "title": "Approach 1: Sort + two pointers",
          "prose": "Steps:\n1) Sort the array.\n2) For each index `i`, use two pointers `l` and `r` to find pairs that sum to `-nums[i]`.\n3) Skip duplicate values for `i`, `l`, and `r` to avoid repeated triplets.\n\nComplexity: O(n^2) time, O(1) extra space (excluding output).",
          "codeJs": "export default function threeSum(nums) {\n  const out = [];\n  const arr = nums.slice().sort((a, b) => a - b);\n\n  for (let i = 0; i < arr.length - 2; i++) {\n    if (i > 0 && arr[i] === arr[i - 1]) continue;\n    let l = i + 1;\n    let r = arr.length - 1;\n    while (l < r) {\n      const sum = arr[i] + arr[l] + arr[r];\n      if (sum === 0) {\n        out.push([arr[i], arr[l], arr[r]]);\n        l++;\n        r--;\n        while (l < r && arr[l] === arr[l - 1]) l++;\n        while (l < r && arr[r] === arr[r + 1]) r--;\n      } else if (sum < 0) {\n        l++;\n      } else {\n        r--;\n      }\n    }\n  }\n\n  return out;\n}\n",
          "codeTs": "export default function threeSum(nums: number[]): number[][] {\n  const out: number[][] = [];\n  const arr = nums.slice().sort((a, b) => a - b);\n\n  for (let i = 0; i < arr.length - 2; i++) {\n    if (i > 0 && arr[i] === arr[i - 1]) continue;\n    let l = i + 1;\n    let r = arr.length - 1;\n    while (l < r) {\n      const sum = arr[i] + arr[l] + arr[r];\n      if (sum === 0) {\n        out.push([arr[i], arr[l], arr[r]]);\n        l++;\n        r--;\n        while (l < r && arr[l] === arr[l - 1]) l++;\n        while (l < r && arr[r] === arr[r + 1]) r--;\n      } else if (sum < 0) {\n        l++;\n      } else {\n        r--;\n      }\n    }\n  }\n\n  return out;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to skip duplicates leads to repeated triplets.",
          "Not sorting makes the two-pointer strategy invalid.",
          "Mutating the input array unintentionally."
        ],
        "edgeCases": [
          "All zeros: [0,0,0,0] => [[0,0,0]]",
          "No valid triplets => []",
          "Duplicates with negatives and positives."
        ],
        "techniques": [
          "Sorting + two-pointer scan.",
          "Duplicate skipping."
        ]
      }
    },
    "tests": "import threeSum from './threeSum';\n\nconst normalize = (triplets) => {\n  return triplets\n    .map((t) => t.slice().sort((a, b) => a - b))\n    .sort((a, b) => (a[0] - b[0]) || (a[1] - b[1]) || (a[2] - b[2]));\n};\n\ndescribe('threeSum', () => {\n  test('finds unique triplets', () => {\n    const res = threeSum([-1, 0, 1, 2, -1, -4]);\n    expect(normalize(res)).toEqual(normalize([[-1, -1, 2], [-1, 0, 1]]));\n  });\n\n  test('handles all zeros', () => {\n    const res = threeSum([0, 0, 0, 0]);\n    expect(normalize(res)).toEqual([[0, 0, 0]]);\n  });\n\n  test('returns empty when no triplets', () => {\n    const res = threeSum([1, 2, -2, -1]);\n    expect(res).toEqual([]);\n  });\n});\n",
    "testsTs": "import threeSum from './threeSum';\n\ndescribe('threeSum (TypeScript)', () => {\n  it('returns empty when no match', () => {\n    expect(threeSum([1, 2, 3])).toEqual([]);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-merge-sorted-arrays",
    "title": "Merge Two Sorted Arrays",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "apple",
      "meta"
    ],
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "sorting",
      "algorithms",
      "iteration"
    ],
    "description": {
      "summary": "Merge two already-sorted arrays into a single sorted array. Do not call sort on the combined output; use a two-pointer merge.",
      "arguments": [
        {
          "name": "a",
          "type": "number[]",
          "desc": "Sorted array (non-decreasing)."
        },
        {
          "name": "b",
          "type": "number[]",
          "desc": "Sorted array (non-decreasing)."
        }
      ],
      "returns": {
        "type": "number[]",
        "desc": "Merged sorted array."
      },
      "examples": [
        "mergeSortedArrays([1,3,5], [2,4,6]) // => [1,2,3,4,5,6]",
        "mergeSortedArrays([], [1,2]) // => [1,2]",
        "mergeSortedArrays([1,2], []) // => [1,2]"
      ]
    },
    "starterCode": "export default function mergeSortedArrays(a, b) {\n  // TODO: Merge two sorted arrays without using sort()\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function mergeSortedArrays(a: number[], b: number[]): number[] {\n  // TODO: Merge two sorted arrays without using sort()\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Use two pointers to walk both arrays and push the smaller current value each step. This runs in O(n + m).",
      "approaches": [
        {
          "title": "Approach 1: Two-pointer merge",
          "prose": "Steps:\n1) Initialize i=0, j=0 and result = [].\n2) While i < a.length and j < b.length, push the smaller of a[i], b[j], then advance that pointer.\n3) Append the remaining tail from whichever array is left.\n\nComplexity: O(n + m) time, O(n + m) space.",
          "codeJs": "export default function mergeSortedArrays(a, b) {\n  const out = [];\n  let i = 0;\n  let j = 0;\n  while (i < a.length && j < b.length) {\n    if (a[i] <= b[j]) {\n      out.push(a[i++]);\n    } else {\n      out.push(b[j++]);\n    }\n  }\n  while (i < a.length) out.push(a[i++]);\n  while (j < b.length) out.push(b[j++]);\n  return out;\n}\n",
          "codeTs": "export default function mergeSortedArrays(a: number[], b: number[]): number[] {\n  const out: number[] = [];\n  let i = 0;\n  let j = 0;\n  while (i < a.length && j < b.length) {\n    if (a[i] <= b[j]) {\n      out.push(a[i++]);\n    } else {\n      out.push(b[j++]);\n    }\n  }\n  while (i < a.length) out.push(a[i++]);\n  while (j < b.length) out.push(b[j++]);\n  return out;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using sort() on the merged array (not allowed in the prompt).",
          "Forgetting to append the remaining tail values."
        ],
        "edgeCases": [
          "One or both arrays empty.",
          "Duplicate values and negatives."
        ],
        "techniques": [
          "Two-pointer merge",
          "Stable ordering"
        ]
      }
    },
    "tests": "import mergeSortedArrays from './mergeSortedArrays';\n\ndescribe('mergeSortedArrays', () => {\n  test('merges two sorted arrays', () => {\n    expect(mergeSortedArrays([1,3,5], [2,4,6])).toEqual([1,2,3,4,5,6]);\n  });\n\n  test('handles empty arrays', () => {\n    expect(mergeSortedArrays([], [1,2])).toEqual([1,2]);\n    expect(mergeSortedArrays([1,2], [])).toEqual([1,2]);\n  });\n\n  test('handles duplicates', () => {\n    expect(mergeSortedArrays([1,2,2], [2,3])).toEqual([1,2,2,2,3]);\n  });\n});\n",
    "testsTs": "import mergeSortedArrays from './mergeSortedArrays';\n\ndescribe('mergeSortedArrays (TypeScript)', () => {\n  it('merges arrays', () => {\n    expect(mergeSortedArrays([0], [1])).toEqual([0,1]);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-valid-anagram",
    "title": "Valid Anagram",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "apple"
    ],
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "strings",
      "algorithms",
      "sorting",
      "iteration"
    ],
    "description": {
      "summary": "Return true if two strings are anagrams (same characters with the same counts). Treat strings as case-sensitive and include all characters.",
      "arguments": [
        {
          "name": "s",
          "type": "string",
          "desc": "First string."
        },
        {
          "name": "t",
          "type": "string",
          "desc": "Second string."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "True if s and t are anagrams; otherwise false."
      },
      "examples": [
        "isAnagram('anagram', 'nagaram') // => true",
        "isAnagram('rat', 'car') // => false"
      ]
    },
    "starterCode": "export default function isAnagram(s, t) {\n  // TODO: Return true if s and t are anagrams\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function isAnagram(s: string, t: string): boolean {\n  // TODO: Return true if s and t are anagrams\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Count characters in one string and subtract using the other. If all counts end at zero, they are anagrams.",
      "approaches": [
        {
          "title": "Approach 1: Frequency map",
          "prose": "Steps:\n1) If lengths differ, return false.\n2) Build a frequency map for s.\n3) Decrement counts for t; if any count goes below 0, return false.\n4) Return true at the end.\n\nComplexity: O(n) time, O(k) space.",
          "codeJs": "export default function isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  const freq = Object.create(null);\n  for (const ch of s) freq[ch] = (freq[ch] || 0) + 1;\n  for (const ch of t) {\n    if (!freq[ch]) return false;\n    freq[ch] -= 1;\n  }\n  return true;\n}\n",
          "codeTs": "export default function isAnagram(s: string, t: string): boolean {\n  if (s.length !== t.length) return false;\n  const freq: Record<string, number> = Object.create(null);\n  for (const ch of s) freq[ch] = (freq[ch] || 0) + 1;\n  for (const ch of t) {\n    if (!freq[ch]) return false;\n    freq[ch] -= 1;\n  }\n  return true;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Ignoring length mismatch (quick fail).",
          "Using sort() is fine but slower (O(n log n))."
        ],
        "edgeCases": [
          "Empty strings are anagrams.",
          "Repeated characters."
        ],
        "techniques": [
          "Frequency counting",
          "Early exit"
        ]
      }
    },
    "tests": "import isAnagram from './isAnagram';\n\ndescribe('isAnagram', () => {\n  test('detects anagrams', () => {\n    expect(isAnagram('anagram', 'nagaram')).toBe(true);\n  });\n\n  test('detects non-anagrams', () => {\n    expect(isAnagram('rat', 'car')).toBe(false);\n  });\n\n  test('handles empty strings', () => {\n    expect(isAnagram('', '')).toBe(true);\n  });\n});\n",
    "testsTs": "import isAnagram from './isAnagram';\n\ndescribe('isAnagram (TypeScript)', () => {\n  it('handles repeats', () => {\n    expect(isAnagram('aabb', 'bbaa')).toBe(true);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-median-of-array",
    "title": "Median of Array",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "apple"
    ],
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "numbers",
      "math",
      "sorting",
      "algorithms"
    ],
    "description": {
      "summary": "Return the median of a list of numbers. For even length, return the average of the two middle values. Do not mutate the input.",
      "arguments": [
        {
          "name": "nums",
          "type": "number[]",
          "desc": "Array of numbers."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "Median value."
      },
      "examples": [
        "median([3,1,2]) // => 2",
        "median([4,1,2,3]) // => 2.5"
      ]
    },
    "starterCode": "export default function median(nums) {\n  // TODO: Return the median without mutating input\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function median(nums: number[]): number {\n  // TODO: Return the median without mutating input\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Sort a copy of the array, then take the middle value (or average of two middles).",
      "approaches": [
        {
          "title": "Approach 1: Sort copy and pick middle",
          "prose": "Steps:\n1) Copy and sort the array.\n2) Let mid = Math.floor(n/2).\n3) If n is odd, return sorted[mid].\n4) If n is even, return (sorted[mid-1] + sorted[mid]) / 2.\n\nComplexity: O(n log n) time due to sorting.",
          "codeJs": "export default function median(nums) {\n  const arr = nums.slice().sort((a, b) => a - b);\n  const n = arr.length;\n  if (n === 0) return NaN;\n  const mid = Math.floor(n / 2);\n  if (n % 2 === 1) return arr[mid];\n  return (arr[mid - 1] + arr[mid]) / 2;\n}\n",
          "codeTs": "export default function median(nums: number[]): number {\n  const arr = nums.slice().sort((a, b) => a - b);\n  const n = arr.length;\n  if (n === 0) return NaN;\n  const mid = Math.floor(n / 2);\n  if (n % 2 === 1) return arr[mid];\n  return (arr[mid - 1] + arr[mid]) / 2;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Sorting mutates the array if you forget to copy.",
          "Even length requires averaging."
        ],
        "edgeCases": [
          "Empty array (return NaN or throw).",
          "Negative values."
        ],
        "techniques": [
          "Sorting",
          "Middle index math"
        ]
      }
    },
    "tests": "import median from './median';\n\ndescribe('median', () => {\n  test('odd length', () => {\n    expect(median([3,1,2])).toBe(2);\n  });\n\n  test('even length', () => {\n    expect(median([4,1,2,3])).toBe(2.5);\n  });\n});\n",
    "testsTs": "import median from './median';\n\ndescribe('median (TypeScript)', () => {\n  it('handles negatives', () => {\n    expect(median([-1, -5, -3])).toBe(-3);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-dom-renderer",
    "title": "Build a DOM Renderer from a Nested Object",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "dom",
      "tree",
      "recursion",
      "traversal"
    ],
    "companies": [
      "meta"
    ],
    "description": {
      "summary": "Implement render(node) to convert a JSON-like DOM description into real DOM nodes using createElement/createTextNode. Constraints: handle string/number children, skip null/undefined, map className→class, avoid innerHTML. Complexity: O(n) time, O(h) recursion stack.",
      "arguments": [
        {
          "name": "node",
          "type": "Object",
          "desc": "A DOM description like { type: 'div', props: {...}, children: [...] }, where children can be strings, numbers, or nested nodes."
        }
      ],
      "returns": {
        "type": "HTMLElement | Text",
        "desc": "The root DOM node (HTMLElement or Text) created from the input."
      },
      "examples": [
        "const tree = { type: 'div', props: { id: 'root' }, children: [\n  { type: 'h1', children: 'Hello' },\n  { type: 'p', children: 'World' }\n] };\nconst el = render(tree);\nel.getAttribute('id'); // 'root'",
        "render({ type: 'span', children: 'Hi' }).textContent // 'Hi'",
        "render({ type: 'div', children: [0, '', null, { type: 'em', children: 'ok' }] }).textContent // '0ok'"
      ]
    },
    "starterCode": "export default function render(node) {\n  // TODO: Create DOM nodes from a nested object\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type DomNode = {\n  type: string;\n  props?: Record<string, any>;\n  children?: DomNode[] | string | number | null;\n};\n\nexport default function render(node: DomNode | string | number | null): HTMLElement | Text {\n  // TODO: Create DOM nodes from a nested object\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: recursively build DOM nodes, mapping className to class, and returning Text nodes for primitive children. Always append children in order to preserve structure.",
      "approaches": [
        {
          "title": "Approach: Recursive build with createElement",
          "prose": "Step-by-step:\n1) If node is null/undefined, return an empty Text node to keep structure stable.\n2) If node is a string or number, return document.createTextNode(String(node)).\n3) Create the element with document.createElement(node.type).\n4) Apply props: skip null/undefined, map className → class, set other attributes as strings.\n5) Render children: if array, render each child in order and append; if single, render and append.\n6) Return the built element.",
          "codeJs": "export default function render(node) {\n  if (node == null) return document.createTextNode('');\n  if (typeof node === 'string' || typeof node === 'number') {\n    return document.createTextNode(String(node));\n  }\n  const el = document.createElement(node.type);\n  const props = node.props || {};\n  for (const [key, value] of Object.entries(props)) {\n    if (value == null) continue;\n    if (key === 'className') el.setAttribute('class', String(value));\n    else el.setAttribute(key, String(value));\n  }\n  const children = node.children;\n  if (Array.isArray(children)) {\n    children.forEach((child) => el.appendChild(render(child)));\n  } else if (children != null) {\n    el.appendChild(render(children));\n  }\n  return el;\n}\n",
          "codeTs": "type DomNode = {\n  type: string;\n  props?: Record<string, any>;\n  children?: DomNode[] | string | number | null;\n};\n\nexport default function render(node: DomNode | string | number | null): HTMLElement | Text {\n  if (node == null) return document.createTextNode('');\n  if (typeof node === 'string' || typeof node === 'number') {\n    return document.createTextNode(String(node));\n  }\n  const el = document.createElement(node.type);\n  const props = node.props || {};\n  for (const [key, value] of Object.entries(props)) {\n    if (value == null) continue;\n    if (key === 'className') el.setAttribute('class', String(value));\n    else el.setAttribute(key, String(value));\n  }\n  const children = node.children;\n  if (Array.isArray(children)) {\n    children.forEach((child) => el.appendChild(render(child)));\n  } else if (children != null) {\n    el.appendChild(render(children));\n  }\n  return el;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using innerHTML instead of createElement/createTextNode can cause injection bugs.",
          "Dropping 0 or empty-string children changes output.",
          "Forgetting to map className to class leads to missing styles."
        ],
        "edgeCases": [
          "node is null/undefined should return an empty Text node.",
          "children can be a single node or an array.",
          "props can include null/undefined values that should be skipped."
        ],
        "techniques": [
          "Depth-first recursion to preserve order.",
          "Attribute mapping for props.",
          "Text node creation for primitives."
        ]
      },
      "followUpQuestions": [
        "How would you support event handlers (onClick)?",
        "How would you handle boolean attributes (disabled, checked)?"
      ],
      "resources": [
        {
          "title": "MDN — Document.createElement",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement"
        }
      ]
    },
    "tests": "import render from './render';\n\nconst ensureDocument = () => {\n  if (typeof document !== 'undefined') return;\n\n  class TextNode {\n    constructor(value) {\n      this.nodeType = 3;\n      this.nodeValue = String(value);\n    }\n    get textContent() {\n      return this.nodeValue;\n    }\n  }\n\n  class ElementNode {\n    constructor(tag) {\n      this.nodeType = 1;\n      this.tagName = String(tag).toUpperCase();\n      this.attributes = {};\n      this.children = [];\n      this.id = '';\n    }\n    setAttribute(key, value) {\n      this.attributes[key] = String(value);\n    }\n    getAttribute(key) {\n      return Object.prototype.hasOwnProperty.call(this.attributes, key) ? this.attributes[key] : null;\n    }\n    appendChild(child) {\n      this.children.push(child);\n      return child;\n    }\n    get textContent() {\n      return this.children.map((c) => (c.nodeType === 3 ? c.nodeValue : c.textContent)).join('');\n    }\n  }\n\n  globalThis.document = {\n    createElement: (tag) => new ElementNode(tag),\n    createTextNode: (value) => new TextNode(value)\n  };\n};\n\nensureDocument();\n\n\ndescribe('render', () => {\n  test('creates elements with props and nested children', () => {\n    const dom = {\n      type: 'div',\n      props: { id: 'root', className: 'wrap' },\n      children: [\n        { type: 'h1', children: 'HELLO' },\n        { type: 'p', children: 'World' }\n      ]\n    };\n    const el = render(dom);\n    expect(el.tagName).toBe('DIV');\n    expect(el.getAttribute('id')).toBe('root');\n    expect(el.getAttribute('class')).toBe('wrap');\n    expect(el.children.length).toBe(2);\n    expect(el.children[0].tagName).toBe('H1');\n    expect(el.children[0].textContent).toBe('HELLO');\n  });\n\n  test('handles string children', () => {\n    const el = render({ type: 'span', children: 'Hi' });\n    expect(el.textContent).toBe('Hi');\n  });\n\n  test('keeps numeric children and skips null', () => {\n    const el = render({ type: 'div', children: [0, null, '', { type: 'em', children: 'ok' }] });\n    expect(el.textContent).toBe('0ok');\n  });\n\n  test('returns a text node for null input', () => {\n    const node = render(null);\n    expect(node.nodeType).toBe(3);\n    expect(node.textContent).toBe('');\n  });\n});\n",
    "testsTs": "import render from './render';\n\nconst ensureDocument = () => {\n  if (typeof document !== 'undefined') return;\n\n  class TextNode {\n    constructor(value) {\n      this.nodeType = 3;\n      this.nodeValue = String(value);\n    }\n    get textContent() {\n      return this.nodeValue;\n    }\n  }\n\n  class ElementNode {\n    constructor(tag) {\n      this.nodeType = 1;\n      this.tagName = String(tag).toUpperCase();\n      this.attributes = {};\n      this.children = [];\n      this.id = '';\n    }\n    setAttribute(key, value) {\n      this.attributes[key] = String(value);\n    }\n    getAttribute(key) {\n      return Object.prototype.hasOwnProperty.call(this.attributes, key) ? this.attributes[key] : null;\n    }\n    appendChild(child) {\n      this.children.push(child);\n      return child;\n    }\n    get textContent() {\n      return this.children.map((c) => (c.nodeType === 3 ? c.nodeValue : c.textContent)).join('');\n    }\n  }\n\n  globalThis.document = {\n    createElement: (tag) => new ElementNode(tag),\n    createTextNode: (value) => new TextNode(value)\n  };\n};\n\nensureDocument();\n\n\ndescribe('render', () => {\n  test('creates elements with props and nested children', () => {\n    const dom = {\n      type: 'div',\n      props: { id: 'root', className: 'wrap' },\n      children: [\n        { type: 'h1', children: 'HELLO' },\n        { type: 'p', children: 'World' }\n      ]\n    };\n    const el = render(dom);\n    expect(el.tagName).toBe('DIV');\n    expect(el.getAttribute('id')).toBe('root');\n    expect(el.getAttribute('class')).toBe('wrap');\n    expect(el.children.length).toBe(2);\n    expect(el.children[0].tagName).toBe('H1');\n    expect(el.children[0].textContent).toBe('HELLO');\n  });\n\n  test('handles string children', () => {\n    const el = render({ type: 'span', children: 'Hi' });\n    expect(el.textContent).toBe('Hi');\n  });\n\n  test('keeps numeric children and skips null', () => {\n    const el = render({ type: 'div', children: [0, null, '', { type: 'em', children: 'ok' }] });\n    expect(el.textContent).toBe('0ok');\n  });\n\n  test('returns a text node for null input', () => {\n    const node = render(null);\n    expect(node.nodeType).toBe(3);\n    expect(node.textContent).toBe('');\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-timer-manager",
    "title": "Custom setTimeout/clearTimeout Timer Manager",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "timers",
      "event-loop",
      "async",
      "closure"
    ],
    "companies": [
      "meta"
    ],
    "description": {
      "summary": "Build a timer registry with mySetTimeout, myClearTimeout, and myClearAllTimeouts. Return your own numeric ids, store native handles, and clean up on fire. Complexity: O(1) set/clear, O(k) for clearAll.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "Callback to run after the delay."
        },
        {
          "name": "delay",
          "type": "number",
          "desc": "Delay in milliseconds."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "A numeric id that can be used to cancel the timer."
      },
      "examples": [
        "const id = timerManager.mySetTimeout(() => console.log('hi'), 100);\n// later\ntimerManager.myClearTimeout(id);",
        "const a = timerManager.mySetTimeout(() => {}, 10);\nconst b = timerManager.mySetTimeout(() => {}, 20);\ntimerManager.myClearAllTimeouts();",
        "const id = timerManager.mySetTimeout(() => {}, 0); // fires next tick"
      ]
    },
    "starterCode": "function timerManager() {}\n\nlet _nextId = 1;\nconst _timers = new Map();\n\ntimerManager.mySetTimeout = function mySetTimeout(fn, delay) {\n  // TODO: schedule timer, store handle, return id\n  throw new Error('Not implemented');\n};\n\ntimerManager.myClearTimeout = function myClearTimeout(id) {\n  // TODO: cancel if exists and cleanup\n};\n\ntimerManager.myClearAllTimeouts = function myClearAllTimeouts() {\n  // TODO: cancel all timers\n};\n\nexport default timerManager;\n",
    "starterCodeTs": "function timerManager() {}\n\nlet _nextId = 1;\nconst _timers = new Map<number, ReturnType<typeof setTimeout>>();\n\ntimerManager.mySetTimeout = function mySetTimeout(fn: () => void, delay: number): number {\n  // TODO: schedule timer, store handle, return id\n  throw new Error('Not implemented');\n};\n\ntimerManager.myClearTimeout = function myClearTimeout(id: number): void {\n  // TODO: cancel if exists and cleanup\n};\n\ntimerManager.myClearAllTimeouts = function myClearAllTimeouts(): void {\n  // TODO: cancel all timers\n};\n\nexport default timerManager;\n",
    "solutionBlock": {
      "overview": "Goal: wrap setTimeout with an id-based registry so timers can be canceled individually or all at once. Always remove timers from the map when they fire or are cleared.",
      "approaches": [
        {
          "title": "Approach: Map-backed registry",
          "prose": "Step-by-step:\n1) Keep an incrementing id counter and a Map of id → native timeout handle.\n2) mySetTimeout: create a new id, schedule setTimeout, store the handle in the map.\n3) Inside the timeout callback, delete the id from the map before calling the user function.\n4) myClearTimeout: look up the handle by id, clear it, and delete it from the map.\n5) myClearAllTimeouts: clear every handle in the map, then empty the map.",
          "codeJs": "function timerManager() {}\n\nlet _nextId = 1;\nconst _timers = new Map();\n\ntimerManager.mySetTimeout = function mySetTimeout(fn, delay) {\n  const id = _nextId++;\n  const handle = setTimeout(() => {\n    _timers.delete(id);\n    fn();\n  }, delay);\n  _timers.set(id, handle);\n  return id;\n};\n\ntimerManager.myClearTimeout = function myClearTimeout(id) {\n  const handle = _timers.get(id);\n  if (handle != null) {\n    clearTimeout(handle);\n    _timers.delete(id);\n  }\n};\n\ntimerManager.myClearAllTimeouts = function myClearAllTimeouts() {\n  for (const handle of _timers.values()) {\n    clearTimeout(handle);\n  }\n  _timers.clear();\n};\n\nexport default timerManager;\n",
          "codeTs": "function timerManager() {}\n\nlet _nextId = 1;\nconst _timers = new Map<number, ReturnType<typeof setTimeout>>();\n\ntimerManager.mySetTimeout = function mySetTimeout(fn: () => void, delay: number): number {\n  const id = _nextId++;\n  const handle = setTimeout(() => {\n    _timers.delete(id);\n    fn();\n  }, delay);\n  _timers.set(id, handle);\n  return id;\n};\n\ntimerManager.myClearTimeout = function myClearTimeout(id: number): void {\n  const handle = _timers.get(id);\n  if (handle != null) {\n    clearTimeout(handle);\n    _timers.delete(id);\n  }\n};\n\ntimerManager.myClearAllTimeouts = function myClearAllTimeouts(): void {\n  for (const handle of _timers.values()) {\n    clearTimeout(handle);\n  }\n  _timers.clear();\n};\n\nexport default timerManager;\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Returning the native handle instead of your own id breaks the registry.",
          "Not deleting entries after a timer fires causes memory leaks.",
          "clearAllTimeouts without clearing the map leaves stale state."
        ],
        "edgeCases": [
          "Clearing an unknown id should be a no-op.",
          "clearAllTimeouts on an empty map should be safe.",
          "Zero-delay timers should still be tracked and cleaned up."
        ],
        "techniques": [
          "Map for id → handle lookup.",
          "Incrementing id counter.",
          "Cleanup inside the timer callback."
        ]
      },
      "followUpQuestions": [
        "How would you implement setInterval using this registry?",
        "How would you support pausing and resuming timers?"
      ],
      "resources": [
        {
          "title": "MDN — setTimeout",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        }
      ]
    },
    "tests": "import timerManager from './timerManager';\nconst { mySetTimeout, myClearTimeout, myClearAllTimeouts } = timerManager;\n\nconst withFakeTimers = (fn) => {\n  const realSetTimeout = globalThis.setTimeout;\n  const realClearTimeout = globalThis.clearTimeout;\n\n  let now = 0;\n  let nextId = 1;\n  const timers = new Map();\n\n  const fakeSetTimeout = (cb, delay = 0) => {\n    const id = nextId++;\n    const ms = typeof delay === 'number' && delay > 0 ? delay : 0;\n    timers.set(id, { time: now + ms, cb });\n    return id;\n  };\n\n  const fakeClearTimeout = (id) => {\n    timers.delete(id);\n  };\n\n  const advance = (ms) => {\n    const target = now + ms;\n    while (true) {\n      let nextTime = Infinity;\n      let nextTimerId = null;\n      for (const [id, t] of timers.entries()) {\n        if (t.time <= target && t.time < nextTime) {\n          nextTime = t.time;\n          nextTimerId = id;\n        }\n      }\n      if (nextTimerId == null) break;\n      const { cb } = timers.get(nextTimerId);\n      timers.delete(nextTimerId);\n      now = nextTime;\n      cb();\n    }\n    now = target;\n  };\n\n  globalThis.setTimeout = fakeSetTimeout;\n  globalThis.clearTimeout = fakeClearTimeout;\n\n  try {\n    fn({ advance });\n  } finally {\n    globalThis.setTimeout = realSetTimeout;\n    globalThis.clearTimeout = realClearTimeout;\n  }\n};\n\ndescribe('timer manager', () => {\n  test('runs scheduled callback', () => {\n    withFakeTimers(({ advance }) => {\n      let called = 0;\n      mySetTimeout(() => { called += 1; }, 50);\n      expect(called).toBe(0);\n      advance(49);\n      expect(called).toBe(0);\n      advance(1);\n      expect(called).toBe(1);\n    });\n  });\n\n  test('clears a specific timer', () => {\n    withFakeTimers(({ advance }) => {\n      let called = 0;\n      const id = mySetTimeout(() => { called += 1; }, 30);\n      myClearTimeout(id);\n      advance(30);\n      expect(called).toBe(0);\n    });\n  });\n\n  test('clears all timers', () => {\n    withFakeTimers(({ advance }) => {\n      let called = 0;\n      mySetTimeout(() => { called += 1; }, 10);\n      mySetTimeout(() => { called += 1; }, 20);\n      myClearAllTimeouts();\n      advance(25);\n      expect(called).toBe(0);\n    });\n  });\n\n  test('returns unique ids and ignores unknown clear', () => {\n    withFakeTimers(() => {\n      const id1 = mySetTimeout(() => {}, 5);\n      const id2 = mySetTimeout(() => {}, 5);\n      expect(id1 === id2).toBe(false);\n      let threw = false;\n      try { myClearTimeout(99999); } catch { threw = true; }\n      expect(threw).toBe(false);\n    });\n  });\n});\n",
    "testsTs": "import timerManager from './timerManager';\nconst { mySetTimeout, myClearTimeout, myClearAllTimeouts } = timerManager;\n\nconst withFakeTimers = (fn) => {\n  const realSetTimeout = globalThis.setTimeout;\n  const realClearTimeout = globalThis.clearTimeout;\n\n  let now = 0;\n  let nextId = 1;\n  const timers = new Map();\n\n  const fakeSetTimeout = (cb, delay = 0) => {\n    const id = nextId++;\n    const ms = typeof delay === 'number' && delay > 0 ? delay : 0;\n    timers.set(id, { time: now + ms, cb });\n    return id;\n  };\n\n  const fakeClearTimeout = (id) => {\n    timers.delete(id);\n  };\n\n  const advance = (ms) => {\n    const target = now + ms;\n    while (true) {\n      let nextTime = Infinity;\n      let nextTimerId = null;\n      for (const [id, t] of timers.entries()) {\n        if (t.time <= target && t.time < nextTime) {\n          nextTime = t.time;\n          nextTimerId = id;\n        }\n      }\n      if (nextTimerId == null) break;\n      const { cb } = timers.get(nextTimerId);\n      timers.delete(nextTimerId);\n      now = nextTime;\n      cb();\n    }\n    now = target;\n  };\n\n  globalThis.setTimeout = fakeSetTimeout;\n  globalThis.clearTimeout = fakeClearTimeout;\n\n  try {\n    fn({ advance });\n  } finally {\n    globalThis.setTimeout = realSetTimeout;\n    globalThis.clearTimeout = realClearTimeout;\n  }\n};\n\ndescribe('timer manager', () => {\n  test('runs scheduled callback', () => {\n    withFakeTimers(({ advance }) => {\n      let called = 0;\n      mySetTimeout(() => { called += 1; }, 50);\n      expect(called).toBe(0);\n      advance(49);\n      expect(called).toBe(0);\n      advance(1);\n      expect(called).toBe(1);\n    });\n  });\n\n  test('clears a specific timer', () => {\n    withFakeTimers(({ advance }) => {\n      let called = 0;\n      const id = mySetTimeout(() => { called += 1; }, 30);\n      myClearTimeout(id);\n      advance(30);\n      expect(called).toBe(0);\n    });\n  });\n\n  test('clears all timers', () => {\n    withFakeTimers(({ advance }) => {\n      let called = 0;\n      mySetTimeout(() => { called += 1; }, 10);\n      mySetTimeout(() => { called += 1; }, 20);\n      myClearAllTimeouts();\n      advance(25);\n      expect(called).toBe(0);\n    });\n  });\n\n  test('returns unique ids and ignores unknown clear', () => {\n    withFakeTimers(() => {\n      const id1 = mySetTimeout(() => {}, 5);\n      const id2 = mySetTimeout(() => {}, 5);\n      expect(id1 === id2).toBe(false);\n      let threw = false;\n      try { myClearTimeout(99999); } catch { threw = true; }\n      expect(threw).toBe(false);\n    });\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-timer-manager-and-dom-renderer",
    "title": "Clear All Timers + Render DOM Elements",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "intermediate",
    "tags": [
      "timers",
      "dom",
      "recursion",
      "async"
    ],
    "companies": [
      "meta"
    ],
    "description": {
      "summary": "Solve two independent tasks: implement clearAllTimeouts for a timer registry and render a DOM tree from a nested object. Constraints: do not couple logic, avoid innerHTML. Complexity: clearAll O(k), render O(n) time.",
      "arguments": [],
      "returns": {
        "type": "Object",
        "desc": "Expose clearAllTimeouts and render."
      },
      "examples": [
        "timerRender.clearAllTimeouts();",
        "const dom = { type: 'div', children: [{ type: 'span', children: 'Hi' }] };\nconst el = timerRender.render(dom);\nel.textContent // 'Hi'",
        "timerRender.render({ type: 'p', children: [1, '2'] }).textContent // '12'"
      ]
    },
    "starterCode": "const timerRender = {};\n\ntimerRender.clearAllTimeouts = function clearAllTimeouts() {\n  // TODO: cancel all timers in your registry\n};\n\n// DOM renderer\ntimerRender.render = function render(node) {\n  // TODO: build DOM from nested object\n  throw new Error('Not implemented');\n};\n\nexport default timerRender;\n",
    "starterCodeTs": "const timerRender: {\n  clearAllTimeouts: () => void;\n  render: (node: any) => HTMLElement | Text;\n} = {\n  clearAllTimeouts() {\n    // TODO: cancel all timers in your registry\n  },\n  render(node: any) {\n    // TODO: build DOM from nested object\n    throw new Error('Not implemented');\n  }\n};\n\nexport default timerRender;\n",
    "solutionBlock": {
      "overview": "Goal: implement two independent utilities: clear all timeouts in a registry and render a nested DOM description into actual nodes.",
      "approaches": [
        {
          "title": "Approach: Separate utilities",
          "prose": "Step-by-step:\nA) clearAllTimeouts\n1) Store timeout handles in a Map outside the function.\n2) Iterate the map values and call clearTimeout on each handle.\n3) Clear the map so the registry is empty.\n\nB) render\n1) If node is null/undefined, return an empty Text node.\n2) If node is a string or number, return document.createTextNode(String(node)).\n3) Create an element from node.type.\n4) Apply props (map className → class, skip null/undefined values).\n5) Recursively render children (array or single) and append in order.\n6) Return the element.",
          "codeJs": "const timerRender = {};\n\nconst _timers = new Map();\n\ntimerRender.clearAllTimeouts = function clearAllTimeouts() {\n  for (const handle of _timers.values()) clearTimeout(handle);\n  _timers.clear();\n};\n\nfunction render(node) {\n  if (node == null) return document.createTextNode('');\n  if (typeof node === 'string' || typeof node === 'number') return document.createTextNode(String(node));\n  const el = document.createElement(node.type);\n  const props = node.props || {};\n  for (const [k, v] of Object.entries(props)) {\n    if (v == null) continue;\n    el.setAttribute(k === 'className' ? 'class' : k, String(v));\n  }\n  const children = node.children;\n  if (Array.isArray(children)) children.forEach((c) => el.appendChild(render(c)));\n  else if (children != null) el.appendChild(render(children));\n  return el;\n}\n\ntimerRender.render = render;\n\nexport default timerRender;\n",
          "codeTs": "const timerRender: { clearAllTimeouts: () => void; render: (node: any) => HTMLElement | Text } = {\n  clearAllTimeouts() {\n    // registry cleanup here\n  },\n  render(node: any) {\n    if (node == null) return document.createTextNode('');\n    if (typeof node === 'string' || typeof node === 'number') return document.createTextNode(String(node));\n    const el = document.createElement(node.type);\n    const props = node.props || {};\n    for (const [k, v] of Object.entries(props)) {\n      if (v == null) continue;\n      el.setAttribute(k === 'className' ? 'class' : k, String(v));\n    }\n    const children = node.children;\n    if (Array.isArray(children)) children.forEach((c) => el.appendChild(timerRender.render(c)));\n    else if (children != null) el.appendChild(timerRender.render(children));\n    return el;\n  }\n};\n\nexport default timerRender;\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Mixing timer state with render logic makes both harder to test.",
          "Using innerHTML for render is unsafe.",
          "Forgetting to clear the registry after clearing handles."
        ],
        "edgeCases": [
          "clearAllTimeouts should handle an empty registry.",
          "render should accept single child or array.",
          "render should handle primitive children (string/number)."
        ],
        "techniques": [
          "Separate utilities for unrelated tasks.",
          "Map-based timer registry.",
          "Recursive DOM builder."
        ]
      },
      "followUpQuestions": [
        "How would you add event handlers to render?",
        "How would you prove clearAllTimeouts is safe to call during execution?"
      ],
      "resources": []
    },
    "tests": "import timerRender from './timerRender';\nconst { clearAllTimeouts, render } = timerRender;\n\nconst ensureDocument = () => {\n  if (typeof document !== 'undefined') return;\n\n  class TextNode {\n    constructor(value) {\n      this.nodeType = 3;\n      this.nodeValue = String(value);\n    }\n    get textContent() {\n      return this.nodeValue;\n    }\n  }\n\n  class ElementNode {\n    constructor(tag) {\n      this.nodeType = 1;\n      this.tagName = String(tag).toUpperCase();\n      this.attributes = {};\n      this.children = [];\n      this.id = '';\n    }\n    setAttribute(key, value) {\n      this.attributes[key] = String(value);\n    }\n    getAttribute(key) {\n      return Object.prototype.hasOwnProperty.call(this.attributes, key) ? this.attributes[key] : null;\n    }\n    appendChild(child) {\n      this.children.push(child);\n      return child;\n    }\n    get textContent() {\n      return this.children.map((c) => (c.nodeType === 3 ? c.nodeValue : c.textContent)).join('');\n    }\n  }\n\n  globalThis.document = {\n    createElement: (tag) => new ElementNode(tag),\n    createTextNode: (value) => new TextNode(value)\n  };\n};\n\nensureDocument();\n\n\ndescribe('clearAllTimeouts + render', () => {\n  test('render builds nested DOM', () => {\n    const dom = { type: 'div', children: [{ type: 'span', children: 'Hi' }] };\n    const el = render(dom);\n    expect(el.tagName).toBe('DIV');\n    expect(el.textContent).toBe('Hi');\n  });\n\n  test('render maps className and preserves numbers', () => {\n    const el = render({ type: 'div', props: { className: 'box', 'data-x': 1 }, children: 0 });\n    expect(el.getAttribute('class')).toBe('box');\n    expect(el.getAttribute('data-x')).toBe('1');\n    expect(el.textContent).toBe('0');\n  });\n\n  test('render skips null children', () => {\n    const el = render({ type: 'p', children: [null, 'ok'] });\n    expect(el.textContent).toBe('ok');\n  });\n\n  test('clearAllTimeouts is callable', () => {\n    let threw = false;\n    try {\n      clearAllTimeouts();\n    } catch {\n      threw = true;\n    }\n    expect(threw).toBe(false);\n  });\n});\n",
    "testsTs": "import timerRender from './timerRender';\nconst { clearAllTimeouts, render } = timerRender;\n\nconst ensureDocument = () => {\n  if (typeof document !== 'undefined') return;\n\n  class TextNode {\n    constructor(value) {\n      this.nodeType = 3;\n      this.nodeValue = String(value);\n    }\n    get textContent() {\n      return this.nodeValue;\n    }\n  }\n\n  class ElementNode {\n    constructor(tag) {\n      this.nodeType = 1;\n      this.tagName = String(tag).toUpperCase();\n      this.attributes = {};\n      this.children = [];\n      this.id = '';\n    }\n    setAttribute(key, value) {\n      this.attributes[key] = String(value);\n    }\n    getAttribute(key) {\n      return Object.prototype.hasOwnProperty.call(this.attributes, key) ? this.attributes[key] : null;\n    }\n    appendChild(child) {\n      this.children.push(child);\n      return child;\n    }\n    get textContent() {\n      return this.children.map((c) => (c.nodeType === 3 ? c.nodeValue : c.textContent)).join('');\n    }\n  }\n\n  globalThis.document = {\n    createElement: (tag) => new ElementNode(tag),\n    createTextNode: (value) => new TextNode(value)\n  };\n};\n\nensureDocument();\n\n\ndescribe('clearAllTimeouts + render', () => {\n  test('render builds nested DOM', () => {\n    const dom = { type: 'div', children: [{ type: 'span', children: 'Hi' }] };\n    const el = render(dom);\n    expect(el.tagName).toBe('DIV');\n    expect(el.textContent).toBe('Hi');\n  });\n\n  test('render maps className and preserves numbers', () => {\n    const el = render({ type: 'div', props: { className: 'box', 'data-x': 1 }, children: 0 });\n    expect(el.getAttribute('class')).toBe('box');\n    expect(el.getAttribute('data-x')).toBe('1');\n    expect(el.textContent).toBe('0');\n  });\n\n  test('render skips null children', () => {\n    const el = render({ type: 'p', children: [null, 'ok'] });\n    expect(el.textContent).toBe('ok');\n  });\n\n  test('clearAllTimeouts is callable', () => {\n    let threw = false;\n    try {\n      clearAllTimeouts();\n    } catch {\n      threw = true;\n    }\n    expect(threw).toBe(false);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-dom-find-node",
    "title": "Find a Node in a DOM Tree (DFS/BFS)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "dom",
      "tree",
      "traversal",
      "recursion"
    ],
    "companies": [
      "meta"
    ],
    "description": {
      "summary": "Implement findNode(root, predicate) to traverse the DOM and return the first matching element. Use DFS/BFS with early exit. Complexity: O(n) time, O(h) recursion stack.",
      "arguments": [
        {
          "name": "root",
          "type": "Element",
          "desc": "Root DOM element to traverse."
        },
        {
          "name": "predicate",
          "type": "Function",
          "desc": "Returns true for the desired node."
        }
      ],
      "returns": {
        "type": "Element | null",
        "desc": "The first matching node, or null if not found."
      },
      "examples": [
        "const node = findNode(root, el => el.id === 'target');",
        "const btn = findNode(root, el => el.tagName === 'BUTTON');",
        "const none = findNode(root, () => false); // null"
      ]
    },
    "starterCode": "export default function findNode(root, predicate) {\n  // TODO: traverse DOM and return first match\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function findNode(root: Element, predicate: (el: Element) => boolean): Element | null {\n  // TODO: traverse DOM and return first match\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: traverse the DOM tree with DFS and return the first node that satisfies the predicate, or null if no match is found.",
      "approaches": [
        {
          "title": "Approach: DFS with early exit",
          "prose": "Step-by-step:\n1) If root is null/undefined, return null.\n2) If predicate(root) is true, return root immediately.\n3) Iterate through element children and recursively search each subtree.\n4) As soon as a recursive call returns a node, bubble it up.\n5) If no child matches, return null.",
          "codeJs": "export default function findNode(root, predicate) {\n  if (!root) return null;\n  if (predicate(root)) return root;\n  for (const child of root.children) {\n    const found = findNode(child, predicate);\n    if (found) return found;\n  }\n  return null;\n}\n",
          "codeTs": "export default function findNode(root: Element, predicate: (el: Element) => boolean): Element | null {\n  if (!root) return null;\n  if (predicate(root)) return root;\n  for (const child of Array.from(root.children)) {\n    const found = findNode(child, predicate);\n    if (found) return found;\n  }\n  return null;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using childNodes may include text nodes unintentionally.",
          "Not returning early wastes time on large trees.",
          "Not handling a null root can throw."
        ],
        "edgeCases": [
          "Root itself matches the predicate.",
          "No matching node exists.",
          "Deeply nested trees require recursion depth awareness."
        ],
        "techniques": [
          "DFS recursion with early return.",
          "Iterative BFS as an alternative.",
          "Predicate-based filtering."
        ]
      },
      "followUpQuestions": [
        "How would you implement an iterative version?",
        "How would you support shadow DOM boundaries?"
      ],
      "resources": []
    },
    "tests": "import findNode from './findNode';\n\nconst ensureDocument = () => {\n  if (typeof document !== 'undefined') return;\n\n  class TextNode {\n    constructor(value) {\n      this.nodeType = 3;\n      this.nodeValue = String(value);\n    }\n    get textContent() {\n      return this.nodeValue;\n    }\n  }\n\n  class ElementNode {\n    constructor(tag) {\n      this.nodeType = 1;\n      this.tagName = String(tag).toUpperCase();\n      this.attributes = {};\n      this.children = [];\n      this.id = '';\n    }\n    setAttribute(key, value) {\n      this.attributes[key] = String(value);\n    }\n    getAttribute(key) {\n      return Object.prototype.hasOwnProperty.call(this.attributes, key) ? this.attributes[key] : null;\n    }\n    appendChild(child) {\n      this.children.push(child);\n      return child;\n    }\n    get textContent() {\n      return this.children.map((c) => (c.nodeType === 3 ? c.nodeValue : c.textContent)).join('');\n    }\n  }\n\n  globalThis.document = {\n    createElement: (tag) => new ElementNode(tag),\n    createTextNode: (value) => new TextNode(value)\n  };\n};\n\nensureDocument();\n\n\ndescribe('findNode', () => {\n  test('finds a node by predicate', () => {\n    const root = document.createElement('div');\n    const a = document.createElement('span');\n    const b = document.createElement('p');\n    b.id = 'target';\n    root.appendChild(a);\n    root.appendChild(b);\n\n    const found = findNode(root, (el) => el.id === 'target');\n    expect(found).toBe(b);\n  });\n\n  test('returns null when not found', () => {\n    const root = document.createElement('div');\n    expect(findNode(root, () => false)).toBe(null);\n  });\n\n  test('returns root when it matches', () => {\n    const root = document.createElement('div');\n    const found = findNode(root, (el) => el.tagName === 'DIV');\n    expect(found).toBe(root);\n  });\n\n  test('finds deep nested node', () => {\n    const root = document.createElement('div');\n    const mid = document.createElement('section');\n    const deep = document.createElement('span');\n    deep.id = 'deep';\n    mid.appendChild(deep);\n    root.appendChild(mid);\n    const found = findNode(root, (el) => el.id === 'deep');\n    expect(found).toBe(deep);\n  });\n});\n",
    "testsTs": "import findNode from './findNode';\n\nconst ensureDocument = () => {\n  if (typeof document !== 'undefined') return;\n\n  class TextNode {\n    constructor(value) {\n      this.nodeType = 3;\n      this.nodeValue = String(value);\n    }\n    get textContent() {\n      return this.nodeValue;\n    }\n  }\n\n  class ElementNode {\n    constructor(tag) {\n      this.nodeType = 1;\n      this.tagName = String(tag).toUpperCase();\n      this.attributes = {};\n      this.children = [];\n      this.id = '';\n    }\n    setAttribute(key, value) {\n      this.attributes[key] = String(value);\n    }\n    getAttribute(key) {\n      return Object.prototype.hasOwnProperty.call(this.attributes, key) ? this.attributes[key] : null;\n    }\n    appendChild(child) {\n      this.children.push(child);\n      return child;\n    }\n    get textContent() {\n      return this.children.map((c) => (c.nodeType === 3 ? c.nodeValue : c.textContent)).join('');\n    }\n  }\n\n  globalThis.document = {\n    createElement: (tag) => new ElementNode(tag),\n    createTextNode: (value) => new TextNode(value)\n  };\n};\n\nensureDocument();\n\n\ndescribe('findNode', () => {\n  test('finds a node by predicate', () => {\n    const root = document.createElement('div');\n    const a = document.createElement('span');\n    const b = document.createElement('p');\n    b.id = 'target';\n    root.appendChild(a);\n    root.appendChild(b);\n\n    const found = findNode(root, (el) => el.id === 'target');\n    expect(found).toBe(b);\n  });\n\n  test('returns null when not found', () => {\n    const root = document.createElement('div');\n    expect(findNode(root, () => false)).toBe(null);\n  });\n\n  test('returns root when it matches', () => {\n    const root = document.createElement('div');\n    const found = findNode(root, (el) => el.tagName === 'DIV');\n    expect(found).toBe(root);\n  });\n\n  test('finds deep nested node', () => {\n    const root = document.createElement('div');\n    const mid = document.createElement('section');\n    const deep = document.createElement('span');\n    deep.id = 'deep';\n    mid.appendChild(deep);\n    root.appendChild(mid);\n    const found = findNode(root, (el) => el.id === 'deep');\n    expect(found).toBe(deep);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-dom-twin-node",
    "title": "Find the Corresponding Node in Twin DOM Trees",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "dom",
      "tree",
      "traversal"
    ],
    "companies": [
      "meta"
    ],
    "description": {
      "summary": "Given two identical DOM trees and a node in tree A, return the corresponding node in tree B. Traverse both trees in sync or compute a path index. Complexity: O(n) time, O(h) stack.",
      "arguments": [
        {
          "name": "rootA",
          "type": "Element",
          "desc": "Root of tree A."
        },
        {
          "name": "rootB",
          "type": "Element",
          "desc": "Root of tree B."
        },
        {
          "name": "targetA",
          "type": "Element",
          "desc": "Node reference in tree A."
        }
      ],
      "returns": {
        "type": "Element | null",
        "desc": "The corresponding node in tree B."
      },
      "examples": [
        "const twin = findTwin(rootA, rootB, targetA);",
        "// if targetA is rootA, result is rootB",
        "// if targetA is the 2nd child of rootA, result is the 2nd child of rootB"
      ]
    },
    "starterCode": "export default function findTwin(rootA, rootB, targetA) {\n  // TODO: return the node in rootB that corresponds to targetA in rootA\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function findTwin(rootA: Element, rootB: Element, targetA: Element): Element | null {\n  // TODO: return the node in rootB that corresponds to targetA in rootA\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: find the node in tree B that corresponds to a given node in tree A, assuming both trees have identical structure.",
      "approaches": [
        {
          "title": "Approach: Parallel DFS traversal",
          "prose": "Step-by-step:\n1) If any root is null, return null.\n2) If rootA is the targetA, return rootB immediately (same position).\n3) Traverse children in order for both trees simultaneously.\n4) Recursively search each pair of children; if a match is found, return it.\n5) If no child matches, return null.",
          "codeJs": "export default function findTwin(rootA, rootB, targetA) {\n  if (!rootA || !rootB) return null;\n  if (rootA === targetA) return rootB;\n  const childrenA = rootA.children;\n  const childrenB = rootB.children;\n  for (let i = 0; i < childrenA.length; i++) {\n    const found = findTwin(childrenA[i], childrenB[i], targetA);\n    if (found) return found;\n  }\n  return null;\n}\n",
          "codeTs": "export default function findTwin(rootA: Element, rootB: Element, targetA: Element): Element | null {\n  if (!rootA || !rootB) return null;\n  if (rootA === targetA) return rootB;\n  const childrenA = Array.from(rootA.children);\n  const childrenB = Array.from(rootB.children);\n  for (let i = 0; i < childrenA.length; i++) {\n    const found = findTwin(childrenA[i], childrenB[i], targetA);\n    if (found) return found;\n  }\n  return null;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Traversing only tree A without matching positions in tree B.",
          "Assuming IDs are unique across trees (they might not be).",
          "Using querySelector to locate the twin can be incorrect if duplicates exist."
        ],
        "edgeCases": [
          "targetA is the root.",
          "Trees are identical but very deep.",
          "Structural mismatch should return null or be guarded."
        ],
        "techniques": [
          "Parallel DFS over both trees.",
          "Path-index approach (record child indices from rootA to targetA).",
          "Early exit when match found."
        ]
      },
      "followUpQuestions": [
        "What if the trees are not identical?",
        "How would you handle text nodes?"
      ],
      "resources": []
    },
    "tests": "import findTwin from './findTwin';\n\nconst ensureDocument = () => {\n  if (typeof document !== 'undefined') return;\n\n  class TextNode {\n    constructor(value) {\n      this.nodeType = 3;\n      this.nodeValue = String(value);\n    }\n    get textContent() {\n      return this.nodeValue;\n    }\n  }\n\n  class ElementNode {\n    constructor(tag) {\n      this.nodeType = 1;\n      this.tagName = String(tag).toUpperCase();\n      this.attributes = {};\n      this.children = [];\n      this.id = '';\n    }\n    setAttribute(key, value) {\n      this.attributes[key] = String(value);\n    }\n    getAttribute(key) {\n      return Object.prototype.hasOwnProperty.call(this.attributes, key) ? this.attributes[key] : null;\n    }\n    appendChild(child) {\n      this.children.push(child);\n      return child;\n    }\n    get textContent() {\n      return this.children.map((c) => (c.nodeType === 3 ? c.nodeValue : c.textContent)).join('');\n    }\n  }\n\n  globalThis.document = {\n    createElement: (tag) => new ElementNode(tag),\n    createTextNode: (value) => new TextNode(value)\n  };\n};\n\nensureDocument();\n\n\nconst buildTree = () => {\n  const root = document.createElement('div');\n  const a = document.createElement('span');\n  const b = document.createElement('p');\n  const c = document.createElement('em');\n  b.appendChild(c);\n  root.appendChild(a);\n  root.appendChild(b);\n  return { root, target: c };\n};\n\ndescribe('findTwin', () => {\n  test('finds corresponding node in twin tree', () => {\n    const a = buildTree();\n    const b = buildTree();\n    const twin = findTwin(a.root, b.root, a.target);\n    expect(twin).toBe(b.target);\n  });\n\n  test('returns root when target is root', () => {\n    const a = buildTree();\n    const b = buildTree();\n    const twin = findTwin(a.root, b.root, a.root);\n    expect(twin).toBe(b.root);\n  });\n\n  test('returns null for missing target', () => {\n    const a = buildTree();\n    const b = buildTree();\n    const other = document.createElement('div');\n    const twin = findTwin(a.root, b.root, other);\n    expect(twin).toBe(null);\n  });\n\n  test('returns null for missing roots', () => {\n    const a = buildTree();\n    expect(findTwin(null, a.root, a.target)).toBe(null);\n    expect(findTwin(a.root, null, a.target)).toBe(null);\n  });\n});\n",
    "testsTs": "import findTwin from './findTwin';\n\nconst ensureDocument = () => {\n  if (typeof document !== 'undefined') return;\n\n  class TextNode {\n    constructor(value) {\n      this.nodeType = 3;\n      this.nodeValue = String(value);\n    }\n    get textContent() {\n      return this.nodeValue;\n    }\n  }\n\n  class ElementNode {\n    constructor(tag) {\n      this.nodeType = 1;\n      this.tagName = String(tag).toUpperCase();\n      this.attributes = {};\n      this.children = [];\n      this.id = '';\n    }\n    setAttribute(key, value) {\n      this.attributes[key] = String(value);\n    }\n    getAttribute(key) {\n      return Object.prototype.hasOwnProperty.call(this.attributes, key) ? this.attributes[key] : null;\n    }\n    appendChild(child) {\n      this.children.push(child);\n      return child;\n    }\n    get textContent() {\n      return this.children.map((c) => (c.nodeType === 3 ? c.nodeValue : c.textContent)).join('');\n    }\n  }\n\n  globalThis.document = {\n    createElement: (tag) => new ElementNode(tag),\n    createTextNode: (value) => new TextNode(value)\n  };\n};\n\nensureDocument();\n\n\nconst buildTree = () => {\n  const root = document.createElement('div');\n  const a = document.createElement('span');\n  const b = document.createElement('p');\n  const c = document.createElement('em');\n  b.appendChild(c);\n  root.appendChild(a);\n  root.appendChild(b);\n  return { root, target: c };\n};\n\ndescribe('findTwin', () => {\n  test('finds corresponding node in twin tree', () => {\n    const a = buildTree();\n    const b = buildTree();\n    const twin = findTwin(a.root, b.root, a.target);\n    expect(twin).toBe(b.target);\n  });\n\n  test('returns root when target is root', () => {\n    const a = buildTree();\n    const b = buildTree();\n    const twin = findTwin(a.root, b.root, a.root);\n    expect(twin).toBe(b.root);\n  });\n\n  test('returns null for missing target', () => {\n    const a = buildTree();\n    const b = buildTree();\n    const other = document.createElement('div');\n    const twin = findTwin(a.root, b.root, other);\n    expect(twin).toBe(null);\n  });\n\n  test('returns null for missing roots', () => {\n    const a = buildTree();\n    expect(findTwin(null, a.root, a.target)).toBe(null);\n    expect(findTwin(a.root, null, a.target)).toBe(null);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-stack-queue-implementation",
    "title": "Implement Stack and Queue in JavaScript",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "intermediate",
    "tags": [
      "algorithms",
      "arrays"
    ],
    "companies": [
      "meta"
    ],
    "description": {
      "summary": "Implement Stack (push/pop/peek/size) and Queue (enqueue/dequeue/peek/size). Use a head index or deque to keep queue operations O(1). Complexity: O(1) amortized operations.",
      "arguments": [],
      "returns": {
        "type": "Object",
        "desc": "Export Stack and Queue constructors."
      },
      "examples": [
        "const { Stack, Queue } = stackQueue;\nconst s = new Stack();\ns.push(1); s.push(2); s.pop(); // 2",
        "const q = new Queue();\nq.enqueue(1); q.enqueue(2); q.dequeue(); // 1",
        "const q2 = new Queue();\nq2.dequeue(); // undefined (empty)"
      ]
    },
    "starterCode": "function Stack() {\n  // TODO\n}\nStack.prototype.push = function (value) {};\nStack.prototype.pop = function () {};\nStack.prototype.peek = function () {};\nStack.prototype.size = function () {};\n\nfunction Queue() {\n  // TODO\n}\nQueue.prototype.enqueue = function (value) {};\nQueue.prototype.dequeue = function () {};\nQueue.prototype.peek = function () {};\nQueue.prototype.size = function () {};\n\nconst stackQueue = { Stack, Queue };\nexport default stackQueue;\n",
    "starterCodeTs": "function Stack<T>() {\n  // TODO\n}\nStack.prototype.push = function (value: any): void {};\nStack.prototype.pop = function (): any { return undefined; };\nStack.prototype.peek = function (): any { return undefined; };\nStack.prototype.size = function (): number { return 0; };\n\nfunction Queue<T>() {\n  // TODO\n}\nQueue.prototype.enqueue = function (value: any): void {};\nQueue.prototype.dequeue = function (): any { return undefined; };\nQueue.prototype.peek = function (): any { return undefined; };\nQueue.prototype.size = function (): number { return 0; };\n\nconst stackQueue = { Stack, Queue };\nexport default stackQueue;\n",
    "solutionBlock": {
      "overview": "Goal: implement Stack (LIFO) and Queue (FIFO) with push/pop/peek/size and enqueue/dequeue/peek/size in O(1) amortized time.",
      "approaches": [
        {
          "title": "Approach: Array-backed structures",
          "prose": "Step-by-step:\n1) Stack: store items in an array.\n2) push: add to end; pop: remove from end; peek: return last item; size: return length.\n3) Queue: use an array with head index to avoid O(n) shift.\n4) enqueue: push to end; dequeue: return item at head and increment head.\n5) If head grows large, optionally compact the array to keep memory bounded.",
          "codeJs": "function Stack() { this.items = []; }\nStack.prototype.push = function (v) { this.items.push(v); };\nStack.prototype.pop = function () { return this.items.pop(); };\nStack.prototype.peek = function () { return this.items[this.items.length - 1]; };\nStack.prototype.size = function () { return this.items.length; };\n\nfunction Queue() { this.items = []; this.head = 0; }\nQueue.prototype.enqueue = function (v) { this.items.push(v); };\nQueue.prototype.dequeue = function () {\n  if (this.head >= this.items.length) return undefined;\n  const val = this.items[this.head++];\n  if (this.head > 50) { this.items = this.items.slice(this.head); this.head = 0; }\n  return val;\n};\nQueue.prototype.peek = function () { return this.items[this.head]; };\nQueue.prototype.size = function () { return this.items.length - this.head; };\n\nconst stackQueue = { Stack, Queue };\nexport default stackQueue;\n",
          "codeTs": "function Stack<T>() { (this as any).items = []; }\n(Stack.prototype as any).push = function (v: any) { this.items.push(v); };\n(Stack.prototype as any).pop = function () { return this.items.pop(); };\n(Stack.prototype as any).peek = function () { return this.items[this.items.length - 1]; };\n(Stack.prototype as any).size = function () { return this.items.length; };\n\nfunction Queue<T>() { (this as any).items = []; (this as any).head = 0; }\n(Queue.prototype as any).enqueue = function (v: any) { this.items.push(v); };\n(Queue.prototype as any).dequeue = function () {\n  if (this.head >= this.items.length) return undefined;\n  const val = this.items[this.head++];\n  if (this.head > 50) { this.items = this.items.slice(this.head); this.head = 0; }\n  return val;\n};\n(Queue.prototype as any).peek = function () { return this.items[this.head]; };\n(Queue.prototype as any).size = function () { return this.items.length - this.head; };\n\nconst stackQueue = { Stack, Queue };\nexport default stackQueue;\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using Array.shift for dequeue makes it O(n).",
          "peek should not remove the element.",
          "Not handling empty pop/dequeue should return undefined, not throw."
        ],
        "edgeCases": [
          "Calling pop/dequeue on an empty structure.",
          "Alternating enqueue/dequeue over a long sequence.",
          "Peek on empty should return undefined."
        ],
        "techniques": [
          "Array-backed stack with push/pop.",
          "Queue with head index for O(1) dequeue.",
          "Optional compaction when head grows large."
        ]
      },
      "followUpQuestions": [
        "How would you implement a circular buffer?",
        "What operations are needed for a browser history stack?"
      ],
      "resources": []
    },
    "tests": "import stackQueue from './stackQueue';\nconst { Stack, Queue } = stackQueue;\n\ndescribe('Stack', () => {\n  test('push/pop/peek/size', () => {\n    const s = new Stack();\n    s.push(1); s.push(2);\n    expect(s.peek()).toBe(2);\n    expect(s.size()).toBe(2);\n    expect(s.pop()).toBe(2);\n    expect(s.pop()).toBe(1);\n    expect(s.pop()).toBe(undefined);\n  });\n\n  test('empty peek returns undefined', () => {\n    const s = new Stack();\n    expect(s.peek()).toBe(undefined);\n  });\n});\n\ndescribe('Queue', () => {\n  test('enqueue/dequeue/peek/size', () => {\n    const q = new Queue();\n    q.enqueue(1); q.enqueue(2);\n    expect(q.peek()).toBe(1);\n    expect(q.size()).toBe(2);\n    expect(q.dequeue()).toBe(1);\n    expect(q.dequeue()).toBe(2);\n    expect(q.dequeue()).toBe(undefined);\n  });\n\n  test('empty dequeue/peek returns undefined', () => {\n    const q = new Queue();\n    expect(q.dequeue()).toBe(undefined);\n    expect(q.peek()).toBe(undefined);\n  });\n});\n",
    "testsTs": "import stackQueue from './stackQueue';\nconst { Stack, Queue } = stackQueue;\n\ndescribe('Stack', () => {\n  test('push/pop/peek/size', () => {\n    const s = new Stack();\n    s.push(1); s.push(2);\n    expect(s.peek()).toBe(2);\n    expect(s.size()).toBe(2);\n    expect(s.pop()).toBe(2);\n    expect(s.pop()).toBe(1);\n    expect(s.pop()).toBe(undefined);\n  });\n\n  test('empty peek returns undefined', () => {\n    const s = new Stack();\n    expect(s.peek()).toBe(undefined);\n  });\n});\n\ndescribe('Queue', () => {\n  test('enqueue/dequeue/peek/size', () => {\n    const q = new Queue();\n    q.enqueue(1); q.enqueue(2);\n    expect(q.peek()).toBe(1);\n    expect(q.size()).toBe(2);\n    expect(q.dequeue()).toBe(1);\n    expect(q.dequeue()).toBe(2);\n    expect(q.dequeue()).toBe(undefined);\n  });\n\n  test('empty dequeue/peek returns undefined', () => {\n    const q = new Queue();\n    expect(q.dequeue()).toBe(undefined);\n    expect(q.peek()).toBe(undefined);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-palindrome-check",
    "title": "Check if a String Is a Palindrome",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "intermediate",
    "tags": [
      "strings",
      "iteration",
      "algorithms"
    ],
    "companies": [
      "meta"
    ],
    "description": {
      "summary": "Normalize the input (lowercase + strip non-alphanumerics) and check if it reads the same forwards and backwards using two pointers. Complexity: O(n) time, O(n) space for normalization (O(1) extra possible).",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "Input string."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "True if str is a palindrome."
      },
      "examples": [
        "isPalindrome('Racecar') // true",
        "isPalindrome('A man, a plan, a canal: Panama') // true",
        "isPalindrome('12321') // true",
        "isPalindrome('hello') // false"
      ]
    },
    "starterCode": "export default function isPalindrome(str) {\n  // TODO: return true if str is a palindrome\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function isPalindrome(str: string): boolean {\n  // TODO: return true if str is a palindrome\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: normalize the string (lowercase + strip non‑alphanumerics) and verify it reads the same forwards and backwards using two pointers.",
      "approaches": [
        {
          "title": "Approach: Two-pointer scan",
          "prose": "Step-by-step:\n1) Convert to lowercase and remove all non‑alphanumeric characters.\n2) Set two pointers: i at start, j at end.\n3) While i < j, compare characters.\n4) If any mismatch, return false immediately.\n5) If you finish the scan, return true.",
          "codeJs": "export default function isPalindrome(str) {\n  const s = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i] !== s[j]) return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n",
          "codeTs": "export default function isPalindrome(str: string): boolean {\n  const s = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n  let i = 0;\n  let j = s.length - 1;\n  while (i < j) {\n    if (s[i] !== s[j]) return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Skipping normalization causes false negatives.",
          "Dropping digits can change results.",
          "Reverse-string comparisons allocate extra memory."
        ],
        "edgeCases": [
          "Empty string should return true.",
          "Single-character strings are palindromes.",
          "Strings with only punctuation after normalization."
        ],
        "techniques": [
          "Regex normalization to keep only [a-z0-9].",
          "Two-pointer scan with early exit.",
          "Case-insensitive comparison."
        ]
      },
      "followUpQuestions": [
        "How would you handle Unicode characters?",
        "Can you do it without allocating a new string?"
      ],
      "resources": []
    },
    "tests": "import isPalindrome from './isPalindrome';\n\ndescribe('isPalindrome', () => {\n  test('simple palindromes', () => {\n    expect(isPalindrome('racecar')).toBe(true);\n    expect(isPalindrome('Racecar')).toBe(true);\n  });\n\n  test('ignores non-alphanumerics', () => {\n    expect(isPalindrome('A man, a plan, a canal: Panama')).toBe(true);\n  });\n\n  test('handles digits', () => {\n    expect(isPalindrome('12321')).toBe(true);\n    expect(isPalindrome('12310')).toBe(false);\n  });\n\n  test('non-palindrome', () => {\n    expect(isPalindrome('hello')).toBe(false);\n  });\n});\n",
    "testsTs": "import isPalindrome from './isPalindrome';\n\ndescribe('isPalindrome', () => {\n  test('simple palindromes', () => {\n    expect(isPalindrome('racecar')).toBe(true);\n    expect(isPalindrome('Racecar')).toBe(true);\n  });\n\n  test('ignores non-alphanumerics', () => {\n    expect(isPalindrome('A man, a plan, a canal: Panama')).toBe(true);\n  });\n\n  test('handles digits', () => {\n    expect(isPalindrome('12321')).toBe(true);\n    expect(isPalindrome('12310')).toBe(false);\n  });\n\n  test('non-palindrome', () => {\n    expect(isPalindrome('hello')).toBe(false);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-maze-path",
    "title": "Maze Traversal (Find a Path in a Grid)",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "intermediate",
    "tags": [
      "algorithms",
      "grid",
      "arrays"
    ],
    "companies": [
      "meta"
    ],
    "description": {
      "summary": "Given a 2D grid of 0/1 (0=open, 1=wall), determine if a path exists from start to end using 4-direction moves. Use BFS/DFS with visited tracking. Complexity: O(rows*cols) time, O(rows*cols) space.",
      "arguments": [
        {
          "name": "grid",
          "type": "number[][]",
          "desc": "0 = open, 1 = wall."
        },
        {
          "name": "start",
          "type": "[number, number]",
          "desc": "Start cell [row, col]."
        },
        {
          "name": "end",
          "type": "[number, number]",
          "desc": "End cell [row, col]."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "True if a path exists, else false."
      },
      "examples": [
        "hasPath([[0,0,1],[1,0,1],[0,0,0]],[0,0],[2,2]) // true",
        "hasPath([[0]],[0,0],[0,0]) // true",
        "hasPath([[1,0],[0,1]],[0,0],[0,1]) // false",
        "hasPath([[0,1],[0,0]],[0,0],[1,1]) // true"
      ]
    },
    "starterCode": "export default function hasPath(grid, start, end) {\n  // TODO: return true if there is a path from start to end\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function hasPath(grid: number[][], start: [number, number], end: [number, number]): boolean {\n  // TODO: return true if there is a path from start to end\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: treat the grid as a graph and use BFS/DFS with a visited set to determine if a path exists from start to end.",
      "approaches": [
        {
          "title": "Approach: BFS",
          "prose": "Step-by-step:\n1) Read start/end coordinates and grid bounds.\n2) If start or end is blocked, return false.\n3) Use a queue (BFS) or stack (DFS) and a visited matrix.\n4) Pop a cell, check if it is the end.\n5) Push valid, unvisited neighbors (up/down/left/right).\n6) If the search finishes without reaching the end, return false.",
          "codeJs": "export default function hasPath(grid, start, end) {\n  const [sr, sc] = start;\n  const [er, ec] = end;\n  const rows = grid.length;\n  if (grid[sr][sc] === 1 || grid[er][ec] === 1) return false;\n  const cols = grid[0].length;\n  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n  const queue = [[sr, sc]];\n  let head = 0;\n  visited[sr][sc] = true;\n\n  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];\n  while (head < queue.length) {\n    const [r, c] = queue[head++];\n    if (r === er && c === ec) return true;\n    for (const [dr, dc] of dirs) {\n      const nr = r + dr;\n      const nc = c + dc;\n      if (nr < 0 || nc < 0 || nr >= rows || nc >= cols) continue;\n      if (visited[nr][nc]) continue;\n      if (grid[nr][nc] === 1) continue;\n      visited[nr][nc] = true;\n      queue.push([nr, nc]);\n    }\n  }\n  return false;\n}\n",
          "codeTs": "export default function hasPath(grid: number[][], start: [number, number], end: [number, number]): boolean {\n  const [sr, sc] = start;\n  const [er, ec] = end;\n  const rows = grid.length;\n  if (grid[sr][sc] === 1 || grid[er][ec] === 1) return false;\n  const cols = grid[0].length;\n  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n  const queue: Array<[number, number]> = [[sr, sc]];\n  let head = 0;\n  visited[sr][sc] = true;\n\n  const dirs: Array<[number, number]> = [[1,0],[-1,0],[0,1],[0,-1]];\n  while (head < queue.length) {\n    const [r, c] = queue[head++];\n    if (r === er && c === ec) return true;\n    for (const [dr, dc] of dirs) {\n      const nr = r + dr;\n      const nc = c + dc;\n      if (nr < 0 || nc < 0 || nr >= rows || nc >= cols) continue;\n      if (visited[nr][nc]) continue;\n      if (grid[nr][nc] === 1) continue;\n      visited[nr][nc] = true;\n      queue.push([nr, nc]);\n    }\n  }\n  return false;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to mark visited can cause infinite loops.",
          "Using Array.shift for BFS leads to O(n^2) behavior.",
          "Not checking bounds before access can throw errors."
        ],
        "edgeCases": [
          "Start equals end.",
          "Start or end is a wall.",
          "Single-cell grid."
        ],
        "techniques": [
          "BFS with queue + head index.",
          "DFS with stack or recursion.",
          "Visited matrix to avoid revisits."
        ]
      },
      "followUpQuestions": [
        "How would you return the actual path?",
        "How would you support diagonal moves?"
      ],
      "resources": []
    },
    "tests": "import hasPath from './mazePath';\n\ndescribe('hasPath', () => {\n  test('finds path in grid', () => {\n    const grid = [\n      [0,0,1],\n      [1,0,1],\n      [0,0,0]\n    ];\n    expect(hasPath(grid, [0,0], [2,2])).toBe(true);\n  });\n\n  test('returns false when blocked', () => {\n    const grid = [\n      [0,1,1],\n      [1,1,1],\n      [1,1,0]\n    ];\n    expect(hasPath(grid, [0,0], [2,2])).toBe(false);\n  });\n\n  test('start equals end', () => {\n    const grid = [[0]];\n    expect(hasPath(grid, [0,0], [0,0])).toBe(true);\n  });\n\n  test('returns false if start or end is a wall', () => {\n    const grid = [\n      [1,0],\n      [0,1]\n    ];\n    expect(hasPath(grid, [0,0], [0,1])).toBe(false);\n    expect(hasPath(grid, [1,0], [1,1])).toBe(false);\n  });\n});\n",
    "testsTs": "import hasPath from './mazePath';\n\ndescribe('hasPath', () => {\n  test('finds path in grid', () => {\n    const grid = [\n      [0,0,1],\n      [1,0,1],\n      [0,0,0]\n    ];\n    expect(hasPath(grid, [0,0], [2,2])).toBe(true);\n  });\n\n  test('returns false when blocked', () => {\n    const grid = [\n      [0,1,1],\n      [1,1,1],\n      [1,1,0]\n    ];\n    expect(hasPath(grid, [0,0], [2,2])).toBe(false);\n  });\n\n  test('start equals end', () => {\n    const grid = [[0]];\n    expect(hasPath(grid, [0,0], [0,0])).toBe(true);\n  });\n\n  test('returns false if start or end is a wall', () => {\n    const grid = [\n      [1,0],\n      [0,1]\n    ];\n    expect(hasPath(grid, [0,0], [0,1])).toBe(false);\n    expect(hasPath(grid, [1,0], [1,1])).toBe(false);\n  });\n});\n",
    "access": "premium",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-take-latest",
    "title": "Take Latest (Abort Previous Requests)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "async",
      "cancellation",
      "abort-controller",
      "concurrency",
      "promises",
      "ui"
    ],
    "description": {
      "summary": "Implement takeLatest(fn) that wraps an async function and guarantees only the most recent call can resolve. Each new call aborts the previous one via AbortController, and stale results must not update state. This prevents out-of-order responses in search-as-you-type, autocomplete, and live filtering. Concepts: async, cancellation, race control.",
      "arguments": [
        {
          "name": "fn",
          "type": "(signal: AbortSignal, ...args: any[]) => Promise<T>",
          "desc": "Async worker to run. It receives an AbortSignal as the first argument, followed by your call arguments."
        }
      ],
      "returns": {
        "type": "(...args: any[]) => Promise<T>",
        "desc": "A wrapped function that aborts the previous call and resolves only the latest result."
      },
      "examples": [
        "const searchLatest = takeLatest((signal, q) =>\n  fetch(`/api/search?q=${q}`, { signal }).then(r => r.json())\n);\n\nsearchLatest('rea');\nsearchLatest('react'); // aborts the previous call\n",
        "const latest = takeLatest(async (signal, id) => {\n  const res = await fetch(`/user/${id}`, { signal });\n  return res.json();\n});\n\nconst user = await latest(42);\n"
      ]
    },
    "starterCode": "export default function takeLatest(fn) {\n  // TODO: return a wrapped function that aborts previous calls and resolves only the latest\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function takeLatest<TArgs extends any[], TResult>(\n  fn: (signal: AbortSignal, ...args: TArgs) => Promise<TResult>\n): (...args: TArgs) => Promise<TResult> {\n  // TODO: return a wrapped function that aborts previous calls and resolves only the latest\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Keep one AbortController per in-flight call. When a new call starts, abort the previous controller and increment a call id. When a promise settles, only resolve if its id matches the latest; otherwise reject with an AbortError. This prevents stale results from winning the race.",
      "approaches": [
        {
          "title": "Approach: AbortController + call id guard",
          "prose": "Step-by-step:\n1) Track a `currentId` and `currentController` in the closure.\n2) On every call, increment `currentId` and abort the previous controller (if any).\n3) Create a new AbortController and call `fn(signal, ...args)`.\n4) If the promise settles but its `callId` is not the latest, reject with an AbortError; otherwise forward the value or error.\n\nComplexity: O(1) time and O(1) space per call.",
          "codeJs": "function toAbortError(reason, message = 'Aborted') {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  try { err.name = 'AbortError'; } catch { try { Object.defineProperty(err, 'name', { value: 'AbortError' }); } catch {} }\n  return err;\n}\n\nexport default function takeLatest(fn) {\n  let currentId = 0;\n  let currentController = null;\n\n  return function (...args) {\n    currentId += 1;\n    const callId = currentId;\n\n    if (currentController && !currentController.signal.aborted) {\n      try {\n        currentController.abort(toAbortError(null, 'Cancelled'));\n      } catch {\n        // ignore\n      }\n    }\n\n    const controller = new AbortController();\n    currentController = controller;\n\n    return Promise.resolve()\n      .then(() => fn(controller.signal, ...args))\n      .then(\n        (value) => {\n          if (callId !== currentId) throw toAbortError(null, 'Stale');\n          return value;\n        },\n        (err) => {\n          if (callId !== currentId) throw toAbortError(null, 'Stale');\n          throw err;\n        }\n      );\n  };\n}\n",
          "codeTs": "function toAbortError(reason: any, message: string = 'Aborted'): Error {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  try { (err as any).name = 'AbortError'; } catch { try { Object.defineProperty(err as any, 'name', { value: 'AbortError' }); } catch {} }\n  return err;\n}\n\nexport default function takeLatest<TArgs extends any[], TResult>(\n  fn: (signal: AbortSignal, ...args: TArgs) => Promise<TResult>\n): (...args: TArgs) => Promise<TResult> {\n  let currentId = 0;\n  let currentController: AbortController | null = null;\n\n  return function (...args: TArgs): Promise<TResult> {\n    currentId += 1;\n    const callId = currentId;\n\n    if (currentController && !currentController.signal.aborted) {\n      try {\n        currentController.abort(toAbortError(null, 'Cancelled'));\n      } catch {\n        // ignore\n      }\n    }\n\n    const controller = new AbortController();\n    currentController = controller;\n\n    return Promise.resolve()\n      .then(() => fn(controller.signal, ...args))\n      .then(\n        (value) => {\n          if (callId !== currentId) throw toAbortError(null, 'Stale');\n          return value;\n        },\n        (err) => {\n          if (callId !== currentId) throw toAbortError(null, 'Stale');\n          throw err;\n        }\n      );\n  };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to abort the previous controller allows stale requests to continue.",
          "If the worker ignores AbortSignal, you still need a call id guard to prevent stale updates.",
          "Not normalizing abort errors can lead to inconsistent error handling in tests and UI code."
        ],
        "edgeCases": [
          "Multiple rapid calls in the same tick should still resolve only the latest one.",
          "A previous call may resolve after being aborted; it must be ignored.",
          "AbortController can have an undefined reason; create a fallback AbortError."
        ],
        "techniques": [
          "AbortController for cancellation wiring.",
          "Monotonic call id to ignore stale results.",
          "Error normalization to standardize AbortError handling."
        ]
      },
      "followUpQuestions": [
        "js-abortable-helpers",
        "js-debounce",
        "js-promise-all"
      ],
      "resources": [
        {
          "title": "MDN – AbortController",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController"
        },
        {
          "title": "MDN – AbortSignal",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal"
        }
      ]
    },
    "tests": "import takeLatest from './takeLatest';\n\nfunction toAbortError(reason, message = 'Aborted') {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  try { err.name = 'AbortError'; } catch { try { Object.defineProperty(err, 'name', { value: 'AbortError' }); } catch {} }\n  return err;\n}\n\nfunction delay(ms, value, signal) {\n  return new Promise((resolve, reject) => {\n    const id = setTimeout(() => resolve(value), ms);\n    if (signal) {\n      if (signal.aborted) {\n        clearTimeout(id);\n        return reject(toAbortError(signal.reason));\n      }\n      signal.addEventListener(\n        'abort',\n        () => {\n          clearTimeout(id);\n          reject(toAbortError(signal.reason));\n        },\n        { once: true }\n      );\n    }\n  });\n}\n\ndescribe('takeLatest', () => {\n  test('resolves only the latest call', async () => {\n    const latest = takeLatest((signal, value, ms) => delay(ms, value, signal));\n\n    const p1 = latest('first', 30);\n    const p2 = latest('second', 5);\n\n    await expect(p1).rejects.toMatchObject({ name: 'AbortError' });\n    await expect(p2).resolves.toBe('second');\n  });\n\n  test('propagates errors from the latest call', async () => {\n    const latest = takeLatest(async () => {\n      throw new Error('boom');\n    });\n\n    await expect(latest()).rejects.toThrow('boom');\n  });\n\n  test('aborts the previous controller immediately', async () => {\n    const latest = takeLatest((signal) => delay(20, 'ok', signal));\n\n    const p1 = latest();\n    await new Promise((r) => setTimeout(r, 1));\n    const p2 = latest();\n\n    await expect(p1).rejects.toMatchObject({ name: 'AbortError' });\n    await expect(p2).resolves.toBe('ok');\n  });\n});\n",
    "testsTs": "import takeLatest from './takeLatest';\n\nfunction toAbortError(reason: any, message: string = 'Aborted'): Error {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  try { (err as any).name = 'AbortError'; } catch { try { Object.defineProperty(err as any, 'name', { value: 'AbortError' }); } catch {} }\n  return err;\n}\n\nfunction delay(ms: number, value: string, signal?: AbortSignal): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const id = setTimeout(() => resolve(value), ms);\n    if (signal) {\n      if (signal.aborted) {\n        clearTimeout(id);\n        return reject(toAbortError((signal as any).reason));\n      }\n      signal.addEventListener(\n        'abort',\n        () => {\n          clearTimeout(id);\n          reject(toAbortError((signal as any).reason));\n        },\n        { once: true }\n      );\n    }\n  });\n}\n\ndescribe('takeLatest (TypeScript)', () => {\n  it('resolves only the latest call', async () => {\n    const latest = takeLatest((signal, value: string, ms: number) => delay(ms, value, signal));\n\n    const p1 = latest('first', 30);\n    const p2 = latest('second', 5);\n\n    await expect(p1).rejects.toMatchObject({ name: 'AbortError' });\n    await expect(p2).resolves.toBe('second');\n  });\n\n  it('propagates errors from the latest call', async () => {\n    const latest = takeLatest(async () => {\n      throw new Error('boom');\n    });\n\n    await expect(latest()).rejects.toThrow('boom');\n  });\n\n  it('aborts the previous controller immediately', async () => {\n    const latest = takeLatest((signal) => delay(20, 'ok', signal));\n\n    const p1 = latest();\n    await new Promise((r) => setTimeout(r, 1));\n    const p2 = latest();\n\n    await expect(p1).rejects.toMatchObject({ name: 'AbortError' });\n    await expect(p2).resolves.toBe('ok');\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-promise-any",
    "title": "Promise.any (First Fulfilled)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "promise",
      "async",
      "concurrency",
      "error-handling",
      "utilities"
    ],
    "description": {
      "summary": "Implement promiseAny(promises) that behaves like Promise.any. It should resolve with the first fulfilled value, ignoring rejections until all inputs reject. If everything rejects (or the input is empty), it should reject with an AggregateError containing all reasons. Concepts: promises, racing, error aggregation.",
      "arguments": [
        {
          "name": "promises",
          "type": "Array<T | Promise<T>>",
          "desc": "An array of values or promises. Values are treated as already-fulfilled promises."
        }
      ],
      "returns": {
        "type": "Promise<T>",
        "desc": "Resolves to the first fulfilled value, or rejects with AggregateError when all reject."
      },
      "examples": [
        "promiseAny([\n  Promise.reject(new Error('A')),\n  Promise.resolve('ok'),\n  Promise.resolve('later')\n]).then(v => {\n  // v === 'ok'\n});\n",
        "promiseAny([Promise.reject('x'), Promise.reject('y')])\n  .catch(err => {\n    // err.name === 'AggregateError'\n    // err.errors === ['x', 'y']\n  });\n"
      ]
    },
    "starterCode": "export default function promiseAny(promises) {\n  // TODO: resolve on first fulfillment; reject with AggregateError if all reject\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function promiseAny<T>(promises: Array<T | Promise<T>>): Promise<T> {\n  // TODO: resolve on first fulfillment; reject with AggregateError if all reject\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Track how many inputs have rejected and collect their reasons. Resolve immediately on the first fulfillment. If all inputs reject (or the array is empty), reject with an AggregateError that includes all reasons.",
      "approaches": [
        {
          "title": "Approach: Count rejections and aggregate reasons",
          "prose": "Algorithm:\n1) Validate input: reject with TypeError if not an array.\n2) If the array is empty, reject with AggregateError containing an empty errors array.\n3) For each item, wrap with Promise.resolve and attach handlers.\n4) On fulfillment, resolve immediately.\n5) On rejection, store the reason at the same index and increment a counter.\n6) If all have rejected, reject with AggregateError.\n\nComplexity: O(n) time and O(n) space for stored errors.",
          "codeJs": "function createAggregateError(errors) {\n  const Agg = (typeof globalThis !== 'undefined' && globalThis.AggregateError) ? globalThis.AggregateError : null;\n  if (typeof Agg === 'function') {\n    return new Agg(errors, 'All promises were rejected');\n  }\n  const err = new Error('All promises were rejected');\n  try { err.name = 'AggregateError'; } catch { try { Object.defineProperty(err, 'name', { value: 'AggregateError' }); } catch {} }\n  err.errors = errors;\n  return err;\n}\n\n\nexport default function promiseAny(promises) {\n  if (!Array.isArray(promises)) {\n    return Promise.reject(new TypeError('Argument must be an array'));\n  }\n  const n = promises.length;\n  if (n === 0) {\n    return Promise.reject(createAggregateError([]));\n  }\n\n  return new Promise((resolve, reject) => {\n    const errors = new Array(n);\n    let rejected = 0;\n\n    promises.forEach((p, i) => {\n      Promise.resolve(p).then(\n        (value) => resolve(value),\n        (err) => {\n          errors[i] = err;\n          rejected += 1;\n          if (rejected === n) {\n            reject(createAggregateError(errors));\n          }\n        }\n      );\n    });\n  });\n}\n",
          "codeTs": "function createAggregateError(errors: any[]): Error {\n  const Agg = (typeof globalThis !== 'undefined' && (globalThis as any).AggregateError)\n    ? (globalThis as any).AggregateError\n    : null;\n  if (typeof Agg === 'function') {\n    return new Agg(errors, 'All promises were rejected');\n  }\n  const err = new Error('All promises were rejected');\n  try { (err as any).name = 'AggregateError'; } catch { try { Object.defineProperty(err as any, 'name', { value: 'AggregateError' }); } catch {} }\n  (err as any).errors = errors;\n  return err;\n}\n\n\nexport default function promiseAny<T>(promises: Array<T | Promise<T>>): Promise<T> {\n  if (!Array.isArray(promises)) {\n    return Promise.reject(new TypeError('Argument must be an array'));\n  }\n  const n = promises.length;\n  if (n === 0) {\n    return Promise.reject(createAggregateError([]));\n  }\n\n  return new Promise<T>((resolve, reject) => {\n    const errors: any[] = new Array(n);\n    let rejected = 0;\n\n    promises.forEach((p, i) => {\n      Promise.resolve(p).then(\n        (value) => resolve(value as T),\n        (err) => {\n          errors[i] = err;\n          rejected += 1;\n          if (rejected === n) {\n            reject(createAggregateError(errors));\n          }\n        }\n      );\n    });\n  });\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using Promise.race is incorrect because it rejects on the first rejection.",
          "Forgetting the empty array case (Promise.any rejects immediately with AggregateError).",
          "Not preserving rejection reasons makes debugging harder."
        ],
        "edgeCases": [
          "Non-promise values should be treated as fulfilled inputs.",
          "All inputs reject should produce an AggregateError with all reasons.",
          "Mixed sync and async inputs should still resolve on the first fulfillment."
        ],
        "techniques": [
          "Promise.resolve to normalize inputs.",
          "Rejection counting and reason aggregation.",
          "AggregateError compatibility fallback."
        ]
      },
      "followUpQuestions": [
        "js-promise-all",
        "js-concurrency-map-limit"
      ],
      "resources": [
        {
          "title": "MDN – Promise.any()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"
        },
        {
          "title": "MDN – AggregateError",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError"
        }
      ]
    },
    "tests": "import promiseAny from './promiseAny';\n\ndescribe('promiseAny', () => {\n  test('resolves on first fulfillment', async () => {\n    const bad = Promise.reject(new Error('nope'));\n    const slow = new Promise((resolve) => setTimeout(() => resolve('slow'), 20));\n    const fast = Promise.resolve('fast');\n\n    await expect(promiseAny([bad, slow, fast])).resolves.toBe('fast');\n  });\n\n  test('handles non-promise values', async () => {\n    await expect(promiseAny([0, Promise.resolve(2)])).resolves.toBe(0);\n  });\n\n  test('rejects with AggregateError when all reject', async () => {\n    let err;\n    try {\n      await promiseAny([Promise.reject('a'), Promise.reject('b')]);\n    } catch (e) {\n      err = e;\n    }\n    expect(err).toBeTruthy();\n    expect(err.name).toBe('AggregateError');\n    expect(Array.isArray(err.errors)).toBe(true);\n    expect(err.errors.length).toBe(2);\n  });\n\n  test('rejects for empty input', async () => {\n    let err;\n    try {\n      await promiseAny([]);\n    } catch (e) {\n      err = e;\n    }\n    expect(err).toBeTruthy();\n    expect(err.name).toBe('AggregateError');\n  });\n});\n",
    "testsTs": "import promiseAny from './promiseAny';\n\ndescribe('promiseAny (TypeScript)', () => {\n  it('resolves on first fulfillment', async () => {\n    const bad = Promise.reject(new Error('nope'));\n    const slow = new Promise<string>((resolve) => setTimeout(() => resolve('slow'), 20));\n    const fast = Promise.resolve('fast');\n\n    await expect(promiseAny([bad, slow, fast])).resolves.toBe('fast');\n  });\n\n  it('handles non-promise values', async () => {\n    await expect(promiseAny<number | Promise<number>>([0, Promise.resolve(2)])).resolves.toBe(0);\n  });\n\n  it('rejects with AggregateError when all reject', async () => {\n    let err: any;\n    try {\n      await promiseAny([Promise.reject('a'), Promise.reject('b')]);\n    } catch (e) {\n      err = e;\n    }\n    expect(err).toBeTruthy();\n    expect(err.name).toBe('AggregateError');\n    expect(Array.isArray((err as any).errors)).toBe(true);\n    expect((err as any).errors.length).toBe(2);\n  });\n\n  it('rejects for empty input', async () => {\n    let err: any;\n    try {\n      await promiseAny([]);\n    } catch (e) {\n      err = e;\n    }\n    expect(err).toBeTruthy();\n    expect(err.name).toBe('AggregateError');\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-poll-until",
    "title": "Poll Until (with Timeout + Abort)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "async",
      "cancellation",
      "timers",
      "control-flow",
      "promises"
    ],
    "description": {
      "summary": "Implement pollUntil(check, { interval, timeout, signal }) that repeatedly runs a check until it returns a truthy value. Wait interval milliseconds between attempts. Reject if the timeout is reached or the AbortSignal is aborted. Useful for waiting on background jobs, eventual consistency, or feature flags without blocking the UI thread.",
      "arguments": [
        {
          "name": "check",
          "type": "() => T | Promise<T>",
          "desc": "A function that returns a value (or Promise). A truthy result ends polling and becomes the resolve value."
        },
        {
          "name": "options",
          "type": "{ interval?: number, timeout?: number, signal?: AbortSignal }",
          "desc": "Polling configuration. interval is the delay between attempts. timeout is the max time to wait. signal cancels polling."
        }
      ],
      "returns": {
        "type": "Promise<T>",
        "desc": "Resolves with the first truthy value returned by check, or rejects on timeout/abort."
      },
      "examples": [
        "const result = await pollUntil(async () => {\n  const status = await fetchStatus();\n  return status === 'ready' ? status : false;\n}, { interval: 200, timeout: 5000 });\n",
        "const ac = new AbortController();\nconst p = pollUntil(() => isReady(), { interval: 100, signal: ac.signal });\nac.abort(); // cancels polling\n"
      ]
    },
    "starterCode": "export default function pollUntil(check, options = {}) {\n  // TODO: poll until check returns a truthy value or rejects on timeout/abort\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type PollOptions = {\n  interval?: number;\n  timeout?: number;\n  signal?: AbortSignal;\n};\n\nexport default function pollUntil<T>(\n  check: () => T | Promise<T>,\n  options: PollOptions = {}\n): Promise<T> {\n  // TODO: poll until check returns a truthy value or rejects on timeout/abort\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Run the check immediately, then schedule the next attempt with setTimeout if it is still falsy. Track start time for timeout, and wire an AbortSignal to cancel. Always clear timeouts and listeners on resolve or reject.",
      "approaches": [
        {
          "title": "Approach: Recursive setTimeout loop",
          "prose": "Steps:\n1) Normalize options: interval (default 50), timeout (optional), signal (optional).\n2) If signal is already aborted, reject immediately with AbortError.\n3) Define an async attempt() function that calls check(); if the result is truthy, resolve.\n4) If check throws, reject immediately.\n5) If timeout elapsed, reject with Error('Timeout').\n6) Otherwise, schedule the next attempt using setTimeout(attempt, interval).\n7) On resolve/reject/abort, clear any timeout and remove the abort listener.\n\nComplexity: O(k) time for k attempts, O(1) extra space.",
          "codeJs": "function toAbortError(reason, message = 'Aborted') {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  err.name = 'AbortError';\n  return err;\n}\n\nexport default function pollUntil(check, options = {}) {\n  const { interval = 50, timeout, signal } = options;\n\n  return new Promise((resolve, reject) => {\n    let timerId;\n    let done = false;\n    const start = Date.now();\n\n    const cleanup = () => {\n      if (timerId) clearTimeout(timerId);\n      if (signal) signal.removeEventListener('abort', onAbort);\n    };\n\n    const onAbort = () => {\n      if (done) return;\n      done = true;\n      cleanup();\n      reject(toAbortError(signal && signal.reason));\n    };\n\n    if (signal) {\n      if (signal.aborted) {\n        reject(toAbortError(signal.reason));\n        return;\n      }\n      signal.addEventListener('abort', onAbort, { once: true });\n    }\n\n    const attempt = async () => {\n      try {\n        const result = await check();\n        if (result) {\n          done = true;\n          cleanup();\n          resolve(result);\n          return;\n        }\n      } catch (err) {\n        done = true;\n        cleanup();\n        reject(err);\n        return;\n      }\n\n      if (timeout != null && Date.now() - start >= timeout) {\n        done = true;\n        cleanup();\n        reject(new Error('Timeout'));\n        return;\n      }\n\n      timerId = setTimeout(attempt, interval);\n    };\n\n    attempt();\n  });\n}\n",
          "codeTs": "type PollOptions = {\n  interval?: number;\n  timeout?: number;\n  signal?: AbortSignal;\n};\n\nfunction toAbortError(reason: any, message: string = 'Aborted'): Error {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  (err as any).name = 'AbortError';\n  return err;\n}\n\nexport default function pollUntil<T>(\n  check: () => T | Promise<T>,\n  options: PollOptions = {}\n): Promise<T> {\n  const { interval = 50, timeout, signal } = options;\n\n  return new Promise<T>((resolve, reject) => {\n    let timerId: ReturnType<typeof setTimeout> | undefined;\n    let done = false;\n    const start = Date.now();\n\n    const cleanup = () => {\n      if (timerId) clearTimeout(timerId);\n      if (signal) signal.removeEventListener('abort', onAbort);\n    };\n\n    const onAbort = () => {\n      if (done) return;\n      done = true;\n      cleanup();\n      reject(toAbortError(signal && (signal as any).reason));\n    };\n\n    if (signal) {\n      if (signal.aborted) {\n        reject(toAbortError((signal as any).reason));\n        return;\n      }\n      signal.addEventListener('abort', onAbort, { once: true });\n    }\n\n    const attempt = async (): Promise<void> => {\n      try {\n        const result = await check();\n        if (result) {\n          done = true;\n          cleanup();\n          resolve(result as T);\n          return;\n        }\n      } catch (err) {\n        done = true;\n        cleanup();\n        reject(err);\n        return;\n      }\n\n      if (timeout != null && Date.now() - start >= timeout) {\n        done = true;\n        cleanup();\n        reject(new Error('Timeout'));\n        return;\n      }\n\n      timerId = setTimeout(attempt, interval);\n    };\n\n    attempt();\n  });\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using setInterval without cleanup can leave polling running forever.",
          "Forgetting to remove the abort listener causes memory leaks.",
          "Treating falsy values as success can end polling too early."
        ],
        "edgeCases": [
          "timeout = 0 should timeout immediately if the first check is falsy.",
          "check throwing should reject immediately and stop polling.",
          "signal already aborted should reject without running check."
        ],
        "techniques": [
          "Recursive setTimeout for precise control.",
          "AbortSignal wiring for cancellation.",
          "Timeout tracking via Date.now()."
        ]
      },
      "followUpQuestions": [
        "js-sleep",
        "js-abortable-helpers",
        "js-concurrency-map-limit"
      ],
      "resources": [
        {
          "title": "MDN – AbortController",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController"
        }
      ]
    },
    "tests": "import pollUntil from './pollUntil';\n\ndescribe('pollUntil', () => {\n  test('resolves when check becomes truthy', async () => {\n    let count = 0;\n    const result = await pollUntil(() => {\n      count += 1;\n      return count >= 3 ? 'ready' : false;\n    }, { interval: 5, timeout: 50 });\n\n    expect(result).toBe('ready');\n  });\n\n  test('supports async checks', async () => {\n    let count = 0;\n    const result = await pollUntil(async () => {\n      count += 1;\n      await new Promise((r) => setTimeout(r, 2));\n      return count === 2 ? 42 : false;\n    }, { interval: 5, timeout: 50 });\n\n    expect(result).toBe(42);\n  });\n\n  test('rejects on timeout', async () => {\n    await expect(\n      pollUntil(() => false, { interval: 5, timeout: 20 })\n    ).rejects.toThrow('Timeout');\n  });\n\n  test('rejects when aborted', async () => {\n    const ac = new AbortController();\n    const p = pollUntil(() => false, { interval: 5, signal: ac.signal });\n    setTimeout(() => ac.abort(), 10);\n    await expect(p).rejects.toMatchObject({ name: 'AbortError' });\n  });\n});\n",
    "testsTs": "import pollUntil from './pollUntil';\n\ndescribe('pollUntil (TypeScript)', () => {\n  it('resolves when check becomes truthy', async () => {\n    let count = 0;\n    const result = await pollUntil(() => {\n      count += 1;\n      return count >= 3 ? 'ready' : false;\n    }, { interval: 5, timeout: 50 });\n\n    expect(result).toBe('ready');\n  });\n\n  it('supports async checks', async () => {\n    let count = 0;\n    const result = await pollUntil(async () => {\n      count += 1;\n      await new Promise((r) => setTimeout(r, 2));\n      return count === 2 ? 42 : false;\n    }, { interval: 5, timeout: 50 });\n\n    expect(result).toBe(42);\n  });\n\n  it('rejects on timeout', async () => {\n    await expect(\n      pollUntil(() => false, { interval: 5, timeout: 20 })\n    ).rejects.toThrow('Timeout');\n  });\n\n  it('rejects when aborted', async () => {\n    const ac = new AbortController();\n    const p = pollUntil(() => false, { interval: 5, signal: ac.signal });\n    setTimeout(() => ac.abort(), 10);\n    await expect(p).rejects.toMatchObject({ name: 'AbortError' });\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-fetch-json-timeout",
    "title": "Fetch JSON with Timeout + Abort",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "web-apis",
      "fetch",
      "abort-controller",
      "async",
      "promises",
      "cancellation"
    ],
    "description": {
      "summary": "Implement fetchJson(url, options) that fetches JSON with built-in timeout and abort support. It should abort on timeout, respect an external AbortSignal, and throw on non-2xx HTTP responses. This mirrors real-world client utilities for APIs. Concepts: fetch, AbortController, timeouts, error handling.",
      "arguments": [
        {
          "name": "url",
          "type": "string",
          "desc": "The request URL."
        },
        {
          "name": "options",
          "type": "{ timeoutMs?: number, signal?: AbortSignal, fetchFn?: Function, ...init }",
          "desc": "Optional timeout, AbortSignal, and a fetch function override for testing. Any extra fields are passed to fetch."
        }
      ],
      "returns": {
        "type": "Promise<any>",
        "desc": "Resolves with parsed JSON or rejects on timeout, abort, or non-OK response."
      },
      "examples": [
        "// Basic usage\nconst data = await fetchJson('/api/user/42', { timeoutMs: 2000 });\n",
        "// With external cancellation\nconst ac = new AbortController();\nconst p = fetchJson('/api/search?q=js', { signal: ac.signal });\nac.abort();\nawait p; // rejects with AbortError\n"
      ]
    },
    "starterCode": "export default async function fetchJson(url, options = {}) {\n  // TODO: support timeoutMs + AbortSignal, throw on non-OK responses\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type FetchJsonOptions = {\n  timeoutMs?: number;\n  signal?: AbortSignal;\n  fetchFn?: (input: string, init?: any) => Promise<{ ok: boolean; status: number; json: () => Promise<any> }>;\n  [key: string]: any;\n};\n\nexport default async function fetchJson<T = any>(\n  url: string,\n  options: FetchJsonOptions = {}\n): Promise<T> {\n  // TODO: support timeoutMs + AbortSignal, throw on non-OK responses\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Create a new AbortController per call. If an external signal aborts, forward that to the controller. If a timeout is set, abort after the deadline. Call fetch, throw on non-OK status, and return response.json(). Always clear timers and listeners.",
      "approaches": [
        {
          "title": "Approach: AbortController + timeout guard",
          "prose": "Steps:\n1) Extract timeoutMs, signal, and fetchFn from options.\n2) Create an AbortController and forward external aborts.\n3) If timeoutMs is set, abort with a Timeout AbortError.\n4) Call fetch with the combined signal.\n5) Throw on non-OK status.\n6) Parse and return JSON.\n7) Always cleanup listeners and timers.\n\nComplexity: O(1) extra work beyond the network request.",
          "codeJs": "function toAbortError(reason, message = 'Aborted') {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  try { err.name = 'AbortError'; } catch { try { Object.defineProperty(err, 'name', { value: 'AbortError' }); } catch {} }\n  return err;\n}\n\nexport default async function fetchJson(url, options = {}) {\n  const { timeoutMs, signal, fetchFn, ...init } = options;\n  const fetcher = fetchFn || (typeof fetch === 'function' ? fetch : null);\n  if (!fetcher) throw new Error('fetchFn is required');\n\n  const controller = new AbortController();\n  let timeoutId;\n\n  const onAbort = () => {\n    controller.abort(toAbortError(signal && signal.reason));\n  };\n\n  if (signal) {\n    if (signal.aborted) {\n      controller.abort(toAbortError(signal.reason));\n    } else {\n      signal.addEventListener('abort', onAbort, { once: true });\n    }\n  }\n\n  if (typeof timeoutMs === 'number' && timeoutMs >= 0) {\n    timeoutId = setTimeout(() => {\n      controller.abort(toAbortError(null, 'Timeout'));\n    }, timeoutMs);\n  }\n\n  try {\n    if (controller.signal.aborted) {\n      throw toAbortError(controller.signal.reason);\n    }\n\n    const res = await fetcher(url, { ...init, signal: controller.signal });\n    if (!res || !res.ok) {\n      const status = res && typeof res.status === 'number' ? res.status : 0;\n      throw new Error(`HTTP ${status}`);\n    }\n    return await res.json();\n  } finally {\n    if (timeoutId) clearTimeout(timeoutId);\n    if (signal) signal.removeEventListener('abort', onAbort);\n  }\n}\n",
          "codeTs": "function toAbortError(reason: any, message: string = 'Aborted'): Error {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  try { (err as any).name = 'AbortError'; } catch { try { Object.defineProperty(err as any, 'name', { value: 'AbortError' }); } catch {} }\n  return err;\n}\n\ntype FetchJsonOptions = {\n  timeoutMs?: number;\n  signal?: AbortSignal;\n  fetchFn?: (input: string, init?: any) => Promise<{ ok: boolean; status: number; json: () => Promise<any> }>;\n  [key: string]: any;\n};\n\nexport default async function fetchJson<T = any>(\n  url: string,\n  options: FetchJsonOptions = {}\n): Promise<T> {\n  const { timeoutMs, signal, fetchFn, ...init } = options;\n  const fetcher = fetchFn || (typeof fetch === 'function' ? fetch : null);\n  if (!fetcher) throw new Error('fetchFn is required');\n\n  const controller = new AbortController();\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n\n  const onAbort = () => {\n    controller.abort(toAbortError(signal && (signal as any).reason));\n  };\n\n  if (signal) {\n    if (signal.aborted) {\n      controller.abort(toAbortError((signal as any).reason));\n    } else {\n      signal.addEventListener('abort', onAbort, { once: true });\n    }\n  }\n\n  if (typeof timeoutMs === 'number' && timeoutMs >= 0) {\n    timeoutId = setTimeout(() => {\n      controller.abort(toAbortError(null, 'Timeout'));\n    }, timeoutMs);\n  }\n\n  try {\n    if (controller.signal.aborted) {\n      throw toAbortError((controller.signal as any).reason);\n    }\n\n    const res = await fetcher(url, { ...init, signal: controller.signal });\n    if (!res || !res.ok) {\n      const status = res && typeof res.status === 'number' ? res.status : 0;\n      throw new Error(`HTTP ${status}`);\n    }\n    return await res.json();\n  } finally {\n    if (timeoutId) clearTimeout(timeoutId);\n    if (signal) signal.removeEventListener('abort', onAbort);\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using Promise.race without AbortController does not cancel the fetch.",
          "Forgetting to clear timeouts or abort listeners can leak resources.",
          "Not checking response.ok can silently treat HTTP 404/500 as success."
        ],
        "edgeCases": [
          "signal already aborted: reject immediately.",
          "timeoutMs = 0 should timeout immediately.",
          "fetchFn not provided and fetch missing: throw a helpful error."
        ],
        "techniques": [
          "AbortController for cancellation.",
          "Timeout guard with setTimeout.",
          "Defensive error handling for non-OK responses."
        ]
      },
      "followUpQuestions": [
        "js-abortable-helpers",
        "js-promise-all"
      ],
      "resources": [
        {
          "title": "MDN – fetch()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/fetch"
        },
        {
          "title": "MDN – AbortController",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController"
        }
      ]
    },
    "tests": "import fetchJson from './fetchJson';\n\nfunction toAbortError(reason, message = 'Aborted') {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  try { err.name = 'AbortError'; } catch { try { Object.defineProperty(err, 'name', { value: 'AbortError' }); } catch {} }\n  return err;\n}\n\nfunction makeFetch({ delay = 0, ok = true, status = 200, jsonData = {} } = {}) {\n  return function fetchMock(_url, init = {}) {\n    const signal = init.signal;\n    return new Promise((resolve, reject) => {\n      let done = false;\n      const finish = () => {\n        if (done) return;\n        done = true;\n        if (signal) signal.removeEventListener('abort', onAbort);\n        resolve({\n          ok,\n          status,\n          json: async () => jsonData\n        });\n      };\n\n      const onAbort = () => {\n        if (done) return;\n        done = true;\n        clearTimeout(timerId);\n        reject(toAbortError(signal && signal.reason));\n      };\n\n      if (signal) {\n        if (signal.aborted) return onAbort();\n        signal.addEventListener('abort', onAbort, { once: true });\n      }\n\n      const timerId = setTimeout(finish, delay);\n    });\n  };\n}\n\ndescribe('fetchJson', () => {\n  test('resolves JSON for ok responses', async () => {\n    const fetchFn = makeFetch({ jsonData: { ok: true } });\n    await expect(fetchJson('/ok', { fetchFn, timeoutMs: 100 })).resolves.toEqual({ ok: true });\n  });\n\n  test('throws on non-ok status', async () => {\n    const fetchFn = makeFetch({ ok: false, status: 404 });\n    await expect(fetchJson('/missing', { fetchFn })).rejects.toThrow('HTTP 404');\n  });\n\n  test('aborts on timeout', async () => {\n    const fetchFn = makeFetch({ delay: 50, jsonData: { ok: true } });\n    await expect(fetchJson('/slow', { fetchFn, timeoutMs: 10 })).rejects.toMatchObject({\n      name: 'AbortError',\n      message: 'Timeout'\n    });\n  });\n\n  test('respects external abort signal', async () => {\n    const ac = new AbortController();\n    const fetchFn = makeFetch({ delay: 30, jsonData: { ok: true } });\n    const p = fetchJson('/abort', { fetchFn, signal: ac.signal });\n    setTimeout(() => ac.abort(new Error('Cancelled')), 5);\n    await expect(p).rejects.toMatchObject({ name: 'AbortError' });\n  });\n});\n",
    "testsTs": "import fetchJson from './fetchJson';\n\nfunction toAbortError(reason: any, message: string = 'Aborted'): Error {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  try { (err as any).name = 'AbortError'; } catch { try { Object.defineProperty(err as any, 'name', { value: 'AbortError' }); } catch {} }\n  return err;\n}\n\nfunction makeFetch({ delay = 0, ok = true, status = 200, jsonData = {} } = {}) {\n  return function fetchMock(_url: string, init: any = {}) {\n    const signal: AbortSignal | undefined = init.signal;\n    return new Promise((resolve, reject) => {\n      let done = false;\n      const finish = () => {\n        if (done) return;\n        done = true;\n        if (signal) signal.removeEventListener('abort', onAbort);\n        resolve({\n          ok,\n          status,\n          json: async () => jsonData\n        });\n      };\n\n      const onAbort = () => {\n        if (done) return;\n        done = true;\n        clearTimeout(timerId);\n        reject(toAbortError(signal && (signal as any).reason));\n      };\n\n      if (signal) {\n        if (signal.aborted) return onAbort();\n        signal.addEventListener('abort', onAbort, { once: true });\n      }\n\n      const timerId = setTimeout(finish, delay);\n    });\n  };\n}\n\ndescribe('fetchJson (TypeScript)', () => {\n  it('resolves JSON for ok responses', async () => {\n    const fetchFn = makeFetch({ jsonData: { ok: true } });\n    await expect(fetchJson('/ok', { fetchFn, timeoutMs: 100 })).resolves.toEqual({ ok: true });\n  });\n\n  it('throws on non-ok status', async () => {\n    const fetchFn = makeFetch({ ok: false, status: 404 });\n    await expect(fetchJson('/missing', { fetchFn })).rejects.toThrow('HTTP 404');\n  });\n\n  it('aborts on timeout', async () => {\n    const fetchFn = makeFetch({ delay: 50, jsonData: { ok: true } });\n    await expect(fetchJson('/slow', { fetchFn, timeoutMs: 10 })).rejects.toMatchObject({\n      name: 'AbortError',\n      message: 'Timeout'\n    });\n  });\n\n  it('respects external abort signal', async () => {\n    const ac = new AbortController();\n    const fetchFn = makeFetch({ delay: 30, jsonData: { ok: true } });\n    const p = fetchJson('/abort', { fetchFn, signal: ac.signal });\n    setTimeout(() => ac.abort(new Error('Cancelled')), 5);\n    await expect(p).rejects.toMatchObject({ name: 'AbortError' });\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-stream-to-text",
    "title": "Stream to Text (ReadableStream -> string)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "web-apis",
      "streams",
      "text-decoder",
      "async",
      "promises"
    ],
    "description": {
      "summary": "Implement streamToText(stream, options) that reads a ReadableStream<Uint8Array> and returns the full string. Use TextDecoder with stream=true to handle multi-byte characters across chunk boundaries. Optionally support AbortSignal to cancel reading. Concepts: Streams API, TextDecoder, async iteration.",
      "arguments": [
        {
          "name": "stream",
          "type": "ReadableStream<Uint8Array>",
          "desc": "A stream of byte chunks (e.g., from fetch(...).body)."
        },
        {
          "name": "options",
          "type": "{ encoding?: string, signal?: AbortSignal }",
          "desc": "Optional text encoding and AbortSignal for cancellation."
        }
      ],
      "returns": {
        "type": "Promise<string>",
        "desc": "Resolves to the decoded text, or rejects on abort."
      },
      "examples": [
        "const res = await fetch('/api/logs');\nconst text = await streamToText(res.body);",
        "const ac = new AbortController();\nconst p = streamToText(stream, { signal: ac.signal });\nac.abort();"
      ]
    },
    "starterCode": "export default async function streamToText(stream, options = {}) {\n  // TODO: read stream with a reader + TextDecoder\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type StreamToTextOptions = {\n  encoding?: string;\n  signal?: AbortSignal;\n};\n\nexport default async function streamToText(\n  stream: { getReader: () => { read: () => Promise<{ done: boolean; value?: Uint8Array }>; cancel?: () => void } },\n  options: StreamToTextOptions = {}\n): Promise<string> {\n  // TODO: read stream with a reader + TextDecoder\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Get a reader, read chunks in a loop, and decode with TextDecoder using `{ stream: true }` so multi-byte characters aren’t split. Flush the decoder at the end. If an AbortSignal is provided, cancel and throw an AbortError.",
      "approaches": [
        {
          "title": "Approach: Reader loop + TextDecoder",
          "prose": "Steps:\n1) Validate stream and getReader().\n2) Create TextDecoder with optional encoding.\n3) Read in a loop: decode each chunk with `{ stream: true }` and append.\n4) When done, flush decoder and append final text.\n5) If signal aborts, cancel the reader and throw AbortError.\n\nComplexity: O(n) time and O(n) memory for the final string.",
          "codeJs": "function toAbortError(reason, message = 'Aborted') {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  try { err.name = 'AbortError'; } catch { try { Object.defineProperty(err, 'name', { value: 'AbortError' }); } catch {} }\n  return err;\n}\n\nexport default async function streamToText(stream, options = {}) {\n  if (!stream || typeof stream.getReader !== 'function') {\n    throw new TypeError('stream must be a ReadableStream');\n  }\n\n  const { encoding = 'utf-8', signal } = options;\n  const reader = stream.getReader();\n  const decoder = new TextDecoder(encoding);\n  let output = '';\n  let aborted = false;\n\n  const onAbort = () => {\n    aborted = true;\n    if (reader.cancel) reader.cancel();\n  };\n\n  if (signal) {\n    if (signal.aborted) {\n      if (reader.cancel) reader.cancel();\n      throw toAbortError(signal.reason);\n    }\n    signal.addEventListener('abort', onAbort, { once: true });\n  }\n\n  try {\n    while (true) {\n      if (aborted) throw toAbortError(signal && signal.reason);\n      const { done, value } = await reader.read();\n      if (aborted) throw toAbortError(signal && signal.reason);\n      if (done) break;\n      if (value) output += decoder.decode(value, { stream: true });\n    }\n    output += decoder.decode();\n    return output;\n  } finally {\n    if (signal) signal.removeEventListener('abort', onAbort);\n  }\n}\n",
          "codeTs": "function toAbortError(reason: any, message: string = 'Aborted'): Error {\n  if (reason && reason.name === 'AbortError') return reason;\n  const err = new Error(reason && reason.message ? reason.message : message);\n  try { (err as any).name = 'AbortError'; } catch { try { Object.defineProperty(err as any, 'name', { value: 'AbortError' }); } catch {} }\n  return err;\n}\n\ntype StreamToTextOptions = {\n  encoding?: string;\n  signal?: AbortSignal;\n};\n\nexport default async function streamToText(\n  stream: { getReader: () => { read: () => Promise<{ done: boolean; value?: Uint8Array }>; cancel?: () => void } },\n  options: StreamToTextOptions = {}\n): Promise<string> {\n  if (!stream || typeof stream.getReader !== 'function') {\n    throw new TypeError('stream must be a ReadableStream');\n  }\n\n  const { encoding = 'utf-8', signal } = options;\n  const reader = stream.getReader();\n  const decoder = new TextDecoder(encoding);\n  let output = '';\n  let aborted = false;\n\n  const onAbort = () => {\n    aborted = true;\n    if (reader.cancel) reader.cancel();\n  };\n\n  if (signal) {\n    if (signal.aborted) {\n      if (reader.cancel) reader.cancel();\n      throw toAbortError((signal as any).reason);\n    }\n    signal.addEventListener('abort', onAbort, { once: true });\n  }\n\n  try {\n    while (true) {\n      if (aborted) throw toAbortError(signal && (signal as any).reason);\n      const { done, value } = await reader.read();\n      if (aborted) throw toAbortError(signal && (signal as any).reason);\n      if (done) break;\n      if (value) output += decoder.decode(value, { stream: true });\n    }\n    output += decoder.decode();\n    return output;\n  } finally {\n    if (signal) signal.removeEventListener('abort', onAbort);\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Calling TextDecoder without { stream: true } can corrupt multi-byte characters.",
          "Not flushing the decoder at the end may drop trailing bytes.",
          "Ignoring abort signals can leave readers open or stuck."
        ],
        "edgeCases": [
          "Empty stream should resolve to an empty string.",
          "Split emoji or accented chars across chunks should decode correctly.",
          "Aborted signal should reject immediately."
        ],
        "techniques": [
          "ReadableStream reader loop.",
          "TextDecoder streaming decode.",
          "AbortSignal cancellation."
        ]
      },
      "followUpQuestions": [
        "js-parse-ndjson",
        "js-fetch-json-timeout"
      ],
      "resources": [
        {
          "title": "MDN – Streams API",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Streams_API"
        },
        {
          "title": "MDN – TextDecoder",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder"
        }
      ]
    },
    "tests": "import streamToText from './streamToText';\n\nfunction makeStream(chunks) {\n  let i = 0;\n  let cancelled = false;\n  return {\n    getReader() {\n      return {\n        read() {\n          if (cancelled) return Promise.resolve({ done: true });\n          if (i >= chunks.length) return Promise.resolve({ done: true, value: undefined });\n          return Promise.resolve({ done: false, value: chunks[i++] });\n        },\n        cancel() {\n          cancelled = true;\n        }\n      };\n    }\n  };\n}\n\ndescribe('streamToText', () => {\n  test('concatenates chunks', async () => {\n    const enc = new TextEncoder();\n    const stream = makeStream([enc.encode('Hello '), enc.encode('World')]);\n    await expect(streamToText(stream)).resolves.toBe('Hello World');\n  });\n\n  test('handles multibyte characters across chunks', async () => {\n    const enc = new TextEncoder();\n    const bytes = enc.encode('Hi 🌍');\n    const part1 = bytes.slice(0, 4);\n    const part2 = bytes.slice(4);\n    const stream = makeStream([part1, part2]);\n    await expect(streamToText(stream)).resolves.toBe('Hi 🌍');\n  });\n\n  test('rejects on abort', async () => {\n    const enc = new TextEncoder();\n    const stream = makeStream([enc.encode('data')]);\n    const ac = new AbortController();\n    ac.abort(new Error('Stop'));\n    await expect(streamToText(stream, { signal: ac.signal })).rejects.toMatchObject({\n      name: 'AbortError'\n    });\n  });\n});\n",
    "testsTs": "import streamToText from './streamToText';\n\nfunction makeStream(chunks: Uint8Array[]) {\n  let i = 0;\n  let cancelled = false;\n  return {\n    getReader() {\n      return {\n        read() {\n          if (cancelled) return Promise.resolve({ done: true });\n          if (i >= chunks.length) return Promise.resolve({ done: true, value: undefined });\n          return Promise.resolve({ done: false, value: chunks[i++] });\n        },\n        cancel() {\n          cancelled = true;\n        }\n      };\n    }\n  };\n}\n\ndescribe('streamToText (TypeScript)', () => {\n  it('concatenates chunks', async () => {\n    const enc = new TextEncoder();\n    const stream = makeStream([enc.encode('Hello '), enc.encode('World')]);\n    await expect(streamToText(stream)).resolves.toBe('Hello World');\n  });\n\n  it('handles multibyte characters across chunks', async () => {\n    const enc = new TextEncoder();\n    const bytes = enc.encode('Hi 🌍');\n    const part1 = bytes.slice(0, 4);\n    const part2 = bytes.slice(4);\n    const stream = makeStream([part1, part2]);\n    await expect(streamToText(stream)).resolves.toBe('Hi 🌍');\n  });\n\n  it('rejects on abort', async () => {\n    const enc = new TextEncoder();\n    const stream = makeStream([enc.encode('data')]);\n    const ac = new AbortController();\n    ac.abort(new Error('Stop'));\n    await expect(streamToText(stream, { signal: ac.signal })).rejects.toMatchObject({\n      name: 'AbortError'\n    });\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-storage-ttl-cache",
    "title": "Storage TTL Cache (localStorage/sessionStorage)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "web-apis",
      "storage",
      "caching",
      "local-storage",
      "sessionstorage"
    ],
    "description": {
      "summary": "Implement createTtlStorage(storage, now?) that returns { set, get, remove }. It should store JSON values with an optional TTL and automatically expire items when read. This mirrors real-world caching layers on top of localStorage/sessionStorage.",
      "arguments": [
        {
          "name": "storage",
          "type": "{ getItem, setItem, removeItem }",
          "desc": "A Storage-like object (localStorage/sessionStorage compatible)."
        },
        {
          "name": "now",
          "type": "() => number",
          "desc": "Optional time provider (defaults to Date.now) for testing."
        }
      ],
      "returns": {
        "type": "{ set: (key, value, ttlMs?) => void, get: (key) => any, remove: (key) => void }",
        "desc": "A tiny TTL-aware cache wrapper."
      },
      "examples": [
        "const cache = createTtlStorage(localStorage);\ncache.set('user', { id: 1 }, 5000);\ncache.get('user');",
        "cache.set('perm', 'ok'); // no expiry"
      ]
    },
    "starterCode": "export default function createTtlStorage(storage, now = () => Date.now()) {\n  // TODO: return { set, get, remove } with TTL behavior\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "type StorageLike = {\n  getItem: (key: string) => string | null;\n  setItem: (key: string, value: string) => void;\n  removeItem: (key: string) => void;\n};\n\nexport default function createTtlStorage(\n  storage: StorageLike,\n  now: () => number = () => Date.now()\n): {\n  set: (key: string, value: any, ttlMs?: number) => void;\n  get: (key: string) => any;\n  remove: (key: string) => void;\n} {\n  // TODO: return { set, get, remove } with TTL behavior\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Store a JSON envelope { v, exp } where exp is the absolute expiration timestamp or null. On get, parse the envelope, check exp, and delete expired or invalid entries.",
      "approaches": [
        {
          "title": "Approach: JSON envelope with exp timestamp",
          "prose": "Steps:\n1) Validate that storage has getItem/setItem/removeItem.\n2) set(): store JSON { v: value, exp: ttlMs == null ? null : now()+max(ttlMs,0) }.\n3) get(): read, JSON.parse, and return v if exp is null or in the future; otherwise remove and return null.\n4) If JSON.parse fails, remove the key and return null.\n\nComplexity: O(1) per operation.",
          "codeJs": "export default function createTtlStorage(storage, now = () => Date.now()) {\n  if (!storage || typeof storage.getItem !== 'function') {\n    throw new TypeError('storage must implement getItem/setItem/removeItem');\n  }\n\n  const set = (key, value, ttlMs) => {\n    const exp = ttlMs == null ? null : now() + Math.max(0, ttlMs);\n    const payload = JSON.stringify({ v: value, exp });\n    storage.setItem(String(key), payload);\n  };\n\n  const get = (key) => {\n    const raw = storage.getItem(String(key));\n    if (raw == null) return null;\n    try {\n      const data = JSON.parse(raw);\n      if (!data || !('v' in data)) return null;\n      if (data.exp != null && now() >= data.exp) {\n        storage.removeItem(String(key));\n        return null;\n      }\n      return data.v;\n    } catch {\n      storage.removeItem(String(key));\n      return null;\n    }\n  };\n\n  const remove = (key) => {\n    storage.removeItem(String(key));\n  };\n\n  return { set, get, remove };\n}\n",
          "codeTs": "type StorageLike = {\n  getItem: (key: string) => string | null;\n  setItem: (key: string, value: string) => void;\n  removeItem: (key: string) => void;\n};\n\nexport default function createTtlStorage(\n  storage: StorageLike,\n  now: () => number = () => Date.now()\n) {\n  if (!storage || typeof storage.getItem !== 'function') {\n    throw new TypeError('storage must implement getItem/setItem/removeItem');\n  }\n\n  const set = (key: string, value: any, ttlMs?: number) => {\n    const exp = ttlMs == null ? null : now() + Math.max(0, ttlMs);\n    const payload = JSON.stringify({ v: value, exp });\n    storage.setItem(String(key), payload);\n  };\n\n  const get = (key: string) => {\n    const raw = storage.getItem(String(key));\n    if (raw == null) return null;\n    try {\n      const data = JSON.parse(raw) as { v?: any; exp?: number | null };\n      if (!data || !('v' in data)) return null;\n      if (data.exp != null && now() >= data.exp) {\n        storage.removeItem(String(key));\n        return null;\n      }\n      return data.v;\n    } catch {\n      storage.removeItem(String(key));\n      return null;\n    }\n  };\n\n  const remove = (key: string) => {\n    storage.removeItem(String(key));\n  };\n\n  return { set, get, remove };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to remove expired entries can leave stale data forever.",
          "Not handling JSON.parse errors can crash reads on corrupted storage.",
          "Using localStorage for sensitive data is risky (it’s readable by JS)."
        ],
        "edgeCases": [
          "ttlMs omitted: item should persist until explicitly removed.",
          "ttlMs = 0 or negative: item expires immediately.",
          "Missing keys should return null."
        ],
        "techniques": [
          "JSON envelope storage.",
          "Time-based expiry checks.",
          "Defensive parsing + cleanup."
        ]
      },
      "followUpQuestions": [
        "js-stringify-query-string",
        "js-parse-query-string"
      ],
      "resources": [
        {
          "title": "MDN – Web Storage API",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API"
        }
      ]
    },
    "tests": "import createTtlStorage from './createTtlStorage';\n\nfunction makeStorage() {\n  const map = new Map();\n  return {\n    getItem: (k) => (map.has(k) ? map.get(k) : null),\n    setItem: (k, v) => { map.set(k, String(v)); },\n    removeItem: (k) => { map.delete(k); },\n    _map: map\n  };\n}\n\ndescribe('createTtlStorage', () => {\n  test('stores and retrieves values without ttl', () => {\n    const store = makeStorage();\n    const cache = createTtlStorage(store, () => 0);\n    cache.set('a', { x: 1 });\n    expect(cache.get('a')).toEqual({ x: 1 });\n  });\n\n  test('expires values after ttl', () => {\n    const store = makeStorage();\n    let t = 0;\n    const cache = createTtlStorage(store, () => t);\n    cache.set('a', 'ok', 10);\n    expect(cache.get('a')).toBe('ok');\n    t = 10;\n    expect(cache.get('a')).toBe(null);\n  });\n\n  test('removes corrupted JSON entries', () => {\n    const store = makeStorage();\n    store.setItem('bad', '{not json');\n    const cache = createTtlStorage(store, () => 0);\n    expect(cache.get('bad')).toBe(null);\n    expect(store.getItem('bad')).toBe(null);\n  });\n\n  test('remove deletes key', () => {\n    const store = makeStorage();\n    const cache = createTtlStorage(store, () => 0);\n    cache.set('x', 1);\n    cache.remove('x');\n    expect(cache.get('x')).toBe(null);\n  });\n});\n",
    "testsTs": "import createTtlStorage from './createTtlStorage';\n\nfunction makeStorage() {\n  const map = new Map<string, string>();\n  return {\n    getItem: (k: string) => (map.has(k) ? map.get(k)! : null),\n    setItem: (k: string, v: string) => { map.set(k, String(v)); },\n    removeItem: (k: string) => { map.delete(k); },\n    _map: map\n  };\n}\n\ndescribe('createTtlStorage (TypeScript)', () => {\n  it('stores and retrieves values without ttl', () => {\n    const store = makeStorage();\n    const cache = createTtlStorage(store, () => 0);\n    cache.set('a', { x: 1 });\n    expect(cache.get('a')).toEqual({ x: 1 });\n  });\n\n  it('expires values after ttl', () => {\n    const store = makeStorage();\n    let t = 0;\n    const cache = createTtlStorage(store, () => t);\n    cache.set('a', 'ok', 10);\n    expect(cache.get('a')).toBe('ok');\n    t = 10;\n    expect(cache.get('a')).toBe(null);\n  });\n\n  it('removes corrupted JSON entries', () => {\n    const store = makeStorage();\n    store.setItem('bad', '{not json');\n    const cache = createTtlStorage(store, () => 0);\n    expect(cache.get('bad')).toBe(null);\n    expect(store.getItem('bad')).toBe(null);\n  });\n\n  it('remove deletes key', () => {\n    const store = makeStorage();\n    const cache = createTtlStorage(store, () => 0);\n    cache.set('x', 1);\n    cache.remove('x');\n    expect(cache.get('x')).toBe(null);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-escape-html",
    "title": "Escape HTML for Safe Text",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "security",
      "strings",
      "html",
      "dom",
      "utilities"
    ],
    "description": {
      "summary": "Implement escapeHtml(text) to convert &, <, >, \" and ' into HTML entities so user-provided text can be safely inserted into HTML text nodes or attributes. This is context-specific encoding for XSS prevention (text only).",
      "arguments": [
        {
          "name": "text",
          "type": "string",
          "desc": "Raw user text to escape for HTML."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "Escaped HTML-safe string."
      },
      "examples": [
        "escapeHtml('<div class=\"x\">Tom & Jerry\\'s</div>')\n// => \"&lt;div class=&quot;x&quot;&gt;Tom &amp; Jerry&#39;s&lt;/div&gt;\"",
        "escapeHtml('5 > 3 & 2 < 4')\n// => \"5 &gt; 3 &amp; 2 &lt; 4\""
      ]
    },
    "starterCode": "export default function escapeHtml(text) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function escapeHtml(text: string): string {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Escaping converts special characters into HTML entities so the browser treats them as text, not markup. This prevents user input from turning into tags or attributes when inserted into HTML.",
      "approaches": [
        {
          "title": "Approach 1: Regex + lookup map (preferred)",
          "prose": "Create a map for the five characters and replace them with a single regex pass. Complexity is O(n) time and O(n) space.",
          "codeJs": "export default function escapeHtml(text) {\n  const map = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  return String(text).replace(/[&<>\"']/g, (ch) => map[ch]);\n}\n",
          "codeTs": "export default function escapeHtml(text: string): string {\n  const map: Record<string, string> = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  return String(text).replace(/[&<>\"']/g, (ch) => map[ch]);\n}\n"
        },
        {
          "title": "Approach 2: Chained replace (simple but order-sensitive)",
          "prose": "You can chain replace calls, but you must escape `&` first or you will double-escape the entities you create later.",
          "codeJs": "export default function escapeHtml(text) {\n  return String(text)\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n",
          "codeTs": "export default function escapeHtml(text: string): string {\n  return String(text)\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Escaping is context-specific. HTML escaping does not make strings safe for URLs, JS, or CSS contexts.",
          "If you chain replacements, escape `&` first or you will double-escape entities.",
          "Escaping does not allow rich HTML; use a sanitizer with an allowlist when you must accept markup."
        ],
        "edgeCases": [
          "Empty string should return an empty string.",
          "Already-escaped input will be escaped again (expected for raw-text encoding).",
          "Quotes matter for attribute contexts; escape both `\"` and `'`."
        ],
        "techniques": [
          "Regex replacement with a lookup table.",
          "String normalization via String(text).",
          "Context-aware output encoding."
        ]
      },
      "followUpQuestions": [
        "js-dom-renderer",
        "js-dom-find-node"
      ],
      "resources": [
        {
          "title": "OWASP – XSS Prevention Cheat Sheet",
          "url": "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
        },
        {
          "title": "MDN – Element.textContent",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent"
        }
      ]
    },
    "tests": "import escapeHtml from './escapeHtml';\n\ndescribe('escapeHtml', () => {\n  test('escapes HTML special characters', () => {\n    const input = '<div class=\"x\">Tom & Jerry\\'s</div>';\n    const out = '&lt;div class=&quot;x&quot;&gt;Tom &amp; Jerry&#39;s&lt;/div&gt;';\n    expect(escapeHtml(input)).toBe(out);\n  });\n\n  test('leaves safe text unchanged', () => {\n    expect(escapeHtml('hello world')).toBe('hello world');\n  });\n\n  test('escapes ampersands in existing entities', () => {\n    expect(escapeHtml('&lt;script&gt;')).toBe('&amp;lt;script&amp;gt;');\n  });\n});\n",
    "testsTs": "import escapeHtml from './escapeHtml';\n\ndescribe('escapeHtml (TypeScript)', () => {\n  it('escapes HTML special characters', () => {\n    const input = '<div class=\"x\">Tom & Jerry\\'s</div>';\n    const out = '&lt;div class=&quot;x&quot;&gt;Tom &amp; Jerry&#39;s&lt;/div&gt;';\n    expect(escapeHtml(input)).toBe(out);\n  });\n\n  it('leaves safe text unchanged', () => {\n    expect(escapeHtml('hello world')).toBe('hello world');\n  });\n\n  it('escapes ampersands in existing entities', () => {\n    expect(escapeHtml('&lt;script&gt;')).toBe('&amp;lt;script&amp;gt;');\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-validate-username",
    "title": "Validate Username (Rules + Edge Cases)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "validation",
      "strings",
      "edge-cases",
      "best-practices",
      "utilities"
    ],
    "description": {
      "summary": "Implement validateUsername(name) to enforce common username rules and handle edge cases safely. Rules: 3\u201316 chars, lowercase letters/digits/underscore only, must start with a letter, no consecutive underscores, and no trailing underscore.",
      "arguments": [
        {
          "name": "name",
          "type": "string",
          "desc": "The username to validate."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "True if valid; otherwise false."
      },
      "examples": [
        "validateUsername('alice_1') // => true",
        "validateUsername('2cool')   // => false (must start with a letter)",
        "validateUsername('bob__x')  // => false (no consecutive underscores)"
      ]
    },
    "starterCode": "export default function validateUsername(name) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function validateUsername(name: string): boolean {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Validate step-by-step: type guard, length check, allowed characters, and underscore rules. This makes edge cases explicit and tests easy to reason about.",
      "approaches": [
        {
          "title": "Approach 1: Explicit checks (clear and testable)",
          "prose": "Steps:\n1) Ensure input is a string.\n2) Check length between 3 and 16.\n3) Verify allowed characters (lowercase letters, digits, underscore).\n4) Ensure it starts with a letter.\n5) Reject consecutive underscores and trailing underscore.\n\nComplexity: O(n) time, O(1) extra space.",
          "codeJs": "export default function validateUsername(name) {\n  if (typeof name !== 'string') return false;\n  const len = name.length;\n  if (len < 3 || len > 16) return false;\n  if (!/^[a-z][a-z0-9_]*$/.test(name)) return false;\n  if (name.endsWith('_')) return false;\n  if (name.includes('__')) return false;\n  return true;\n}\n",
          "codeTs": "export default function validateUsername(name: string): boolean {\n  if (typeof name !== 'string') return false;\n  const len = name.length;\n  if (len < 3 || len > 16) return false;\n  if (!/^[a-z][a-z0-9_]*$/.test(name)) return false;\n  if (name.endsWith('_')) return false;\n  if (name.includes('__')) return false;\n  return true;\n}\n"
        },
        {
          "title": "Approach 2: Single regex (compact)",
          "prose": "A single regex can encode all rules. It is shorter but harder to maintain. Keep tests strong so refactors do not break edge cases.",
          "codeJs": "export default function validateUsername(name) {\n  return typeof name === 'string' && /^[a-z](?!.*__)[a-z0-9_]{1,14}[a-z0-9]$/.test(name);\n}\n",
          "codeTs": "export default function validateUsername(name: string): boolean {\n  return typeof name === 'string' && /^[a-z](?!.*__)[a-z0-9_]{1,14}[a-z0-9]$/.test(name);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to reject trailing underscores.",
          "Allowing uppercase letters or hyphens accidentally.",
          "Regex-only solutions that hide edge-case intent without tests."
        ],
        "edgeCases": [
          "Length boundaries: 3 and 16 are valid; 2 and 17 are invalid.",
          "Leading digit is invalid even if the rest is valid.",
          "Consecutive underscores are invalid anywhere in the string."
        ],
        "techniques": [
          "Boundary checks before regex for clarity.",
          "String methods for simple rules (endsWith, includes).",
          "Small, focused unit tests for each rule."
        ]
      },
      "followUpQuestions": [
        "js-parse-query-string",
        "js-stringify-query-string"
      ],
      "resources": [
        {
          "title": "MDN \u2013 Regular expressions",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions"
        }
      ]
    },
    "tests": "import validateUsername from './validateUsername';\n\ndescribe('validateUsername', () => {\n  test('accepts valid usernames', () => {\n    expect(validateUsername('alice_1')).toBe(true);\n    expect(validateUsername('abc')).toBe(true);\n    expect(validateUsername('a123456789012345')).toBe(true);\n  });\n\n  test('rejects invalid length', () => {\n    expect(validateUsername('ab')).toBe(false);\n    expect(validateUsername('a1234567890123456')).toBe(false);\n  });\n\n  test('rejects uppercase or invalid chars', () => {\n    expect(validateUsername('Alice')).toBe(false);\n    expect(validateUsername('bob-dash')).toBe(false);\n  });\n\n  test('rejects leading digit, trailing underscore, or consecutive underscores', () => {\n    expect(validateUsername('2cool')).toBe(false);\n    expect(validateUsername('bob_')).toBe(false);\n    expect(validateUsername('bob__x')).toBe(false);\n  });\n});\n",
    "testsTs": "import validateUsername from './validateUsername';\n\ndescribe('validateUsername (TypeScript)', () => {\n  it('accepts valid usernames', () => {\n    expect(validateUsername('alice_1')).toBe(true);\n    expect(validateUsername('abc')).toBe(true);\n    expect(validateUsername('a123456789012345')).toBe(true);\n  });\n\n  it('rejects invalid length', () => {\n    expect(validateUsername('ab')).toBe(false);\n    expect(validateUsername('a1234567890123456')).toBe(false);\n  });\n\n  it('rejects uppercase or invalid chars', () => {\n    expect(validateUsername('Alice')).toBe(false);\n    expect(validateUsername('bob-dash')).toBe(false);\n  });\n\n  it('rejects leading digit, trailing underscore, or consecutive underscores', () => {\n    expect(validateUsername('2cool')).toBe(false);\n    expect(validateUsername('bob_')).toBe(false);\n    expect(validateUsername('bob__x')).toBe(false);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-safe-json-parse",
    "title": "Safe JSON Parse (Fallback on Error)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "error-handling",
      "validation",
      "strings",
      "edge-cases",
      "utilities"
    ],
    "description": {
      "summary": "Implement safeJsonParse(text, fallback = null) to safely parse JSON. It should return the parsed value for valid JSON strings and the fallback for invalid JSON or non-string inputs. This is a common edge-case strategy for parsing unknown inputs.",
      "arguments": [
        {
          "name": "text",
          "type": "string",
          "desc": "The JSON string to parse."
        },
        {
          "name": "fallback",
          "type": "any",
          "desc": "Value to return when parsing fails. Defaults to null."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "Parsed JSON value or the fallback."
      },
      "examples": [
        "safeJsonParse('{\"ok\":true}') // => { ok: true }",
        "safeJsonParse('not json', []) // => []",
        "safeJsonParse(42, { ok: false }) // => { ok: false }"
      ]
    },
    "starterCode": "export default function safeJsonParse(text, fallback = null) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function safeJsonParse(text: string, fallback: any = null): any {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Guard the input type, then try JSON.parse in a try/catch. On any error, return the fallback. Keep the behavior predictable so tests can cover invalid inputs and boundary cases.",
      "approaches": [
        {
          "title": "Approach: Guard + try/catch",
          "prose": "Steps:\n1) If text is not a string, return fallback.\n2) Attempt JSON.parse.\n3) On error, return fallback.\n\nComplexity: O(n) time for parsing, O(1) extra space.",
          "codeJs": "export default function safeJsonParse(text, fallback = null) {\n  if (typeof text !== 'string') return fallback;\n  try {\n    return JSON.parse(text);\n  } catch {\n    return fallback;\n  }\n}\n",
          "codeTs": "export default function safeJsonParse(text: string, fallback: any = null): any {\n  if (typeof text !== 'string') return fallback;\n  try {\n    return JSON.parse(text);\n  } catch {\n    return fallback;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Assuming JSON.parse always returns an object (it can return numbers, strings, booleans, or null).",
          "Catching errors but returning undefined, which makes tests ambiguous.",
          "Parsing non-strings without guarding can throw or behave unexpectedly."
        ],
        "edgeCases": [
          "Valid primitives like '0', 'true', and 'null' should parse correctly.",
          "Whitespace around JSON is valid and should parse.",
          "Invalid JSON should always return the fallback without throwing."
        ],
        "techniques": [
          "Type guards before parsing.",
          "Deterministic fallback behavior for tests.",
          "Focused unit tests per edge case."
        ]
      },
      "followUpQuestions": [
        "js-parse-query-string",
        "js-stringify-query-string"
      ],
      "resources": [
        {
          "title": "MDN \u2013 JSON.parse()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"
        }
      ]
    },
    "tests": "import safeJsonParse from './safeJsonParse';\n\ndescribe('safeJsonParse', () => {\n  test('parses valid JSON objects and arrays', () => {\n    expect(safeJsonParse('{\"ok\":true}')).toEqual({ ok: true });\n    expect(safeJsonParse('[1,2,3]')).toEqual([1, 2, 3]);\n  });\n\n  test('parses valid primitives', () => {\n    expect(safeJsonParse('0')).toBe(0);\n    expect(safeJsonParse('true')).toBe(true);\n    expect(safeJsonParse('null')).toBe(null);\n  });\n\n  test('returns fallback on invalid JSON', () => {\n    const fallback = { ok: false };\n    expect(safeJsonParse('{bad}', fallback)).toBe(fallback);\n  });\n\n  test('returns fallback for non-string input', () => {\n    expect(safeJsonParse(42, [])).toEqual([]);\n  });\n});\n",
    "testsTs": "import safeJsonParse from './safeJsonParse';\n\ndescribe('safeJsonParse (TypeScript)', () => {\n  it('parses valid JSON objects and arrays', () => {\n    expect(safeJsonParse('{\"ok\":true}')).toEqual({ ok: true });\n    expect(safeJsonParse('[1,2,3]')).toEqual([1, 2, 3]);\n  });\n\n  it('parses valid primitives', () => {\n    expect(safeJsonParse('0')).toBe(0);\n    expect(safeJsonParse('true')).toBe(true);\n    expect(safeJsonParse('null')).toBe(null);\n  });\n\n  it('returns fallback on invalid JSON', () => {\n    const fallback = { ok: false };\n    expect(safeJsonParse('{bad}', fallback)).toBe(fallback);\n  });\n\n  it('returns fallback for non-string input', () => {\n    expect(safeJsonParse(42 as any, [])).toEqual([]);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-measure-duration",
    "title": "Measure Function Duration (Profiling Wrapper)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "performance",
      "web-performance",
      "debugging",
      "functions",
      "utilities"
    ],
    "description": {
      "summary": "Implement measure(fn, now?) to profile execution time. It should run a function, measure the duration using the provided clock, and return { result, durationMs }. It must support both sync and async functions (return a Promise in all cases).",
      "arguments": [
        {
          "name": "fn",
          "type": "() => any | Promise<any>",
          "desc": "Function to execute and measure."
        },
        {
          "name": "now",
          "type": "() => number",
          "desc": "Optional clock (defaults to performance.now or Date.now)."
        }
      ],
      "returns": {
        "type": "Promise<{ result: any, durationMs: number }>",
        "desc": "The function result plus elapsed time in ms."
      },
      "examples": [
        "await measure(() => doWork())",
        "await measure(async () => await fetchData(), () => 0)"
      ]
    },
    "starterCode": "export default async function measure(fn, now = () => Date.now()) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default async function measure(\n  fn: () => any | Promise<any>,\n  now: () => number = () => Date.now()\n): Promise<{ result: any; durationMs: number }> {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Capture a start time, execute the function, then capture an end time after it finishes. Wrap the result in Promise.resolve so both sync and async paths are handled consistently.",
      "approaches": [
        {
          "title": "Approach: Promise.resolve wrapper",
          "prose": "Steps:\n1) Record start time.\n2) Call fn and wrap with Promise.resolve.\n3) After it resolves, record end time and return { result, durationMs }.\n4) If fn throws or rejects, propagate the error.\n\nComplexity: O(1) extra work (not counting fn).",
          "codeJs": "export default async function measure(fn, now = () => Date.now()) {\n  const start = now();\n  const result = await Promise.resolve().then(fn);\n  const end = now();\n  return { result, durationMs: end - start };\n}\n",
          "codeTs": "export default async function measure(\n  fn: () => any | Promise<any>,\n  now: () => number = () => Date.now()\n): Promise<{ result: any; durationMs: number }> {\n  const start = now();\n  const result = await Promise.resolve().then(fn);\n  const end = now();\n  return { result, durationMs: end - start };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using Date.now() for small durations can be too coarse; prefer performance.now when available.",
          "Measuring async work without awaiting gives misleading durations.",
          "Profiling adds overhead; keep wrappers lightweight."
        ],
        "edgeCases": [
          "Function throws: error should propagate (no swallowing).",
          "Async function resolves: duration should cover await time.",
          "Clock function can be injected for deterministic tests."
        ],
        "techniques": [
          "Promise.resolve to normalize sync vs async."
        ]
      },
      "followUpQuestions": [
        "js-debounce",
        "js-poll-until"
      ],
      "resources": [
        {
          "title": "MDN \u2013 Performance.now()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Performance/now"
        }
      ]
    },
    "tests": "import measure from './measure';\n\ndescribe('measure', () => {\n  test('measures sync functions', async () => {\n    let t = 0;\n    const now = () => (t += 5);\n    const { result, durationMs } = await measure(() => 42, now);\n    expect(result).toBe(42);\n    expect(durationMs).toBe(5);\n  });\n\n  test('measures async functions', async () => {\n    let t = 100;\n    const now = () => (t += 10);\n    const { result, durationMs } = await measure(async () => 'ok', now);\n    expect(result).toBe('ok');\n    expect(durationMs).toBe(10);\n  });\n\n  test('propagates errors', async () => {\n    const now = () => 1;\n    await expect(measure(() => { throw new Error('boom'); }, now)).rejects.toThrow('boom');\n  });\n});\n",
    "testsTs": "import measure from './measure';\n\ndescribe('measure (TypeScript)', () => {\n  it('measures sync functions', async () => {\n    let t = 0;\n    const now = () => (t += 5);\n    const { result, durationMs } = await measure(() => 42, now);\n    expect(result).toBe(42);\n    expect(durationMs).toBe(5);\n  });\n\n  it('measures async functions', async () => {\n    let t = 100;\n    const now = () => (t += 10);\n    const { result, durationMs } = await measure(async () => 'ok', now);\n    expect(result).toBe('ok');\n    expect(durationMs).toBe(10);\n  });\n\n  it('propagates errors', async () => {\n    const now = () => 1;\n    await expect(measure(() => { throw new Error('boom'); }, now)).rejects.toThrow('boom');\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-create-cleanup-bag",
    "title": "Cleanup Bag (Dispose Subscriptions)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "best-practices",
      "event-handling",
      "utilities",
      "debugging",
      "performance"
    ],
    "description": {
      "summary": "Implement createCleanupBag() that helps prevent memory leaks by tracking cleanup functions (like removing event listeners or cancelling timers). It should return { add, dispose, size }. add(fn) registers a cleanup and returns a function to remove it. dispose() runs all remaining cleanups once and clears the bag.",
      "arguments": [],
      "returns": {
        "type": "{ add: (fn: () => void) => () => void, dispose: () => void, size: () => number }",
        "desc": "A cleanup registry that can be disposed safely."
      },
      "examples": [
        "const bag = createCleanupBag();\nconst off = bag.add(() => clearInterval(id));\n// later...\nbag.dispose();",
        "// add after dispose runs immediately\nbag.dispose();\nbag.add(() => console.log('cleanup'));"
      ]
    },
    "starterCode": "export default function createCleanupBag() {\n  // TODO: return { add, dispose, size }\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function createCleanupBag(): {\n  add: (fn: () => void) => () => void;\n  dispose: () => void;\n  size: () => number;\n} {\n  // TODO: return { add, dispose, size }\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Track cleanup callbacks in a Set. add() registers a cleanup and returns a remover. dispose() runs each cleanup once and clears the Set. If add() is called after dispose(), run it immediately to avoid leaks.",
      "approaches": [
        {
          "title": "Approach: Set + idempotent dispose",
          "prose": "Steps:\n1) Keep a Set of cleanup functions.\n2) add(fn): if already disposed, run fn immediately and return a no-op remover; otherwise store fn and return a remover that deletes it.\n3) dispose(): run all remaining cleanups once, clear the Set, mark disposed.\n\nComplexity: O(n) to dispose; O(1) per add/remove.",
          "codeJs": "export default function createCleanupBag() {\n  const cleanups = new Set();\n  let disposed = false;\n\n  const add = (fn) => {\n    if (typeof fn !== 'function') throw new TypeError('cleanup must be a function');\n    if (disposed) {\n      fn();\n      return () => {};\n    }\n    cleanups.add(fn);\n    let removed = false;\n    return () => {\n      if (removed) return;\n      removed = true;\n      cleanups.delete(fn);\n    };\n  };\n\n  const dispose = () => {\n    if (disposed) return;\n    disposed = true;\n    for (const fn of Array.from(cleanups)) {\n      try { fn(); } finally { cleanups.delete(fn); }\n    }\n  };\n\n  const size = () => cleanups.size;\n\n  return { add, dispose, size };\n}\n",
          "codeTs": "export default function createCleanupBag() {\n  const cleanups = new Set<() => void>();\n  let disposed = false;\n\n  const add = (fn: () => void) => {\n    if (typeof fn !== 'function') throw new TypeError('cleanup must be a function');\n    if (disposed) {\n      fn();\n      return () => {};\n    }\n    cleanups.add(fn);\n    let removed = false;\n    return () => {\n      if (removed) return;\n      removed = true;\n      cleanups.delete(fn);\n    };\n  };\n\n  const dispose = () => {\n    if (disposed) return;\n    disposed = true;\n    for (const fn of Array.from(cleanups)) {\n      try { fn(); } finally { cleanups.delete(fn); }\n    }\n  };\n\n  const size = () => cleanups.size;\n\n  return { add, dispose, size };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to clear references keeps memory alive unnecessarily.",
          "Calling cleanup twice can cause errors; make dispose idempotent.",
          "Not handling add-after-dispose can leak resources."
        ],
        "edgeCases": [
          "dispose() called multiple times should be safe.",
          "remove a cleanup before dispose should skip it.",
          "add() after dispose should run immediately."
        ],
        "techniques": [
          "Set for stable O(1) add/remove.",
          "Idempotent cleanup patterns."
        ]
      },
      "followUpQuestions": [
        "js-debounce",
        "js-event-loop"
      ],
      "resources": [
        {
          "title": "MDN \u2013 addEventListener/removeEventListener",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener"
        }
      ]
    },
    "tests": "import createCleanupBag from './createCleanupBag';\n\ndescribe('createCleanupBag', () => {\n  test('disposes remaining cleanups', () => {\n    const bag = createCleanupBag();\n    const calls = [];\n    const offA = bag.add(() => calls.push('a'));\n    bag.add(() => calls.push('b'));\n    offA();\n\n    bag.dispose();\n\n    expect(calls).toEqual(['b']);\n    expect(bag.size()).toBe(0);\n  });\n\n  test('dispose is idempotent', () => {\n    const bag = createCleanupBag();\n    let count = 0;\n    bag.add(() => count++);\n    bag.dispose();\n    bag.dispose();\n    expect(count).toBe(1);\n  });\n\n  test('add after dispose runs immediately', () => {\n    const bag = createCleanupBag();\n    let ran = 0;\n    bag.dispose();\n    bag.add(() => ran++);\n    expect(ran).toBe(1);\n    expect(bag.size()).toBe(0);\n  });\n});\n",
    "testsTs": "import createCleanupBag from './createCleanupBag';\n\ndescribe('createCleanupBag (TypeScript)', () => {\n  it('disposes remaining cleanups', () => {\n    const bag = createCleanupBag();\n    const calls: string[] = [];\n    const offA = bag.add(() => calls.push('a'));\n    bag.add(() => calls.push('b'));\n    offA();\n\n    bag.dispose();\n\n    expect(calls).toEqual(['b']);\n    expect(bag.size()).toBe(0);\n  });\n\n  it('dispose is idempotent', () => {\n    const bag = createCleanupBag();\n    let count = 0;\n    bag.add(() => count++);\n    bag.dispose();\n    bag.dispose();\n    expect(count).toBe(1);\n  });\n\n  it('add after dispose runs immediately', () => {\n    const bag = createCleanupBag();\n    let ran = 0;\n    bag.dispose();\n    bag.add(() => ran++);\n    expect(ran).toBe(1);\n    expect(bag.size()).toBe(0);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-format-date-timezone",
    "title": "Format Date in Time Zone (YYYY-MM-DD)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "date-time",
      "intl",
      "time-zones",
      "timers",
      "utilities",
      "strings",
      "edge-cases",
      "best-practices"
    ],
    "description": {
      "summary": "Implement formatDateInTimeZone(date, timeZone) to return a YYYY-MM-DD string for a given Date (or timestamp) in a specific IANA time zone. Use Intl.DateTimeFormat and handle invalid dates safely.",
      "arguments": [
        {
          "name": "date",
          "type": "Date | number",
          "desc": "Date object or timestamp (ms)."
        },
        {
          "name": "timeZone",
          "type": "string",
          "desc": "IANA time zone (e.g., 'UTC', 'America/Los_Angeles')."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "Formatted date as YYYY-MM-DD in the specified time zone."
      },
      "examples": [
        "formatDateInTimeZone(new Date('2020-01-01T00:30:00Z'), 'America/Los_Angeles') // => '2019-12-31'",
        "formatDateInTimeZone(1593646200000, 'UTC') // => '2020-07-01'"
      ]
    },
    "starterCode": "export default function formatDateInTimeZone(date, timeZone) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function formatDateInTimeZone(date: Date | number, timeZone: string): string {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Use Intl.DateTimeFormat with a fixed locale and the provided timeZone. formatToParts lets you build a stable YYYY-MM-DD string without relying on locale-specific formatting.",
      "approaches": [
        {
          "title": "Approach: Intl.DateTimeFormat + formatToParts",
          "prose": "Steps:\n1) Normalize input to a Date.\n2) Throw if the date is invalid.\n3) Use Intl.DateTimeFormat with { year, month, day } and the timeZone.\n4) Read year/month/day from formatToParts and build YYYY-MM-DD.\n\nComplexity: O(1) time, O(1) space.",
          "codeJs": "export default function formatDateInTimeZone(date, timeZone) {\n  const d = date instanceof Date ? date : new Date(date);\n  if (Number.isNaN(d.getTime())) throw new TypeError('Invalid date');\n\n  const parts = new Intl.DateTimeFormat('en-US', {\n    timeZone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit'\n  }).formatToParts(d);\n\n  const map = {};\n  for (const p of parts) {\n    if (p.type !== 'literal') map[p.type] = p.value;\n  }\n\n  return `${map.year}-${map.month}-${map.day}`;\n}\n",
          "codeTs": "export default function formatDateInTimeZone(date: Date | number, timeZone: string): string {\n  const d = date instanceof Date ? date : new Date(date);\n  if (Number.isNaN(d.getTime())) throw new TypeError('Invalid date');\n\n  const parts = new Intl.DateTimeFormat('en-US', {\n    timeZone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit'\n  }).formatToParts(d);\n\n  const map: Record<string, string> = {};\n  for (const p of parts) {\n    if (p.type !== 'literal') map[p.type] = p.value;\n  }\n\n  return `${map.year}-${map.month}-${map.day}`;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Manual offset math fails across daylight saving time changes.",
          "Using toISOString always returns UTC, not the target time zone.",
          "Locale formatting can vary; formatToParts avoids ambiguity."
        ],
        "edgeCases": [
          "Invalid dates should throw or be handled explicitly.",
          "Dates near midnight can change the local day depending on time zone.",
          "Invalid time zones should throw a RangeError from Intl."
        ],
        "techniques": [
          "Intl.DateTimeFormat with timeZone option.",
          "formatToParts for stable output."
        ]
      },
      "followUpQuestions": [
        "js-storage-ttl-cache",
        "js-sleep"
      ],
      "resources": [
        {
          "title": "MDN \u2013 Intl.DateTimeFormat",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat"
        }
      ]
    },
    "tests": "import formatDateInTimeZone from './formatDateInTimeZone';\n\ndescribe('formatDateInTimeZone', () => {\n  test('formats date in different time zones', () => {\n    const date = new Date('2020-01-01T00:30:00Z');\n    expect(formatDateInTimeZone(date, 'America/Los_Angeles')).toBe('2019-12-31');\n    expect(formatDateInTimeZone(date, 'Asia/Tokyo')).toBe('2020-01-01');\n  });\n\n  test('accepts a timestamp', () => {\n    const ts = Date.parse('2020-07-01T23:30:00Z');\n    expect(formatDateInTimeZone(ts, 'UTC')).toBe('2020-07-01');\n  });\n\n  test('throws on invalid date', () => {\n    expect(() => formatDateInTimeZone(new Date('invalid'), 'UTC')).toThrow();\n  });\n});\n",
    "testsTs": "import formatDateInTimeZone from './formatDateInTimeZone';\n\ndescribe('formatDateInTimeZone (TypeScript)', () => {\n  it('formats date in different time zones', () => {\n    const date = new Date('2020-01-01T00:30:00Z');\n    expect(formatDateInTimeZone(date, 'America/Los_Angeles')).toBe('2019-12-31');\n    expect(formatDateInTimeZone(date, 'Asia/Tokyo')).toBe('2020-01-01');\n  });\n\n  it('accepts a timestamp', () => {\n    const ts = Date.parse('2020-07-01T23:30:00Z');\n    expect(formatDateInTimeZone(ts, 'UTC')).toBe('2020-07-01');\n  });\n\n  it('throws on invalid date', () => {\n    expect(() => formatDateInTimeZone(new Date('invalid'), 'UTC')).toThrow();\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-create-spy-function",
    "title": "Create a Spy Function (Test Double)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "testing",
      "functions",
      "closure",
      "this",
      "debugging",
      "best-practices",
      "utilities"
    ],
    "description": {
      "summary": "Implement createSpy(impl?) to produce a callable spy that records every call (args + this) and optionally delegates to an implementation. Spies are a core unit-testing tool to verify behavior at boundaries (network, storage, analytics) without needing a full mocking library.",
      "arguments": [
        {
          "name": "impl",
          "type": "Function (optional)",
          "desc": "Optional implementation to call. The spy must preserve the caller's this value."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A spy function with metadata: calls, thisValues, callCount(), lastCall(), reset()."
      },
      "examples": [
        "const spy = createSpy((a, b) => a + b);\nspy(1, 2); // => 3\nspy.calls; // => [[1, 2]]\nspy.callCount(); // => 1",
        "const obj = { x: 2, fn: createSpy(function (n) { return this.x + n; }) };\nobj.fn(3); // => 5 (this preserved)\nobj.fn.thisValues[0] === obj; // true"
      ]
    },
    "starterCode": "export default function createSpy(impl) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export type SpyFn<TArgs extends any[] = any[], TResult = any> = ((...args: TArgs) => TResult) & {\n  calls: TArgs[];\n  thisValues: any[];\n  callCount: () => number;\n  lastCall: () => TArgs | null;\n  reset: () => void;\n};\n\nexport default function createSpy<TArgs extends any[] = any[], TResult = any>(\n  impl?: (this: any, ...args: TArgs) => TResult\n): SpyFn<TArgs, TResult> {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "A spy is just a function with extra state. Record calls in arrays, and if an implementation is provided, delegate to it using apply() so this binding is preserved.",
      "approaches": [
        {
          "title": "Approach: Closure + attached metadata",
          "prose": "Steps:\n1) Create a function spy(...args).\n2) Push args into spy.calls and this into spy.thisValues.\n3) If impl exists, return impl.apply(this, args).\n4) Attach helpers: callCount(), lastCall(), reset().\n\nComplexity: O(1) per call and O(k) memory for k calls.",
          "codeJs": "export default function createSpy(impl) {\n  function spy(...args) {\n    spy.calls.push(args);\n    spy.thisValues.push(this);\n    if (typeof impl === 'function') {\n      return impl.apply(this, args);\n    }\n    return undefined;\n  }\n\n  spy.calls = [];\n  spy.thisValues = [];\n  spy.callCount = () => spy.calls.length;\n  spy.lastCall = () => (spy.calls.length ? spy.calls[spy.calls.length - 1] : null);\n  spy.reset = () => {\n    spy.calls.length = 0;\n    spy.thisValues.length = 0;\n  };\n\n  return spy;\n}\n",
          "codeTs": "export type SpyFn<TArgs extends any[] = any[], TResult = any> = ((...args: TArgs) => TResult) & {\n  calls: TArgs[];\n  thisValues: any[];\n  callCount: () => number;\n  lastCall: () => TArgs | null;\n  reset: () => void;\n};\n\nexport default function createSpy<TArgs extends any[] = any[], TResult = any>(\n  impl?: (this: any, ...args: TArgs) => TResult\n): SpyFn<TArgs, TResult> {\n  const spy = function (this: any, ...args: TArgs) {\n    (spy as any).calls.push(args);\n    (spy as any).thisValues.push(this);\n    if (typeof impl === 'function') {\n      return impl.apply(this, args);\n    }\n    return undefined as any as TResult;\n  } as SpyFn<TArgs, TResult>;\n\n  spy.calls = [] as TArgs[];\n  spy.thisValues = [] as any[];\n  spy.callCount = () => spy.calls.length;\n  spy.lastCall = () => (spy.calls.length ? spy.calls[spy.calls.length - 1] : null);\n  spy.reset = () => {\n    spy.calls.length = 0;\n    spy.thisValues.length = 0;\n  };\n\n  return spy;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Calling impl(...args) loses the caller's this; use impl.apply(this, args).",
          "Forgetting to reset between tests causes order-dependent failures.",
          "Asserting too much about call order can make tests brittle; prefer behavior-based assertions."
        ],
        "edgeCases": [
          "No implementation: spy still records calls and returns undefined.",
          "Zero calls: lastCall() should return null.",
          "The spy may be used as a method; thisValues should reflect the receiver."
        ],
        "techniques": [
          "Closure to keep state private.",
          "Attach metadata onto the function object.",
          "Preserve this via apply()."
        ]
      },
      "resources": [
        {
          "title": "MDN \u2013 Function.prototype.apply",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
        }
      ],
      "followUpQuestions": [
        "js-call-apply-bind",
        "js-testing-edge-cases-strategy"
      ]
    },
    "tests": "import createSpy from './createSpy';\n\ndescribe('createSpy', () => {\n  test('records calls and arguments', () => {\n    const spy = createSpy();\n    spy(1, 2);\n    spy('a');\n\n    expect(spy.callCount()).toBe(2);\n    expect(spy.calls).toEqual([[1, 2], ['a']]);\n    expect(spy.lastCall()).toEqual(['a']);\n  });\n\n  test('delegates to the implementation and returns its value', () => {\n    const spy = createSpy((a, b) => a + b);\n    const out = spy(2, 3);\n    expect(out).toBe(5);\n    expect(spy.calls[0]).toEqual([2, 3]);\n  });\n\n  test('preserves this binding when used as a method', () => {\n    const obj = {\n      x: 10,\n      fn: createSpy(function (n) { return this.x + n; })\n    };\n\n    const out = obj.fn(2);\n\n    expect(out).toBe(12);\n    expect(obj.fn.thisValues[0]).toBe(obj);\n  });\n\n  test('reset clears recorded calls', () => {\n    const spy = createSpy();\n    spy(1);\n    spy.reset();\n    expect(spy.callCount()).toBe(0);\n    expect(spy.calls).toEqual([]);\n    expect(spy.lastCall()).toBe(null);\n  });\n});\n",
    "testsTs": "import createSpy from './createSpy';\n\ndescribe('createSpy (TypeScript)', () => {\n  it('records calls and arguments', () => {\n    const spy = createSpy<[number, number], number>();\n    spy(1, 2);\n\n    expect(spy.callCount()).toBe(1);\n    expect(spy.calls).toEqual([[1, 2]]);\n    expect(spy.lastCall()).toEqual([1, 2]);\n  });\n\n  it('delegates to the implementation and returns its value', () => {\n    const spy = createSpy<[number, number], number>((a, b) => a + b);\n    expect(spy(2, 3)).toBe(5);\n    expect(spy.calls[0]).toEqual([2, 3]);\n  });\n\n  it('preserves this binding when used as a method', () => {\n    const obj = {\n      x: 7,\n      fn: createSpy<[number], number>(function (this: any, n) { return this.x + n; })\n    };\n\n    expect(obj.fn(5)).toBe(12);\n    expect(obj.fn.thisValues[0]).toBe(obj);\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-05"
  },
  {
    "id": "js-create-deferred-promise",
    "title": "Create a Deferred Promise (For Async Tests)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "intermediate",
    "tags": [
      "testing",
      "promise",
      "async",
      "concurrency",
      "utilities",
      "error-handling",
      "best-practices"
    ],
    "description": {
      "summary": "Implement createDeferred() to build a controllable Promise: { promise, resolve, reject }. This is a common testing tool to make async flows deterministic (you decide exactly when something resolves/rejects).",
      "arguments": [],
      "returns": {
        "type": "{ promise: Promise, resolve: Function, reject: Function }",
        "desc": "A deferred object whose promise can be resolved/rejected from the outside."
      },
      "examples": [
        "const d = createDeferred();\nsetTimeout(() => d.resolve('ok'), 0);\nawait d.promise; // => 'ok'",
        "const d = createDeferred();\nd.reject(new Error('fail'));\nawait d.promise; // rejects"
      ]
    },
    "starterCode": "export default function createDeferred() {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export type Deferred<T> = {\n  promise: Promise<T>;\n  resolve: (value: T | PromiseLike<T>) => void;\n  reject: (reason?: any) => void;\n};\n\nexport default function createDeferred<T = unknown>(): Deferred<T> {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Create a Promise and capture its resolve/reject functions from the constructor. Return them alongside the promise. This is often used in tests to control the timing of async operations without relying on real timers.",
      "approaches": [
        {
          "title": "Approach: Capture resolve/reject from new Promise",
          "prose": "Steps:\n1) Declare variables resolve/reject.\n2) Create a new Promise((res, rej) => { resolve = res; reject = rej; }).\n3) Return { promise, resolve, reject }.\n\nComplexity: O(1) time, O(1) space.",
          "codeJs": "export default function createDeferred() {\n  let resolve;\n  let reject;\n\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n",
          "codeTs": "export type Deferred<T> = {\n  promise: Promise<T>;\n  resolve: (value: T | PromiseLike<T>) => void;\n  reject: (reason?: any) => void;\n};\n\nexport default function createDeferred<T = unknown>(): Deferred<T> {\n  let resolve!: (value: T | PromiseLike<T>) => void;\n  let reject!: (reason?: any) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using deferred promises everywhere can hide real race conditions; use them for tests and controlled orchestration only.",
          "If a deferred is never resolved/rejected, awaits can hang \u2014 add timeouts in real code.",
          "Prefer dependency injection over global state to make async code testable."
        ],
        "edgeCases": [
          "Resolving/rejecting multiple times should not throw; only the first call wins (Promise semantics).",
          "Resolving with another Promise should adopt its eventual state.",
          "Rejecting with non-Error values is allowed but less debuggable."
        ],
        "techniques": [
          "Promise constructor captures resolve/reject.",
          "Use in tests to control async deterministically.",
          "Adopt states by resolving with a PromiseLike."
        ]
      },
      "resources": [
        {
          "title": "MDN \u2013 Promise constructor",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise"
        }
      ],
      "followUpQuestions": [
        "js-take-latest",
        "js-promise-any"
      ]
    },
    "tests": "import createDeferred from './createDeferred';\n\ndescribe('createDeferred', () => {\n  test('resolves when resolve is called', async () => {\n    const d = createDeferred();\n    d.resolve(123);\n    const out = await d.promise;\n    expect(out).toBe(123);\n  });\n\n  test('rejects when reject is called', async () => {\n    const d = createDeferred();\n    const err = new Error('nope');\n    d.reject(err);\n\n    try {\n      await d.promise;\n      throw new Error('Expected promise to reject');\n    } catch (e) {\n      expect(e).toBe(err);\n    }\n  });\n\n  test('adopts another promise when resolving', async () => {\n    const d = createDeferred();\n    d.resolve(Promise.resolve('ok'));\n    const out = await d.promise;\n    expect(out).toBe('ok');\n  });\n});\n",
    "testsTs": "import createDeferred from './createDeferred';\n\ndescribe('createDeferred (TypeScript)', () => {\n  it('resolves when resolve is called', async () => {\n    const d = createDeferred<number>();\n    d.resolve(42);\n    const out = await d.promise;\n    expect(out).toBe(42);\n  });\n\n  it('rejects when reject is called', async () => {\n    const d = createDeferred<number>();\n    const err = new Error('fail');\n    d.reject(err);\n\n    try {\n      await d.promise;\n      throw new Error('Expected promise to reject');\n    } catch (e) {\n      expect(e).toBe(err);\n    }\n  });\n\n  it('adopts another promise when resolving', async () => {\n    const d = createDeferred<string>();\n    d.resolve(Promise.resolve('ok'));\n    expect(await d.promise).toBe('ok');\n  });\n});\n",
    "access": "free",
    "updatedAt": "2026-02-05"
  }
]
