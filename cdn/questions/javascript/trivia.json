[
  {
    "id": "js-event-loop",
    "title": "Explain the JavaScript Event Loop",
    "description": "JavaScript runs on a single thread. Each cycle: it executes synchronous code, drains all microtasks (e.g., Promise callbacks), then runs one macrotask (e.g., setTimeout) before repeating. This is why Promises run before timers and why long microtask chains can block rendering.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "event-loop",
      "async",
      "microtasks",
      "promise",
      "timers"
    ],
    "importance": 5,
    "companies": [
      "meta"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Big Picture</strong>\n\nJavaScript runs <strong>on a single thread</strong>, meaning it can only do <strong>one thing at a time</strong>. So how does it handle things like <code>setTimeout</code>, <code>fetch</code>, or <code>Promise.then</code> without freezing? That‚Äôs where the <strong>event loop</strong> comes in.\n\nThink of it like a manager that decides <em>what piece of code runs next</em> among all waiting tasks."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gears'></i> <strong>The Three Main Parts</strong>\n\nThe JavaScript runtime manages execution using three core parts: the <strong>Call Stack</strong>, <strong>Task Queues</strong>, and the <strong>Event Loop</strong>."
        },
        {
          "type": "list",
          "columns": [
            "Component",
            "Purpose",
            "Examples / Details"
          ],
          "rows": [
            [
              "<strong>Call Stack</strong>",
              "Where synchronous code runs, line by line. If a function takes too long here, everything else waits (blocking).",
              "<code>console.log</code>, loops, math operations, synchronous functions"
            ],
            [
              "<strong>Task Queues (two types)</strong>",
              "Where async tasks wait until the stack is clear ‚Äî split into Microtask and Macrotask queues.",
              "Async callbacks, Promises, timers, I/O events"
            ],
            [
              "<strong>Microtask Queue</strong>",
              "Smaller, high-priority tasks that run immediately after the stack is clear.",
              "<code>Promise.then</code>, <code>queueMicrotask</code>, <code>process.nextTick</code>"
            ],
            [
              "<strong>Macrotask Queue</strong>",
              "Larger, lower-priority tasks that can yield to the browser for rendering between runs.",
              "<code>setTimeout</code>, DOM events, I/O, <code>setInterval</code>"
            ]
          ],
          "caption": "Call Stack and Task Queues at a glance."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-repeat'></i> <strong>The Event Loop</strong>\n\nThe event loop constantly checks:\n1. Is the call stack empty?  \n2. Any microtasks waiting? ‚Üí Run all of them.  \n3. Take one macrotask and run it.  \nThen the cycle repeats forever."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log('A');\n\nsetTimeout(() => console.log('B (macrotask)'));\n\nPromise.resolve()\n  .then(() => console.log('C (microtask)'))\n  .then(() => console.log('D (microtask)'));\n\nconsole.log('E');\n\n// Output:\n// A\n// E\n// C\n// D\n// B"
        },
        {
          "type": "text",
          "text": "<strong>Why this order?</strong>\n- <code>A</code> and <code>E</code> ‚Üí run first (synchronous stack).  \n- Then the event loop runs <strong>all microtasks</strong> ‚Üí <code>C</code>, <code>D</code>.  \n- Finally, the next macrotask runs ‚Üí <code>B</code>.  \n\nThat‚Äôs why <strong>Promises always run before timers</strong>, even when scheduled ‚Äúat the same time.‚Äù"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-layer-group'></i> <strong>Microtasks vs. Macrotasks (Summary)</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Type",
            "Examples",
            "Runs When",
            "Priority"
          ],
          "rows": [
            [
              "<strong>Microtask</strong>",
              "<code>Promise.then</code>, <code>queueMicrotask</code>",
              "After the current call stack, before rendering",
              "High"
            ],
            [
              "<strong>Macrotask</strong>",
              "<code>setTimeout</code>, <code>setInterval</code>, DOM events",
              "After microtasks, allows rendering",
              "Normal"
            ]
          ],
          "caption": "Microtasks run before macrotasks within each event loop cycle."
        },
        {
          "type": "text",
          "text": "After each macrotask, <strong>all microtasks</strong> are drained before the next one starts. That‚Äôs why too many microtasks (like recursive Promises) can block rendering."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function loop() {\n  Promise.resolve().then(loop); // microtask recursion\n}\nloop(); // browser freezes ‚Äî it never yields control back"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-server'></i> <strong>In Node.js</strong>\n\nThe event loop runs through several <strong>phases</strong>:\n<pre class='md-pre'>timers ‚Üí pending callbacks ‚Üí poll ‚Üí check ‚Üí close callbacks</pre>\nMicrotasks (<code>Promise.then</code>, <code>process.nextTick</code>) run <strong>after each phase</strong>, unlike browsers where they run once per loop."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "setTimeout(() => console.log('timer'));\nsetImmediate(() => console.log('immediate'));\nPromise.resolve().then(() => console.log('microtask'));\n\n// Common order:\n// microtask ‚Üí timer ‚Üí immediate"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- JavaScript executes <strong>synchronously</strong> on a single thread.  \n- The <strong>event loop</strong> coordinates between the stack and queues.  \n- <strong>Microtasks</strong> (Promises) always run before <strong>macrotasks</strong> (timers).  \n- Too many microtasks can freeze rendering.  \n- Use macrotasks for deferred work and microtasks for quick follow-ups."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nImagine you‚Äôre the only cashier at a store. You serve one customer at a time (the call stack). When a customer needs to grab something, you tell them to step aside (macrotask). But before you call the next one, you handle quick questions like ‚ÄòCan I get a receipt?‚Äô (microtasks). You repeat this all day ‚Äî that‚Äôs the event loop!"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-closures",
    "title": "Explain Closures in JavaScript",
    "description": "A closure happens when a function keeps access to variables from its outer scope, even after that outer function has finished. It‚Äôs how JavaScript allows private data and persistent state inside functions.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "closure",
      "functions",
      "lexical-environment",
      "scope"
    ],
    "importance": 5,
    "companies": [
      "amazon",
      "google",
      "netflix",
      "apple",
      "meta"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nA **closure** is when a function remembers variables from the place where it was created ‚Äî not from where it is called. It means inner functions can keep using values from an outer function, even after that outer function has finished running."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Simple example\nfunction makeCounter() {\n  let count = 0; // stays in memory\n  return function () {\n    count++;\n    return count;\n  };\n}\n\nconst counter = makeCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\n\n// The inner function still 'remembers' count"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lock'></i> <strong>Why It‚Äôs Useful</strong>\n\nClosures are powerful because they let you:\n- Keep variables **private** (not accessible globally)\n- Store **state** between function calls\n- Create **helpers** like <code>once()</code>, <code>memoize()</code>, and other reusable patterns"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example: once()\nfunction once(fn) {\n  let called = false;\n  let value;\n  return function (...args) {\n    if (!called) {\n      called = true;\n      value = fn.apply(this, args);\n    }\n    return value;\n  };\n}\n\nconst init = once(() => console.log('Initialized'));\ninit(); // Logs once\ninit(); // Does nothing ‚Äî remembers state"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common Mistake</strong>\n\nUsing <code>var</code> in loops creates one shared variable for all iterations ‚Äî so all functions close over the same value:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const funcs = [];\nfor (var i = 0; i < 3; i++) {\n  funcs.push(() => i);\n}\nconsole.log(funcs.map(fn => fn())); // [3, 3, 3]"
        },
        {
          "type": "text",
          "text": "<strong>Fixes:</strong>\n- Use <code>let</code> for block scoping\n- Or use an IIFE (immediately invoked function) to capture a copy"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Fix with let\nfor (let j = 0; j < 3; j++) {\n  setTimeout(() => console.log(j), 0);\n}\n// 0 1 2"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-memory'></i> <strong>Memory Notes</strong>\n\nClosures keep their referenced variables alive as long as the inner function exists. This can accidentally hold big objects or DOM elements in memory, so always clean up unused references."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Functions automatically form closures in JavaScript.  \n- Inner functions remember outer variables (their <strong>lexical scope</strong>).  \n- Used for data privacy, persistence, and modular code.  \n- Use <code>let</code>/<code>const</code> to avoid loop bugs.  \n- Don‚Äôt overuse closures in long-lived objects to prevent memory leaks."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nImagine you leave a room (outer function ends), but you gave your friend (inner function) a copy of the key to your drawer (variables). Even though you‚Äôre gone, they can still open it ‚Äî that‚Äôs a closure!"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-this-keyword",
    "title": "Explain the `this` keyword in JavaScript",
    "description": "The value of `this` in JavaScript depends on how a function is called ‚Äî not where it‚Äôs defined. It can refer to the global object, a specific object, or be `undefined` in strict mode or arrow functions. The value of this depends on call site, strict mode, and arrow functions. Misbinding is a common source of bugs; test with call/apply/bind.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "binding",
      "context",
      "functions",
      "this"
    ],
    "importance": 5,
    "companies": [
      "amazon",
      "google",
      "apple",
      "meta"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nThe value of <code>this</code> in JavaScript is determined by <strong>how a function is called</strong>, not by where it is written. It points to the <strong>execution context</strong> ‚Äî the object that 'owns' the function at the time of invocation."
        },
        {
          "type": "list",
          "columns": [
            "Call Type",
            "Value of <code>this</code>",
            "Example"
          ],
          "rows": [
            [
              "<strong>Global / Default</strong>",
              "In browsers ‚Üí <code>window</code>, in strict mode ‚Üí <code>undefined</code>",
              "<code>console.log(this)</code>"
            ],
            [
              "<strong>Object method</strong>",
              "The object before the dot",
              "<code>user.sayHi()</code> ‚Üí <code>this === user</code>"
            ],
            [
              "<strong>Constructor</strong>",
              "The newly created instance",
              "<code>new Person()</code>"
            ],
            [
              "<strong>Explicit binding</strong>",
              "Set manually using <code>call</code>, <code>apply</code>, or <code>bind</code>",
              "<code>fn.call(obj)</code> ‚Üí <code>this === obj</code>"
            ],
            [
              "<strong>Arrow function</strong>",
              "Does not bind <code>this</code>; inherits it from its outer scope",
              "<code>() => this</code> inside an object ‚Üí outer <code>this</code>"
            ]
          ],
          "caption": "How `this` changes based on how the function is called."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example 1: Default binding\nfunction show() {\n  console.log(this);\n}\nshow(); // window (or undefined in strict mode)"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example 2: Method call\nconst user = {\n  name: 'Mia',\n  greet() {\n    console.log('Hi, ' + this.name);\n  }\n};\nuser.greet(); // 'Hi, Mia'"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example 3: Detached method loses context\nconst greetFn = user.greet;\ngreetFn(); // undefined or 'Hi, undefined' ‚Äî this is lost"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-link'></i> <strong>Fixing Lost Context</strong>\n\nYou can control or preserve <code>this</code> explicitly using:\n- <code>call()</code> / <code>apply()</code> ‚Üí call immediately\n- <code>bind()</code> ‚Üí return a new function with fixed <code>this</code>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const boundGreet = user.greet.bind(user);\nboundGreet(); // 'Hi, Mia'"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bolt'></i> <strong>Arrow Functions</strong>\n\nArrow functions **don‚Äôt have their own <code>this</code>**. They inherit it from the surrounding scope. Great for callbacks that need lexical <code>this</code>."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function Timer() {\n  this.seconds = 0;\n  setInterval(() => {\n    this.seconds++;\n    console.log(this.seconds);\n  }, 1000);\n}\nnew Timer(); // works fine\n\n// But using a normal function would break:\n// setInterval(function() { this.seconds++ }, 1000); // this = undefined"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common Pitfalls</strong>\n\n- Forgetting <code>new</code> ‚Üí <code>this</code> becomes global (or undefined in strict mode)\n- Losing context when passing methods as callbacks\n- Misusing arrow functions in class methods (they can‚Äôt be rebound)"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- <code>this</code> depends on the <strong>call site</strong>, not where the function is defined.  \n- Arrow functions don‚Äôt have their own <code>this</code>.  \n- <code>call</code>, <code>apply</code>, and <code>bind</code> let you control <code>this</code> explicitly.  \n- <code>new</code> creates a new object and binds <code>this</code> to it."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of <code>this</code> as the person holding the phone üì± ‚Äî not the number you dialed. The number (function) stays the same, but who picks up (the object that calls it) decides what <code>this</code> will be."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A class method passed as a callback loses <code>this</code>, breaking access to instance state.<br><br><strong>Common pitfalls</strong><br><ul><li>Forgetting to bind methods in constructors.</li><li>Using arrow functions and expecting dynamic this.</li><li>Calling functions without a receiver in strict mode.</li></ul><strong>Trade-off or test tip</strong><br>Binding is explicit but creates new functions. Test with call/apply/bind and verify this values.</strong>"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-hoisting-tdz",
    "title": "Explain Hoisting and the Temporal Dead Zone (TDZ)",
    "description": "During the creation phase, JavaScript moves declarations to the top of their scope (hoisting). However, variables declared with `let` and `const` exist in a 'temporal dead zone' until their declaration is reached, making them inaccessible before initialization.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "hoisting",
      "temporal-dead-zone",
      "scope",
      "variables"
    ],
    "importance": 5,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nBefore JavaScript executes any code, it first scans your script to find all variable and function declarations. It sets up memory for them in a process called <strong>hoisting</strong>. But ‚Äî not all declarations behave the same way."
        },
        {
          "type": "list",
          "columns": [
            "Declaration Type",
            "Hoisted?",
            "Initialized Before Declaration?",
            "Example"
          ],
          "rows": [
            [
              "<code>var</code>",
              "Yes",
              "‚úÖ Initialized to <code>undefined</code>",
              "<code>console.log(a); var a = 5;</code> ‚Üí undefined"
            ],
            [
              "<code>let</code>",
              "Yes",
              "‚ùå In TDZ (no access before declaration)",
              "<code>console.log(b); let b = 5;</code> ‚Üí ReferenceError"
            ],
            [
              "<code>const</code>",
              "Yes",
              "‚ùå In TDZ (must be initialized immediately)",
              "<code>const c = 10;</code>"
            ],
            [
              "<code>function</code>",
              "Yes (fully hoisted)",
              "‚úÖ Can be called before definition",
              "<code>foo(); function foo() {}</code>"
            ]
          ],
          "caption": "How different declarations behave during hoisting."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-up-long'></i> <strong>What is Hoisting?</strong>\n\nHoisting means declarations are <strong>moved to the top of their scope</strong> before code runs. This doesn‚Äôt mean your code is literally moved ‚Äî it‚Äôs just how JavaScript‚Äôs memory setup works during the 'creation phase' of execution."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example 1: var is hoisted\nconsole.log(name); // undefined\nvar name = 'Alice';\n// JS internally treats it like:\n// var name;\n// console.log(name);\n// name = 'Alice';"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>The Temporal Dead Zone (TDZ)</strong>\n\nFor <code>let</code> and <code>const</code>, the variable exists but is not initialized yet. The time between the start of the scope and the actual declaration line is called the <strong>temporal dead zone</strong>. Accessing the variable in this zone causes a <code>ReferenceError</code>."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example 2: let and TDZ\nconsole.log(age); // ‚ùå ReferenceError\nlet age = 25;\n\n// In memory:\n// TDZ starts ‚Üí variable exists but not initialized\n// Declaration reached ‚Üí initialized to 25"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bolt'></i> <strong>Functions vs Variables</strong>\n\nFunction declarations are hoisted <strong>with their full definition</strong>, so you can call them before they appear. But <strong>function expressions</strong> (especially with <code>let</code> or <code>const</code>) behave like normal variables."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example 3: function vs expression\nsayHi(); // ‚úÖ Works\nfunction sayHi() { console.log('Hi!'); }\n\nsayHello(); // ‚ùå ReferenceError\nconst sayHello = function() { console.log('Hello!'); };"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common Pitfalls</strong>\n\n- Thinking <code>let</code> or <code>const</code> aren‚Äôt hoisted (they are ‚Äî just uninitialized).  \n- Forgetting that accessing them early throws an error, not <code>undefined</code>.  \n- Mixing function declarations and expressions in confusing ways."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- JavaScript hoists all declarations before execution.  \n- <code>var</code> ‚Üí initialized as <code>undefined</code>.  \n- <code>let</code> / <code>const</code> ‚Üí uninitialized, causing a TDZ.  \n- <code>function</code> declarations ‚Üí fully hoisted and callable early.  \n- Avoid referencing variables before their declaration line."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of it like a classroom roll call üìã. The teacher knows all students‚Äô names at the start (hoisting), but only after they say 'here' (initialization) can they answer questions. Until then, they‚Äôre in the **temporal dead zone**!"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-var-let-const-hoisting",
    "title": "Explain the difference in hoisting between `var`, `let`, and `const`",
    "description": "All variable declarations are hoisted, but only `var` is initialized with `undefined`. Variables declared with `let` and `const` exist in the temporal dead zone until execution reaches their declaration, making them inaccessible beforehand.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "hoisting",
      "variables",
      "let",
      "const",
      "scope"
    ],
    "importance": 4,
    "companies": [
      "google",
      "apple"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nAll variable declarations are **hoisted** ‚Äî meaning they‚Äôre recognized by JavaScript before execution. However, only <code>var</code> is **initialized** immediately with <code>undefined</code>. <code>let</code> and <code>const</code> are hoisted too, but they stay in the **temporal dead zone (TDZ)** until the actual declaration line."
        },
        {
          "type": "list",
          "columns": [
            "Keyword",
            "Hoisted?",
            "Initialized Before Declaration?",
            "Accessible Before Declaration?",
            "Reassignable?",
            "Redeclarable?"
          ],
          "rows": [
            [
              "<code>var</code>",
              "‚úÖ Yes",
              "‚úÖ Initialized to <code>undefined</code>",
              "‚úÖ Yes (but value = undefined)",
              "‚úÖ Yes",
              "‚úÖ Yes"
            ],
            [
              "<code>let</code>",
              "‚úÖ Yes",
              "‚ùå Not initialized (TDZ)",
              "‚ùå No ‚Äî ReferenceError",
              "‚úÖ Yes",
              "‚ùå No"
            ],
            [
              "<code>const</code>",
              "‚úÖ Yes",
              "‚ùå Not initialized (TDZ)",
              "‚ùå No ‚Äî ReferenceError",
              "‚ùå No (must initialize immediately)",
              "‚ùå No"
            ]
          ],
          "caption": "Hoisting and accessibility differences between var, let, and const."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-up-long'></i> <strong>How It Works Under the Hood</strong>\n\nWhen the JavaScript engine creates an execution context, it allocates memory for all declared variables:\n- <code>var</code> is assigned <code>undefined</code> immediately.\n- <code>let</code> and <code>const</code> are known but remain uninitialized until their declaration line is reached."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example 1: var\nconsole.log(a); // undefined\nvar a = 10;\n\n// Example 2: let\nconsole.log(b); // ‚ùå ReferenceError (TDZ)\nlet b = 10;\n\n// Example 3: const\nconsole.log(c); // ‚ùå ReferenceError (TDZ)\nconst c = 10;"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>The Temporal Dead Zone (TDZ)</strong>\n\nThe TDZ is the time between entering a scope and the moment a <code>let</code> or <code>const</code> variable is declared. Accessing it during this period throws a <code>ReferenceError</code>. It helps prevent using variables before they're safely initialized."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "{\n  // TDZ starts\n  console.log(x); // ‚ùå ReferenceError\n  let x = 5; // TDZ ends here\n  console.log(x); // ‚úÖ 5\n}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- <strong>All declarations are hoisted</strong>, but initialization differs.\n- <code>var</code> ‚Üí hoisted + initialized as <code>undefined</code>.\n- <code>let</code> / <code>const</code> ‚Üí hoisted but uninitialized (TDZ).\n- Accessing <code>let</code> or <code>const</code> before declaration ‚Üí <code>ReferenceError</code>.\n- <code>const</code> also requires immediate initialization."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nImagine you‚Äôre checking into a hotel üè®. Rooms (<code>var</code>, <code>let</code>, <code>const</code>) are reserved at check-in (hoisting), but only <code>var</code> gets its key immediately. <code>let</code> and <code>const</code> exist but you can‚Äôt enter until the receptionist actually hands over the key ‚Äî that‚Äôs the **temporal dead zone**!"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-promises-async-await",
    "title": "Promises and async/await",
    "description": "Promises represent a value that may be available now, later, or never. `async/await` is syntax sugar over Promises that makes asynchronous code look synchronous, while preserving microtask scheduling and error propagation via rejections.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "async-await",
      "concurrency",
      "error-handling",
      "microtasks",
      "promise"
    ],
    "importance": 5,
    "companies": [
      "meta"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nA <strong>Promise</strong> is a container for an eventual result: <code>pending ‚Üí fulfilled</code> (resolved) or <code>pending ‚Üí rejected</code>. <code>async/await</code> makes working with Promises easier: <code>await</code> pauses within an <code>async</code> function until the Promise settles, then returns the value or throws the rejection."
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "What it means",
            "Example"
          ],
          "rows": [
            [
              "<strong>Promise states</strong>",
              "pending ‚Üí fulfilled / rejected",
              "<code>new Promise((res, rej) => ...)</code>"
            ],
            [
              "<strong>Thenables</strong>",
              "Anything with <code>.then</code> behaves like a Promise",
              "Libraries often return thenables"
            ],
            [
              "<strong>Microtasks</strong>",
              "Promise callbacks (<code>.then/.catch/.finally</code>) run as <em>microtasks</em>",
              "Run after current stack, before timers"
            ],
            [
              "<strong>async</strong>",
              "Marks a function that <em>always returns a Promise</em>",
              "<code>async function f(){ return 1 }</code>"
            ],
            [
              "<strong>await</strong>",
              "Pauses inside <code>async</code> until the Promise settles",
              "<code>const data = await fetch(...)</code>"
            ]
          ],
          "caption": "Promises and async/await at a glance."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Basic Promise\nfunction getUser(id) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => resolve({ id, name: 'John' }), 200);\n  });\n}\n\ngetUser(1)\n  .then(u => u.name)\n  .then(name => console.log(name))\n  .catch(err => console.error('Error:', err))\n  .finally(() => console.log('done'));"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Equivalent with async/await\nasync function main() {\n  try {\n    const u = await getUser(1); // waits for fulfillment\n    console.log(u.name);\n  } catch (err) {\n    console.error('Error:', err); // rejections become throw\n  } finally {\n    console.log('done');\n  }\n}\nmain();"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-people-arrows'></i> <strong>Sequential vs Parallel</strong>\n\nUsing <code>await</code> inside a loop can serialize work unintentionally. Create Promises first, then <code>await Promise.all</code> for parallelism."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// ‚ùå Sequential (slow)\nfor (const url of urls) {\n  const res = await fetch(url);\n  results.push(await res.json());\n}\n\n// ‚úÖ Parallel (fast)\nconst promises = urls.map(url => fetch(url).then(r => r.json()));\nconst results = await Promise.all(promises);"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-layer-group'></i> <strong>Promise combinators</strong>"
        },
        {
          "type": "list",
          "columns": [
            "API",
            "Settles When",
            "Behavior"
          ],
          "rows": [
            [
              "<code>Promise.all([...])</code>",
              "All fulfill or one rejects",
              "Fast-fail; rejects on first rejection"
            ],
            [
              "<code>Promise.allSettled([...])</code>",
              "All settle",
              "Never rejects; returns statuses"
            ],
            [
              "<code>Promise.race([...])</code>",
              "First settles",
              "Adopts winner's state/value"
            ],
            [
              "<code>Promise.any([...])</code>",
              "First fulfillment",
              "Rejects only if <em>all</em> reject (AggregateError)"
            ]
          ],
          "caption": "Choosing the right combinator."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Error handling</strong>\n\nWith Promises, use <code>.catch</code> or the second arg of <code>.then</code>. With <code>async/await</code>, use <code>try/catch</code>. Unhandled rejections can crash Node.js (depending on version) or show as console warnings in browsers."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Handling errors: async/await\nasync function load() {\n  try {\n    const data = await fetch('/api').then(r => {\n      if (!r.ok) throw new Error('HTTP ' + r.status);\n      return r.json();\n    });\n    return data;\n  } catch (e) {\n    // handle or rethrow\n    throw e;\n  }\n}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common pitfalls</strong>\n\n- Forgetting to <code>return</code> inside <code>.then</code> chains ‚Üí next <code>.then</code> gets <code>undefined</code>.\n- Using <code>await</code> in <code>Array.prototype.forEach</code> (it won‚Äôt await). Prefer <code>for...of</code> or <code>Promise.all</code>.\n- Assuming <code>async</code> functions throw synchronously ‚Äî they return a rejected Promise instead.\n- No built-in cancellation for Promises (use <code>AbortController</code> with <code>fetch</code> or libraries that support cancel)."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// from callback to Promise\nfunction readFileP(path) {\n  const fs = require?.('fs'); // works in Node\n  return new Promise((resolve, reject) => {\n    fs.readFile(path, 'utf8', (err, data) => {\n      if (err) reject(err); else resolve(data);\n    });\n  });\n}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Promises model eventual results and schedule callbacks as <strong>microtasks</strong>.\n- <code>async/await</code> is Promise syntax sugar: clearer flow, same semantics.\n- Prefer parallel with <code>Promise.all</code>; avoid accidental serialization.\n- Use <code>try/catch</code> (or <code>.catch</code>) and pick the right combinator for your needs."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of a Promise as an order ticket üßæ: you place the order (create Promise), you‚Äôll be notified when it‚Äôs ready (microtask). With <code>await</code>, you stand by the counter for <em>just that ticket</em> without blocking other customers ‚Äî when it‚Äôs ready, you pick it up and continue."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-event-delegation",
    "title": "Explain Event Delegation in JavaScript",
    "description": "Event delegation is a technique where a single event listener on a parent element handles events for multiple child elements by using event bubbling and checking the event target. Edge cases include stopPropagation and nested targets; test performance in large lists.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "event-delegation",
      "dom",
      "events",
      "bubbling"
    ],
    "importance": 4,
    "companies": [
      "bytedance",
      "meta"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\n**Event delegation** lets you attach **one event listener** to a **common ancestor** instead of multiple listeners to each child. When an event occurs, it bubbles up the DOM, and you check which child element triggered it using <code>event.target</code>."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example: Without delegation\nconst items = document.querySelectorAll('li');\nitems.forEach(item => item.addEventListener('click', () => {\n  console.log('Clicked:', item.textContent);\n}));"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example: With event delegation\nconst list = document.querySelector('ul');\nlist.addEventListener('click', (event) => {\n  if (event.target.tagName === 'LI') {\n    console.log('Clicked:', event.target.textContent);\n  }\n});"
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Explanation",
            "Example / Note"
          ],
          "rows": [
            [
              "<strong>Event Bubbling</strong>",
              "Events start from the target element and bubble up to its ancestors.",
              "<code>click</code> on <code>li</code> ‚Üí bubbles to <code>ul</code>"
            ],
            [
              "<strong>event.target</strong>",
              "The original element that triggered the event.",
              "Used to identify which child was clicked"
            ],
            [
              "<strong>event.currentTarget</strong>",
              "The element that the event listener is attached to.",
              "Usually the parent in delegation"
            ]
          ],
          "caption": "How event delegation uses bubbling and target references."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bolt'></i> <strong>Why Use Event Delegation?</strong>\n\n- Better **performance** ‚Äî fewer event listeners in the DOM.\n- Handles **dynamic elements** added later (since the listener is on a stable ancestor).\n- Cleaner, more maintainable code for lists, tables, or repeated components."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example: Dynamic content\nconst container = document.querySelector('#buttons');\n\ncontainer.addEventListener('click', (e) => {\n  if (e.target.matches('button.delete')) {\n    e.target.remove();\n  }\n});\n\n// Works even if buttons are added later!"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common Pitfalls</strong>\n\n- Forgetting to check <code>event.target</code> ‚Üí all clicks bubble and trigger the handler.\n- Relying on <code>event.target</code> when nested elements are inside clickable items (use <code>.closest()</code> to handle this safely)."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example: Using closest() for nested targets\nlist.addEventListener('click', (event) => {\n  const li = event.target.closest('li');\n  if (!li) return; // click outside any li\n  console.log('Clicked item:', li.textContent);\n});"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Attach listener on parent, not each child.\n- Use event bubbling + <code>event.target</code> (or <code>closest()</code>) to detect the real source.\n- Improves performance and works for dynamically added elements."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nImagine a restaurant. Instead of each waiter (child) taking orders, there‚Äôs one manager (parent) who hears all requests and decides who called ‚Äî that‚Äôs **event delegation**!"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A long, dynamic list of comments can be handled with a single click listener on the list container.<br><br><strong>Common pitfalls</strong><br><ul><li>Using <code>event.target</code> directly instead of <code>closest()</code> to find the intended item.</li><li>Forgetting that <code>stopPropagation</code> can block delegation.</li><li>Not handling keyboard events, so accessibility suffers.</li></ul><strong>Trade-off or test tip</strong><br>Delegation saves memory but adds selector logic. Test by adding/removing items dynamically and ensuring handlers still work."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-null-undefined-undeclared",
    "title": "What is the difference between a variable that is: null, undefined or undeclared?",
    "description": "In JavaScript, `undefined` means a variable has been declared but not assigned a value, `null` means an intentional empty value, and `undeclared` means the variable has never been defined in the current scope.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "null",
      "undefined",
      "undeclared",
      "types",
      "variables"
    ],
    "importance": 3,
    "companies": [
      "google"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nIn JavaScript, we have three different 'empty' states for variables ‚Äî <code>undefined</code>, <code>null</code>, and <code>undeclared</code>. Each one tells a different story about the variable‚Äôs existence and purpose."
        },
        {
          "type": "list",
          "columns": [
            "Type",
            "Meaning",
            "Example",
            "typeof Result"
          ],
          "rows": [
            [
              "<code>undefined</code>",
              "Variable declared but not assigned a value.",
              "<code>let a;</code><br><code>console.log(a); // undefined</code>",
              "<code>'undefined'</code>"
            ],
            [
              "<code>null</code>",
              "Intentional absence of value.",
              "<code>let b = null;</code><br><code>console.log(b); // null</code>",
              "<code>'object'</code> (historical bug)"
            ],
            [
              "<code>undeclared</code>",
              "Variable not declared at all in current scope.",
              "<code>console.log(c); // ‚ùå ReferenceError</code>",
              "‚Äî"
            ]
          ],
          "caption": "Quick comparison of undefined, null, and undeclared."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>undefined</strong>\n\n- A variable automatically becomes <code>undefined</code> when it is declared but not initialized.\n- It also appears when accessing missing object properties or parameters that were not passed."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "let name;\nconsole.log(name); // undefined\n\nconst user = {};\nconsole.log(user.age); // undefined\n\nfunction greet(message) {\n  console.log(message); // undefined if no argument\n}\ngreet();"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>null</strong>\n\n- <code>null</code> is something you assign deliberately to indicate that a variable should be empty.\n- It‚Äôs a developer‚Äôs way of saying, ‚ÄúI know this exists, but it currently has no value.‚Äù"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "let selectedUser = null; // intentionally empty\nif (!selectedUser) {\n  console.log('No user selected');\n}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>undeclared</strong>\n\n- A variable that has never been declared in the current scope.\n- Trying to read it results in a <code>ReferenceError</code>.\n- Accidentally assigning to it (without <code>let</code>, <code>const</code>, or <code>var</code>) creates a global variable in non-strict mode ‚Äî which is almost always a mistake."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log(x); // ‚ùå ReferenceError: x is not defined\n\nfunction test() {\n  y = 10; // creates global variable in non-strict mode\n}\ntest();\nconsole.log(window.y); // 10"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common Confusions</strong>\n\n- <code>typeof null</code> returns <code>'object'</code> ‚Äî this is a long-standing bug in JavaScript.\n- <code>undefined == null</code> is <strong>true</strong> because both mean 'no value'.\n- <code>undefined === null</code> is <strong>false</strong> because they are different types."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log(undefined == null);  // true\nconsole.log(undefined === null); // false"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- <strong>undefined</strong>: Variable exists but has no value yet ‚Äî default initial state used by JavaScript.\n- <strong>null</strong>: Deliberate empty value ‚Äî use when you want to reset or clear a variable explicitly.\n- <strong>undeclared</strong>: Variable not defined in the current scope ‚Äî avoid entirely; it signals a missing declaration or typo."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nImagine you ordered coffee ‚òï:\n- <strong>undefined</strong> ‚Üí The cup exists, but it‚Äôs still empty because no one poured coffee yet.\n- <strong>null</strong> ‚Üí You got an empty cup on purpose (you asked for none).\n- <strong>undeclared</strong> ‚Üí There‚Äôs no cup at all ‚Äî you never placed an order."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-equality-vs-strict-equality",
    "title": "What is the difference between == and === in JavaScript?",
    "description": "In JavaScript, `==` is the loose equality operator that compares values after type conversion, while `===` is the strict equality operator that compares both value and type without conversion. Edge cases include null/undefined and NaN, so prefer explicit conversion and add tests.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "operators",
      "comparison",
      "types",
      "javascript"
    ],
    "importance": 5,
    "companies": [
      "google",
      "apple"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nIn JavaScript, both `==` and `===` are used for comparing two values, but they behave very differently.\n\n- `==` (loose equality) **converts the operands** to the same type before comparison.\n- `===` (strict equality) **checks both value and type** without converting anything."
        },
        {
          "type": "list",
          "columns": [
            "Operator",
            "Compares",
            "Does Type Conversion?",
            "Example",
            "Result"
          ],
          "rows": [
            [
              "<code>==</code>",
              "Value only",
              "Yes",
              "<code>'5' == 5</code>",
              "<code>true</code>"
            ],
            [
              "<code>===</code>",
              "Value and Type",
              "No",
              "<code>'5' === 5</code>",
              "<code>false</code>"
            ]
          ],
          "caption": "Quick comparison between loose (==) and strict (===) equality."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Loose Equality (==)</strong>\n\n- Automatically converts operands to the same type before comparing.\n- Can cause confusing results because of type coercion.\n- Useful only when you explicitly want type conversion."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log('5' == 5);      // true (string converted to number)\nconsole.log(0 == false);     // true\nconsole.log(null == undefined); // true\nconsole.log('' == 0);        // true (empty string converts to 0)"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Strict Equality (===)</strong>\n\n- Compares **both type and value** exactly as they are.\n- Does not perform type coercion.\n- This is the recommended operator for most cases."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log('5' === 5);    // false (string vs number)\nconsole.log(0 === false);   // false (number vs boolean)\nconsole.log(null === undefined); // false (different types)\nconsole.log(5 === 5);       // true"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common Pitfalls</strong>\n\n- Using `==` can lead to hidden bugs when JavaScript tries to 'help' by converting types.\n- Example: `[] == false` ‚Üí `true`, but `[] === false` ‚Üí `false`.\n- Always use `===` unless you specifically need type coercion (which is rare)."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log([] == false);  // true (empty array converts to false)\nconsole.log([] === false); // false"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- <strong>==</strong>: Compares values after converting their types. May return unexpected results.\n- <strong>===</strong>: Compares both value and type. Safer and preferred in almost all cases.\n\nüëâ Rule of thumb: If you‚Äôre not sure ‚Äî use <code>===</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nImagine two people named Alex:\n- Using <strong>==</strong> is like saying ‚Äúthey have the same name‚Äù ‚Äî even if one is human and one is a robot.\n- Using <strong>===</strong> is like saying ‚Äúsame name <em>and</em> same species‚Äù ‚Äî no confusion at all."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Compare query parameters or form values (strings) to numbers and booleans in validation logic.<br><br><strong>Common pitfalls</strong><br><ul><li><code>==</code> coercion producing surprising results like <code>'' == 0</code> or <code>null == undefined</code>.</li><li>Forgetting <code>NaN</code> is never equal to itself.</li><li>Relying on loose equality in code that should be type-safe.</li></ul><strong>Trade-off or test tip</strong><br>Use <code>===</code> by default; convert types explicitly when needed. Add tests for <code>null</code>, <code>undefined</code>, and <code>NaN</code>."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-hoisting",
    "title": "Explain 'hoisting' in JavaScript",
    "description": "Hoisting is JavaScript‚Äôs default behavior of moving declarations to the top of their scope before code execution. In practice, it means you can use certain variables and functions before declaring them ‚Äî but only partially.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "hoisting",
      "scope",
      "variables",
      "functions"
    ],
    "importance": 2,
    "companies": [
      "google",
      "meta"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nBefore your code runs, JavaScript‚Äôs engine scans the scope and moves **declarations** (not initializations) to the top. This is called <strong>hoisting</strong>.\n\nIt applies to <code>var</code> variables, function declarations, and class declarations ‚Äî but with different effects."
        },
        {
          "type": "list",
          "columns": [
            "Type",
            "Is Hoisted?",
            "Initialized Before Use?",
            "Notes"
          ],
          "rows": [
            [
              "<code>var</code>",
              "Yes",
              "No (initialized as <code>undefined</code>)",
              "Accessible before declaration, but value is <code>undefined</code>."
            ],
            [
              "<code>let</code> & <code>const</code>",
              "Yes (declared, but in TDZ)",
              "No (ReferenceError if accessed early)",
              "They exist in memory but cannot be accessed before declaration due to the Temporal Dead Zone."
            ],
            [
              "Function declarations",
              "Yes",
              "Yes",
              "Fully hoisted ‚Äî can be called before defined."
            ],
            [
              "Function expressions / arrow functions",
              "No (unless assigned to <code>var</code>, then value is <code>undefined</code>)",
              "No",
              "They behave like normal variables; not callable before definition."
            ]
          ],
          "caption": "Summary of hoisting behavior for different declarations."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Example: var Hoisting</strong>\n\nA variable declared with <code>var</code> is hoisted to the top of its scope, but only its declaration ‚Äî not its assignment."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log(a); // undefined\nvar a = 5;\nconsole.log(a); // 5"
        },
        {
          "type": "text",
          "text": "Under the hood, the code above is interpreted like this:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "var a;\nconsole.log(a); // undefined\na = 5;\nconsole.log(a); // 5"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Example: let and const Hoisting</strong>\n\nAlthough <code>let</code> and <code>const</code> are hoisted, they live in a special phase called the **Temporal Dead Zone (TDZ)**. You can‚Äôt access them until the line where they are declared."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log(x); // ‚ùå ReferenceError\nlet x = 10;\nconsole.log(x); // ‚úÖ 10"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Example: Function Hoisting</strong>\n\nFunction declarations are fully hoisted, meaning you can call them before they appear in the code."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "sayHello(); // ‚úÖ Works fine\n\nfunction sayHello() {\n  console.log('Hello!');\n}"
        },
        {
          "type": "text",
          "text": "However, function expressions or arrow functions are <strong>not hoisted</strong> the same way:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "greet(); // ‚ùå TypeError: greet is not a function\n\nvar greet = function() {\n  console.log('Hi there!');\n};"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common Misunderstanding</strong>\n\nHoisting doesn‚Äôt move code literally ‚Äî it‚Äôs about how JavaScript‚Äôs memory is allocated before execution.\n\nVariables and functions are known to the engine before code runs, which is why you can sometimes access them early."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- <strong>Declarations</strong> (not assignments) are hoisted.\n- <code>var</code> ‚Üí hoisted and initialized as <code>undefined</code>.\n- <code>let</code> / <code>const</code> ‚Üí hoisted but in TDZ (can‚Äôt access early).\n- Function declarations ‚Üí fully hoisted.\n- Function expressions ‚Üí treated as variables, not hoisted safely."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of hoisting like setting the stage before a play:\n- <code>var</code> = the actor is on stage but asleep (exists, but undefined).\n- <code>let</code>/<code>const</code> = actor is behind the curtain (exists, but unreachable).\n- Function declaration = actor is fully ready, already rehearsed.\n- Function expression = actor hasn‚Äôt arrived yet ‚Äî script will fail if you try to cue them early."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-higher-order-function",
    "title": "What is the definition of a higher-order function?",
    "description": "A higher-order function is a function that either takes another function as an argument, returns a function, or does both. It treats functions as values, enabling powerful patterns like callbacks, closures, and function composition.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "callbacks",
      "closure",
      "functional-programming",
      "functions"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nIn JavaScript, a <strong>higher-order function</strong> is any function that either:\n- Takes one or more functions as arguments, <em>or</em>\n- Returns another function as its result.\n\nIn other words, it treats functions as values ‚Äî passing them around just like variables."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Description",
            "Example"
          ],
          "rows": [
            [
              "Accepts functions as arguments",
              "A function receives another function and calls it inside.",
              "<code>setTimeout(() => console.log('Hi!'), 1000)</code>"
            ],
            [
              "Returns a function",
              "A function produces another function when called.",
              "<code>function multiplier(x) { return y => x * y }</code>"
            ]
          ],
          "caption": "The two main ways a function can be considered higher-order."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Example 1: Taking a Function as an Argument</strong>\n\nFunctions like <code>map</code>, <code>filter</code>, and <code>forEach</code> are classic examples ‚Äî they take another function and apply it to elements of an array."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(n => n * 2);\nconsole.log(doubled); // [2, 4, 6, 8]"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Example 2: Returning a Function</strong>\n\nA function can return another function that 'remembers' the outer scope ‚Äî this is often used in currying or closures."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function greet(message) {\n  return function(name) {\n    console.log(`${message}, ${name}!`);\n  };\n}\n\nconst sayHello = greet('Hello');\nsayHello('Alice'); // Hello, Alice!"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Why It Matters</strong>\n\nHigher-order functions are the foundation of modern JavaScript patterns like:\n- **Callbacks** (e.g., event handlers)\n- **Promises and async/await**\n- **Functional utilities** like <code>map</code>, <code>reduce</code>, <code>filter</code>\n- **Middleware and decorators** in frameworks like Express or Redux."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nA higher-order function:\n- Takes one or more functions as parameters **or** returns a function.\n- Enables reusability and abstraction in code.\n- Is a key building block of functional programming in JavaScript."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of a higher-order function like a chef that doesn‚Äôt cook food directly ‚Äî it takes other chefs (functions) and tells them <em>how</em> to cook. The chef can even create a new chef recipe on the spot and hand it back to you!"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-event-bubbling-capturing",
    "title": "What is event bubbling and capturing in JavaScript?",
    "description": "Event bubbling and capturing define the order in which events propagate through the DOM. Bubbling moves upward from the target element to its ancestors, while capturing moves downward from the root to the target.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "dom",
      "events",
      "bubbling",
      "capturing",
      "event-propagation"
    ],
    "importance": 3,
    "companies": [
      "google"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nWhen an event (like a click) occurs in the DOM, it doesn‚Äôt just happen on one element. Instead, it travels through a **three-phase path**:\n\n1. **Capturing phase** ‚Äì The event travels from the root of the document down to the target element.\n2. **Target phase** ‚Äì The event occurs on the exact target element.\n3. **Bubbling phase** ‚Äì The event bubbles up from the target element back to the root."
        },
        {
          "type": "list",
          "columns": [
            "Phase",
            "Direction",
            "Triggered On",
            "Listener Option"
          ],
          "rows": [
            [
              "Capturing",
              "Top ‚Üí Down",
              "From document to target",
              "<code>addEventListener('click', handler, true)</code>"
            ],
            [
              "Target",
              "‚Äî",
              "Actual element clicked",
              "Event fires directly on target"
            ],
            [
              "Bubbling",
              "Bottom ‚Üí Up",
              "From target to document",
              "<code>addEventListener('click', handler)</code> (default)"
            ]
          ],
          "caption": "The three phases of DOM event propagation."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Example: Bubbling (Default Behavior)</strong>\n\nWhen you click on a nested element, the event first triggers on the innermost element and then moves upward to its ancestors."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<div id='parent'>\n  <button id='child'>Click Me</button>\n</div>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "document.getElementById('parent').addEventListener('click', () => {\n  console.log('Parent clicked');\n});\n\ndocument.getElementById('child').addEventListener('click', () => {\n  console.log('Child clicked');\n});"
        },
        {
          "type": "text",
          "text": "Output when you click the button:\n<pre class='md-pre'><code>Child clicked\nParent clicked</code></pre>\n\nThe event starts at the <code>button</code> (target) and bubbles up to the <code>div</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Example: Capturing Phase</strong>\n\nIf you set the third parameter of <code>addEventListener</code> to <code>true</code>, the handler will fire during the capturing phase instead of bubbling."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "document.getElementById('parent').addEventListener('click', () => {\n  console.log('Parent capturing');\n}, true);\n\ndocument.getElementById('child').addEventListener('click', () => {\n  console.log('Child clicked');\n});"
        },
        {
          "type": "text",
          "text": "Output when you click the button:\n<pre class='md-pre'><code>Parent capturing\nChild clicked</code></pre>\n\nNow the parent reacts first because the event is captured while traveling down the DOM tree."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Stopping Event Propagation</strong>\n\nYou can stop the event from moving further in either direction using:\n- <code>event.stopPropagation()</code> ‚Üí stops it from continuing up or down.\n- <code>event.stopImmediatePropagation()</code> ‚Üí also prevents other handlers on the same element from firing."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "child.addEventListener('click', e => {\n  e.stopPropagation();\n  console.log('Only child handled this.');\n});"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- The event path has three phases: capturing ‚Üí target ‚Üí bubbling.\n- Bubbling is the **default** in JavaScript.\n- You can listen in the capturing phase by passing <code>true</code> as the third argument.\n- <code>stopPropagation()</code> prevents the event from continuing.\n\nThis knowledge is crucial for efficient event handling and **event delegation** in complex UIs."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of event flow like a water drop hitting nested cups:\n- **Capturing:** The water flows from the biggest cup down to the smallest one.\n- **Target:** The drop hits the smallest cup (the clicked element).\n- **Bubbling:** The water splashes back up through the larger cups."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-call-apply-bind",
    "title": "What is the difference between call(), apply(), and bind() in JavaScript?",
    "description": "All three methods are used to control the value of `this` when calling a function. The difference is how they pass arguments and when the function is executed. These affect this-binding and performance, so test with bound handlers and avoid unnecessary allocations.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "functions",
      "this",
      "context",
      "call-apply-bind"
    ],
    "importance": 4,
    "companies": [
      "apple",
      "meta"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nIn JavaScript, functions are special objects ‚Äî they have built-in methods like <code>call()</code>, <code>apply()</code>, and <code>bind()</code> that allow you to explicitly set what <code>this</code> refers to when a function runs.\n\nThey all help you reuse a function with different objects as its <code>this</code> context."
        },
        {
          "type": "list",
          "columns": [
            "Method",
            "When It's Executed",
            "How Arguments Are Passed",
            "Return Value"
          ],
          "rows": [
            [
              "<code>call()</code>",
              "Immediately",
              "As a comma-separated list",
              "Return value of the function"
            ],
            [
              "<code>apply()</code>",
              "Immediately",
              "As an array (or array-like)",
              "Return value of the function"
            ],
            [
              "<code>bind()</code>",
              "Later (creates a new function)",
              "As a comma-separated list",
              "New function with bound context"
            ]
          ],
          "caption": "Comparison between call(), apply(), and bind()."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Example Setup</strong>\n\nLet's start with a simple function that uses <code>this</code>:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const person = { name: 'Alice' };\n\nfunction greet(greeting, punctuation) {\n  console.log(`${greeting}, ${this.name}${punctuation}`);\n}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>1. call()</strong>\n\n<code>call()</code> invokes the function immediately and passes arguments one by one."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "greet.call(person, 'Hello', '!'); // Hello, Alice!"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>2. apply()</strong>\n\n<code>apply()</code> is just like <code>call()</code>, but it takes arguments as an array."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "greet.apply(person, ['Hi', '!!']); // Hi, Alice!!"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>3. bind()</strong>\n\n<code>bind()</code> does not run the function immediately. Instead, it returns a new function with a permanently bound <code>this</code> value."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const greetAlice = greet.bind(person, 'Hey');\ngreetAlice('!!!'); // Hey, Alice!!!"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common Mistake</strong>\n\nA frequent confusion is expecting <code>bind()</code> to call the function immediately. Remember: it only returns a new function ‚Äî you have to call it manually later."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const fn = greet.bind(person, 'Hello');\nfn('!'); // Works\n// greet.bind(person, 'Hello')('!') also works"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- **call()** ‚Üí Calls immediately, arguments as a list.\n- **apply()** ‚Üí Calls immediately, arguments as an array.\n- **bind()** ‚Üí Returns a new function (call it later).\n\nAll three methods let you control what <code>this</code> refers to."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of it like renting a car:\n- <strong>call()</strong> ‚Üí You rent and drive it right away.\n- <strong>apply()</strong> ‚Üí You rent and drive it right away, but hand over your passengers list (array).\n- <strong>bind()</strong> ‚Üí You book it for later ‚Äî the car is reserved and ready to use when you need it."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Borrow a method from another object (e.g., <code>Array.prototype.slice</code>) or fix <code>this</code> in a callback.\n<br><br><strong>Common pitfalls</strong><br><ul><li>Forgetting to bind, causing <code>this</code> to be <code>undefined</code> in strict mode.</li><li>Using <code>apply</code> with very large arrays and hitting argument limits.</li><li>Binding inside render loops and creating new functions each time.</li></ul><strong>Trade-off or test tip</strong><br><code>bind</code> is clear but allocates a new function; reuse bound handlers where possible. Test by calling the function with a mocked <code>this</code>."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-foreach-vs-map",
    "title": "Can you describe the main difference between Array.forEach() and Array.map() methods and why you would pick one versus the other?",
    "description": "Both forEach() and map() loop through array elements, but map() creates and returns a new array, while forEach() simply executes a function for each element without returning anything. Map is for transforms while forEach is for side effects; test immutability and return values.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrays",
      "loops",
      "functional-programming",
      "array-methods"
    ],
    "importance": 3,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nBoth <code>forEach()</code> and <code>map()</code> are used to iterate over arrays, but they serve **different purposes**:\n\n- <strong>forEach()</strong> is for performing side effects (like logging or updating variables). It doesn‚Äôt return anything useful.\n- <strong>map()</strong> transforms data ‚Äî it creates a **new array** based on what you return in each iteration."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "<code>forEach()</code>",
            "<code>map()</code>"
          ],
          "rows": [
            [
              "Return value",
              "<code>undefined</code>",
              "New array with transformed values"
            ],
            [
              "Purpose",
              "Execute side effects (e.g., log, mutate external state)",
              "Transform data into a new array"
            ],
            [
              "Mutates original array?",
              "No (but can if you explicitly modify it)",
              "No"
            ],
            [
              "Chaining",
              "No ‚Äî returns undefined",
              "Yes ‚Äî returns a new array"
            ],
            [
              "Typical use case",
              "Logging, counters, DOM manipulation",
              "Mapping API results, converting data"
            ]
          ],
          "caption": "Differences between forEach() and map()."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Example: forEach()</strong>\n\nUsed when you want to **do something** for each element, not necessarily produce a new array."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const nums = [1, 2, 3];\nnums.forEach(n => console.log(n * 2));\n\n// Output:\n// 2\n// 4\n// 6\n// (forEach returns undefined)"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Example: map()</strong>\n\nUsed when you want to **transform** each element and keep the results in a new array."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const nums = [1, 2, 3];\nconst doubled = nums.map(n => n * 2);\n\nconsole.log(doubled); // [2, 4, 6]"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common Mistake</strong>\n\nUsing <code>map()</code> just for its side effects. Since it expects you to return something, doing so wastes performance and memory.\n\nIf you‚Äôre not using the returned array, you probably meant <code>forEach()</code>."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// ‚ùå Wrong: using map() for side effects only\nnumbers.map(n => console.log(n)); // just prints, no new array needed\n\n// ‚úÖ Correct:\nnumbers.forEach(n => console.log(n));"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- <strong>Use forEach()</strong> ‚Üí when you want to iterate and perform an action (no return).\n- <strong>Use map()</strong> ‚Üí when you want to create a new array by transforming data.\n\nIf you need chaining or data transformation, always prefer <code>map()</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nImagine sorting mail:\n- <strong>forEach()</strong> ‚Üí you open each envelope and read it.\n- <strong>map()</strong> ‚Üí you open each envelope, copy the letter, and build a new stack of letters ‚Äî the transformed result."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Transform API data into UI rows: use <code>map</code> to return a new array, and <code>forEach</code> only for side effects.<br><br><strong>Common pitfalls</strong><br><ul><li>Expecting <code>forEach</code> to return a transformed array.</li><li>Mutating the original array inside <code>map</code>.</li><li>Ignoring return values and creating unused arrays.</li></ul><strong>Trade-off or test tip</strong><br><code>map</code> is declarative but allocates a new array. Test immutability and verify return values.</strong>"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-cookie-sessionstorage-localstorage",
    "title": "Describe the difference between a cookie, sessionStorage and localStorage in browsers",
    "description": "Cookies, sessionStorage, and localStorage all store data in the browser, but they differ in size limits, expiration, and how they are sent to the server. Security and expiration differ, so choose carefully; test storage limits and cross-tab behavior.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "cookies",
      "local-storage",
      "sessionstorage",
      "storage",
      "web-apis"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nBrowsers provide several ways to store data on the client side. The three most common are:\n- <strong>Cookies</strong> ‚Äì small pieces of data sent to and from the server.\n- <strong>localStorage</strong> ‚Äì stores data persistently in the browser.\n- <strong>sessionStorage</strong> ‚Äì stores data temporarily for one browser tab session."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Cookies",
            "localStorage",
            "sessionStorage"
          ],
          "rows": [
            [
              "Lifetime",
              "Can have an expiration date or last until manually deleted",
              "Persists indefinitely until cleared",
              "Cleared when the tab or browser is closed"
            ],
            [
              "Storage limit",
              "~4KB",
              "~5‚Äì10MB",
              "~5‚Äì10MB"
            ],
            [
              "Accessible from JavaScript?",
              "Yes (unless flagged HttpOnly)",
              "Yes",
              "Yes"
            ],
            [
              "Automatically sent to server?",
              "Yes ‚Äî sent with every HTTP request to matching domain",
              "No",
              "No"
            ],
            [
              "Primary use",
              "Authentication, server sessions, user tracking",
              "Client-side caching, preferences, offline data",
              "Temporary state per tab (e.g., wizard steps)"
            ],
            [
              "Shared between tabs?",
              "Yes (same domain)",
              "Yes (same domain)",
              "No ‚Äî per tab only"
            ]
          ],
          "caption": "Comparison between cookies, localStorage, and sessionStorage."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Cookies</strong>\n\n- Can be read by both the browser and the server.\n- Often used for authentication tokens or session IDs.\n- Sent automatically with requests to matching domains.\n\n```javascript\ndocument.cookie = 'theme=dark; expires=Fri, 31 Dec 2025 23:59:59 GMT; path=/';\n```"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>localStorage</strong>\n\n- Stores data **persistently** ‚Äî it remains even after closing the browser.\n- Only accessible through JavaScript (never sent to the server).\n\n```javascript\nlocalStorage.setItem('theme', 'dark');\nconsole.log(localStorage.getItem('theme')); // 'dark'\n```"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>sessionStorage</strong>\n\n- Works just like localStorage but is **limited to one tab**.\n- The data disappears when the tab is closed.\n\n```javascript\nsessionStorage.setItem('tab', 'checkout');\nconsole.log(sessionStorage.getItem('tab')); // 'checkout'\n```"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Security Notes</strong>\n\n- Never store sensitive data (like passwords or tokens) in localStorage or sessionStorage ‚Äî they are easily accessible by JavaScript.\n- For secure cookies, use the <code>HttpOnly</code> and <code>Secure</code> flags so they can‚Äôt be accessed via JavaScript and are only sent over HTTPS."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- **Cookies:** Small, server-aware, and often used for authentication.\n- **localStorage:** Large, persistent, and purely client-side.\n- **sessionStorage:** Temporary, tab-specific storage.\n\nChoose based on how long the data should live and whether the server needs to read it."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of them like hotel storage options:\n- **Cookies:** Front desk storage ‚Äî accessible by staff (server) and you (browser).\n- **localStorage:** Your personal locker ‚Äî data stays even if you leave and come back later.\n- **sessionStorage:** Your room table ‚Äî data disappears when you check out (close the tab)."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>You need to persist a theme preference and an auth flag, deciding between cookies and Web Storage based on security and lifetime.<br><br><strong>Common pitfalls</strong><br><ul><li>Storing sensitive tokens in <code>localStorage</code> (XSS risk).</li><li>Forgetting cookies are sent with every request.</li><li>Assuming <code>sessionStorage</code> persists across tabs.</li></ul><strong>Trade-off or test tip</strong><br>Cookies are better for server auth; Web Storage is client-only. Test storage limits and SameSite settings.</strong>"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-prototypal-inheritance",
    "title": "Explain how prototypal inheritance works in JavaScript",
    "description": "Prototypal inheritance means objects inherit from other objects via the prototype chain. Methods defined on a prototype are shared across instances, which saves memory and enables behavior reuse. Use Object.create or function prototypes to link objects without copying methods.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "prototypes",
      "inheritance",
      "oop",
      "objects"
    ],
    "importance": 5,
    "companies": [
      "google",
      "netflix",
      "apple"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nIn JavaScript, objects don‚Äôt inherit from classes (like in many other languages). Instead, they inherit directly from **other objects**. This is called <strong>prototypal inheritance</strong>.\n\nEvery object has an internal link to another object called its <strong>prototype</strong>. If you try to access a property that doesn‚Äôt exist on the object itself, JavaScript looks for it on the prototype ‚Äî and keeps going up the <strong>prototype chain</strong> until it finds it or reaches <code>null</code>."
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Description",
            "Example / Notes"
          ],
          "rows": [
            [
              "<strong>Prototype</strong>",
              "The object from which another object inherits properties.",
              "<code>Object.getPrototypeOf(obj)</code> returns it."
            ],
            [
              "<strong>Prototype Chain</strong>",
              "A chain of linked objects that JS traverses when looking up properties.",
              "Ends when reaching <code>Object.prototype</code> ‚Üí <code>null</code>."
            ],
            [
              "<strong>__proto__</strong>",
              "A reference to an object's prototype (legacy but still widely used).",
              "Equivalent to <code>Object.getPrototypeOf(obj)</code>."
            ],
            [
              "<strong>constructor.prototype</strong>",
              "Defines the prototype for all objects created by a constructor function.",
              "Used when creating objects via <code>new</code>."
            ]
          ],
          "caption": "Key concepts in JavaScript's prototypal inheritance model."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Example: Simple Inheritance</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const animal = {\n  eats: true,\n  walk() {\n    console.log('Animal walks');\n  }\n};\n\nconst dog = Object.create(animal); // dog inherits from animal\n\ndog.barks = true;\n\ndog.walk(); // 'Animal walks' (inherited)\nconsole.log(dog.eats); // true"
        },
        {
          "type": "text",
          "text": "Here‚Äôs what happens when you call <code>dog.walk()</code>:\n1. JS looks for <code>walk</code> on <code>dog</code>.\n2. It doesn‚Äôt find it, so it looks at <code>dog.__proto__</code> (which points to <code>animal</code>).\n3. Finds <code>walk</code> there and executes it."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Using constructor functions</strong>\n\nBefore ES6 classes, developers often used constructor functions to define prototypes:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.speak = function() {\n  console.log(`${this.name} makes a sound.`);\n};\n\nconst cat = new Animal('Milo');\ncat.speak(); // Milo makes a sound."
        },
        {
          "type": "text",
          "text": "All objects created using <code>new Animal()</code> share the same <code>speak()</code> method via <code>Animal.prototype</code> ‚Äî not a copy for each instance."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>ES6 class syntax</strong>\n\nES6 <code>class</code> syntax is just syntactic sugar over the same prototypal mechanism."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak() {\n    console.log(`${this.name} makes a sound.`);\n  }\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nconst rex = new Dog('Rex');\nrex.speak(); // Rex barks"
        },
        {
          "type": "text",
          "text": "Behind the scenes, <code>Dog</code> inherits from <code>Animal</code> by setting <code>Dog.prototype.__proto__ = Animal.prototype</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common Misunderstanding</strong>\n\nPrototypal inheritance doesn‚Äôt copy properties ‚Äî it links objects. If you change a method on the prototype, all objects linked to it see the change immediately."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "animal.walk = function() { console.log('Animal strolls'); };\n\ndog.walk(); // 'Animal strolls' (updated for all inheriting objects)"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Every object in JS has a prototype (except <code>Object.prototype</code>).\n- Property lookups follow the prototype chain.\n- Prototypal inheritance <strong>links</strong> objects ‚Äî it doesn‚Äôt clone them.\n- Modern <code>class</code> syntax still uses prototypes under the hood."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of it like a family tree:\n- Each child (object) can use traits from their parent (prototype).\n- If the child doesn‚Äôt have a skill, it checks if the parent does.\n- If not, it goes further up the chain ‚Äî until there‚Äôs no ancestor left."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-data-types",
    "title": "What are the various data types in JavaScript?",
    "description": "JavaScript has eight main data types: seven primitives (string, number, bigint, boolean, undefined, symbol, null) and one non-primitive type (object). Understanding which values are primitive vs object helps with comparisons, copying, and mutation behavior. This affects state updates, copying, and performance; test typeof null and array detection.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "data-types",
      "basics",
      "fundamentals",
      "primitives",
      "objects"
    ],
    "importance": 2,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\\n\\nJavaScript values fall into two main categories:\\n- **Primitive types** ‚Äî stored directly, immutable, and compared by value.\\n- **Non-primitive type** ‚Äî objects, which are mutable and compared by reference.\\n\\nThere are **8 total data types** in JavaScript (as of ES2020)."
        },
        {
          "type": "list",
          "columns": [
            "Category",
            "Data Type",
            "Description",
            "Example"
          ],
          "rows": [
            [
              "Primitive",
              "<strong>Number</strong>",
              "Represents both integers and floating-point numbers.",
              "<code>42</code>, <code>3.14</code>, <code>NaN</code>"
            ],
            [
              "Primitive",
              "<strong>String</strong>",
              "Represents text data enclosed in quotes.",
              "<code>'Hello'</code>, <code>\\\"World\\\"</code>, <code>`Hi`</code>"
            ],
            [
              "Primitive",
              "<strong>Boolean</strong>",
              "Represents true/false values.",
              "<code>true</code>, <code>false</code>"
            ],
            [
              "Primitive",
              "<strong>Undefined</strong>",
              "A variable that has been declared but not assigned a value.",
              "<code>let x; console.log(x); // undefined</code>"
            ],
            [
              "Primitive",
              "<strong>Null</strong>",
              "An intentional empty value (represents 'nothing').",
              "<code>let y = null;</code>"
            ],
            [
              "Primitive",
              "<strong>Symbol</strong>",
              "A unique and immutable value often used as object keys.",
              "<code>const id = Symbol('id');</code>"
            ],
            [
              "Primitive",
              "<strong>BigInt</strong>",
              "Used for integers larger than <code>2^53 - 1</code>.",
              "<code>12345678901234567890n</code>"
            ],
            [
              "Non-Primitive",
              "<strong>Object</strong>",
              "Used to store collections of data and more complex entities.",
              "<code>{ name: 'Alice', age: 25 }</code>"
            ]
          ],
          "caption": "JavaScript data types at a glance."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Primitives Are Immutable</strong>\\n\\nPrimitive values can‚Äôt be changed directly ‚Äî any modification creates a new value instead.\\n\\n```javascript\\nlet str = 'Hi';\\nstr[0] = 'Y'; // ‚ùå has no effect\\nconsole.log(str); // 'Hi'\\n```"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Objects Are Mutable</strong>\\n\\nObjects, arrays, and functions can be modified because they are stored by reference."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const user = { name: 'Alice' };\\nconst ref = user;\\nref.name = 'Bob';\\nconsole.log(user.name); // 'Bob' (same reference)"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common Confusion</strong>\\n\\n<code>typeof null</code> returns <code>'object'</code> ‚Äî this is a well-known JavaScript quirk kept for backward compatibility."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log(typeof null); // 'object'"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- **Primitive types (7):** Number, String, Boolean, Undefined, Null, Symbol, BigInt.\n- **Non-primitive type (1):** Object.\n\nEverything else in JavaScript (arrays, functions, dates, regex, etc.) is an object."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of primitives as single paper notes ‚Äî once written, they can‚Äôt be changed. Objects are like folders ‚Äî you can add, remove, or edit their contents anytime."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>An API returns mixed values; you need to detect primitives vs objects before cloning or updating state.<br><br><strong>Common pitfalls</strong><br><ul><li>Assuming <code>typeof null</code> is \"object\" for valid checks.</li><li>Treating arrays as plain objects without <code>Array.isArray</code>.</li><li>Mutating objects when you meant to copy.</li></ul><strong>Trade-off or test tip</strong><br>Primitives are predictable, objects are flexible but mutable. Test <code>typeof</code>, <code>Array.isArray</code>, and reference equality.</strong>"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-nan-property",
    "title": "What is the NaN property in JavaScript?",
    "description": "NaN stands for Not-a-Number and is the only value in JavaScript that is not equal to itself. Use Number.isNaN to check for it reliably, because global isNaN coerces values. This is important for numeric validation and edge cases. Edge cases include empty strings and non-numeric input; test with Number.isNaN.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "global-object",
      "isnan",
      "nan",
      "numbers",
      "type-coercion"
    ],
    "importance": 2,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\n<code>NaN</code> stands for <strong>Not-a-Number</strong>. It is a special numeric value that represents the result of an invalid mathematical operation ‚Äî something that cannot produce a meaningful number."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log(0 / 0);         // NaN\nconsole.log(parseInt('Hi'));  // NaN\nconsole.log(Math.sqrt(-1));   // NaN"
        },
        {
          "type": "list",
          "columns": [
            "Property",
            "Description",
            "Example"
          ],
          "rows": [
            [
              "<strong>Type</strong>",
              "The type of <code>NaN</code> is actually <code>number</code>.",
              "<code>typeof NaN // 'number'</code>"
            ],
            [
              "<strong>Equality</strong>",
              "<code>NaN</code> is the only value in JavaScript that is <strong>not equal to itself</strong>.",
              "<code>NaN === NaN // false</code>"
            ],
            [
              "<strong>Check</strong>",
              "Use <code>Number.isNaN()</code> to check if a value is truly NaN.",
              "<code>Number.isNaN(NaN) // true</code>"
            ]
          ],
          "caption": "Key characteristics of NaN in JavaScript."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Why not just 'isNaN'?</strong>\n\nThe global <code>isNaN()</code> function tries to coerce values before checking, which can give confusing results. Always prefer <code>Number.isNaN()</code> because it doesn‚Äôt perform type coercion."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "isNaN('Hello');         // true ‚ùå (string coerced)\nNumber.isNaN('Hello');   // false ‚úÖ"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- <code>NaN</code> represents 'Not-a-Number' but its type is actually <code>number</code>.\n- It results from invalid numeric operations.\n- It‚Äôs the only value in JS that is not equal to itself.\n- Use <code>Number.isNaN()</code> instead of <code>isNaN()</code> to check safely."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of <code>NaN</code> like a 'broken calculator' output ‚Äî the operation ran, but the result doesn‚Äôt make mathematical sense, so JavaScript gives you NaN instead of crashing."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A numeric input can return <code>''</code> or <code>'foo'</code>; you need to detect NaN before calculations.\n<br><br><strong>Common pitfalls</strong><br><ul><li>Using global <code>isNaN</code>, which coerces values.</li><li>Assuming <code>NaN === NaN</code> is true.</li><li>Mixing <code>parseInt</code> and <code>Number</code> without checks.</li></ul><strong>Trade-off or test tip</strong><br>Prefer <code>Number.isNaN</code> for accuracy. Test empty strings, <code>null</code>, and non-numeric inputs.</strong>"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-currying",
    "title": "What is currying in JavaScript?",
    "description": "Currying is a functional programming technique in JavaScript where a function is transformed into a sequence of functions, each taking a single argument. Trade-offs include readability vs reuse, so test partial application and edge cases.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "currying",
      "functional-programming",
      "closure",
      "functions"
    ],
    "importance": 3,
    "companies": [
      "google"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nCurrying transforms a function that takes multiple arguments into a chain of functions, each taking one argument at a time. It allows partial application ‚Äî creating new functions by pre-filling some arguments."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Normal function\nfunction add(a, b, c) {\n  return a + b + c;\n}\n\n// Curried version\nfunction curriedAdd(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\nconsole.log(curriedAdd(2)(3)(4)); // 9"
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Explanation",
            "Example"
          ],
          "rows": [
            [
              "Partial Application",
              "You can call a curried function one step at a time and reuse intermediate results.",
              "<code>const add5 = curriedAdd(5);<br>add5(2)(3); // 10</code>"
            ],
            [
              "Function Composition",
              "Currying makes it easier to build reusable pipelines of small functions.",
              "<code>const multiply = a => b => a * b;<br>const double = multiply(2);<br>double(10); // 20</code>"
            ],
            [
              "Closures in Action",
              "Each inner function 'remembers' the outer function‚Äôs arguments through closure.",
              "<code>curriedAdd(1)(2)(3); // Works because of lexical scope</code>"
            ]
          ],
          "caption": "Key benefits and characteristics of currying."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Modern Short Syntax</strong>\n\nYou can write curried functions using arrow functions for brevity:\n\n```javascript\nconst add = a => b => c => a + b + c;\n\nconsole.log(add(1)(2)(3)); // 6\n```"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Currying transforms multi-argument functions into nested single-argument ones.\n- Enables partial application and functional composition.\n- Helps create reusable, modular logic in a clean, declarative way.\n- Commonly used in frameworks like React, Redux, and functional libraries like Lodash or Ramda."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of currying like a vending machine: instead of inserting all coins at once, you insert them one by one ‚Äî and after the last coin, you finally get your snack."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>You build an API client where you first fix the base URL, then inject auth, then pass endpoint params: <code>api(baseUrl)(token)(path)</code>.<br><br><strong>Common pitfalls</strong><br><ul><li>Losing <code>this</code> context when curried functions call methods.</li><li>Over-currying for simple cases, which hurts readability.</li><li>Confusing currying with default parameters or partial application.</li></ul><strong>Trade-off or test tip</strong><br>Currying improves reuse but adds layers of functions. Unit-test each partial step to ensure the right value is captured."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-callbacks",
    "title": "What are callbacks in JavaScript?",
    "description": "A callback is a function passed as an argument to another function to be executed later, often after a task is completed. Covers: async, callbacks, event loop, functions, higher order functions.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "async",
      "callbacks",
      "event-loop",
      "functions",
      "higher-order-functions"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nA <strong>callback</strong> is simply a function passed into another function as an argument, to be <em>called back</em> later when a certain task finishes. It‚Äôs a fundamental pattern in JavaScript, especially in asynchronous programming."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example: synchronous callback\nfunction greet(name) {\n  console.log('Hello, ' + name);\n}\n\nfunction processUserInput(callback) {\n  const name = 'Alice';\n  callback(name);\n}\n\nprocessUserInput(greet); // Hello, Alice"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Callbacks in Asynchronous Code</strong>\n\nCallbacks are also used to handle tasks that take time (like network requests or file loading), so the program can keep running while waiting for them to finish."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log('Start');\n\nsetTimeout(function() {\n  console.log('This runs later');\n}, 1000);\n\nconsole.log('End');\n// Output: Start ‚Üí End ‚Üí This runs later"
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Explanation",
            "Example"
          ],
          "rows": [
            [
              "Synchronous Callback",
              "Executed immediately during the function call.",
              "<code>[1,2,3].forEach(num => console.log(num));</code>"
            ],
            [
              "Asynchronous Callback",
              "Executed later, after a delay or async operation finishes.",
              "<code>fs.readFile('data.txt', callback);</code>"
            ],
            [
              "Callback Hell",
              "When many callbacks are nested inside each other, making code hard to read.",
              "<code>getData(() => getMore(() => getEvenMore()));</code>"
            ]
          ],
          "caption": "Common callback types and use cases."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- A callback is a function passed as an argument to another function.\n- Allows asynchronous and event-driven behavior.\n- Can cause 'callback hell' when deeply nested ‚Äî use Promises or async/await instead.\n- Core part of how JavaScript handles non-blocking operations."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of callbacks like leaving your phone number with someone: you don‚Äôt wait on the line ‚Äî they‚Äôll call you <em>back</em> when they‚Äôre ready."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Practical notes</strong>\n\nWatch for edge case behavior, common pitfalls, and trade-offs between clarity and performance. Mention accessibility and testing considerations when the concept affects UI output or event timing."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-arrow-functions",
    "title": "What are arrow functions in JavaScript?",
    "description": "Arrow functions are a shorter syntax for writing functions in JavaScript, introduced in ES6. They don‚Äôt have their own `this`, `arguments`, or `prototype`. Use them for callbacks, but watch edge cases with this binding and constructor usage; add tests for behavior.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "arrow-functions",
      "es6",
      "this-binding",
      "functions",
      "syntax"
    ],
    "importance": 3,
    "companies": [
      "meta"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nArrow functions provide a compact syntax for writing functions. They are especially useful for callbacks and one-liners. However, unlike regular functions, they do not have their own <code>this</code> or <code>arguments</code> binding."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Traditional function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function\nconst addArrow = (a, b) => a + b;\n\nconsole.log(addArrow(2, 3)); // 5"
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Description",
            "Example"
          ],
          "rows": [
            [
              "Shorter Syntax",
              "No need for the <code>function</code> keyword or curly braces for one-liners.",
              "<code>const double = x => x * 2;</code>"
            ],
            [
              "Implicit Return",
              "If the body has a single expression, its value is returned automatically.",
              "<code>const add = (a, b) => a + b;</code>"
            ],
            [
              "Lexical <code>this</code>",
              "Arrow functions don‚Äôt create their own <code>this</code> ‚Äî they inherit it from the surrounding scope.",
              "<code>this</code> inside arrow ‚Üí same as outside"
            ],
            [
              "No <code>arguments</code>",
              "They don‚Äôt have an <code>arguments</code> object ‚Äî use rest parameters instead.",
              "<code>const fn = (...args) => console.log(args);</code>"
            ]
          ],
          "caption": "Key differences between arrow functions and traditional functions."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Arrow functions and `this`</strong>\n\nIn regular functions, <code>this</code> depends on how the function is called. But in arrow functions, <code>this</code> is <strong>lexically bound</strong> ‚Äî it refers to the value of <code>this</code> in the outer scope."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function Counter() {\n  this.count = 0;\n  setInterval(() => {\n    this.count++;\n    console.log(this.count);\n  }, 1000);\n}\n\nnew Counter(); // Works ‚úÖ ‚Äî 'this' refers to the Counter instance"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Be careful:</strong>\n\n- You can‚Äôt use arrow functions as constructors (<code>new</code> keyword will throw an error).\n- They also don‚Äôt have their own <code>prototype</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Shorter syntax for cleaner code.\n- Lexically binds <code>this</code> and doesn‚Äôt create its own <code>arguments</code>.\n- Great for callbacks, array methods, and event handlers.\n- Avoid them when you need your own <code>this</code> or when defining class methods."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of arrow functions as assistants ‚Äî they don‚Äôt have their own <code>this</code>; they simply use their boss‚Äôs <code>this</code> from the outer scope."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Using arrow functions inside <code>map</code> or React event handlers to keep callbacks concise.<br><br><strong>Common pitfalls</strong><br><ul><li>Arrow functions do not have their own <code>this</code>, so methods relying on <code>this</code> can break.</li><li>They cannot be used as constructors with <code>new</code>.</li><li>Implicit returns can hide logic mistakes when you switch to a block body.</li></ul><strong>Trade-off or test tip</strong><br>Prefer arrows for short callbacks, but use named functions for clarity and debugging. Test both behavior and <code>this</code> binding."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-object-destructuring",
    "title": "What is Object Destructuring in JavaScript?",
    "description": "Object destructuring is a concise way to extract values from objects (or arrays) and assign them to variables using a syntax that mirrors the object‚Äôs structure. It was introduced in ES6 to make code cleaner and more readable.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "object-destructuring",
      "es6",
      "syntax",
      "variables",
      "objects"
    ],
    "importance": 3,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nObject destructuring lets you extract specific properties from an object and assign them to variables in a single line. Instead of accessing each property individually, you can unpack multiple values at once using a clear and declarative syntax."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Without destructuring\nconst user = { name: 'Alice', age: 25, city: 'Paris' };\nconst name = user.name;\nconst age = user.age;\n\n// With destructuring\nconst { name, age } = user;\n\nconsole.log(name); // 'Alice'\nconsole.log(age);  // 25"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>How it works</strong>\n\nWhen you destructure an object, JavaScript matches variable names to property keys. If a key doesn‚Äôt exist in the object, its variable will be <code>undefined</code>.\n\nYou can also rename variables, set default values, and extract nested properties ‚Äî all within the same expression."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Description",
            "Example"
          ],
          "rows": [
            [
              "Basic Destructuring",
              "Extracts properties directly into variables.",
              "<code>const { name, age } = user;</code>"
            ],
            [
              "Renaming Variables",
              "You can rename a property while destructuring.",
              "<code>const { name: userName } = user;</code>"
            ],
            [
              "Default Values",
              "Provide defaults for missing properties.",
              "<code>const { country = 'Unknown' } = user;</code>"
            ],
            [
              "Nested Destructuring",
              "Extract properties from nested objects easily.",
              "<code>const { address: { city } } = person;</code>"
            ],
            [
              "Combining with Rest",
              "Capture remaining properties using the rest operator.",
              "<code>const { name, ...details } = user;</code>"
            ]
          ],
          "caption": "Common patterns and extensions of object destructuring."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Nested and renamed destructuring example\nconst person = {\n  name: 'Bob',\n  location: { city: 'Berlin', country: 'Germany' },\n  age: 30\n};\n\nconst { name: fullName, location: { city, country } } = person;\n\nconsole.log(fullName); // Bob\nconsole.log(city);     // Berlin"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gears'></i> <strong>Destructuring in Function Parameters</strong>\n\nYou can destructure objects directly inside function parameters. This makes your functions cleaner and self-documenting, especially when handling configuration objects or API responses."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function displayUser({ name, age, city }) {\n  console.log(`${name} is ${age} years old and lives in ${city}.`);\n}\n\ndisplayUser({ name: 'Alice', age: 25, city: 'Paris' });\n// Output: Alice is 25 years old and lives in Paris."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Common Pitfalls</strong>\n\n- Variable names must match property names unless you rename them explicitly.\n- If you try to destructure <code>null</code> or <code>undefined</code>, it throws an error because they aren‚Äôt objects.\n- Always ensure the object exists before destructuring ‚Äî or use default values to avoid runtime errors."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Safe destructuring with default empty object\nconst data = null;\nconst { title = 'Untitled' } = data || {};\nconsole.log(title); // 'Untitled'"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Object destructuring allows you to unpack values from objects easily.\n- Supports renaming, default values, and nested extraction.\n- Improves code readability and reduces repetition.\n- Commonly used in React props, API data handling, and modern JS functions."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of destructuring like unpacking a suitcase: instead of taking each item one by one, you open it once and pull out exactly what you need ‚Äî all in one move."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-design-patterns",
    "title": "What do you mean by JavaScript Design Patterns?",
    "description": "JavaScript design patterns are reusable solutions to common programming problems. They provide structured approaches for organizing code, improving maintainability, scalability, and readability in both small and large applications.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "design-patterns",
      "architecture",
      "object-oriented",
      "functional-programming",
      "best-practices"
    ],
    "importance": 2,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nDesign patterns in JavaScript are tried-and-tested templates that solve recurring software design problems. They represent best practices refined by developers over years of experience and can be adapted to specific use cases. Patterns are not pieces of code you copy and paste, but concepts and structures that guide how you architect your applications."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-layer-group'></i> <strong>Why Design Patterns Matter</strong>\n\nJavaScript applications, especially large ones, often become complex with many interdependent components. Design patterns help structure this complexity by:\n- Promoting **code reusability** and **modularity**.\n- Making code easier to maintain, test, and extend.\n- Encouraging **clear communication** among developers using shared vocabulary.\n- Preventing reinventing the wheel by reusing established best practices."
        },
        {
          "type": "list",
          "columns": [
            "Category",
            "Description",
            "Examples"
          ],
          "rows": [
            [
              "<strong>Creational Patterns</strong>",
              "Deal with object creation mechanisms, trying to create objects in a way that suits the situation.",
              "<code>Singleton</code>, <code>Factory</code>, <code>Builder</code>, <code>Prototype</code>"
            ],
            [
              "<strong>Structural Patterns</strong>",
              "Explain how to compose classes or objects into larger structures while keeping flexibility.",
              "<code>Module</code>, <code>Decorator</code>, <code>Adapter</code>, <code>Facade</code>"
            ],
            [
              "<strong>Behavioral Patterns</strong>",
              "Focus on how objects communicate and cooperate with each other.",
              "<code>Observer</code>, <code>Strategy</code>, <code>Command</code>, <code>Mediator</code>"
            ]
          ],
          "caption": "The three main categories of JavaScript design patterns."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-puzzle-piece'></i> <strong>Common JavaScript Design Patterns</strong>\n\nLet‚Äôs look at a few widely used patterns in JavaScript development:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// 1. Module Pattern ‚Äî encapsulation using closures\nconst CounterModule = (function() {\n  let count = 0;\n  return {\n    increment() { count++; console.log(count); },\n    reset() { count = 0; console.log('Reset!'); }\n  };\n})();\n\nCounterModule.increment(); // 1\nCounterModule.increment(); // 2\nCounterModule.reset(); // Reset!"
        },
        {
          "type": "text",
          "text": "The **Module Pattern** helps keep variables private and exposes only the functionality you want, preventing global namespace pollution ‚Äî one of the most useful patterns in JavaScript before ES6 modules."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// 2. Singleton Pattern ‚Äî one instance shared across application\nclass AppSettings {\n  constructor() {\n    if (AppSettings.instance) return AppSettings.instance;\n    this.theme = 'dark';\n    AppSettings.instance = this;\n  }\n}\n\nconst a = new AppSettings();\nconst b = new AppSettings();\nconsole.log(a === b); // true"
        },
        {
          "type": "text",
          "text": "The **Singleton Pattern** ensures that only one instance of a class exists throughout the app ‚Äî commonly used for global state or configuration management."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// 3. Observer Pattern ‚Äî event-based communication\nclass Observable {\n  constructor() { this.subscribers = []; }\n  subscribe(fn) { this.subscribers.push(fn); }\n  notify(data) { this.subscribers.forEach(fn => fn(data)); }\n}\n\nconst newsFeed = new Observable();\nnewsFeed.subscribe(news => console.log('Breaking:', news));\nnewsFeed.notify('New JavaScript version released!');"
        },
        {
          "type": "text",
          "text": "The **Observer Pattern** enables one-to-many communication ‚Äî when one object‚Äôs state changes, all its dependents are automatically notified. It forms the foundation of event systems and frameworks like React‚Äôs state updates and RxJS observables."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gears'></i> <strong>Design Patterns and Modern Frameworks</strong>\n\nModern JavaScript libraries and frameworks implement many design patterns internally:\n- **React** uses the Observer pattern for state updates and the Composite pattern for UI trees.\n- **Angular** leverages Dependency Injection (a creational pattern) and the Module pattern.\n- **Vue** uses a reactive Observer pattern for efficient DOM reactivity.\n- **Redux** is a combination of Command, Observer, and Singleton concepts.\n\nUnderstanding these patterns helps developers reason about how frameworks work under the hood and write cleaner, more scalable code."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>When to Use Design Patterns</strong>\n\nNot every problem needs a design pattern ‚Äî overusing them can lead to unnecessary complexity. You should apply them when:\n- The same design problem occurs multiple times.\n- You want to improve code readability and reduce coupling.\n- Your codebase is growing and needs a consistent architecture.\n- Teams need a shared structure and predictable patterns."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Design patterns are reusable solutions to common programming problems.\n- They improve scalability, maintainability, and readability.\n- JavaScript uses patterns like Module, Singleton, Observer, and Factory widely.\n- Frameworks like React, Angular, and Vue are built upon these principles.\n- Apply them wisely ‚Äî patterns should simplify, not complicate, your code."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of design patterns as blueprints for building software. You don‚Äôt copy the blueprint exactly ‚Äî you adapt it to your project, knowing that others have successfully used that same design to build reliable and maintainable structures before."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-deferred-scripts",
    "title": "What is the role of deferred scripts in JavaScript?",
    "description": "Deferred scripts are JavaScript files that load in parallel with HTML parsing but execute only after the document has been fully parsed. They help improve page load performance by preventing render-blocking behavior.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "script-loading",
      "performance",
      "html",
      "defer",
      "async"
    ],
    "importance": 1,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nNormally, when the browser encounters a <code>&lt;script&gt;</code> tag during HTML parsing, it stops rendering, fetches the script, and executes it immediately before continuing. This behavior blocks the page rendering process and slows down the perceived load time.\n\nDeferred scripts solve this problem by allowing the browser to continue parsing HTML while downloading the script in the background ‚Äî executing it only after the entire document is parsed."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Regular script (blocks rendering) -->\n<script src=\"main.js\"></script>\n\n<!-- Deferred script (non-blocking) -->\n<script src=\"main.js\" defer></script>"
        },
        {
          "type": "list",
          "columns": [
            "Attribute",
            "When It Executes",
            "HTML Parsing",
            "Use Case"
          ],
          "rows": [
            [
              "<strong>No Attribute</strong>",
              "Immediately, as soon as it's downloaded.",
              "Blocks HTML parsing until execution finishes.",
              "Small scripts or inline JS that must run early."
            ],
            [
              "<strong>defer</strong>",
              "After HTML parsing completes (in order).",
              "Does not block HTML parsing.",
              "Scripts that depend on the DOM being ready."
            ],
            [
              "<strong>async</strong>",
              "As soon as it's downloaded (not ordered).",
              "Does not block HTML parsing, but order is unpredictable.",
              "Independent scripts like analytics or ads."
            ]
          ],
          "caption": "Comparison of normal, async, and deferred script loading."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gears'></i> <strong>How Deferred Scripts Work Internally</strong>\n\n1. The browser encounters a <code>&lt;script defer&gt;</code> tag while parsing HTML.\n2. It starts downloading the script in parallel with HTML parsing.\n3. The script is queued for execution after the document has been fully parsed.\n4. Deferred scripts preserve their order ‚Äî if multiple scripts are marked as <code>defer</code>, they will execute sequentially in the order they appear in the document.\n\nThis makes <code>defer</code> especially useful for including multiple dependent scripts without blocking page rendering."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Both scripts load in parallel but run after HTML parsing -->\n<script src=\"lib.js\" defer></script>\n<script src=\"app.js\" defer></script>\n<!-- Guaranteed: lib.js runs before app.js -->"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Why Deferred Scripts Are Important</strong>\n\n- They **improve performance** by eliminating render-blocking delays.\n- The **DOM is fully available** when they execute, meaning no need to wait for <code>DOMContentLoaded</code> manually.\n- **Execution order is preserved**, unlike with <code>async</code>.\n- They are **ideal for application scripts** that depend on the DOM or other scripts.\n\nDeferred scripts effectively allow your HTML, CSS, and JS to load concurrently without competing for render time."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// main.js (loaded with defer)\nconsole.log(document.readyState); // 'interactive' or 'complete'\n\nwindow.addEventListener('DOMContentLoaded', () => {\n  console.log('DOM fully parsed before script ran!');\n});"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Key Considerations</strong>\n\n- The <code>defer</code> attribute only works for **external scripts** (those with <code>src</code> attributes).\n- Inline scripts cannot use <code>defer</code>.\n- In old browsers (pre-HTML5), support for <code>defer</code> was inconsistent, but it‚Äôs now standard in all major browsers.\n- Combining <code>defer</code> and <code>async</code> on the same script is invalid ‚Äî only one behavior applies."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- <code>defer</code> allows scripts to load without blocking HTML parsing.\n- Deferred scripts execute only after the DOM is fully parsed.\n- Execution order is maintained as per their order in the document.\n- Perfect for DOM-dependent scripts or modular JavaScript bundles.\n- Leads to faster, smoother user experiences and better performance scores (like in Lighthouse)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of <code>defer</code> like scheduling a meeting after you've finished your main work ‚Äî the script is downloaded while you‚Äôre busy, but it only executes once your workspace (HTML) is ready. It keeps everything efficient and orderly."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-classes",
    "title": "What are classes in JavaScript?",
    "description": "Classes in JavaScript are syntactic sugar over prototype-based inheritance. Introduced in ES6, they provide a cleaner and more familiar syntax for creating objects and handling inheritance, making JavaScript feel more like traditional object-oriented languages.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "classes",
      "oop",
      "inheritance",
      "es6",
      "syntax"
    ],
    "importance": 3,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nJavaScript classes are templates for creating objects that encapsulate data (properties) and behavior (methods). While they resemble classes in languages like Java or C#, under the hood they still use **prototypes** ‚Äî a fundamental feature of JavaScript‚Äôs object system.\n\nThe class syntax provides a more structured, readable, and modern way to define constructor functions, methods, and inheritance."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Defining a simple class\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\nconst alice = new Person('Alice', 25);\nalice.greet(); // Hello, my name is Alice"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-layer-group'></i> <strong>How Classes Work Internally</strong>\n\n- The <code>class</code> syntax is **syntactic sugar** over constructor functions and the prototype chain.\n- Each class has a special <code>constructor()</code> method that initializes new objects.\n- Methods defined inside a class are automatically added to the prototype, not the instance.\n- This keeps memory usage efficient since all instances share the same methods."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Description",
            "Example"
          ],
          "rows": [
            [
              "Constructor",
              "A special method used for initializing objects when a class is instantiated.",
              "<code>constructor(name) { this.name = name; }</code>"
            ],
            [
              "Instance Methods",
              "Functions shared by all instances through the prototype.",
              "<code>greet() { console.log(this.name); }</code>"
            ],
            [
              "Static Methods",
              "Methods called directly on the class, not instances.",
              "<code>static info() { console.log('This is a Person class'); }</code>"
            ],
            [
              "Getters & Setters",
              "Allow controlled access to properties.",
              "<code>get age() { return this._age; }</code>"
            ]
          ],
          "caption": "Core components and features of JavaScript classes."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-code-branch'></i> <strong>Inheritance with Classes</strong>\n\nJavaScript supports class inheritance using the <code>extends</code> keyword. The child class inherits properties and methods from the parent class and can add its own. The <code>super()</code> keyword allows calling the parent‚Äôs constructor or methods."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a sound.`);\n  }\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nconst dog = new Dog('Rex');\ndog.speak(); // Rex barks."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Behind the Scenes</strong>\n\nEven though classes look new, they‚Äôre still built on top of JavaScript‚Äôs **prototype chain**:\n- Every class has a hidden <code>[[Prototype]]</code> link.\n- The class body methods are added to <code>ClassName.prototype</code>.\n- When you call a method on an instance, JavaScript looks it up through this prototype chain.\n\nThis means the following two approaches are equivalent in behavior:\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.greet = function() {\n  console.log('Hello, ' + this.name);\n};\n```\n\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  greet() {\n    console.log('Hello, ' + this.name);\n  }\n}\n```"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Important Details</strong>\n\n- Class declarations are **not hoisted** like function declarations. You must define them before using them.\n- You can define **anonymous classes** or assign them to variables.\n- By default, class methods are **non-enumerable**, meaning they don‚Äôt show up in <code>for...in</code> loops.\n- Using <code>new</code> is mandatory when instantiating classes ‚Äî calling a class as a function throws an error."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example: static method and getter\nclass MathHelper {\n  static square(n) {\n    return n * n;\n  }\n\n  get description() {\n    return 'This class provides math utilities.';\n  }\n}\n\nconsole.log(MathHelper.square(5)); // 25\nconst helper = new MathHelper();\nconsole.log(helper.description); // This class provides math utilities."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Classes define blueprints for creating objects with shared behavior.\n- They simplify working with prototypes and inheritance.\n- Support constructors, instance methods, static methods, and getters/setters.\n- Classes improve code organization and readability, making OOP patterns easier to implement in JavaScript.\n- Under the hood, they‚Äôre still prototype-based ‚Äî just easier to read and maintain."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of a class like a cookie cutter üç™ ‚Äî it defines the shape and design. Each cookie (object) made from it shares the same structure, but with its own details (property values)."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-object-creation-methods",
    "title": "In JavaScript, how many different methods can you make an object?",
    "description": "There are several ways to create objects in JavaScript ‚Äî each serving a unique purpose. From using object literals to the Object.create() method and ES6 classes, these approaches allow developers to structure data and behavior in flexible ways.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "objects",
      "oop",
      "object-creation",
      "prototypes",
      "es6"
    ],
    "importance": 2,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nJavaScript is an object-oriented language built around objects and prototypes. There isn‚Äôt just one way to create an object ‚Äî there are **multiple**, each suited to different use cases. Some are simple and declarative, while others give fine-grained control over inheritance and property configuration."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-list-ol'></i> <strong>1. Object Literal Syntax</strong>\n\nThis is the simplest and most common way to create objects in JavaScript. You directly define key-value pairs inside curly braces."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// 1. Object literal\nconst person = {\n  name: 'Alice',\n  age: 25,\n  greet() {\n    console.log(`Hello, I am ${this.name}`);\n  }\n};\n\nperson.greet(); // Hello, I am Alice"
        },
        {
          "type": "text",
          "text": "‚úÖ **When to use:** When you need a quick, simple object with fixed structure. Ideal for configurations, settings, or small data objects."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-code'></i> <strong>2. Using the <code>new Object()</code> Constructor</strong>\n\nThe <code>Object</code> constructor creates an empty object, after which you can manually add properties."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// 2. Using new Object()\nconst user = new Object();\nuser.name = 'Bob';\nuser.age = 30;\nuser.greet = function() {\n  console.log('Hi, I am ' + this.name);\n};\n\nuser.greet(); // Hi, I am Bob"
        },
        {
          "type": "text",
          "text": "‚úÖ **When to use:** Rarely used in modern code ‚Äî the object literal is cleaner and faster. But useful when creating objects dynamically in certain APIs or legacy systems."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gear'></i> <strong>3. Using a Constructor Function</strong>\n\nBefore ES6 introduced classes, constructor functions were the main way to create reusable object blueprints. You use the <code>new</code> keyword to create instances."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// 3. Constructor function\nfunction Car(make, model) {\n  this.make = make;\n  this.model = model;\n}\n\nCar.prototype.start = function() {\n  console.log(`${this.make} ${this.model} is starting...`);\n};\n\nconst car1 = new Car('Toyota', 'Corolla');\ncar1.start(); // Toyota Corolla is starting..."
        },
        {
          "type": "text",
          "text": "‚úÖ **When to use:** When you need multiple objects of the same type that share methods. It provides structure and supports prototype-based inheritance."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-building'></i> <strong>4. Using ES6 Classes</strong>\n\nClasses are syntactic sugar over constructor functions. They provide a more intuitive and readable way to define object blueprints with methods and inheritance."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// 4. Using ES6 class\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a sound.`);\n  }\n}\n\nconst dog = new Animal('Rex');\ndog.speak(); // Rex makes a sound."
        },
        {
          "type": "text",
          "text": "‚úÖ **When to use:** Perfect for creating structured, reusable object templates in modern applications. Supports clean inheritance and encapsulation."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-diagram-project'></i> <strong>5. Using Object.create()</strong>\n\n<code>Object.create()</code> allows you to create a new object and manually specify its prototype. This is extremely powerful for prototype-based inheritance and building lightweight objects."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// 5. Using Object.create()\nconst prototypeCar = {\n  start() {\n    console.log('Car started');\n  }\n};\n\nconst myCar = Object.create(prototypeCar);\nmyCar.make = 'Tesla';\nmyCar.start(); // Car started"
        },
        {
          "type": "text",
          "text": "‚úÖ **When to use:** When you need fine control over inheritance or want to create an object that directly inherits from another without using classes or constructors."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-file-code'></i> <strong>6. Using Factory Functions</strong>\n\nA factory function returns a new object each time it‚Äôs called, without using <code>new</code>. It‚Äôs simple and doesn‚Äôt rely on prototypes unless explicitly set."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// 6. Factory function\nfunction createUser(name, age) {\n  return {\n    name,\n    age,\n    greet() {\n      console.log(`Hi, I'm ${this.name}`);\n    }\n  };\n}\n\nconst user1 = createUser('Eve', 22);\nuser1.greet(); // Hi, I'm Eve"
        },
        {
          "type": "text",
          "text": "‚úÖ **When to use:** When you need simple, self-contained object creation without worrying about prototypes or class inheritance. Common in functional programming and React-style design."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-database'></i> <strong>7. Using JSON.parse()</strong>\n\nYou can create objects by parsing a JSON string, commonly used when fetching data from APIs or files."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// 7. Using JSON.parse()\nconst jsonString = '{ \"name\": \"Alice\", \"age\": 25 }';\nconst obj = JSON.parse(jsonString);\nconsole.log(obj.name); // Alice"
        },
        {
          "type": "text",
          "text": "‚úÖ **When to use:** Ideal when receiving JSON data from a server or a configuration file. It quickly transforms string data into usable JavaScript objects."
        },
        {
          "type": "list",
          "columns": [
            "Method",
            "Keyword/Function",
            "Prototype Handling",
            "Common Use Case"
          ],
          "rows": [
            [
              "Object Literal",
              "{ }",
              "Implicit (Object.prototype)",
              "Quick object creation"
            ],
            [
              "new Object()",
              "new Object()",
              "Implicit (Object.prototype)",
              "Legacy/rare use"
            ],
            [
              "Constructor Function",
              "new Function()",
              "Manual prototype linkage",
              "Reusable templates"
            ],
            [
              "ES6 Class",
              "class ...",
              "Automatic prototype linkage",
              "Structured OOP"
            ],
            [
              "Object.create()",
              "Object.create()",
              "Explicit prototype assignment",
              "Fine control over inheritance"
            ],
            [
              "Factory Function",
              "function()",
              "None unless manually added",
              "Functional, flexible object creation"
            ],
            [
              "JSON.parse()",
              "JSON.parse()",
              "Plain object (no methods)",
              "Convert API or config data"
            ]
          ],
          "caption": "Summary of all common object creation methods in JavaScript."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- JavaScript offers many ways to create objects, each with different flexibility and purpose.\n- **Object literals** are simplest, **classes and constructors** handle structure and inheritance, and **Object.create()** gives manual control.\n- **Factory functions** and **JSON parsing** fit data-driven or functional approaches.\n- Choosing the right one depends on whether you need inheritance, performance, or simplicity."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of object creation methods like different ways to build a house:\n- **Object literal:** Prefab home ‚Äî quick and easy.\n- **Constructor/Class:** Architect-designed ‚Äî reusable blueprint.\n- **Factory function:** Custom-built home ‚Äî flexible but independent.\n- **Object.create():** Extension ‚Äî built from an existing foundation.\nEach approach gives you a new home (object), but the building method depends on your needs."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-memoization",
    "title": "What is memoization in JavaScript?",
    "description": "Memoization is an optimization technique that speeds up function execution by caching previously computed results. When the same inputs occur again, the cached result is returned instantly, avoiding redundant calculations.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "memoization",
      "optimization",
      "performance",
      "functions",
      "cache"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nMemoization is a **performance optimization technique** used to make expensive function calls faster by storing (or caching) their results. The next time the function is called with the same arguments, the stored result is returned instead of recalculating it.\n\nThis technique is especially useful in **recursive computations** (like Fibonacci sequences) or **functions that are called repeatedly with identical inputs**."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Basic memoization example\nfunction memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache[key]) {\n      console.log('Fetching from cache:', key);\n      return cache[key];\n    }\n    console.log('Calculating result for:', key);\n    const result = fn(...args);\n    cache[key] = result;\n    return result;\n  };\n}\n\n// Slow recursive function (Fibonacci)\nfunction slowFib(n) {\n  if (n <= 1) return n;\n  return slowFib(n - 1) + slowFib(n - 2);\n}\n\n// Memoized version\nconst fastFib = memoize(slowFib);\n\nconsole.log(fastFib(10)); // Calculates\nconsole.log(fastFib(10)); // Returns from cache"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>How It Works</strong>\n\n1. The function is wrapped in a **higher-order function** that maintains a cache (usually an object or Map).\n2. When the function is called, the wrapper checks if the input has been seen before.\n3. If found in cache, the stored value is returned immediately.\n4. If not found, the function runs normally, stores its result in the cache, and then returns it.\n\nThe key concept: **trade space for time** ‚Äî use memory to store results and avoid unnecessary computation."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Description",
            "Example"
          ],
          "rows": [
            [
              "Purpose",
              "Reduce repeated computation by caching results.",
              "<code>fastFib(40)</code> runs almost instantly after the first call."
            ],
            [
              "Cache Key",
              "A string or serialized form of the input arguments.",
              "<code>JSON.stringify(args)</code> or using <code>Map</code>."
            ],
            [
              "Storage",
              "Typically an object or Map used as a lookup table.",
              "<code>const cache = new Map();</code>"
            ],
            [
              "Trade-off",
              "Uses extra memory but saves CPU cycles for repeated inputs.",
              "Best when function is called frequently with same parameters."
            ]
          ],
          "caption": "Memoization at a glance."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gears'></i> <strong>Memoization vs. Caching</strong>\n\nWhile both involve storing data for faster future access, **memoization** is function-specific ‚Äî it stores **function return values** based on input arguments. General caching, on the other hand, can apply to data from APIs, databases, or file systems.\n\nIn other words:\n- **Memoization** ‚Üí optimization at the **function level**.\n- **Caching** ‚Üí broader concept used in **networking, databases, or browsers**."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Using Map for better performance\nfunction memoizeMap(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = args.toString();\n    if (cache.has(key)) return cache.get(key);\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\nconst add = (a, b) => a + b;\nconst memoizedAdd = memoizeMap(add);\n\nconsole.log(memoizedAdd(2, 3)); // 5 (calculated)\nconsole.log(memoizedAdd(2, 3)); // 5 (cached)"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>When to Use and When Not To</strong>\n\n‚úÖ **Use memoization when:**\n- A function performs expensive or repetitive calculations.\n- The same inputs occur frequently.\n- The function is pure ‚Äî it always returns the same output for the same inputs.\n\nüö´ **Avoid memoization when:**\n- The input range is very large (cache will grow uncontrollably).\n- The function relies on external state or randomness.\n- The computation is cheap (the overhead of caching may outweigh benefits)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Real-World Use Cases</strong>\n\n- **React‚Äôs useMemo() and useCallback():** Prevent re-rendering by memoizing values or functions between renders.\n- **API call optimization:** Cache API responses to avoid fetching the same data multiple times.\n- **Dynamic programming:** In problems like Fibonacci, factorial, or pathfinding (e.g., Dijkstra‚Äôs algorithm), memoization avoids redundant recursive calls.\n- **Machine learning pipelines:** Memoizing preprocessing steps for repeated datasets."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example: API response caching\nasync function memoizedFetch(url) {\n  const cache = memoizedFetch.cache || (memoizedFetch.cache = {});\n  if (cache[url]) return cache[url];\n  const response = await fetch(url);\n  const data = await response.json();\n  cache[url] = data;\n  return data;\n}\n\n// First call fetches from network, second from cache\nawait memoizedFetch('https://api.example.com/data');\nawait memoizedFetch('https://api.example.com/data');"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Memoization caches function results to avoid recomputation.\n- Best for expensive, pure, and repetitive function calls.\n- Can be implemented using objects or Maps as cache stores.\n- Saves time but uses additional memory.\n- Core concept behind performance optimizations in React, Lodash, and Redux selectors."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nThink of memoization like remembering math homework answers ‚Äî once you‚Äôve solved a problem, you don‚Äôt need to redo it every time someone asks. You just recall the answer instantly."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-microtasks-vs-macrotasks",
    "title": "Microtasks vs Macrotasks in JavaScript (Event Loop Priority)",
    "description": "In each event loop turn, JavaScript runs synchronous code, then drains the entire microtask queue (e.g., Promise.then, queueMicrotask) before taking the next macrotask (e.g., setTimeout, DOM events). This priority explains why Promises run before timers and why long microtask chains can delay rendering.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "event-loop",
      "async",
      "microtasks",
      "promise",
      "timers",
      "timing",
      "performance"
    ],
    "importance": 5,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bolt'></i> <strong>Core difference</strong>\n\nBoth are ‚Äúqueued callbacks‚Äù that run <em>after</em> the current synchronous call stack finishes. The difference is <strong>priority and timing</strong>.\n\n- <strong>Microtasks</strong> run <strong>immediately after the call stack</strong> and are <strong>fully drained</strong> before anything else happens.\n- <strong>Macrotasks</strong> run <strong>one at a time</strong> on the next event loop turn, and the browser may render between macrotasks."
        },
        {
          "type": "list",
          "columns": [
            "Queue",
            "Common sources",
            "When it runs",
            "Why it matters"
          ],
          "rows": [
            [
              "<strong>Microtask queue</strong>",
              "<code>Promise.then/catch/finally</code>, <code>queueMicrotask</code>, <code>MutationObserver</code>",
              "After the current call stack, <strong>before</strong> the next macrotask and typically before rendering",
              "Higher priority: can ‚Äúcut in line‚Äù before timers/events"
            ],
            [
              "<strong>Macrotask queue</strong>",
              "<code>setTimeout</code>, <code>setInterval</code>, DOM events, message events, I/O callbacks",
              "Next event loop turn; one macrotask runs, then microtasks drain again",
              "Lets the browser breathe: rendering/input can happen between turns"
            ]
          ],
          "caption": "Microtasks are higher priority than macrotasks."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-repeat'></i> <strong>Event loop rule of thumb (browser)</strong>\n\nFor each turn:\n1) Run all synchronous code (call stack)\n2) <strong>Drain microtasks completely</strong>\n3) Run <strong>one macrotask</strong>\n4) Render (if needed) / handle UI\n5) Repeat"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log('A');\n\nsetTimeout(() => console.log('B (macrotask: timer)'), 0);\n\nPromise.resolve()\n  .then(() => console.log('C (microtask: promise)'))\n  .then(() => console.log('D (microtask: promise)'));\n\nconsole.log('E');\n\n// Output:\n// A\n// E\n// C\n// D\n// B"
        },
        {
          "type": "text",
          "text": "<strong>Interview punchline:</strong> ‚ÄúPromises run before timers because microtasks are drained before the next macrotask.‚Äù"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Common pitfall: microtasks can starve rendering</strong>\n\nBecause the microtask queue is drained completely, a long/recursive microtask chain can delay painting and make the UI feel frozen."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function starveUI() {\n  queueMicrotask(starveUI); // or Promise.resolve().then(starveUI)\n}\nstarveUI();\n\n// Result: browser can't yield to rendering/input."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-screwdriver-wrench'></i> <strong>Practical guidance</strong>\n\n- Use <strong>microtasks</strong> for ‚Äúrun right after this finishes‚Äù follow-ups (e.g., finalize state, chain promise work).\n- Use <strong>macrotasks</strong> to yield control (e.g., split heavy work so the UI can render):\n  - <code>setTimeout(fn, 0)</code> (coarse)\n  - <code>requestAnimationFrame</code> (before next paint)\n  - <code>requestIdleCallback</code> (when idle; best-effort)"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Yield so the UI can render between chunks\nfunction doChunkedWork(items, chunkSize = 200) {\n  let i = 0;\n  function runChunk() {\n    const end = Math.min(i + chunkSize, items.length);\n    for (; i < end; i++) {\n      // heavy work\n    }\n    if (i < items.length) setTimeout(runChunk, 0); // macrotask yield\n  }\n  runChunk();\n}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-server'></i> <strong>Node.js note (don‚Äôt overclaim)</strong>\n\nNode also has microtasks (Promises) and macrotask-like phases (timers, I/O, check, etc.). Microtasks are processed between phases, and <code>process.nextTick</code> has even higher priority than Promise microtasks. In interviews: keep the core browser model correct, then mention Node differences briefly if asked."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>One-sentence answer</strong>\n\n<strong>Microtasks</strong> (Promises/queueMicrotask) run <strong>immediately after the current stack</strong> and are <strong>drained fully</strong> before moving on, while <strong>macrotasks</strong> (timers/events) run <strong>one per turn</strong>, allowing the runtime/browser to render between turns."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-promise-combinators-all-allsettled-race-any",
    "title": "Promise.all vs allSettled vs race vs any (JavaScript Promise Combinators)",
    "description": "Promise combinators coordinate multiple async operations. all fails fast, allSettled always returns results, race resolves/rejects with the first settled promise, and any resolves with the first fulfilled promise (or rejects with AggregateError if all reject). Know the exact output shapes and failure behavior for interviews.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "promise",
      "async",
      "concurrency",
      "error-handling"
    ],
    "importance": 5,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The mental model</strong>\n\nAll four take an <strong>iterable of promises</strong> (values are auto-wrapped via <code>Promise.resolve</code>). The key differences are:\n\n1) <strong>What ‚Äúfinishes‚Äù the combinator</strong> (first failure? first settle? first success? all done?)\n2) <strong>What it returns</strong> (values only vs per-promise status objects)\n3) <strong>How errors behave</strong> (fail-fast vs aggregate)\n\nAlso: these combinators <strong>do not cancel</strong> the other promises; they just decide what result to produce."
        },
        {
          "type": "list",
          "columns": [
            "Combinator",
            "Resolves when...",
            "Rejects when...",
            "Resolved value shape",
            "Typical use"
          ],
          "rows": [
            [
              "<strong>Promise.all</strong>",
              "All promises <strong>fulfill</strong>",
              "Any promise <strong>rejects</strong> (fail-fast)",
              "Array of fulfillment values (in input order)",
              "All-or-nothing dependencies (e.g., load config + user + flags)"
            ],
            [
              "<strong>Promise.allSettled</strong>",
              "All promises <strong>settle</strong> (fulfilled or rejected)",
              "Never (unless input iteration throws)",
              "Array of result objects: <code>{status:'fulfilled', value}</code> or <code>{status:'rejected', reason}</code>",
              "Collect outcomes (e.g., show partial results, log failures)"
            ],
            [
              "<strong>Promise.race</strong>",
              "First promise <strong>settles</strong> and it fulfills",
              "First promise <strong>settles</strong> and it rejects",
              "The first settled value (or rejection reason)",
              "Timeouts / ‚Äúfirst response wins‚Äù"
            ],
            [
              "<strong>Promise.any</strong>",
              "First promise <strong>fulfills</strong>",
              "All promises <strong>reject</strong>",
              "The first fulfilled value; rejects with <code>AggregateError</code>",
              "Fallbacks (e.g., first successful endpoint/CDN)"
            ]
          ],
          "caption": "Cheat sheet: finish condition + error semantics."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-code'></i> <strong>Minimal examples</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const ok1 = Promise.resolve('A');\nconst ok2 = Promise.resolve('B');\nconst bad = Promise.reject(new Error('X'));\n\n// 1) all: fails fast on first rejection\nawait Promise.all([ok1, ok2]);          // -> ['A', 'B']\nawait Promise.all([ok1, bad, ok2]);     // -> rejects with Error('X')\n\n// 2) allSettled: always returns status objects\nawait Promise.allSettled([ok1, bad, ok2]);\n// -> [\n//   { status: 'fulfilled', value: 'A' },\n//   { status: 'rejected', reason: Error('X') },\n//   { status: 'fulfilled', value: 'B' }\n// ]\n\n// 3) race: first settle wins (could be reject)\nawait Promise.race([bad, ok1]);         // -> rejects (bad settles first)\nawait Promise.race([ok1, bad]);         // -> 'A'\n\n// 4) any: first fulfillment wins (ignores rejects until all reject)\nawait Promise.any([bad, ok2]);          // -> 'B'\nawait Promise.any([bad, Promise.reject('Y')]);\n// -> rejects with AggregateError (contains all reasons)"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-layer-group'></i> <strong>Important details interviewers look for</strong>\n\n1) <strong>Input order</strong>: <code>all</code> and <code>allSettled</code> keep the output array aligned with the input order, not completion order.\n\n2) <strong>Fail-fast vs keep-going</strong>:\n- <code>all</code> rejects as soon as one rejects.\n- <code>allSettled</code> waits for all.\n- <code>race</code> settles on the first settled promise (resolve or reject).\n- <code>any</code> resolves on the first fulfillment; only rejects if everything rejects.\n\n3) <strong>No cancellation</strong>: <code>Promise.all</code> rejecting does not stop the other operations. If you need cancellation, you need explicit support (e.g., <code>AbortController</code> for fetch).\n\n4) <strong>AggregateError</strong>: <code>Promise.any</code> rejects with an <code>AggregateError</code>, which bundles all rejection reasons (often via <code>error.errors</code> in many runtimes)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-stopwatch'></i> <strong>Classic pattern: timeout with race</strong>\n\nUse <code>race</code> to bound time. But remember: the original async work continues unless it‚Äôs cancellable."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function timeout(ms) {\n  return new Promise((_, reject) =>\n    setTimeout(() => reject(new Error('Timeout')), ms)\n  );\n}\n\nasync function fetchWithTimeout(url, ms, signal) {\n  // Prefer real cancellation (AbortController) when possible.\n  const fetchPromise = fetch(url, { signal });\n  return Promise.race([fetchPromise, timeout(ms)]);\n}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-network-wired'></i> <strong>Classic pattern: first successful response with any</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "async function firstHealthy(urls) {\n  return Promise.any(\n    urls.map(async (u) => {\n      const r = await fetch(u);\n      if (!r.ok) throw new Error(`${u} -> ${r.status}`);\n      return r;\n    })\n  );\n}\n\n// If all endpoints fail -> AggregateError"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>One-liners to memorize</strong>\n\n- <strong>all</strong>: ‚ÄúAll succeed or I fail fast.‚Äù\n- <strong>allSettled</strong>: ‚ÄúTell me how each one ended.‚Äù\n- <strong>race</strong>: ‚ÄúFirst one to settle decides.‚Äù\n- <strong>any</strong>: ‚ÄúFirst success wins; otherwise aggregate failure.‚Äù"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-object-create-vs-new",
    "title": "Object.create vs new in JavaScript (Prototypes, Constructors, and Inheritance)",
    "description": "Both Object.create and the new keyword create objects, but in different ways. new calls a constructor and sets up prototype + initialization, while Object.create creates a plain object with a specified prototype without running any constructor. Understanding this is key to JavaScript's prototypal inheritance.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "objects",
      "prototypes",
      "inheritance",
      "object-creation",
      "oop",
      "classes"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The core difference</strong>\n\nBoth create objects, but:\n\n- <strong><code>new</code></strong> creates an object by <strong>calling a constructor function</strong>.\n- <strong><code>Object.create</code></strong> creates an object with a <strong>given prototype</strong> <em>without calling any constructor</em>.\n\nSo the real difference is: <strong>constructor-based creation vs pure prototype-based creation</strong>."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "new Constructor()",
            "Object.create(proto)"
          ],
          "rows": [
            [
              "Calls constructor?",
              "Yes",
              "No"
            ],
            [
              "Prototype of the object",
              "Constructor.prototype",
              "Exactly <code>proto</code>"
            ],
            [
              "Can run initialization logic?",
              "Yes (inside constructor)",
              "No (unless you call a function manually)"
            ],
            [
              "Can pass arguments?",
              "Yes",
              "No (directly)"
            ],
            [
              "Typical use",
              "Class-like instantiation",
              "Pure delegation / manual prototype chains"
            ]
          ],
          "caption": "Side-by-side comparison."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gears'></i> <strong>What actually happens with <code>new</code></strong>\n\nWhen you write:\n<pre class='md-pre'>const obj = new Foo(a, b);</pre>\nJavaScript does roughly this:\n1) Create an empty object\n2) Set its <code>[[Prototype]]</code> to <code>Foo.prototype</code>\n3) Call <code>Foo</code> with <code>this = obj</code>\n4) If <code>Foo</code> returns an object, use it; otherwise return <code>obj</code>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function Foo(x) {\n  this.x = x;\n}\n\nconst a = new Foo(10);\n\n// Equivalent (simplified):\nconst a2 = {};\nObject.setPrototypeOf(a2, Foo.prototype);\nFoo.call(a2, 10);\n// return a2"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-link'></i> <strong>What <code>Object.create</code> does</strong>\n\n<code>Object.create(proto)</code> simply creates a new object whose <code>[[Prototype]]</code> is <code>proto</code>. Nothing else happens. No constructor runs. No properties are set (unless you pass a second descriptor argument)."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const proto = {\n  greet() {\n    return 'hi';\n  }\n};\n\nconst obj = Object.create(proto);\n\nobj.greet(); // 'hi'\nobj.hasOwnProperty('greet'); // false (comes from prototype)"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Important interview traps</strong>\n\n1) <strong><code>Object.create(null)</code></strong> creates an object with <strong>no prototype</strong>. It does not inherit from <code>Object.prototype</code>. No <code>toString</code>, no <code>hasOwnProperty</code>. Useful for pure dictionaries / maps.\n\n2) <strong>Forgetting initialization</strong>: With <code>Object.create</code>, if you need state, you must set it manually or call an init function.\n\n3) <strong><code>class</code> is just syntax sugar</strong>: <code>class A {}</code> still uses <code>new</code> and prototypes under the hood."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-sitemap'></i> <strong>Inheritance patterns</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Using new (constructor/class style)\nfunction Animal(name) {\n  this.name = name;\n}\nAnimal.prototype.speak = function () {\n  return this.name + ' makes a noise';\n};\n\nfunction Dog(name) {\n  Animal.call(this, name); // init\n}\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n\nconst d1 = new Dog('Rex');\n\n// Using pure delegation (Object.create style)\nconst animal = {\n  speak() {\n    return this.name + ' makes a noise';\n  }\n};\n\nconst dog = Object.create(animal);\ndog.name = 'Rex';"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-scale-balanced'></i> <strong>When should you use which?</strong>\n\n- Use <strong><code>new</code> / <code>class</code></strong> when:\n  - You want a clear construction step\n  - You need arguments + validation + setup logic\n  - You follow a class-like domain model\n\n- Use <strong><code>Object.create</code></strong> when:\n  - You want <strong>pure prototype delegation</strong>\n  - You want to avoid constructor side effects\n  - You want special objects like <code>Object.create(null)</code>\n  - You are building lightweight objects that just delegate behavior"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>One-sentence answer</strong>\n\n<strong><code>new</code></strong> creates an object by <strong>running a constructor and wiring its prototype</strong>, while <strong><code>Object.create</code></strong> creates an object with a <strong>specified prototype only</strong>, without calling any constructor."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-prototype-vs-__proto__",
    "title": "prototype vs __proto__ in JavaScript (Prototype Chain, new, and Object.getPrototypeOf)",
    "description": "prototype is a property on constructor functions that becomes the [[Prototype]] of instances created with new. __proto__ is the (legacy) accessor for an object's [[Prototype]] link used for property lookup. Mastering this distinction explains inheritance, the prototype chain, and why obj.__proto__ === Foo.prototype after new Foo().",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "prototypes",
      "objects",
      "inheritance",
      "oop",
      "object-creation"
    ],
    "importance": 4,
    "companies": [
      "apple"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bullseye'></i> <strong>High-signal answer (what interviewers want)</strong>\n\n- <strong><code>prototype</code></strong> is a property on <strong>functions</strong> (constructors). It‚Äôs the object that instances created with <code>new</code> will delegate to.\n- <strong><code>__proto__</code></strong> is the <strong>legacy accessor</strong> for an object‚Äôs internal <strong><code>[[Prototype]]</code></strong> link (the real prototype chain pointer).\n\nThey connect via <code>new</code>: <strong><code>Object.getPrototypeOf(obj) === Foo.prototype</code></strong>."
        },
        {
          "type": "list",
          "columns": [
            "Name",
            "Belongs to",
            "Meaning",
            "Use in practice"
          ],
          "rows": [
            [
              "<strong><code>Foo.prototype</code></strong>",
              "Constructor function <code>Foo</code>",
              "The object used as the prototype for instances created by <code>new Foo()</code>",
              "Put shared methods here (or use <code>class</code>)"
            ],
            [
              "<strong><code>obj.__proto__</code></strong> (aka <code>[[Prototype]]</code>)",
              "Any object <code>obj</code>",
              "The actual prototype link used during property lookup",
              "Prefer <code>Object.getPrototypeOf</code>/<code>Object.setPrototypeOf</code>"
            ]
          ],
          "caption": "prototype is on functions; __proto__/[[Prototype]] is on objects."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gears'></i> <strong>The bridge: what <code>new</code> does</strong>\n\nWhen you run:\n<pre class='md-pre'>const obj = new Foo()</pre>\nJavaScript (roughly) does:\n1) Create a new empty object\n2) Set its <code>[[Prototype]]</code> to <code>Foo.prototype</code>\n3) Call <code>Foo</code> with <code>this = obj</code>\n\nThat step #2 is why the two terms show up together in explanations."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function Foo() {}\nFoo.prototype.sayHi = function () { return 'hi'; };\n\nconst obj = new Foo();\n\nobj.sayHi(); // 'hi'\n\n// Canonical checks (prefer these):\nObject.getPrototypeOf(obj) === Foo.prototype; // true\n\n// Legacy accessor (works, but prefer getPrototypeOf):\nobj.__proto__ === Foo.prototype; // true"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-search'></i> <strong>Prototype chain property lookup</strong>\n\nWhen you read <code>obj.prop</code>, the engine:\n1) Looks on <code>obj</code> itself\n2) If not found, follows <code>[[Prototype]]</code> to the next object\n3) Repeats until it finds the property or hits <code>null</code>\n\nThat chain is the <strong>prototype chain</strong>."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const base = { x: 1 };\nconst obj = Object.create(base);\n\nobj.x; // 1 (found on base via prototype chain)\nobj.hasOwnProperty('x'); // false (x is inherited)\nObject.getPrototypeOf(obj) === base; // true"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Top interview pitfalls</strong>\n\n1) <strong>Mixing them up</strong>\n- <code>prototype</code> is on the constructor (<code>Foo.prototype</code>)\n- <code>__proto__</code>/<code>[[Prototype]]</code> is on the instance (<code>obj</code>)\n\n2) <strong>Thinking <code>__proto__</code> is the ‚Äúofficial‚Äù API</strong>\nUse:\n- <code>Object.getPrototypeOf(obj)</code>\n- <code>Object.setPrototypeOf(obj, proto)</code>\n\n3) <strong>Forgetting functions are objects</strong>\nFunctions have <code>[[Prototype]]</code> too (so <code>Foo.__proto__</code> exists), and also have <code>Foo.prototype</code> (used for instances)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-puzzle-piece'></i> <strong>Mind-bender (explains most diagrams)</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function A() {}\n\nconst a = new A();\n\n// Instance delegates to A.prototype:\nObject.getPrototypeOf(a) === A.prototype; // true\n\n// A is a function object, so it delegates to Function.prototype:\nObject.getPrototypeOf(A) === Function.prototype; // true\n\n// A.prototype is a normal object, so it delegates to Object.prototype:\nObject.getPrototypeOf(A.prototype) === Object.prototype; // true\n\n// End of the chain:\nObject.getPrototypeOf(Object.prototype) === null; // true"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-screwdriver-wrench'></i> <strong>Practical rule</strong>\n\n- Put shared methods on <code>Foo.prototype</code> (or use <code>class Foo {}</code>).\n- Inspect prototypes with <code>Object.getPrototypeOf</code>.\n- Avoid setting prototypes at runtime unless you must (can be slow and confusing)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>One-sentence answer</strong>\n\n<strong><code>Foo.prototype</code></strong> is the object that instances created with <code>new Foo()</code> will inherit from, while <strong><code>obj.__proto__</code></strong> (aka <code>[[Prototype]]</code>) is the actual internal prototype link on <code>obj</code> used for property lookup."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-shallow-vs-deep-copy",
    "title": "Shallow Copy vs Deep Copy in JavaScript (Objects, Arrays, References)",
    "description": "A shallow copy duplicates only the top-level structure and keeps nested object references shared, while a deep copy recursively copies everything. Knowing the difference is critical to avoid accidental mutations in state management, React/Angular, and general JavaScript code.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "deep-copy",
      "clone",
      "immutability",
      "objects",
      "arrays",
      "state"
    ],
    "importance": 5,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The core idea</strong>\n\nIn JavaScript, objects and arrays are <strong>reference types</strong>. A ‚Äúcopy‚Äù can either:\n\n- <strong>Shallow copy</strong>: copy only the <strong>top-level</strong> container, but keep <strong>nested objects shared</strong>.\n- <strong>Deep copy</strong>: copy <strong>everything recursively</strong>, so no nested references are shared.\n\nMost bugs around state mutation come from <strong>thinking you made a deep copy but actually making a shallow one</strong>."
        },
        {
          "type": "list",
          "columns": [
            "Type",
            "What gets copied",
            "What stays shared",
            "Mutation risk"
          ],
          "rows": [
            [
              "<strong>Shallow copy</strong>",
              "Only the first level",
              "All nested objects/arrays/functions",
              "High (mutating nested data affects original)"
            ],
            [
              "<strong>Deep copy</strong>",
              "All levels recursively",
              "Nothing (new references everywhere)",
              "Low (copies are fully independent)"
            ]
          ],
          "caption": "The real difference is reference sharing."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-code'></i> <strong>Shallow copy examples</strong>\n\nCommon ways to make shallow copies:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const original = {\n  name: 'Alice',\n  address: { city: 'Paris' }\n};\n\n// Shallow copies:\nconst a = { ...original };           // spread\nconst b = Object.assign({}, original);\n\n// Top-level is new:\na !== original; // true\n\n// Nested object is shared:\na.address === original.address; // true\n\n// Mutating nested object affects both:\na.address.city = 'London';\nconsole.log(original.address.city); // 'London'  ‚ùó"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-code'></i> <strong>Deep copy examples</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const original = {\n  name: 'Alice',\n  address: { city: 'Paris' }\n};\n\n// 1) structuredClone (modern, correct for most cases)\nconst deep1 = structuredClone(original);\n\n// 2) JSON trick (limited!)\nconst deep2 = JSON.parse(JSON.stringify(original));\n\n// Check:\ndeep1.address === original.address; // false\n\ndeep1.address.city = 'Rome';\nconsole.log(original.address.city); // 'Paris' ‚úÖ"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Why JSON.stringify is dangerous</strong>\n\nIt <strong>silently breaks or loses</strong>:\n- <code>undefined</code>, <code>Symbol</code>, functions\n- <code>Date</code>, <code>Map</code>, <code>Set</code>, <code>RegExp</code>\n- Circular references (throws)\n\nSo it only works for <strong>plain data objects</strong>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-layer-group'></i> <strong>What about arrays?</strong>\n\nSame rules apply. <code>[...arr]</code> and <code>arr.slice()</code> are <strong>shallow</strong>."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const arr = [{ x: 1 }, { x: 2 }];\n\nconst copy = [...arr]; // shallow\n\ncopy[0].x = 999;\nconsole.log(arr[0].x); // 999 ‚ùó"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-screwdriver-wrench'></i> <strong>Where this matters in real life</strong>\n\n- React / Angular / Redux / NgRx state updates\n- Undo/redo stacks\n- Caching snapshots\n- Any place you assume ‚Äúold state‚Äù is immutable\n\nA shallow copy of a nested state tree is <strong>not enough</strong>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-scale-balanced'></i> <strong>Performance reality check</strong>\n\n- Deep copying <strong>large objects is expensive</strong>.\n- In practice, you often do <strong>structural sharing</strong>: deep copy only the path you change, keep the rest shared (like Redux/Immer).\n\nThis is why libraries like <strong>Immer</strong> exist."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>One-sentence answer</strong>\n\nA <strong>shallow copy</strong> creates a new top-level object but <strong>reuses nested references</strong>, while a <strong>deep copy</strong> <strong>recursively duplicates everything</strong> so changes in one copy never affect the other."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-map-filter-reduce",
    "title": "map vs filter vs reduce in JavaScript (Array Transformations)",
    "description": "map, filter, and reduce are the three core array transformation methods in JavaScript. map transforms each item, filter keeps some items, and reduce can build any result by accumulating values. Understanding them is essential for clean, functional-style data processing.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "arrays",
      "array-methods",
      "functional-programming",
      "filtering",
      "reduction",
      "immutability",
      "accumulators"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The mental model</strong>\n\nThese three methods are about <strong>transforming arrays without mutating them</strong>:\n\n- <strong><code>map</code></strong>: \"For every item, produce a new item.\"\n- <strong><code>filter</code></strong>: \"Keep only the items that pass a test.\"\n- <strong><code>reduce</code></strong>: \"Combine all items into a single result.\"\n\nThey are the foundation of <strong>functional-style programming</strong> in JavaScript."
        },
        {
          "type": "list",
          "columns": [
            "Method",
            "Input ‚Üí Output",
            "Callback returns",
            "Typical use"
          ],
          "rows": [
            [
              "<strong>map</strong>",
              "Array ‚Üí Array (same length)",
              "The new element",
              "Transform each element (e.g., numbers ‚Üí strings)"
            ],
            [
              "<strong>filter</strong>",
              "Array ‚Üí Array (shorter or same)",
              "<code>true</code> / <code>false</code>",
              "Select a subset (e.g., only active users)"
            ],
            [
              "<strong>reduce</strong>",
              "Array ‚Üí Any (number, object, array, map, etc.)",
              "The new accumulator",
              "Aggregate / fold data into one value"
            ]
          ],
          "caption": "Three different kinds of transformations."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-code'></i> <strong>map: transform each element</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const numbers = [1, 2, 3];\n\nconst doubled = numbers.map(n => n * 2);\n\n// [2, 4, 6]\n// Same length, new values"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-code'></i> <strong>filter: keep some elements</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const numbers = [1, 2, 3, 4, 5];\n\nconst evens = numbers.filter(n => n % 2 === 0);\n\n// [2, 4]\n// Only elements that pass the condition stay"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-code'></i> <strong>reduce: build anything</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const numbers = [1, 2, 3, 4];\n\nconst sum = numbers.reduce((acc, n) => acc + n, 0);\n\n// 10\n// acc is the running total"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-layer-group'></i> <strong>reduce can replace both (but shouldn‚Äôt always)</strong>\n\nYou can implement map and filter with reduce, but it‚Äôs usually <strong>less readable</strong>:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// map with reduce\nconst doubled2 = numbers.reduce((acc, n) => {\n  acc.push(n * 2);\n  return acc;\n}, []);\n\n// filter with reduce\nconst evens2 = numbers.reduce((acc, n) => {\n  if (n % 2 === 0) acc.push(n);\n  return acc;\n}, []);"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common mistakes</strong>\n\n1) <strong>Forgetting the initial value in <code>reduce</code></strong>: Can cause bugs with empty arrays and wrong types.\n\n2) <strong>Mutating the accumulator or items</strong>: Breaks immutability and can cause hard-to-track bugs in UI state.\n\n3) <strong>Overusing <code>reduce</code></strong>: If <code>map</code> or <code>filter</code> expresses the intent, use them."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-screwdriver-wrench'></i> <strong>Real-world examples</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const users = [\n  { id: 1, name: 'Alice', active: true },\n  { id: 2, name: 'Bob', active: false },\n  { id: 3, name: 'Carol', active: true }\n];\n\n// 1) Get names of active users\nconst activeNames = users\n  .filter(u => u.active)\n  .map(u => u.name);\n\n// ['Alice', 'Carol']\n\n// 2) Index by id (reduce ‚Üí object)\nconst byId = users.reduce((acc, u) => {\n  acc[u.id] = u;\n  return acc;\n}, {});\n\n// { '1': {...}, '2': {...}, '3': {...} }"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gauge-high'></i> <strong>Performance note</strong>\n\nChaining <code>filter().map()</code> loops twice. In <strong>hot paths</strong>, a single <code>reduce</code> can be faster. But in normal code, <strong>readability beats micro-optimizations</strong>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>One-sentence answer</strong>\n\n<strong><code>map</code></strong> transforms each element, <strong><code>filter</code></strong> selects some elements, and <strong><code>reduce</code></strong> combines all elements into a single result of any type."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-array-sort-pitfalls",
    "title": "Array.sort Pitfalls in JavaScript (Lexicographic Sorting, Mutation, Comparator)",
    "description": "Array.prototype.sort has several traps: it sorts elements as strings by default, mutates the original array, and requires a correct comparator function for numeric or custom sorting. These pitfalls cause many subtle bugs in real-world code and interviews. Sorting is in-place and lexicographic by default; test numeric comparisons and stability for performance.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "arrays",
      "sorting",
      "comparison",
      "numbers",
      "immutability",
      "array-methods"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>The big trap</strong>\n\n<strong><code>Array.prototype.sort()</code> sorts elements as <em>strings</em> by default</strong>. That means numbers are compared <strong>lexicographically</strong>, not numerically."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const nums = [1, 2, 10, 21];\n\nnums.sort();\n\nconsole.log(nums); // [1, 10, 2, 21] ‚ùó (string comparison)"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-check'></i> <strong>The correct numeric sort</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const nums = [1, 2, 10, 21];\n\nnums.sort((a, b) => a - b);\n\nconsole.log(nums); // [1, 2, 10, 21] ‚úÖ"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Pitfall #1: It mutates the original array</strong>\n\n<code>sort()</code> sorts <strong>in place</strong>. If you‚Äôre in React/Angular/Redux and expect immutability, this can silently corrupt your state."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const original = [3, 1, 2];\nconst sorted = original.sort((a, b) => a - b);\n\nconsole.log(original); // [1, 2, 3] ‚ùó mutated\nconsole.log(sorted === original); // true"
        },
        {
          "type": "text",
          "text": "<strong>Safe pattern:</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const original = [3, 1, 2];\nconst sorted = [...original].sort((a, b) => a - b);\n\nconsole.log(original); // [3, 1, 2] ‚úÖ\nconsole.log(sorted);   // [1, 2, 3]"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Pitfall #2: Wrong comparator logic</strong>\n\nThe comparator must return:\n- <strong>&lt; 0</strong> if <code>a</code> should come before <code>b</code>\n- <strong>&gt; 0</strong> if <code>a</code> should come after <code>b</code>\n- <strong>0</strong> if equal\n\nReturning <code>true</code>/<code>false</code> is a bug."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// ‚ùå Buggy comparator\narr.sort((a, b) => a > b);\n\n// ‚úÖ Correct\narr.sort((a, b) => a - b);"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-layer-group'></i> <strong>Pitfall #3: Sorting objects</strong>\n\nYou must compare a <strong>specific field</strong>:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const users = [\n  { name: 'Bob', age: 30 },\n  { name: 'Alice', age: 25 },\n  { name: 'Carol', age: 35 }\n];\n\n// By age\nusers.sort((a, b) => a.age - b.age);\n\n// By name (locale-safe)\nusers.sort((a, b) => a.name.localeCompare(b.name));"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Stability note</strong>\n\nModern JavaScript engines (ES2019+) guarantee that <code>sort</code> is <strong>stable</strong>, but older engines did not. In interviews, it‚Äôs good to mention that <strong>today it is stable by spec</strong>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>One-sentence answer</strong>\n\n<strong><code>Array.sort()</code></strong> sorts <strong>in place</strong> and compares items as <strong>strings by default</strong>, so you must clone the array for immutability and provide a <strong>correct numeric or custom comparator</strong> to avoid subtle bugs."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Sort prices or dates before rendering a table; a numeric comparator is required to avoid lexicographic order.<br><br><strong>Common pitfalls</strong><br><ul><li>Forgetting <code>sort</code> mutates the original array.</li><li>Using an inconsistent comparator that breaks ordering.</li><li>Assuming default sort is numeric.</li></ul><strong>Trade-off or test tip</strong><br>Copy before sorting to keep immutability. Test with negative numbers and verify stability for performance-sensitive lists.</strong>"
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-mutability-vs-immutability",
    "title": "Mutability vs Immutability in JavaScript (State, References, and Side Effects)",
    "description": "Mutable data can be changed in place, while immutable data is never modified ‚Äî instead, new copies are created. Understanding this difference is critical for predictable state management in React, Angular, Redux/NgRx, and for avoiding side effects and hard-to-debug bugs.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "immutability",
      "state",
      "state-management",
      "change-detection",
      "objects"
    ],
    "importance": 5,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The core difference</strong>\n\n- <strong>Mutable</strong> data can be <strong>changed in place</strong>.\n- <strong>Immutable</strong> data is <strong>never modified</strong>; instead, you <strong>create a new value</strong>.\n\nIn JavaScript, <strong>objects and arrays are mutable by default</strong>. Most bugs in UI state management come from <strong>mutating something you thought was 'a copy'</strong>."
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "What it means",
            "Example"
          ],
          "rows": [
            [
              "<strong>Mutation</strong>",
              "Changing the same object in memory",
              "<code>arr.push(1)</code>, <code>obj.x = 5</code>"
            ],
            [
              "<strong>Immutability</strong>",
              "Creating a new object instead of changing the old one",
              "<code>newArr = [...arr, 1]</code>, <code>newObj = { ...obj, x: 5 }</code>"
            ]
          ],
          "caption": "Same logical change, different memory behavior."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-code'></i> <strong>Mutation in action (the bug factory)</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const state = {\n  user: { name: 'Alice' },\n  loggedIn: true\n};\n\nconst nextState = state; // NOT a copy, same reference!\n\nnextState.user.name = 'Bob';\n\nconsole.log(state.user.name); // 'Bob' ‚ùó original is changed"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-check'></i> <strong>Immutable update (correct pattern)</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const state = {\n  user: { name: 'Alice' },\n  loggedIn: true\n};\n\nconst nextState = {\n  ...state,\n  user: {\n    ...state.user,\n    name: 'Bob'\n  }\n};\n\nconsole.log(state.user.name);    // 'Alice' ‚úÖ\nconsole.log(nextState.user.name); // 'Bob'"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-layer-group'></i> <strong>Why frameworks care so much</strong>\n\nReact, Angular (OnPush), Redux, NgRx, etc. rely heavily on <strong>reference equality</strong> checks (<code>===</code>) to detect changes.\n\nIf you mutate in place:\n- The reference stays the same\n- Change detection may <strong>not run</strong>\n- UI gets <strong>out of sync</strong>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-screwdriver-wrench'></i> <strong>Operations: mutable vs immutable</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Operation",
            "Mutable",
            "Immutable alternative"
          ],
          "rows": [
            [
              "Add to array",
              "<code>arr.push(x)</code>",
              "<code>[...arr, x]</code>"
            ],
            [
              "Remove from array",
              "<code>arr.splice(i, 1)</code>",
              "<code>arr.filter((_, idx) => idx !== i)</code>"
            ],
            [
              "Sort array",
              "<code>arr.sort()</code>",
              "<code>[...arr].sort()</code>"
            ],
            [
              "Update object field",
              "<code>obj.x = 5</code>",
              "<code>{ ...obj, x: 5 }</code>"
            ]
          ],
          "caption": "Same intent, different safety."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gauge-high'></i> <strong>Performance reality</strong>\n\n- Naive deep copying everything is <strong>slow</strong>.\n- Real-world immutable systems use <strong>structural sharing</strong>: only copy the path you change, reuse the rest.\n\nLibraries like <strong>Immer</strong> let you write ‚Äúmutating‚Äù code that produces immutable results under the hood."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Important nuance</strong>\n\nImmutability is a <strong>discipline</strong>, not a JavaScript language rule. <code>const</code> does <strong>not</strong> make objects immutable ‚Äî it only prevents reassigning the variable."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const obj = { x: 1 };\nobj.x = 2; // allowed ‚ùó"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>One-sentence answer</strong>\n\n<strong>Mutable</strong> data is changed in place, while <strong>immutable</strong> data is never modified ‚Äî instead, you create <strong>new values</strong> and keep the old ones untouched, enabling predictable state and cheap change detection."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-secure-cors-handling",
    "title": "How would you securely handle CORS issues in a frontend application?",
    "description": "Explain why CORS errors happen (Same-Origin Policy) and how to fix cross-origin requests safely: server-set Access-Control-Allow-Origin/Methods/Headers, correct preflight handling, or a backend proxy/BFF. The frontend alone cannot bypass CORS.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "cors",
      "security",
      "http",
      "headers",
      "web-apis",
      "cookies",
      "preflight",
      "same-origin",
      "proxy",
      "bff",
      "fetch"
    ],
    "importance": 4,
    "companies": [
      "netflix",
      "meta"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-shield'></i> <strong>Key principle</strong>\n\nCORS is part of the <strong>Same-Origin Policy</strong> enforced by the browser. If the API response doesn‚Äôt include the right CORS headers, the browser blocks your JavaScript from reading it. The fix is almost always <strong>server-side</strong> (or via a trusted proxy/BFF)."
        },
        {
          "type": "list",
          "columns": [
            "Frontend action",
            "What it does (and doesn‚Äôt do)"
          ],
          "rows": [
            [
              "Use same-origin URLs (call your own domain)",
              "Avoids CORS entirely if the API is served from the same origin."
            ],
            [
              "Remove custom headers / use simple requests",
              "May avoid preflight, but still won‚Äôt bypass CORS if the server disallows the origin."
            ],
            [
              "Set <code>credentials: 'include'</code>",
              "Sends cookies, but requires server to allow credentials and a specific origin."
            ],
            [
              "Use <code>mode: 'no-cors'</code>",
              "Does <strong>not</strong> fix CORS; response becomes opaque and unusable."
            ]
          ],
          "caption": "What the frontend can and cannot control"
        },
        {
          "type": "list",
          "columns": [
            "Header",
            "Purpose"
          ],
          "rows": [
            [
              "<code>Access-Control-Allow-Origin</code>",
              "Allow only trusted origins (never use <code>*</code> with credentials)."
            ],
            [
              "<code>Access-Control-Allow-Methods</code>",
              "Explicitly list allowed methods (GET, POST, etc.)."
            ],
            [
              "<code>Access-Control-Allow-Headers</code>",
              "Allow only required headers (e.g., Authorization, Content-Type)."
            ],
            [
              "<code>Access-Control-Allow-Credentials</code>",
              "Needed for cookies; requires a specific origin (not <code>*</code>)."
            ],
            [
              "<code>Access-Control-Max-Age</code>",
              "Cache preflight responses to reduce latency."
            ],
            [
              "<code>Vary: Origin</code>",
              "Prevents caches from mixing responses across origins."
            ]
          ],
          "caption": "Core CORS headers you should understand"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-route'></i> <strong>Preflight (OPTIONS) requests</strong>\n\nBrowsers send a preflight when a request is not ‚Äúsimple‚Äù (custom headers, non-GET/POST, or JSON content type). Your server must respond to <code>OPTIONS</code> with the same CORS headers or the real request will be blocked."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Express example (server-side)\napp.use((req, res, next) => {\n  const allowed = ['https://app.example.com'];\n  const origin = req.headers.origin || '';\n\n  if (allowed.includes(origin)) {\n    res.setHeader('Access-Control-Allow-Origin', origin);\n    res.setHeader('Vary', 'Origin');\n    res.setHeader('Access-Control-Allow-Credentials', 'true');\n  }\n\n  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n\n  if (req.method === 'OPTIONS') return res.sendStatus(204);\n  next();\n});"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-network-wired'></i> <strong>When you can‚Äôt change the API</strong>\n\nUse a backend proxy/BFF: your frontend calls your own server, and your server calls the third-party API. This avoids CORS, keeps API keys private, and lets you enforce auth, logging, and rate limits."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Avoid these</strong>\n\n- Disabling CORS in the browser or using extensions (not a real fix).\n- Using <code>mode: 'no-cors'</code> (opaque responses you cannot read).\n- Setting <code>Access-Control-Allow-Origin: *</code> with credentials."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Interview-ready answer</strong>\n\nYou don‚Äôt ‚Äúfix CORS‚Äù in the frontend; you configure the API (or a proxy/BFF) to allow trusted origins with the right CORS headers, handle preflight correctly, and avoid wildcard origins when credentials are involved."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "content-delivery-caching-strategies-streaming",
    "title": "How would you design caching and content delivery for a streaming platform like Netflix?",
    "description": "High-scale content platforms like Netflix rely on multiple layers of caching and content delivery strategies: browser cache, service workers, CDN edge caches, regional caches, and origin servers. The goal is to minimize latency, bandwidth, and server load while delivering large video files and metadata reliably at global scale.",
    "type": "trivia",
    "technology": "web",
    "difficulty": "hard",
    "tags": [
      "performance",
      "caching",
      "cdn",
      "http-cache",
      "service-worker",
      "streaming",
      "system-design",
      "web-performance"
    ],
    "importance": 5,
    "companies": [
      "netflix"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The big idea</strong>\n\nA streaming platform is basically a <strong>content delivery machine</strong>. The entire game is:\n\n<strong>\"How do we serve huge files to millions of users with the lowest latency and lowest cost?\"</strong>\n\nThe answer is: <strong>multi-layer caching + smart distribution</strong>.\n\nYou never want every user hitting your main servers."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-layer-group'></i> <strong>The caching layers (from closest to farthest)</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Layer",
            "What it caches",
            "Why it matters"
          ],
          "rows": [
            [
              "Browser cache",
              "Images, JS, metadata, even video segments",
              "Instant reuse, zero network cost"
            ],
            [
              "Service Worker cache",
              "App shell, API responses, some media chunks",
              "Offline support, instant loads, custom cache logic"
            ],
            [
              "CDN edge cache",
              "Video segments, images, static assets",
              "Serves content from nearest geographic location"
            ],
            [
              "Regional cache",
              "Popular content in a region",
              "Avoids hitting origin for hot content"
            ],
            [
              "Origin servers",
              "The source of truth",
              "Only hit when cache misses happen"
            ]
          ],
          "caption": "Performance improves as you serve content closer to the user."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-film'></i> <strong>How video streaming actually works</strong>\n\nNetflix-style platforms do <strong>not</strong> stream one huge video file.\n\nThey:\n- Split videos into <strong>small chunks (segments)</strong>\n- Encode them in <strong>multiple qualities</strong> (240p, 480p, 1080p, 4K...)\n- The player downloads chunks dynamically based on network speed\n\nEach chunk is:\n- A static file\n- Perfect for CDN caching\n- Reusable across millions of users"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-cloud'></i> <strong>CDN strategy (the real MVP)</strong>\n\n- Put video segments on <strong>global CDN edge servers</strong>\n- Users download from the <strong>nearest location</strong>\n- Popular content stays hot in cache\n- Cache headers like:\n  - <code>Cache-Control: public, max-age=31536000, immutable</code>\n\nResult:\n‚úÖ Ultra-low latency\n‚úÖ Massive origin offload\n‚úÖ Huge cost savings"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-desktop'></i> <strong>Client-side caching strategies</strong>\n\nOn the frontend:\n\n- Use <strong>HTTP caching</strong> for static assets & metadata\n- Use <strong>Service Workers</strong> for:\n  - App shell caching\n  - Prefetching\n  - Offline / instant reloads\n- Cache:\n  - Thumbnails\n  - Metadata responses\n  - UI bundles\n\nVideo chunks are usually left to the browser + CDN, not manually managed."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-rotate'></i> <strong>Cache invalidation (the hard part)</strong>\n\nStrategies:\n\n- Versioned URLs: <code>/movie/abc/segment-123.v3.ts</code>\n- New deploy = new URLs = old cache becomes irrelevant\n- Metadata APIs use:\n  - <code>ETag</code>\n  - <code>stale-while-revalidate</code>\n\nRule of thumb:\n<strong>Never \"update\" cached content. Change the URL.</strong>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gauge-high'></i> <strong>What you optimize for</strong>\n\n- <strong>Startup time</strong> (time to first frame)\n- <strong>Rebuffering rate</strong>\n- <strong>CDN hit ratio</strong>\n- <strong>Origin load</strong>\n- <strong>Cost per GB served</strong>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>Common mistakes</strong>\n\n- Serving video from origin directly\n- Not using immutable caching\n- Caching personalized content at CDN level\n- Trying to \"micro-manage\" video cache in JS\n- No versioning strategy"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>One-sentence interview answer</strong>\n\n\"I would use multi-layer caching: browser + service worker for app data, CDN edge caches for video segments with immutable URLs, regional caches for hot content, and keep origin servers as a last resort ‚Äî while streaming chunked, multi-bitrate video optimized for cache reuse.\""
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "debounce-vs-throttle-search-input",
    "title": "Debounce vs Throttle in JavaScript: Which One Should You Use for Search Inputs?",
    "description": "Debounce and throttle are two core JavaScript performance optimization techniques for controlling how often a function runs in response to frequent events like typing, scrolling, or resizing. A very common frontend interview question is designing a live search input: should you debounce or throttle the API call, and is 200ms a good debounce value?",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "debounce",
      "throttle",
      "performance",
      "events",
      "search",
      "user-input",
      "rate-limiting",
      "optimization",
      "frontend-interview"
    ],
    "importance": 5,
    "companies": [
      "netflix"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The real interview problem</strong>\n\nThis question is <strong>not</strong> about definitions. It's about this:\n\n<strong>\"How do you prevent expensive work from running too often when the user types?\"</strong>\n\nTyping in a search input can easily trigger <strong>10‚Äì20 events per second</strong>. Calling an API on each keystroke is wasteful, slow, and can even get you rate-limited."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-stopwatch'></i> <strong>Debounce vs Throttle ‚Äî the mental model</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Technique",
            "Mental model",
            "What it does"
          ],
          "rows": [
            [
              "Debounce",
              "\"Wait until the user stops typing\"",
              "Runs the function only after no events happened for N ms"
            ],
            [
              "Throttle",
              "\"Run at most once every N ms\"",
              "Runs the function at a fixed maximum rate"
            ]
          ],
          "caption": "Both reduce frequency, but they solve different UX problems."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-magnifying-glass'></i> <strong>Which one should you use for search?</strong>\n\nAlmost always: <strong>Debounce</strong>.\n\nWhy?\n- You only care about the <strong>final query</strong>\n- Intermediate keystrokes produce <strong>useless requests</strong>\n- Debounce waits until the user pauses, then sends <strong>one clean request</strong>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gauge-high'></i> <strong>Is 200ms a good debounce value?</strong>\n\nUsually yes ‚Äî as a <strong>starting point</strong>.\n\n- Common range: <strong>150‚Äì300ms</strong>\n- <strong>200ms</strong> often feels instant to humans\n- But still cuts request volume massively\n\nTrade-off:\n- Too small ‚Üí still spams API\n- Too big ‚Üí UI feels laggy\n\n<strong>Senior answer:</strong> \"We should measure and tune this based on UX and backend cost.\""
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-code'></i> <strong>Simple debounce implementation</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function debounce(fn, delay) {\n  let timer;\n  return function (...args) {\n    clearTimeout(timer);\n    timer = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n\nconst onSearch = debounce((query) => {\n  fetch(`/api/search?q=${query}`);\n}, 200);"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>The real-world bug: race conditions</strong>\n\nEven with debounce, this can happen:\n\n1) User searches \"rea\"\n2) Then quickly searches \"react\"\n3) The \"rea\" request returns <strong>after</strong> the \"react\" request\n4) UI shows <strong>wrong results</strong>\n\n<strong>Solution:</strong>\n- Cancel in-flight requests (AbortController)\n- Or track request IDs and ignore stale responses"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>When should you use throttle instead?</strong>\n\nThrottle is better for <strong>continuous signals</strong>:\n\n- Scroll handlers\n- Resize events\n- Mouse move / drag\n- Analytics sampling\n\nIn those cases you want <strong>regular updates</strong>, not just the final value."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-skull-crossbones'></i> <strong>Common mistakes</strong>\n\n- Using throttle for search ‚Üí sends half-baked queries\n- Debouncing too aggressively ‚Üí UI feels broken\n- Not cancelling previous requests\n- Letting stale responses overwrite fresh ones"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>One-sentence interview answer</strong>\n\n\"For search inputs I would use <strong>debounce</strong>, not throttle, because I only care about the final query ‚Äî and <strong>~200ms</strong> is a good starting point that should be tuned based on UX and backend cost, plus I‚Äôd handle request cancellation to avoid race conditions.\""
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-30"
  },
  {
    "id": "js-map-vs-object",
    "title": "What‚Äôs the difference between a Map and a plain Object in JavaScript?",
    "technology": "javascript",
    "companies": [
      "bytedance"
    ],
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Map is a dedicated key-value collection with any key type, stable iteration order, and a size property. Plain Objects are great for structured records, but keys are limited to strings/symbols and require care with prototypes and ordering.",
    "type": "trivia",
    "tags": [
      "javascript",
      "objects",
      "es6",
      "data-types",
      "keys",
      "iteration"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nUse <strong>Map</strong> when you need a true key-value collection with non-string keys and predictable iteration. Use a plain <strong>Object</strong> when modeling a fixed record with known string keys."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Map",
            "Object"
          ],
          "rows": [
            [
              "Key types",
              "Any type (objects, functions, primitives)",
              "Strings or symbols only (other types coerce)"
            ],
            [
              "Iteration order",
              "Guaranteed insertion order",
              "Mostly insertion order, but special cases for numeric keys"
            ],
            [
              "Size",
              "<code>map.size</code>",
              "No built-in size (use <code>Object.keys</code>)"
            ],
            [
              "Iteration",
              "Built-in iterators (<code>map.keys()</code>, <code>map.entries()</code>)",
              "Use <code>Object.keys/values/entries</code>"
            ],
            [
              "Prototype safety",
              "No prototype collisions",
              "Potential collisions unless created with <code>Object.create(null)</code>"
            ],
            [
              "Serialization",
              "Not JSON-serializable by default",
              "JSON-friendly for plain data"
            ]
          ],
          "caption": "Key differences between Map and Object"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const map = new Map();\nconst keyObj = { id: 1 };\nmap.set(keyObj, 'value');\n\nconst obj = {};\nobj[keyObj] = 'value';\n\nconsole.log(map.get(keyObj)); // 'value'\nconsole.log(obj); // { \"[object Object]\": \"value\" }\n"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nMap is purpose-built for dynamic key-value data with any key type and stable iteration. Objects are best for structured records and JSON-shaped data."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "http-caching-basics",
    "title": "Explain HTTP caching (Cache-Control, ETag vs Last-Modified, 304 responses)",
    "description": "Interviewers want to hear how browser caching actually works: cache-control directives, validators (ETag vs Last-Modified), conditional requests, and what a 304 means for the response body.",
    "type": "trivia",
    "technology": "web",
    "difficulty": "intermediate",
    "tags": [
      "http",
      "headers",
      "cache",
      "caching",
      "http-cache",
      "web-performance"
    ],
    "importance": 5,
    "companies": [
      "bytedance"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nHTTP caching is about letting the browser reuse responses to avoid network trips. You control it with response headers, and you validate freshness with conditional requests."
        },
        {
          "type": "list",
          "columns": [
            "Directive",
            "Meaning",
            "Typical use"
          ],
          "rows": [
            [
              "<code>max-age</code>",
              "Fresh for N seconds",
              "Static assets"
            ],
            [
              "<code>no-cache</code>",
              "Store but revalidate before use",
              "HTML pages that change often"
            ],
            [
              "<code>no-store</code>",
              "Do not store at all",
              "Sensitive data"
            ],
            [
              "<code>public</code> / <code>private</code>",
              "Cacheable by shared caches or only the browser",
              "User-specific vs shared content"
            ],
            [
              "<code>immutable</code>",
              "Never revalidate during freshness window",
              "Versioned assets"
            ]
          ],
          "caption": "Common Cache-Control directives"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>ETag vs Last-Modified</strong>\n\n- <strong>ETag</strong> is a content validator (hash or version). It is more precise and preferred when you can generate it.\n- <strong>Last-Modified</strong> is a timestamp. It is simpler but less precise (time granularity).\n\nBrowsers revalidate with <code>If-None-Match</code> (ETag) or <code>If-Modified-Since</code> (Last-Modified)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-question'></i> <strong>What is the response body of a 304?</strong>\n\nA <code>304 Not Modified</code> response has <strong>no response body</strong>. The browser reuses the cached body and only reads the headers."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nUse <code>Cache-Control</code> to define freshness, and validators (ETag/Last-Modified) for revalidation. 304 responses are header-only and tell the browser to reuse cached content."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "web-performance-optimize-load-time",
    "title": "How do you optimize a web page‚Äôs response or load time?",
    "description": "This question checks if you can reason about performance across the network, render pipeline, assets, and runtime. Interviewers expect concrete tactics like caching, compression, code splitting, and image optimization.",
    "type": "trivia",
    "technology": "web",
    "difficulty": "intermediate",
    "tags": [
      "performance",
      "web-performance",
      "optimization",
      "caching",
      "cdn",
      "images",
      "http-cache"
    ],
    "importance": 5,
    "companies": [
      "bytedance",
      "apple"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nGood answers cover multiple layers: network, caching, rendering, assets, and runtime. You should also mention measuring with Core Web Vitals or real-user metrics."
        },
        {
          "type": "list",
          "columns": [
            "Layer",
            "What to do",
            "Why it helps"
          ],
          "rows": [
            [
              "Network",
              "Use a CDN, compression (gzip/brotli), HTTP/2 or HTTP/3",
              "Reduce latency and payload size"
            ],
            [
              "Caching",
              "Set Cache-Control + ETag, version assets",
              "Avoid repeated downloads"
            ],
            [
              "JS/CSS",
              "Code split, defer scripts, inline critical CSS",
              "Reduce render blocking and main-thread work"
            ],
            [
              "Images",
              "Responsive images, modern formats, lazy loading",
              "Biggest byte savings"
            ],
            [
              "Runtime",
              "Avoid long tasks, memoize heavy work",
              "Keep the UI responsive"
            ],
            [
              "Measurement",
              "Track LCP, INP, CLS",
              "Verify impact with real metrics"
            ]
          ],
          "caption": "A complete performance answer spans the stack"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nSpeed comes from smaller payloads, smart caching, non-blocking rendering, optimized assets, and continuous measurement."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-current-trends",
    "title": "What are the current trends in JavaScript?",
    "technology": "javascript",
    "companies": [
      "bytedance"
    ],
    "difficulty": "intermediate",
    "importance": 3,
    "description": "This is a breadth check. The best answers mention a few durable themes and explain how you stay current rather than naming one library.",
    "type": "trivia",
    "tags": [
      "javascript",
      "best-practices",
      "frontend-interview",
      "performance"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nTrends shift quickly. A strong answer highlights a few broad directions and ties them to real work, then explains how you keep up with changes."
        },
        {
          "type": "list",
          "columns": [
            "Theme",
            "What it means",
            "How to mention it"
          ],
          "rows": [
            [
              "Type safety",
              "Teams want fewer runtime bugs",
              "Adoption of TypeScript and better tooling"
            ],
            [
              "ES modules everywhere",
              "Native ESM is the default",
              "Module-first builds and tree-shaking"
            ],
            [
              "Faster tooling",
              "Short feedback loops",
              "Modern bundlers and dev servers"
            ],
            [
              "Performance focus",
              "UX depends on responsiveness",
              "Core Web Vitals, code splitting"
            ],
            [
              "Framework evolution",
              "SSR/streaming/edge patterns",
              "Pick frameworks that match product needs"
            ]
          ],
          "caption": "Durable themes you can anchor on"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>How to stay current</strong>\n\nMention how you follow release notes, read RFCs, scan TC39 proposals, or track changelogs for the tools you use."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nShow breadth without name-dropping every tool. Pick a few themes, connect them to impact, and explain how you keep learning."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "ai-streaming-data-handling",
    "title": "How should a front-end handle streaming data from an AI model?",
    "technology": "web",
    "companies": [
      "openai"
    ],
    "difficulty": "intermediate",
    "importance": 4,
    "description": "This checks whether you know how to implement streaming responses (SSE/WebSocket/ReadableStream), update the UI incrementally, and handle cancellation or errors cleanly.",
    "type": "trivia",
    "tags": [
      "real-time",
      "streams",
      "streaming",
      "http",
      "api-calls",
      "error-handling"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nStreaming means you don't wait for the full response. You open a stream (SSE, WebSocket, or fetch + ReadableStream), append chunks to the UI as they arrive, and stop cleanly when the stream ends or errors."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "What happens",
            "Why it matters"
          ],
          "rows": [
            [
              "Open stream",
              "Connect via SSE/WebSocket or fetch stream",
              "Start receiving tokens immediately"
            ],
            [
              "Append chunks",
              "Update UI incrementally as data arrives",
              "Low latency UX"
            ],
            [
              "Handle errors",
              "Show retry/state on disconnect",
              "Resilience on flaky networks"
            ],
            [
              "Cancel/stop",
              "AbortController or close socket",
              "User can stop generation"
            ]
          ],
          "caption": "A minimal streaming flow"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const controller = new AbortController();\nconst res = await fetch('/api/stream', { signal: controller.signal });\nconst reader = res.body.getReader();\nconst decoder = new TextDecoder();\nlet text = '';\n\nwhile (true) {\n  const { done, value } = await reader.read();\n  if (done) break;\n  text += decoder.decode(value, { stream: true });\n  render(text); // append to UI\n}\n\n// controller.abort() to cancel\n"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nOpen a stream, append chunks to the UI, and handle cancel + errors gracefully. The UX should feel responsive even before the full response finishes."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "chat-conversation-state-management",
    "title": "How would you maintain conversation state in a chat app like ChatGPT?",
    "technology": "web",
    "companies": [
      "openai"
    ],
    "difficulty": "intermediate",
    "importance": 4,
    "description": "This probes your ability to model a conversation, manage streaming messages, and handle memory limits or truncation without breaking UX.",
    "type": "trivia",
    "tags": [
      "state-management",
      "ux",
      "real-time",
      "error-handling"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nTreat the conversation as an ordered list of message objects with stable IDs and roles (user/assistant/system). Streaming responses update a \"draft\" message until completion."
        },
        {
          "type": "list",
          "columns": [
            "What to store",
            "Example fields",
            "Why it matters"
          ],
          "rows": [
            [
              "Message list",
              "id, role, text, createdAt",
              "Stable rendering and ordering"
            ],
            [
              "Status",
              "sending, streaming, done, error",
              "Accurate UI states"
            ],
            [
              "Draft message",
              "partial text buffer",
              "Streaming UX"
            ],
            [
              "Context window",
              "summary or truncation",
              "Stay within token limits"
            ]
          ],
          "caption": "Conversation state you should model explicitly"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Common details to mention</strong>\n\n- Optimistic UI: show the user message immediately with a temporary id.\n- Streaming: append chunks to the assistant message while status = streaming.\n- Persistence: keep recent conversations in memory and optionally in localStorage/IndexedDB.\n- Truncation: summarize or trim old turns when sending context to the server."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nModel messages + status clearly, update a streaming draft in place, and handle history size with truncation or summarization."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "sse-vs-websocket-real-time",
    "title": "When would you use SSE over WebSockets for real-time updates?",
    "technology": "web",
    "companies": [
      "openai"
    ],
    "difficulty": "intermediate",
    "importance": 4,
    "description": "Interviewers want to hear trade-offs: SSE is server-to-client, simple, and great for streaming responses, while WebSockets are bidirectional and better for interactive or collaborative apps.",
    "type": "trivia",
    "tags": [
      "real-time",
      "streams",
      "streaming",
      "http"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nSSE is a simple, one-way server-to-client stream over HTTP. WebSockets are full duplex and better when the client must send frequent updates."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "SSE",
            "WebSocket"
          ],
          "rows": [
            [
              "Direction",
              "Server -> client only",
              "Bidirectional"
            ],
            [
              "Setup",
              "Simple HTTP connection",
              "WebSocket handshake"
            ],
            [
              "Best for",
              "Streaming logs, AI tokens",
              "Chat, multiplayer, collaboration"
            ],
            [
              "Reconnect",
              "Built-in (EventSource)",
              "Manual logic"
            ]
          ],
          "caption": "SSE vs WebSocket quick comparison"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>One-sentence interview answer</strong>\n\n\"Use SSE when you only need server-to-client streaming (like token-by-token AI responses). Use WebSockets when the client must send frequent real-time updates back.\""
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "ai-ux-integration-challenges",
    "title": "What UI/UX challenges arise when integrating an AI model into an app?",
    "technology": "web",
    "companies": [
      "openai"
    ],
    "difficulty": "intermediate",
    "importance": 4,
    "description": "This checks if you understand AI-specific UX constraints like latency, streaming, error handling, and unpredictable outputs.",
    "type": "trivia",
    "tags": [
      "ux",
      "error-handling",
      "performance",
      "real-time"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nAI responses are probabilistic, can be slow, and sometimes fail. The UI has to make that uncertainty feel safe and predictable."
        },
        {
          "type": "list",
          "columns": [
            "Challenge",
            "UX response",
            "Why it matters"
          ],
          "rows": [
            [
              "Latency",
              "Show streaming or \"thinking\" state",
              "Reduces perceived wait"
            ],
            [
              "Partial responses",
              "Render incrementally",
              "Feels faster and more transparent"
            ],
            [
              "Failures/timeouts",
              "Clear retry and error messaging",
              "Prevents user confusion"
            ],
            [
              "Uncertainty",
              "Provide edits, undo, or feedback",
              "Builds trust"
            ]
          ],
          "caption": "AI-specific UX concerns"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-info'></i> <strong>Extra points</strong>\n\nMention user controls like stop generation, regenerate, and showing a partial answer safely when the stream fails."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nMake uncertainty visible, keep the UI responsive during streaming, and recover gracefully from errors."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "prompt-engineering-frontend",
    "title": "What is prompt engineering, and how does it relate to frontend features?",
    "technology": "web",
    "companies": [
      "openai"
    ],
    "difficulty": "intermediate",
    "importance": 3,
    "description": "This checks if you understand that prompts are part of product design and can be influenced by frontend UX and input shaping.",
    "type": "trivia",
    "tags": [
      "ux",
      "state-management",
      "best-practices"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nPrompt engineering is the practice of structuring instructions and context so the model produces reliable outputs. Frontend UX often shapes that prompt by guiding what the user provides."
        },
        {
          "type": "list",
          "columns": [
            "Frontend feature",
            "How it affects prompts",
            "Why it helps"
          ],
          "rows": [
            [
              "Templates / presets",
              "Provide structured inputs",
              "More predictable output"
            ],
            [
              "Context selection",
              "Choose relevant files or snippets",
              "Better grounding"
            ],
            [
              "Input validation",
              "Prevent missing fields",
              "Fewer bad responses"
            ],
            [
              "Tone / style toggles",
              "Add lightweight instructions",
              "Consistent UX"
            ]
          ],
          "caption": "How frontend UX shapes prompt quality"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nPrompt engineering is not just a backend concern. Frontend design can guide inputs and context, which directly impacts output quality."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-01-31"
  },
  {
    "id": "js-queue-vs-stack",
    "title": "Stack vs Queue in JavaScript (Differences + Implementation)",
    "technology": "javascript",
    "companies": [
      "meta"
    ],
    "difficulty": "easy",
    "importance": 4,
    "description": "Explain the difference between stack (LIFO) and queue (FIFO) in JavaScript, list core operations, compare time complexity, and show clean O(1) implementations (array head index or two-stacks). Include practical use cases (call stack, BFS, task queue) and common pitfalls.",
    "type": "trivia",
    "tags": [
      "algorithms",
      "arrays"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\nA <strong>stack</strong> is <strong>LIFO</strong> (last in, first out). A <strong>queue</strong> is <strong>FIFO</strong> (first in, first out). Same elements, different removal end."
        },
        {
          "type": "text",
          "text": "<strong>When to use which</strong><br><br>\n- Stack: call stack, undo/redo, backtracking/DFS.\n- Queue: task scheduling, BFS, message processing, event loops."
        },
        {
          "type": "table",
          "title": "Operations & complexity",
          "columns": [
            "Structure",
            "Add",
            "Remove",
            "Peek",
            "Typical Big-O"
          ],
          "rows": [
            [
              "Stack",
              "push",
              "pop",
              "peek",
              "O(1)"
            ],
            [
              "Queue",
              "enqueue",
              "dequeue",
              "peek",
              "O(1) with head index"
            ]
          ]
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Stack (LIFO)\nfunction Stack() { this.items = []; }\nStack.prototype.push = function (v) { this.items.push(v); };\nStack.prototype.pop = function () { return this.items.pop(); };\nStack.prototype.peek = function () { return this.items[this.items.length - 1]; };\n\n// Queue (FIFO) with head index (O(1) dequeue)\nfunction Queue() { this.items = []; this.head = 0; }\nQueue.prototype.enqueue = function (v) { this.items.push(v); };\nQueue.prototype.dequeue = function () {\n  if (this.head >= this.items.length) return undefined;\n  const v = this.items[this.head++];\n  if (this.head > 50 && this.head * 2 > this.items.length) {\n    this.items = this.items.slice(this.head);\n    this.head = 0;\n  }\n  return v;\n};\nQueue.prototype.peek = function () { return this.items[this.head]; };"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Queue with two stacks (amortized O(1))\nfunction Queue2() { this.in = []; this.out = []; }\nQueue2.prototype.enqueue = function (v) { this.in.push(v); };\nQueue2.prototype.dequeue = function () {\n  if (this.out.length === 0) {\n    while (this.in.length) this.out.push(this.in.pop());\n  }\n  return this.out.pop();\n};"
        },
        {
          "type": "text",
          "text": "<strong>Pitfalls</strong><br><br>\n- <code>Array.shift()</code> is O(n) because it re-indexes.\n- If you use a head index, compact occasionally to avoid unbounded memory.\n- Don't mix stack/queue semantics in the same API."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Stack = LIFO, queue = FIFO.\n- Choose based on access order: last-first vs first-first.\n- Use O(1) operations with push/pop and head index (or two stacks)."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-big-o-notation",
    "title": "Big-O Notation (Time and Space Complexity)",
    "technology": "javascript",
    "companies": [
      "meta"
    ],
    "difficulty": "easy",
    "importance": 4,
    "description": "Define Big-O time and space complexity, explain why it matters for scalability, show how to derive it with rules of thumb, and list common classes. Include best/average/worst-case and amortized complexity examples.",
    "type": "trivia",
    "tags": [
      "algorithms",
      "performance",
      "runtime",
      "math"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Core Idea</strong>\n\n<strong>Big-O</strong> describes how time or space usage grows as input size <code>n</code> increases. It is an <em>upper bound</em> that focuses on the dominant growth rate and ignores constants."
        },
        {
          "type": "text",
          "text": "<strong>Time vs space</strong><br><br>\nAlways say which complexity you mean. Example: mergesort is O(n log n) time but O(n) extra space."
        },
        {
          "type": "text",
          "text": "<strong>Rules of thumb</strong><br><br>\n- Sequential steps add: O(n) + O(n) -> O(n).\n- Nested loops multiply: O(n) * O(n) -> O(n^2).\n- Drop constants/lower-order terms: O(3n + 10) -> O(n).\n- Log base does not matter in Big-O."
        },
        {
          "type": "table",
          "title": "Common time complexities",
          "columns": [
            "Big-O",
            "Name",
            "Example"
          ],
          "rows": [
            [
              "O(1)",
              "Constant",
              "Array index access"
            ],
            [
              "O(log n)",
              "Logarithmic",
              "Binary search"
            ],
            [
              "O(n)",
              "Linear",
              "Scan an array"
            ],
            [
              "O(n log n)",
              "Linearithmic",
              "Merge sort"
            ],
            [
              "O(n^2)",
              "Quadratic",
              "Nested loops"
            ],
            [
              "O(2^n)",
              "Exponential",
              "Subset generation"
            ],
            [
              "O(n!)",
              "Factorial",
              "Permutations"
            ]
          ]
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// O(n^2) nested loops\nfor (let i = 0; i < n; i++) {\n  for (let j = 0; j < n; j++) { /* work */ }\n}\n\n// O(log n) binary search\nwhile (lo <= hi) {\n  const mid = (lo + hi) >> 1;\n  if (arr[mid] === target) return mid;\n  if (arr[mid] < target) lo = mid + 1; else hi = mid - 1;\n}"
        },
        {
          "type": "text",
          "text": "<strong>Best/average/worst</strong><br><br>\nA hash map is O(1) average but can degrade to O(n) worst-case. State which case you are discussing."
        },
        {
          "type": "text",
          "text": "<strong>Amortized complexity</strong><br><br>\nDynamic array push is O(1) amortized because occasional O(n) resizes are rare."
        },
        {
          "type": "text",
          "text": "<strong>Pitfalls</strong><br><br>\n- Forgetting hidden loops (e.g., inside array methods).\n- Ignoring recursion depth or extra space.\n- Mixing average and worst-case without saying which."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- Big-O describes growth rate as input grows.\n- Use rules to derive complexity quickly.\n- Be explicit about time vs space and best/average/worst-case."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-01"
  },
  {
    "id": "js-async-race-conditions",
    "title": "Async Race Conditions and Stale UI Updates",
    "description": "When multiple async requests are in flight, they can resolve out of order and overwrite newer UI state. Explain why this happens and how to prevent stale updates with cancellation or guards.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "async",
      "concurrency",
      "cancellation",
      "abort-controller",
      "ui"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The core issue</strong>\n\nAsync calls can resolve out of order. If request A starts, then request B starts, B might finish first. When A finishes later, it can overwrite newer UI state with stale data."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "What happens"
          ],
          "rows": [
            [
              "User types 'rea'",
              "Request A is sent"
            ],
            [
              "User types 'react'",
              "Request B is sent"
            ],
            [
              "Request B returns first",
              "UI shows results for 'react'"
            ],
            [
              "Request A returns later",
              "UI is overwritten with stale 'rea' results"
            ]
          ],
          "caption": "Classic search-as-you-type race condition."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-shield'></i> <strong>How to prevent it</strong>\n\nYou need either <strong>real cancellation</strong> or a <strong>stale-result guard</strong>. Both prevent old responses from winning the race."
        },
        {
          "type": "list",
          "columns": [
            "Technique",
            "How it works",
            "Notes"
          ],
          "rows": [
            [
              "AbortController",
              "Cancel the previous request so it never resolves",
              "Best when the API supports AbortSignal (e.g., fetch)"
            ],
            [
              "Request id guard",
              "Only apply results if the id matches the latest",
              "Works even if the API cannot be cancelled"
            ],
            [
              "takeLatest / switchMap",
              "Wrap calls to auto-cancel or ignore stale results",
              "Common in RxJS or custom utilities"
            ]
          ],
          "caption": "Three reliable ways to avoid stale updates."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "let requestId = 0;\n\nasync function search(query) {\n  const id = ++requestId;\n  const res = await fetch(`/api?q=${query}`);\n  const data = await res.json();\n  if (id !== requestId) return; // stale result\n  render(data);\n}"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "let controller;\n\nasync function search(query) {\n  if (controller) controller.abort();\n  controller = new AbortController();\n  const res = await fetch(`/api?q=${query}`, { signal: controller.signal });\n  const data = await res.json();\n  render(data);\n}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Pitfalls</strong>\n\n- Promise.race does not cancel the losing promises.\n- Debounce reduces request count but does not prevent out-of-order responses.\n- Always clean up abort listeners or timers to avoid leaks."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-web-workers-basics",
    "title": "Web Workers: Off-Main-Thread JavaScript",
    "description": "Explain what Web Workers are, how message passing works (structured clone + Transferables), and the key constraints (no DOM). Include a real scenario, trade-offs (startup + message overhead), and common pitfalls like leaks or copying huge payloads.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "web-apis",
      "web-workers",
      "concurrency",
      "performance",
      "events",
      "browser"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>What is a Web Worker?</strong>\n\nA Web Worker runs JavaScript on a separate thread from the main UI thread. Use it for CPU-heavy work (parsing, compression, image processing) so the UI stays responsive and scrolling stays smooth."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bolt'></i> <strong>Real-world scenario</strong>\n\nExample: you need to parse a 50MB JSON export and compute stats while the user keeps scrolling. Doing this on the main thread will jank the UI. Offload the parsing + aggregation to a worker, then send the small result back to the UI thread."
        },
        {
          "type": "list",
          "columns": [
            "Capability",
            "Main Thread",
            "Worker"
          ],
          "rows": [
            [
              "DOM access",
              "Yes",
              "No"
            ],
            [
              "Heavy compute",
              "Blocks UI",
              "Safe (off-thread)"
            ],
            [
              "Communication",
              "postMessage/onmessage",
              "postMessage/onmessage"
            ],
            [
              "Globals",
              "window/document",
              "self (no DOM)"
            ]
          ],
          "caption": "Workers are for computation, not UI rendering."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-exchange'></i> <strong>How communication works</strong>\n\nWorkers communicate via <code>postMessage</code>. Data is copied using the <strong>structured clone</strong> algorithm, or transferred using <strong>Transferables</strong> (e.g., ArrayBuffer) to avoid expensive copies. Functions and DOM nodes cannot be cloned."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// main thread\nconst worker = new Worker('worker.js');\n\n// Transfer ArrayBuffer to avoid copy\nconst buffer = new Uint8Array([1,2,3]).buffer;\nworker.postMessage({ type: 'analyze', buffer }, [buffer]);\n\nworker.onmessage = (e) => {\n  console.log('result', e.data);\n};\n\n// worker.js\nself.onmessage = (e) => {\n  const view = new Uint8Array(e.data.buffer);\n  const sum = view.reduce((a,b) => a + b, 0);\n  self.postMessage({ sum });\n};"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-sitemap'></i> <strong>Lifecycle + error handling</strong>\n\nWorkers are long-lived by default. Terminate them when done (<code>worker.terminate()</code>) to avoid leaks. Handle errors with <code>worker.onerror</code> and <code>worker.onmessageerror</code> so failures do not silently disappear."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>When to use (and when not to)</strong>\n\nUse workers for CPU-heavy tasks or large data transforms. Avoid them for small tasks where the startup cost + message overhead outweighs the benefit. For I/O-bound work (fetching), a worker usually does not help unless you also do heavy processing on the results."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Common pitfalls interviewers look for</strong>\n\n- Forgetting that workers cannot touch the DOM.\n- Copying large payloads instead of using Transferables.\n- Spawning too many workers (startup + memory cost).\n- Not terminating workers or handling errors.\n- Assuming every API is available inside a worker (environment-dependent)."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-escape-vs-sanitize",
    "title": "Escaping vs Sanitizing: What's the Difference?",
    "description": "Explain the difference between output escaping (context-specific encoding) and sanitizing user input (allowlist filtering). Include when to use each, how they work, and why both matter for XSS prevention.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "security",
      "html",
      "strings",
      "dom",
      "best-practices"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>Big idea</strong>\n\nEscaping and sanitizing both reduce XSS risk, but they solve different problems. <strong>Escaping</strong> encodes characters so the browser treats user input as text in a specific output context. <strong>Sanitizing</strong> removes or rewrites dangerous parts of user-provided markup so some HTML can be allowed."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Escaping",
            "Sanitizing"
          ],
          "rows": [
            [
              "Primary goal",
              "Encode special characters so they render as text",
              "Allow some HTML while blocking dangerous tags/attrs"
            ],
            [
              "Input expectation",
              "Plain text",
              "HTML-like input"
            ],
            [
              "Context",
              "Context-specific (HTML text, attributes, URLs, JS, CSS)",
              "HTML context only"
            ],
            [
              "Typical tooling",
              "textContent, template auto-escaping, encoding helpers",
              "DOMPurify, browser sanitizer APIs, server allowlists"
            ],
            [
              "Failure mode",
              "Wrong encoder for the context can still allow XSS",
              "Weak allowlist can allow XSS or strip too much content"
            ]
          ],
          "caption": "Escaping encodes for a context; sanitizing filters to an allowlist."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bolt'></i> <strong>Real-world scenario</strong>\n\nA profile bio can be plain text (escape and render safely), but a blog editor might allow limited rich text (sanitize with an allowlist). Decide based on the product requirement, not convenience."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const userInput = '<img src=x onerror=alert(1) />';\n\n// Escaping (text only)\nbioEl.textContent = userInput;\n\n// Sanitizing (allow some HTML)\nbioEl.innerHTML = DOMPurify.sanitize(userInput, {\n  ALLOWED_TAGS: ['b', 'i', 'a'],\n  ALLOWED_ATTR: ['href', 'rel', 'target']\n});"
        },
        {
          "type": "list",
          "columns": [
            "Context",
            "Use",
            "Example"
          ],
          "rows": [
            [
              "HTML text",
              "textContent / template escaping",
              "el.textContent = userText"
            ],
            [
              "HTML attribute",
              "Set attributes with encoded values",
              "el.setAttribute('title', safeText)"
            ],
            [
              "URL",
              "Allowlist protocols + URL parsing",
              "new URL(input, location.origin)"
            ],
            [
              "JS string",
              "Avoid inline JS; never concatenate user input",
              "Prefer data attributes or JSON"
            ]
          ],
          "caption": "Encoding is context-specific. Use the right output channel."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Common pitfalls</strong>\n\n- Stripping tags with regex (easy to bypass).\n- Sanitizing once and reusing the result in a different context.\n- Double-escaping by encoding the same value twice.\n- Storing only sanitized HTML and losing the original data."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nEscape for the specific output context. Sanitize only when you must allow markup, and pair it with defense-in-depth like CSP and Trusted Types."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-xss-dom-sinks",
    "title": "DOM XSS: Dangerous Sinks and Safer Alternatives",
    "description": "Explain DOM-based XSS, list common untrusted sources and dangerous sinks, and show safer alternatives. Mention defense-in-depth like CSP and Trusted Types.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "security",
      "dom",
      "browser",
      "best-practices",
      "validation"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>What is DOM XSS?</strong>\n\nDOM-based XSS happens when untrusted data flows directly into a dangerous DOM sink and gets interpreted as code or markup. The attack stays entirely on the client: the server never sees it."
        },
        {
          "type": "list",
          "columns": [
            "Untrusted source",
            "Example"
          ],
          "rows": [
            [
              "URL data",
              "location.search, location.hash, document.referrer"
            ],
            [
              "Cross-window data",
              "postMessage payloads"
            ],
            [
              "Storage",
              "localStorage/sessionStorage values"
            ],
            [
              "Network data",
              "API responses that are treated as HTML"
            ]
          ],
          "caption": "Treat these sources as attacker-controlled unless validated."
        },
        {
          "type": "list",
          "columns": [
            "Risky sink",
            "Safer alternative",
            "Why"
          ],
          "rows": [
            [
              "innerHTML / outerHTML / insertAdjacentHTML",
              "textContent or createElement + append",
              "Avoids parsing attacker-controlled HTML"
            ],
            [
              "document.write",
              "DOM APIs + templates",
              "Prevents HTML injection during parse"
            ],
            [
              "eval / new Function / setTimeout(string)",
              "Function references or direct logic",
              "Blocks arbitrary code execution"
            ],
            [
              "setAttribute('href', userInput)",
              "Validate URL + allowlist protocols",
              "Blocks javascript: and data: schemes"
            ],
            [
              "srcdoc / iframe content",
              "Trusted, sanitized HTML only",
              "Iframes can execute injected markup"
            ]
          ],
          "caption": "Prefer safe DOM APIs and validate dangerous sinks."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const input = location.hash.slice(1); // attacker-controlled\n\n// Bad: interprets HTML\noutput.innerHTML = input;\n\n// Good: renders as text\noutput.textContent = input;\n\n// If you must set a URL, allowlist protocols\nconst url = new URL(input, location.origin);\nif (['http:', 'https:'].includes(url.protocol)) {\n  link.setAttribute('href', url.href);\n}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Red flags in reviews</strong>\n\n- Any direct innerHTML assignment with user data.\n- String-based timers or eval-like APIs.\n- URL assignments without protocol validation.\n- Reusing sanitized HTML in a different context (attribute/JS/CSS)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-shield'></i> <strong>Defense in depth</strong>\n\nUse CSP to limit script execution, adopt Trusted Types to block unsafe sinks, and sanitize only when you must allow rich HTML. Modern frameworks often auto-escape by default, but you can still create XSS with unsafe APIs."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nDOM XSS is about data flow: untrusted source \u2192 dangerous sink. Break the chain with safe DOM APIs, strict validation, and layered defenses."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-testing-edge-cases-strategy",
    "title": "Testing Strategy: Edge Cases and Boundaries",
    "description": "Explain how to design tests that cover boundaries, equivalence classes, invariants, and failure modes. Include a practical checklist and JavaScript-specific pitfalls.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "testing",
      "edge-cases",
      "best-practices",
      "debugging",
      "validation",
      "error-handling"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Goal</strong>\n\nA strong test strategy does not try every input. It finds the <strong>smallest set</strong> that still exposes boundary bugs, invalid inputs, and real-world failure modes. This is how you get high confidence with low test count."
        },
        {
          "type": "list",
          "columns": [
            "Core idea",
            "Why it matters",
            "Example"
          ],
          "rows": [
            [
              "Boundary values",
              "Most bugs happen at edges",
              "min-1, min, max, max+1"
            ],
            [
              "Equivalence classes",
              "Group similar inputs to reduce tests",
              "valid vs invalid formats"
            ],
            [
              "Invariants",
              "Properties that should always hold",
              "sorted output stays sorted"
            ],
            [
              "Failure modes",
              "Graceful handling of bad input",
              "null, undefined, NaN"
            ],
            [
              "Regression cases",
              "Lock in prior bugs",
              "add a test for every fix"
            ]
          ],
          "caption": "Cover the space with intent, not volume."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bolt'></i> <strong>Practical checklist</strong>\n\n1) List inputs and outputs.\n2) Identify constraints (min/max, allowed chars, allowed states).\n3) Pick boundaries and one representative per equivalence class.\n4) Add invalid and unexpected types.\n5) Add a real-world case and a worst-case case.\n6) Add regression tests for any previous bugs."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example: testing clamp(value, min, max)\nconst cases = [\n  [-1, 0, 10, 0],\n  [0, 0, 10, 0],\n  [5, 0, 10, 5],\n  [10, 0, 10, 10],\n  [11, 0, 10, 10]\n];\n\nfor (const [v, min, max, expected] of cases) {\n  expect(clamp(v, min, max)).toBe(expected);\n}\n\n// Invariant example: clamp output is always between min and max\nfor (const [v, min, max] of cases) {\n  const out = clamp(v, min, max);\n  expect(out).toBeGreaterThanOrEqual(min);\n  expect(out).toBeLessThanOrEqual(max);\n}"
        },
        {
          "type": "list",
          "columns": [
            "JavaScript pitfall",
            "Why it breaks tests",
            "What to assert"
          ],
          "rows": [
            [
              "Type coercion",
              "'0' vs 0 behave differently",
              "add explicit type tests"
            ],
            [
              "NaN",
              "NaN !== NaN",
              "use Number.isNaN"
            ],
            [
              "Floating point",
              "0.1 + 0.2 !== 0.3",
              "use toBeCloseTo"
            ],
            [
              "Empty/sparse arrays",
              "holes behave like undefined",
              "test length and iteration"
            ],
            [
              "Dates/timezones",
              "locale-dependent output",
              "assert on UTC or iso strings"
            ]
          ],
          "caption": "JavaScript-specific edge cases to call out explicitly."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Common anti-patterns</strong>\n\n- Only testing happy paths.\n- Too many tests that assert the same behavior.\n- Tests that mirror the implementation instead of the requirements.\n- Random tests without a seed (non-deterministic failures)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nDesign tests around boundaries, invariants, and failure modes. Use a small, deliberate set of cases that make bugs obvious and keep the suite fast and reliable."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-performance-profiling-workflow",
    "title": "Performance Profiling Workflow (Browser DevTools)",
    "description": "Explain a practical workflow for profiling performance in the browser: pick metrics, record traces, isolate bottlenecks, apply fixes, and verify improvements. Include what LCP, INP, and CLS mean and how to measure them.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "performance",
      "web-performance",
      "devtools",
      "debugging",
      "browser",
      "best-practices"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gauge'></i> <strong>Goal</strong>\n\nProfiling turns a vague \"the page feels slow\" into measurable bottlenecks. The best workflow is repeatable: pick a metric, capture a trace, fix the biggest issue, and verify with the same scenario."
        },
        {
          "type": "list",
          "columns": [
            "Metric",
            "What it measures",
            "Why it matters"
          ],
          "rows": [
            [
              "LCP",
              "Largest Contentful Paint",
              "Main content appears quickly"
            ],
            [
              "INP",
              "Interaction to Next Paint",
              "UI responds to user input fast"
            ],
            [
              "CLS",
              "Cumulative Layout Shift",
              "Layout stability (no unexpected jumps)"
            ]
          ],
          "caption": "Start with user-facing metrics before micro-optimizations."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "Action",
            "DevTools hint"
          ],
          "rows": [
            [
              "1. Reproduce",
              "Create a stable scenario (same route, same data)",
              "Use CPU throttling + cold cache"
            ],
            [
              "2. Record",
              "Capture a Performance trace",
              "Record interactions and mark with User Timing"
            ],
            [
              "3. Isolate",
              "Find long tasks, layout thrash, heavy scripting",
              "Look at the flame chart + Main thread"
            ],
            [
              "4. Fix",
              "Reduce or split expensive work",
              "Chunk work, debounce, memoize"
            ],
            [
              "5. Verify",
              "Re-run the same trace and compare",
              "Check LCP/INP/CLS deltas"
            ]
          ],
          "caption": "A repeatable workflow beats random tweaks."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// User Timing marks for trace analysis\nperformance.mark('render-start');\nrenderUI();\nperformance.mark('render-end');\nperformance.measure('render', 'render-start', 'render-end');\n\n// Track Web Vitals in the field (simplified)\nnew PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    console.log(entry.name, entry.value);\n  }\n}).observe({ type: 'largest-contentful-paint', buffered: true });"
        },
        {
          "type": "list",
          "columns": [
            "Signal",
            "Likely cause",
            "Typical fix"
          ],
          "rows": [
            [
              "Long tasks (>50ms)",
              "Too much JS on main thread",
              "Split work, lazy-load, defer"
            ],
            [
              "Forced reflow",
              "Layout thrash (read/write mixing)",
              "Batch DOM reads then writes"
            ],
            [
              "Large paint",
              "Big images or expensive styles",
              "Optimize assets, reduce effects"
            ]
          ],
          "caption": "Use the trace to map signals to fixes."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Common pitfalls</strong>\n\n- Optimizing without a baseline metric.\n- Profiling in dev builds only (prod bundles behave differently).\n- Ignoring long tasks and focusing on tiny wins.\n- Not re-testing after changes."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nPick a metric, record a trace, fix the biggest bottleneck, and verify with the same scenario. That loop is the fastest path to real-world performance gains."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-memory-leaks-common-sources",
    "title": "Memory Leaks in JavaScript: Common Sources and Fixes",
    "description": "Explain how memory leaks happen in the browser, list common sources (listeners, timers, closures, caches, detached DOM), and show practical cleanup patterns and debugging steps.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "memory",
      "garbage-collection",
      "performance",
      "devtools",
      "debugging",
      "browser",
      "events",
      "best-practices"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bug'></i> <strong>What is a memory leak?</strong>\n\nA memory leak happens when objects stay referenced and cannot be garbage collected, even though the app no longer needs them. In long-lived SPAs this causes slowdowns, jank, and crashes over time."
        },
        {
          "type": "list",
          "columns": [
            "Leak source",
            "Why it leaks",
            "Fix pattern"
          ],
          "rows": [
            [
              "Event listeners",
              "Handlers keep closures alive",
              "Remove listeners on cleanup"
            ],
            [
              "Intervals/timeouts",
              "Timers keep callbacks reachable",
              "Clear timers on unmount"
            ],
            [
              "Detached DOM",
              "Nodes retained by JS references",
              "Null references; avoid caching DOM nodes"
            ],
            [
              "Global caches",
              "Maps grow without limits",
              "Bounded caches + eviction"
            ],
            [
              "Observers",
              "Mutation/Intersection observers never disconnected",
              "Call disconnect() on cleanup"
            ],
            [
              "Closures",
              "Captured large objects stay alive",
              "Avoid capturing big data unnecessarily"
            ]
          ],
          "caption": "Leaks usually come from forgotten references."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example: leak from uncleaned listener\nfunction mount(btn) {\n  const handler = () => console.log('click');\n  btn.addEventListener('click', handler);\n  return () => btn.removeEventListener('click', handler);\n}\n\n// Example: cleanup timers\nconst id = setInterval(poll, 2000);\n// later...\nclearInterval(id);"
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "What to do",
            "Why"
          ],
          "rows": [
            [
              "1. Snapshot",
              "Take a heap snapshot (baseline)",
              "Know what normal looks like"
            ],
            [
              "2. Reproduce",
              "Perform the action multiple times",
              "Amplify the leak"
            ],
            [
              "3. Compare",
              "Take another snapshot and compare",
              "Find growing objects"
            ],
            [
              "4. Retainers",
              "Inspect retaining paths",
              "See what keeps objects alive"
            ]
          ],
          "caption": "Use the Memory panel to prove the leak."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Common mistakes</strong>\n\n- Relying on GC to clean up listeners (it will not if references remain).\n- Using global arrays/maps as logs without bounds.\n- Forgetting to unsubscribe from Observables or event buses.\n- Holding DOM nodes in closures after unmount."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nAvoid leaks by removing references: detach listeners, clear timers, disconnect observers, and bound caches. Verify with heap snapshots after repeated actions."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-esm-vs-cjs",
    "title": "ESM vs CommonJS: Differences, Interop, and Tooling",
    "description": "Compare ES Modules (ESM) and CommonJS (CJS): syntax, loading model, live bindings, interop pitfalls, and how bundlers/tree-shaking behave. Include Node.js package.json settings and file extensions.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "modules",
      "imports",
      "exports",
      "build",
      "tooling",
      "optimization"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-puzzle-piece'></i> <strong>Big picture</strong>\n\n<strong>ES Modules (ESM)</strong> are the modern JavaScript module system with static imports/exports. <strong>CommonJS (CJS)</strong> is Node.js\u2019s legacy system using require/module.exports. The key difference is that ESM is statically analyzable, which enables tree-shaking and better tooling."
        },
        {
          "type": "list",
          "columns": [
            "Topic",
            "ESM",
            "CommonJS"
          ],
          "rows": [
            [
              "Syntax",
              "import/export",
              "require/module.exports"
            ],
            [
              "Loading",
              "Static, hoisted",
              "Dynamic at runtime"
            ],
            [
              "Bindings",
              "Live bindings",
              "Snapshot values"
            ],
            [
              "Tree-shaking",
              "Works well",
              "Limited (hard to analyze)"
            ],
            [
              "Interop",
              "Default export vs named exports",
              "module.exports is a single object"
            ]
          ],
          "caption": "ESM\u2019s static structure is the big win for tooling."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// ESM\nexport const add = (a, b) => a + b;\nexport default function sum(arr) {\n  return arr.reduce(add, 0);\n}\n\n// CJS\nconst add = (a, b) => a + b;\nmodule.exports = { add };"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gears'></i> <strong>Node.js module type</strong>\n\nIn Node.js, <code>package.json</code> controls defaults: <code>\"type\": \"module\"</code> makes <code>.js</code> files ESM; <code>\"type\": \"commonjs\"</code> keeps CJS. You can always use <code>.mjs</code> for ESM and <code>.cjs</code> for CJS regardless of the package type."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Interop pitfalls</strong>\n\n- CJS <code>module.exports = value</code> becomes ESM <code>default</code> when imported.\n- Named exports from CJS are not always real named exports.\n- Mixing systems can break tree-shaking unless you publish ESM builds."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nPrefer ESM for new code and libraries. It enables static analysis, tree-shaking, and better tooling. Use CJS only for legacy compatibility or when required by environment constraints."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-tree-shaking",
    "title": "Tree-Shaking: How It Works and Common Pitfalls",
    "description": "Explain tree-shaking (dead code elimination) in modern bundlers, the requirements for it to work (ESM, sideEffects, pure), and how to verify results. Include common pitfalls that prevent tree-shaking.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "modules",
      "build",
      "tooling",
      "optimization",
      "tree",
      "performance"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-seedling'></i> <strong>What is tree-shaking?</strong>\n\nTree-shaking is <strong>dead code elimination</strong>. Bundlers analyze your import graph and remove unused exports so your final bundle is smaller and faster. It works best with ESM because imports/exports are static."
        },
        {
          "type": "list",
          "columns": [
            "Requirement",
            "Why it matters",
            "Example"
          ],
          "rows": [
            [
              "ESM exports",
              "Static analysis of imports",
              "export const foo = ..."
            ],
            [
              "No side effects",
              "Unused code can be safely removed",
              "set \"sideEffects\": false"
            ],
            [
              "Pure annotations",
              "Signals safe removal",
              "/* @__PURE__ */ helper()"
            ]
          ],
          "caption": "Tree-shaking needs static structure + side-effect info."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Good: named ESM exports\nexport const add = (a, b) => a + b;\nexport const multiply = (a, b) => a * b;\n\n// Consumer uses only add\nimport { add } from './math.js';"
        },
        {
          "type": "list",
          "columns": [
            "Pitfall",
            "Why it breaks tree-shaking",
            "Fix"
          ],
          "rows": [
            [
              "CommonJS modules",
              "Require is dynamic",
              "Publish ESM build"
            ],
            [
              "Side-effect imports",
              "Bundler must keep them",
              "Mark sideEffects accurately"
            ],
            [
              "Barrel files with side effects",
              "Re-export triggers file execution",
              "Keep barrels side-effect free"
            ],
            [
              "Dynamic require/import",
              "Unknown at build time",
              "Prefer static imports"
            ]
          ],
          "caption": "Most tree-shaking failures are about side effects or dynamic loading."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-magnifying-glass'></i> <strong>How to verify</strong>\n\nUse a bundle analyzer to compare sizes before/after. In devtools, inspect the output bundle to ensure unused exports are removed. Add perf budgets to prevent regressions."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\nTree-shaking is effective when your code is ESM, side-effect free, and statically analyzable. If bundles stay large, check for CJS dependencies and unmarked side effects."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-intl-datetime-timezone",
    "title": "Intl.DateTimeFormat and Time Zones in JavaScript",
    "description": "Explain how to format dates with Intl.DateTimeFormat, how IANA time zones work, and why manual offset math fails. Include formatToParts, DST pitfalls, and best practices.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "date-time",
      "intl",
      "time-zones",
      "timers",
      "best-practices",
      "edge-cases",
      "strings",
      "browser"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-calendar'></i> <strong>Big idea</strong>\n\nJavaScript dates are stored in UTC milliseconds, but users expect local time zones. <strong>Intl.DateTimeFormat</strong> lets you format a Date for a specific locale and <strong>IANA time zone</strong> (e.g., <code>America/Los_Angeles</code>) without manual offset math."
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "What it means",
            "Why it matters"
          ],
          "rows": [
            [
              "IANA time zone",
              "Standard names like America/New_York",
              "Handles DST rules correctly"
            ],
            [
              "Locale",
              "Formatting rules (order, separators)",
              "Controls display style"
            ],
            [
              "UTC storage",
              "Date internally stored as ms since epoch",
              "Always convert on output"
            ]
          ],
          "caption": "Time zone and locale are independent: time zone changes the clock, locale changes the display."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const date = new Date('2020-01-01T00:30:00Z');\n\nconst fmt = new Intl.DateTimeFormat('en-US', {\n  timeZone: 'America/Los_Angeles',\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit'\n});\n\nfmt.format(date); // e.g. 12/31/2019\n\n// Stable output using formatToParts:\nconst parts = fmt.formatToParts(date);\nconst map = Object.fromEntries(parts.filter(p => p.type !== 'literal').map(p => [p.type, p.value]));\nconst ymd = `${map.year}-${map.month}-${map.day}`;"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Why manual offsets fail</strong>\n\nDaylight Saving Time changes offsets during the year. Subtracting a fixed number of hours can produce incorrect dates. Always use <code>Intl</code> or a time zone\u2013aware library when you need exact local dates."
        },
        {
          "type": "list",
          "columns": [
            "Pitfall",
            "Example",
            "Better approach"
          ],
          "rows": [
            [
              "Using toISOString()",
              "Always returns UTC",
              "Use Intl.DateTimeFormat + timeZone"
            ],
            [
              "Hard-coded offsets",
              "-08:00 is wrong in summer",
              "Let Intl handle DST"
            ],
            [
              "Locale assumptions",
              "MM/DD vs DD/MM confusion",
              "Use formatToParts or fixed locale"
            ]
          ],
          "caption": "Most date bugs are caused by wrong assumptions about offsets or locale."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Best practices</strong>\n\n- Store timestamps in UTC.\n- Convert to a user\u2019s time zone at the edges (UI).\n- Use IANA time zone IDs.\n- Prefer formatToParts for stable, testable output."
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-03"
  },
  {
    "id": "js-mock-vs-stub-vs-spy",
    "title": "Mocks vs Stubs vs Spies (Test Doubles) in JavaScript",
    "description": "Explain the difference between mocks, stubs, and spies in unit testing. Describe when to use each, how to avoid brittle tests, and how dependency injection helps testability. Include an async example and common pitfalls.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "intermediate",
    "tags": [
      "testing",
      "best-practices",
      "debugging",
      "dependency-injection",
      "functions",
      "architecture",
      "async-await"
    ],
    "importance": 4,
    "companies": [],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-vial'></i> <strong>Why this matters</strong>\n\nIn interviews and real code, testing isn't about writing 200 assertions\u2014it\u2019s about verifying behavior <strong>at the right boundary</strong>. Test doubles (mocks/stubs/spies) let you isolate a unit from slow, flaky, or external dependencies (network, storage, time, analytics)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-bullseye'></i> <strong>Practical scenario</strong>\n\nYou have <code>searchUsers(query)</code> that calls an HTTP client and returns parsed JSON. In a unit test, you don\u2019t want real network. You want to:\n\n- <strong>Stub</strong> the HTTP client to return a controlled response.\n- <strong>Spy</strong> on the client to assert it was called correctly.\n- Optionally <strong>mock</strong> the client to both define expectations and fail if they\u2019re not met."
        },
        {
          "type": "list",
          "columns": [
            "Test double",
            "What it is",
            "Use it when",
            "Common smell"
          ],
          "rows": [
            [
              "Spy",
              "Records calls (args/call count)",
              "You want to verify interactions at a boundary",
              "Asserting exact call order everywhere"
            ],
            [
              "Stub",
              "Returns fake data to drive a code path",
              "You need deterministic input (no real network/time)",
              "Stubbing internal implementation details"
            ],
            [
              "Mock",
              "A stub + expectations (\"must be called with X\")",
              "You want strict interaction contracts for critical boundaries",
              "Over-mocking makes refactors painful"
            ]
          ],
          "caption": "Rule of thumb: prefer stubs for inputs, spies for boundary verification, mocks only when strict contracts are worth the brittleness."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Dependency injection makes testing simple.\n// Production code:\nexport async function searchUsers(query, { fetchJson }) {\n  if (!query) return [];\n  const data = await fetchJson(`/api/users?q=${encodeURIComponent(query)}`);\n  return Array.isArray(data) ? data : [];\n}\n\n// Unit test idea:\nconst calls = [];\nconst fetchJsonStub = async (url) => {\n  calls.push(url);\n  return [{ id: 1, name: 'Ada' }];\n};\n\nconst users = await searchUsers('a', { fetchJson: fetchJsonStub });\n// Assert output (preferred)\nexpect(users).toEqual([{ id: 1, name: 'Ada' }]);\n// Assert boundary interaction (spy-like)\nexpect(calls).toEqual(['/api/users?q=a']);"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Common pitfalls</strong>\n\n- <strong>Over-mocking</strong>: tests fail on harmless refactors because they assert internal steps, not outcomes.\n- <strong>Leaking globals</strong>: stubbing <code>global.fetch</code> or <code>Date.now</code> without restoring breaks other tests.\n- <strong>Async flakiness</strong>: tests that depend on real timers or network ordering become flaky.\n- <strong>Missing error paths</strong>: only testing the happy path hides retries/timeouts/empty responses bugs."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-scale-balanced'></i> <strong>Trade-off to mention in interviews</strong>\n\n<strong>Unit tests</strong> are fast and isolate logic but can drift from reality if you mock too much. <strong>Integration tests</strong> catch wiring issues but are slower and harder to debug. A strong strategy uses both:\n\n- Unit tests for core logic + edge cases.\n- A few integration tests for the most important flows (auth, payments, critical UI paths)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Answer to land</strong>\n\n\"I prefer dependency injection so I can stub inputs and spy on boundaries. I assert outputs first, then interactions only when they\u2019re part of the contract (e.g., a retry policy or analytics call). Mocks are useful for strict contracts, but I avoid over-mocking because it makes tests brittle.\""
        }
      ]
    },
    "access": "free",
    "updatedAt": "2026-02-05"
  }
]
