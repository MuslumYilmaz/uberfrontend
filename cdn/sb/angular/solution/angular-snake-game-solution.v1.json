{
  "version": "v2",
  "type": "user-interface",
  "title": "Angular Snake Game (solution)",
  "openFile": "/src/app/app.component.ts",
  "dependencies": {
    "@angular/core": "17.1.0",
    "@angular/common": "17.1.0",
    "@angular/platform-browser": "17.1.0",
    "rxjs": "7.8.1",
    "zone.js": "^0.14.2"
  },
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"angular-snake-game-solution\",\n  \"private\": true\n}\n"
    },
    "/src/main.ts": {
      "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { AppComponent } from './app/app.component';\n\nbootstrapApplication(AppComponent).catch(console.error);\n"
    },
    "/src/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <title>Angular SDK â€¢ Snake Game (solution)</title>\n  </head>\n  <body>\n    <app-root></app-root>\n  </body>\n</html>\n"
    },
    "/src/app/app.component.ts": {
      "code": "import { Component, HostListener, OnDestroy } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ntype Direction = 'UP' | 'DOWN' | 'LEFT' | 'RIGHT';\ninterface Point { x: number; y: number }\n\nconst BOARD_SIZE = 14;\nconst STEP_MS = 140;\nconst INITIAL_SNAKE: Point[] = [\n  { x: 6, y: 7 },\n  { x: 5, y: 7 },\n  { x: 4, y: 7 }\n];\n\nconst DIRECTION_DELTA: Record<Direction, Point> = {\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n  LEFT: { x: -1, y: 0 },\n  RIGHT: { x: 1, y: 0 }\n};\n\nconst OPPOSITE: Record<Direction, Direction> = {\n  UP: 'DOWN',\n  DOWN: 'UP',\n  LEFT: 'RIGHT',\n  RIGHT: 'LEFT'\n};\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnDestroy {\n  readonly boardSize = BOARD_SIZE;\n\n  snake: Point[] = INITIAL_SNAKE.map((point) => ({ ...point }));\n  direction: Direction = 'RIGHT';\n  pendingDirection: Direction = 'RIGHT';\n  food: Point = this.randomFood(this.snake);\n  isRunning = false;\n  isGameOver = false;\n  score = 0;\n\n  private timerId: ReturnType<typeof setInterval> | null = null;\n\n  get length(): number {\n    return this.snake.length;\n  }\n\n  get statusLabel(): string {\n    if (this.isGameOver) return 'Game over';\n    return this.isRunning ? 'Running' : 'Paused';\n  }\n\n  @HostListener('window:keydown', ['$event'])\n  onKeydown(event: KeyboardEvent): void {\n    const key = String(event.key || '').toLowerCase();\n\n    if (key === ' ') {\n      event.preventDefault();\n      if (!this.isGameOver) this.toggleRunning();\n      return;\n    }\n\n    if (key === 'enter' && this.isGameOver) {\n      event.preventDefault();\n      this.reset();\n      return;\n    }\n\n    const nextDirection = this.directionFromKey(key);\n    if (!nextDirection) return;\n\n    event.preventDefault();\n    const activeDirection = this.pendingDirection || this.direction;\n    if (OPPOSITE[activeDirection] === nextDirection) return;\n    this.pendingDirection = nextDirection;\n  }\n\n  toggleRunning(): void {\n    if (this.isGameOver) return;\n    this.isRunning ? this.pause() : this.start();\n  }\n\n  start(): void {\n    if (this.isRunning || this.isGameOver) return;\n    this.isRunning = true;\n    this.clearTimer();\n    this.timerId = setInterval(() => this.tick(), STEP_MS);\n  }\n\n  pause(): void {\n    this.isRunning = false;\n    this.clearTimer();\n  }\n\n  reset(): void {\n    this.clearTimer();\n    this.snake = INITIAL_SNAKE.map((point) => ({ ...point }));\n    this.direction = 'RIGHT';\n    this.pendingDirection = 'RIGHT';\n    this.food = this.randomFood(this.snake);\n    this.isRunning = false;\n    this.isGameOver = false;\n    this.score = 0;\n  }\n\n  isSnake(x: number, y: number): boolean {\n    return this.snake.some((point) => point.x === x && point.y === y);\n  }\n\n  isHead(x: number, y: number): boolean {\n    const head = this.snake[0];\n    return head.x === x && head.y === y;\n  }\n\n  isFood(x: number, y: number): boolean {\n    return this.food.x === x && this.food.y === y;\n  }\n\n  ngOnDestroy(): void {\n    this.clearTimer();\n  }\n\n  private tick(): void {\n    if (!this.isRunning || this.isGameOver) return;\n\n    const stepDirection = this.pendingDirection || this.direction;\n    const currentHead = this.snake[0];\n    const nextHead = this.moveHead(currentHead, stepDirection);\n\n    if (this.outOfBounds(nextHead)) {\n      this.isGameOver = true;\n      this.pause();\n      return;\n    }\n\n    const bodyToCheck = this.snake.slice(0, -1);\n    if (bodyToCheck.some((part) => part.x === nextHead.x && part.y === nextHead.y)) {\n      this.isGameOver = true;\n      this.pause();\n      return;\n    }\n\n    const ateFood = nextHead.x === this.food.x && nextHead.y === this.food.y;\n    const nextSnake = [nextHead, ...this.snake];\n\n    if (!ateFood) {\n      nextSnake.pop();\n    } else {\n      this.score += 1;\n      this.food = this.randomFood(nextSnake);\n    }\n\n    this.snake = nextSnake;\n    this.direction = stepDirection;\n  }\n\n  private directionFromKey(key: string): Direction | null {\n    if (key === 'arrowup' || key === 'w') return 'UP';\n    if (key === 'arrowdown' || key === 's') return 'DOWN';\n    if (key === 'arrowleft' || key === 'a') return 'LEFT';\n    if (key === 'arrowright' || key === 'd') return 'RIGHT';\n    return null;\n  }\n\n  private pointKey(point: Point): string {\n    return String(point.x) + ',' + String(point.y);\n  }\n\n  private randomFood(snake: Point[]): Point {\n    const occupied = new Set(snake.map((point) => this.pointKey(point)));\n    const free: Point[] = [];\n\n    for (let y = 0; y < this.boardSize; y += 1) {\n      for (let x = 0; x < this.boardSize; x += 1) {\n        const key = String(x) + ',' + String(y);\n        if (!occupied.has(key)) free.push({ x, y });\n      }\n    }\n\n    if (!free.length) return { x: 0, y: 0 };\n    return free[Math.floor(Math.random() * free.length)];\n  }\n\n  private moveHead(head: Point, direction: Direction): Point {\n    const delta = DIRECTION_DELTA[direction];\n    return {\n      x: head.x + delta.x,\n      y: head.y + delta.y\n    };\n  }\n\n  private outOfBounds(point: Point): boolean {\n    return point.x < 0 || point.y < 0 || point.x >= this.boardSize || point.y >= this.boardSize;\n  }\n\n  private clearTimer(): void {\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      this.timerId = null;\n    }\n  }\n}\n"
    },
    "/src/app/app.component.html": {
      "code": "<main class=\"page\">\n  <section class=\"card\">\n    <h1 class=\"title\">Snake (Grid + Collision)</h1>\n    <p class=\"subtitle\">\n      Build a keyboard-controlled snake game with food spawning, score updates, and collision handling.\n    </p>\n\n    <div class=\"status-row\">\n      <span class=\"pill\">Score: {{ score }}</span>\n      <span class=\"pill\">Length: {{ length }}</span>\n      <span class=\"pill\" [class.pill--danger]=\"isGameOver\">{{ statusLabel }}</span>\n    </div>\n\n    <div class=\"actions\">\n      <button type=\"button\" class=\"ghost\" (click)=\"toggleRunning()\">\n        {{ isRunning ? 'Pause' : 'Start' }}\n      </button>\n      <button type=\"button\" class=\"ghost\" (click)=\"reset()\">Reset</button>\n    </div>\n\n    <div\n      class=\"board\"\n      role=\"grid\"\n      aria-label=\"snake board\"\n      [style.gridTemplateColumns]=\"'repeat(' + boardSize + ', minmax(0, 1fr))'\"\n    >\n      <ng-container *ngFor=\"let row of [].constructor(boardSize); let rowIndex = index\">\n        <div\n          *ngFor=\"let col of [].constructor(boardSize); let colIndex = index\"\n          class=\"cell\"\n          [class.cell--snake]=\"isSnake(colIndex, rowIndex)\"\n          [class.cell--head]=\"isHead(colIndex, rowIndex)\"\n          [class.cell--food]=\"isFood(colIndex, rowIndex)\"\n          [attr.aria-label]=\"isHead(colIndex, rowIndex) ? 'snake head' : (isFood(colIndex, rowIndex) ? 'food' : 'empty cell')\"\n        ></div>\n      </ng-container>\n    </div>\n\n    <p class=\"hint\">Use Arrow keys or WASD to move. Space pauses, Enter resets after game over.</p>\n  </section>\n</main>\n"
    },
    "/src/app/app.component.css": {
      "code": ".page{min-height:100vh;display:grid;place-items:center;padding:24px;background:#0a0a0a;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}\n.card{width:min(700px,100%);background:#0b1020;border:1px solid #1f2937;border-radius:14px;padding:18px;display:grid;gap:14px;}\n.title{margin:0;font-size:22px;font-weight:800;}\n.subtitle{margin:0;color:#9ca3af;font-size:13px;}\n.status-row{display:flex;flex-wrap:wrap;gap:8px;}\n.pill{border:1px solid #334155;border-radius:999px;padding:6px 10px;font-size:12px;color:#d1d5db;background:#0a0f1e;}\n.pill--danger{border-color:#7f1d1d;color:#fecaca;background:rgba(127,29,29,.25);}\n.actions{display:flex;gap:10px;}\n.ghost{background:transparent;color:#e5e7eb;border:1px solid #374151;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer;}\n.ghost:hover{border-color:#60a5fa;}\n.board{width:min(560px,100%);display:grid;gap:4px;border-radius:12px;background:#0a0f1e;border:1px solid #334155;padding:8px;}\n.cell{aspect-ratio:1/1;border-radius:4px;background:#111827;}\n.cell--snake{background:#2563eb;}\n.cell--head{background:#93c5fd;}\n.cell--food{background:#f43f5e;}\n.hint{margin:0;color:#94a3b8;font-size:12px;}\n"
    },
    "/src/styles.css": {
      "code": ":root { color-scheme: dark; }\nhtml, body { margin: 0; height: 100%; background:#0a0a0a; }\nbody { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }\n"
    },
    "/tsconfig.json": {
      "code": "{\n  \"compilerOptions\": {\n    \"target\": \"es2022\",\n    \"strict\": true,\n    \"noEmitOnError\": false\n  }\n}\n"
    }
  }
}
