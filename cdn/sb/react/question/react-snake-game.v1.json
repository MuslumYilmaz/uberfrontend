{
  "dependencies": {
    "react": "18.x",
    "react-dom": "18.x",
    "react-scripts": "5.0.1"
  },
  "openFile": "/src/App.tsx",
  "files": {
    "package.json": "{\n  \"name\": \"react-snake-game\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.x\",\n    \"react-dom\": \"18.x\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": { \"start\": \"react-scripts start\" }\n}\n",
    "public/index.html": "<!doctype html><html lang=\"en\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"><title>React SDK â€¢ Snake Game</title></head><body><div id=\"root\"></div></body></html>",
    "src/index.tsx": "import React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport App from './App';\n\ncreateRoot(document.getElementById('root')!).render(<App />);\n",
    "src/App.tsx": "import React, { useEffect, useMemo, useState } from 'react';\nimport './App.css';\n\nconst BOARD_SIZE = 14;\nconst STEP_MS = 140;\nconst INITIAL_SNAKE = [\n  { x: 6, y: 7 },\n  { x: 5, y: 7 },\n  { x: 4, y: 7 },\n];\n\nconst DIRECTIONS = {\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n  LEFT: { x: -1, y: 0 },\n  RIGHT: { x: 1, y: 0 },\n};\n\nconst OPPOSITE = {\n  UP: 'DOWN',\n  DOWN: 'UP',\n  LEFT: 'RIGHT',\n  RIGHT: 'LEFT',\n};\n\nfunction pointKey(point) {\n  return point.x + ',' + point.y;\n}\n\nfunction randomFood(snake) {\n  const occupied = new Set(snake.map(pointKey));\n  const free = [];\n  for (let y = 0; y < BOARD_SIZE; y += 1) {\n    for (let x = 0; x < BOARD_SIZE; x += 1) {\n      const key = x + ',' + y;\n      if (!occupied.has(key)) free.push({ x, y });\n    }\n  }\n  if (!free.length) return { x: 0, y: 0 };\n  return free[Math.floor(Math.random() * free.length)];\n}\n\nfunction moveHead(head, direction) {\n  const delta = DIRECTIONS[direction];\n  return {\n    x: head.x + delta.x,\n    y: head.y + delta.y,\n  };\n}\n\nfunction isOutOfBounds(point) {\n  return point.x < 0 || point.y < 0 || point.x >= BOARD_SIZE || point.y >= BOARD_SIZE;\n}\n\nexport default function App() {\n  const [snake, setSnake] = useState(INITIAL_SNAKE);\n  const [direction, setDirection] = useState('RIGHT');\n  const [pendingDirection, setPendingDirection] = useState('RIGHT');\n  const [food, setFood] = useState(() => randomFood(INITIAL_SNAKE));\n  const [isRunning, setIsRunning] = useState(false);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState(0);\n\n  useEffect(() => {\n    const onKeyDown = (event) => {\n      const key = String(event.key || '').toLowerCase();\n\n      // TODO: Map Arrow keys / WASD to nextDirection.\n      // TODO: Prevent immediate reverse direction using OPPOSITE map.\n      // TODO: Space should toggle pause/start.\n      // TODO: Enter should reset when game is over.\n      void key;\n    };\n\n    window.addEventListener('keydown', onKeyDown);\n    return () => window.removeEventListener('keydown', onKeyDown);\n  }, [direction, isGameOver]);\n\n  useEffect(() => {\n    if (!isRunning || isGameOver) return undefined;\n\n    const timerId = window.setInterval(() => {\n      // TODO: Move snake one step based on pendingDirection.\n      // TODO: Detect wall collision and self collision -> game over.\n      // TODO: If snake eats food, grow and add score.\n      // TODO: If no food eaten, move by removing tail.\n      // TODO: Keep direction and pendingDirection in sync per tick.\n    }, STEP_MS);\n\n    return () => window.clearInterval(timerId);\n  }, [isRunning, isGameOver, pendingDirection, food]);\n\n  const snakeSet = useMemo(() => new Set(snake.map(pointKey)), [snake]);\n  const foodKey = pointKey(food);\n\n  const resetGame = () => {\n    // TODO: Restore initial snake/direction/score/running/gameOver/food.\n  };\n\n  return (\n    <main className=\"page\">\n      <section className=\"card\">\n        <h1>Snake (Grid + Collision)</h1>\n        <p className=\"subtitle\">\n          Build a keyboard-controlled snake game with food spawning, score updates, and collision handling.\n        </p>\n\n        <div className=\"statusRow\">\n          <span className=\"pill\">Score: {score}</span>\n          <span className=\"pill\">Length: {snake.length}</span>\n          <span className={isGameOver ? 'pill pill--danger' : 'pill'}>\n            {isGameOver ? 'Game over' : isRunning ? 'Running' : 'Paused'}\n          </span>\n        </div>\n\n        <div className=\"actions\">\n          <button\n            type=\"button\"\n            className=\"ghost\"\n            onClick={() => {\n              if (!isGameOver) setIsRunning((value) => !value);\n            }}\n          >\n            {isRunning ? 'Pause' : 'Start'}\n          </button>\n          <button type=\"button\" className=\"ghost\" onClick={resetGame}>Reset</button>\n        </div>\n\n        <div\n          className=\"board\"\n          role=\"grid\"\n          aria-label=\"snake board\"\n          style={{ gridTemplateColumns: 'repeat(' + BOARD_SIZE + ', minmax(0, 1fr))' }}\n        >\n          {Array.from({ length: BOARD_SIZE * BOARD_SIZE }, (_, index) => {\n            const x = index % BOARD_SIZE;\n            const y = Math.floor(index / BOARD_SIZE);\n            const key = x + ',' + y;\n            const isHead = snake[0] && snake[0].x === x && snake[0].y === y;\n            const isBody = snakeSet.has(key);\n            const isFood = key === foodKey;\n\n            return (\n              <div\n                key={key}\n                className={[\n                  'cell',\n                  isBody ? 'cell--snake' : '',\n                  isHead ? 'cell--head' : '',\n                  isFood ? 'cell--food' : '',\n                ].join(' ').trim()}\n                aria-label={isHead ? 'snake head' : isFood ? 'food' : 'empty cell'}\n              />\n            );\n          })}\n        </div>\n\n        <p className=\"hint\">Use Arrow keys or WASD to move. Space pauses, Enter resets after game over.</p>\n      </section>\n    </main>\n  );\n}\n",
    "src/App.css": ":root { color-scheme: dark; }\nhtml, body { margin: 0; height: 100%; background: #0a0a0a; }\nbody { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }\n\n.page {\n  min-height: 100vh;\n  display: grid;\n  place-items: center;\n  padding: 24px;\n  background: #0a0a0a;\n  color: #e5e7eb;\n}\n\n.card {\n  width: min(680px, 100%);\n  background: #0b1020;\n  border: 1px solid #1f2937;\n  border-radius: 14px;\n  padding: 18px;\n  display: grid;\n  gap: 14px;\n}\n\nh1 {\n  margin: 0;\n  font-size: 22px;\n  font-weight: 800;\n}\n\n.subtitle {\n  margin: 0;\n  color: #9ca3af;\n  font-size: 13px;\n}\n\n.statusRow {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 8px;\n}\n\n.pill {\n  border: 1px solid #334155;\n  border-radius: 999px;\n  padding: 6px 10px;\n  font-size: 12px;\n  color: #d1d5db;\n  background: #0a0f1e;\n}\n\n.pill--danger {\n  border-color: #7f1d1d;\n  color: #fecaca;\n  background: rgba(127, 29, 29, 0.25);\n}\n\n.actions {\n  display: flex;\n  gap: 10px;\n}\n\n.ghost {\n  background: transparent;\n  color: #e5e7eb;\n  border: 1px solid #374151;\n  border-radius: 12px;\n  padding: 10px 14px;\n  font-weight: 700;\n  cursor: pointer;\n}\n\n.ghost:hover {\n  border-color: #60a5fa;\n}\n\n.board {\n  width: min(560px, 100%);\n  display: grid;\n  gap: 4px;\n  border-radius: 12px;\n  background: #0a0f1e;\n  border: 1px solid #334155;\n  padding: 8px;\n}\n\n.cell {\n  aspect-ratio: 1 / 1;\n  border-radius: 4px;\n  background: #111827;\n}\n\n.cell--snake {\n  background: #2563eb;\n}\n\n.cell--head {\n  background: #93c5fd;\n}\n\n.cell--food {\n  background: #f43f5e;\n}\n\n.hint {\n  margin: 0;\n  color: #94a3b8;\n  font-size: 12px;\n}\n",
    "tsconfig.json": "{\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"strict\": true\n  }\n}\n"
  }
}
