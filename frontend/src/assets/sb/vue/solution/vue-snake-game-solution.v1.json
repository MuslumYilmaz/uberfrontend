{
  "dependencies": {
    "vue": "3.x"
  },
  "openFile": "/src/App.vue",
  "files": {
    "package.json": "{\"name\":\"vue-snake-game-solution\",\"version\":\"0.1.0\",\"private\":true,\"dependencies\":{\"vue\":\"3.x\"},\"scripts\":{\"serve\":\"vue-cli-service serve\"}}\n",
    "public/index.html": "<!doctype html><html lang=\"en\"><head><meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"><title>Vue SDK â€¢ Snake Game (solution)</title></head><body><div id=\"app\"></div></body></html>",
    "src/main.ts": "import { createApp } from 'vue';\nimport App from './App.vue';\nimport './App.css';\n\ncreateApp(App).mount('#app');\n",
    "src/App.vue": "<template>\n  <main class=\"page\">\n    <section class=\"card\">\n      <h1>Snake (Grid + Collision)</h1>\n      <p class=\"subtitle\">\n        Build a keyboard-controlled snake game with food spawning, score updates, and collision handling.\n      </p>\n\n      <div class=\"status-row\">\n        <span class=\"pill\">Score: {{ score }}</span>\n        <span class=\"pill\">Length: {{ snake.length }}</span>\n        <span class=\"pill\" :class=\"{ 'pill--danger': isGameOver }\">\n          {{ isGameOver ? 'Game over' : isRunning ? 'Running' : 'Paused' }}\n        </span>\n      </div>\n\n      <div class=\"actions\">\n        <button class=\"ghost\" type=\"button\" @click=\"toggleRunning\">\n          {{ isRunning ? 'Pause' : 'Start' }}\n        </button>\n        <button class=\"ghost\" type=\"button\" @click=\"resetGame\">Reset</button>\n      </div>\n\n      <div\n        class=\"board\"\n        role=\"grid\"\n        aria-label=\"snake board\"\n        :style=\"{ gridTemplateColumns: 'repeat(' + BOARD_SIZE + ', minmax(0, 1fr))' }\"\n      >\n        <template v-for=\"row in rows\" :key=\"'row-' + row\">\n          <div\n            v-for=\"col in cols\"\n            :key=\"cellKey(col, row)\"\n            class=\"cell\"\n            :class=\"{\n              'cell--snake': isSnake(col, row),\n              'cell--head': isHead(col, row),\n              'cell--food': isFood(col, row)\n            }\"\n            :aria-label=\"isHead(col, row) ? 'snake head' : (isFood(col, row) ? 'food' : 'empty cell')\"\n          ></div>\n        </template>\n      </div>\n\n      <p class=\"hint\">Use Arrow keys or WASD to move. Space pauses, Enter resets after game over.</p>\n    </section>\n  </main>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, onBeforeUnmount, onMounted, ref } from 'vue';\n\ntype Direction = 'UP' | 'DOWN' | 'LEFT' | 'RIGHT';\ntype Point = { x: number; y: number };\n\nconst BOARD_SIZE = 14;\nconst STEP_MS = 140;\nconst INITIAL_SNAKE: Point[] = [\n  { x: 6, y: 7 },\n  { x: 5, y: 7 },\n  { x: 4, y: 7 }\n];\n\nconst DIRECTIONS: Record<Direction, Point> = {\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n  LEFT: { x: -1, y: 0 },\n  RIGHT: { x: 1, y: 0 }\n};\n\nconst OPPOSITE: Record<Direction, Direction> = {\n  UP: 'DOWN',\n  DOWN: 'UP',\n  LEFT: 'RIGHT',\n  RIGHT: 'LEFT'\n};\n\nconst snake = ref<Point[]>(INITIAL_SNAKE.map((point) => ({ ...point })));\nconst direction = ref<Direction>('RIGHT');\nconst pendingDirection = ref<Direction>('RIGHT');\nconst food = ref<Point>(randomFood(snake.value));\nconst isRunning = ref(false);\nconst isGameOver = ref(false);\nconst score = ref(0);\n\nlet timerId: number | null = null;\n\nconst rows = computed(() => Array.from({ length: BOARD_SIZE }, (_, index) => index));\nconst cols = computed(() => Array.from({ length: BOARD_SIZE }, (_, index) => index));\n\nconst snakeLookup = computed(() => {\n  const set = new Set<string>();\n  for (const segment of snake.value) {\n    set.add(cellKey(segment.x, segment.y));\n  }\n  return set;\n});\n\nfunction cellKey(x: number, y: number): string {\n  return String(x) + ',' + String(y);\n}\n\nfunction isSnake(x: number, y: number): boolean {\n  return snakeLookup.value.has(cellKey(x, y));\n}\n\nfunction isHead(x: number, y: number): boolean {\n  const snakeHead = snake.value[0];\n  return !!snakeHead && snakeHead.x === x && snakeHead.y === y;\n}\n\nfunction isFood(x: number, y: number): boolean {\n  return food.value.x === x && food.value.y === y;\n}\n\nfunction moveHead(origin: Point, nextDirection: Direction): Point {\n  const delta = DIRECTIONS[nextDirection];\n  return { x: origin.x + delta.x, y: origin.y + delta.y };\n}\n\nfunction isOutOfBounds(point: Point): boolean {\n  return point.x < 0 || point.y < 0 || point.x >= BOARD_SIZE || point.y >= BOARD_SIZE;\n}\n\nfunction randomFood(currentSnake: Point[]): Point {\n  const occupied = new Set(currentSnake.map((point) => cellKey(point.x, point.y)));\n  const free: Point[] = [];\n\n  for (let y = 0; y < BOARD_SIZE; y += 1) {\n    for (let x = 0; x < BOARD_SIZE; x += 1) {\n      const key = cellKey(x, y);\n      if (!occupied.has(key)) free.push({ x, y });\n    }\n  }\n\n  if (!free.length) return { x: 0, y: 0 };\n  return free[Math.floor(Math.random() * free.length)];\n}\n\nfunction clearTimer(): void {\n  if (timerId !== null) {\n    clearInterval(timerId);\n    timerId = null;\n  }\n}\n\nfunction startLoop(): void {\n  if (timerId !== null) return;\n  timerId = window.setInterval(tick, STEP_MS);\n}\n\nfunction pauseLoop(): void {\n  clearTimer();\n  isRunning.value = false;\n}\n\nfunction resetGame(): void {\n  clearTimer();\n  snake.value = INITIAL_SNAKE.map((point) => ({ ...point }));\n  direction.value = 'RIGHT';\n  pendingDirection.value = 'RIGHT';\n  food.value = randomFood(snake.value);\n  score.value = 0;\n  isRunning.value = false;\n  isGameOver.value = false;\n}\n\nfunction tick(): void {\n  if (!isRunning.value || isGameOver.value) return;\n\n  const stepDirection = pendingDirection.value || direction.value;\n  const currentHead = snake.value[0];\n  const nextHead = moveHead(currentHead, stepDirection);\n\n  if (isOutOfBounds(nextHead)) {\n    isGameOver.value = true;\n    pauseLoop();\n    return;\n  }\n\n  const bodyToCheck = snake.value.slice(0, -1);\n  if (bodyToCheck.some((segment) => segment.x === nextHead.x && segment.y === nextHead.y)) {\n    isGameOver.value = true;\n    pauseLoop();\n    return;\n  }\n\n  const ateFood = nextHead.x === food.value.x && nextHead.y === food.value.y;\n  const nextSnake = [nextHead, ...snake.value];\n\n  if (!ateFood) {\n    nextSnake.pop();\n  } else {\n    score.value += 1;\n    food.value = randomFood(nextSnake);\n  }\n\n  snake.value = nextSnake;\n  direction.value = stepDirection;\n}\n\nfunction toggleRunning(): void {\n  if (isGameOver.value) return;\n  isRunning.value = !isRunning.value;\n  if (isRunning.value) startLoop();\n  else pauseLoop();\n}\n\nfunction directionFromKey(key: string): Direction | null {\n  if (key === 'arrowup' || key === 'w') return 'UP';\n  if (key === 'arrowdown' || key === 's') return 'DOWN';\n  if (key === 'arrowleft' || key === 'a') return 'LEFT';\n  if (key === 'arrowright' || key === 'd') return 'RIGHT';\n  return null;\n}\n\nfunction onKeydown(event: KeyboardEvent): void {\n  const key = String(event.key || '').toLowerCase();\n\n  if (key === ' ') {\n    event.preventDefault();\n    if (!isGameOver.value) toggleRunning();\n    return;\n  }\n\n  if (key === 'enter' && isGameOver.value) {\n    event.preventDefault();\n    resetGame();\n    return;\n  }\n\n  const nextDirection = directionFromKey(key);\n  if (!nextDirection) return;\n\n  event.preventDefault();\n  const activeDirection = pendingDirection.value || direction.value;\n  if (OPPOSITE[activeDirection] === nextDirection) return;\n  pendingDirection.value = nextDirection;\n}\n\nonMounted(() => {\n  window.addEventListener('keydown', onKeydown);\n});\n\nonBeforeUnmount(() => {\n  window.removeEventListener('keydown', onKeydown);\n  clearTimer();\n});\n</script>\n",
    "src/App.css": ":root{color-scheme:dark;}\nhtml,body{margin:0;height:100%;background:#0a0a0a;}\nbody{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}\n.page{min-height:100vh;display:grid;place-items:center;padding:24px;background:#0a0a0a;color:#e5e7eb;}\n.card{width:min(700px,100%);background:#0b1020;border:1px solid #1f2937;border-radius:14px;padding:18px;display:grid;gap:14px;}\nh1{margin:0;font-size:22px;font-weight:800;}\n.subtitle{margin:0;color:#9ca3af;font-size:13px;}\n.status-row{display:flex;flex-wrap:wrap;gap:8px;}\n.pill{border:1px solid #334155;border-radius:999px;padding:6px 10px;font-size:12px;color:#d1d5db;background:#0a0f1e;}\n.pill--danger{border-color:#7f1d1d;color:#fecaca;background:rgba(127,29,29,.25);}\n.actions{display:flex;gap:10px;}\n.ghost{background:transparent;color:#e5e7eb;border:1px solid #374151;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer;}\n.ghost:hover{border-color:#60a5fa;}\n.board{width:min(560px,100%);display:grid;gap:4px;border-radius:12px;background:#0a0f1e;border:1px solid #334155;padding:8px;}\n.cell{aspect-ratio:1/1;border-radius:4px;background:#111827;}\n.cell--snake{background:#2563eb;}\n.cell--head{background:#93c5fd;}\n.cell--food{background:#f43f5e;}\n.hint{margin:0;color:#94a3b8;font-size:12px;}\n",
    "tsconfig.json": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"Node\",\n    \"strict\": true,\n    \"allowJs\": true\n  }\n}\n"
  }
}
