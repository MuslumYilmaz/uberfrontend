[
  {
    "id": "angular-counter-starter",
    "title": "Counter (Standalone Component)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "easy",
    "importance": 5,
    "tags": [
      "components",
      "event-binding",
      "state"
    ],
    "description": {
      "summary": "Implement a standalone counter with increment, decrement, and reset. Guard the decrement at zero, disable the minus button when the value is 0, and keep state in a single component property for predictable behavior.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Display the current count value.",
          "Provide \"+\", \"-\", and \"Reset\" buttons.",
          "Disable the decrement button when the count is 0."
        ],
        "expectedBehavior": [
          "Clicking \"+\" increases the count by 1.",
          "Clicking \"-\" decreases the count by 1, but never below 0.",
          "Clicking \"Reset\" sets the count back to 0."
        ],
        "implementationNotes": [
          "Use a regular class property (e.g. `count = 0`) to store state.",
          "Use template event bindings like `(click)=\"...\"` for button actions.",
          "No need for child components, signals, or advanced patterns in this starter."
        ],
        "techFocus": [
          "Standalone component setup",
          "Basic state management in a component",
          "Event binding and conditional disabling"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise requires a single piece of state: the number of times the user has interacted with the counter. Store it in a component property (e.g. `count = 0`) on a standalone root component. Use three buttons wired with Angular event bindings to increment, decrement, and reset that state. Guard the decrement so the value never drops below zero and expose a simple derived flag to control the disabled state of the \"-\" button.\n\n**Test cases**\n- Click \"+\" once → count becomes `1`.\n- Click \"+\" multiple times → count increases by 1 on each click.\n- With count at `0`, \"-\" is disabled and clicking it does nothing.\n- From a positive value, clicking \"-\" decreases the count by 1, but never below `0`.\n- From a positive value, clicking \"Reset\" sets count back to `0` and disables \"-\" again.",
      "approaches": [
        {
          "title": "Standalone component with internal state and guarded decrement",
          "prose": "Use a single standalone `AppComponent` that holds the `count` state.\n\n1. Declare `count = 0` as a class property.\n2. Add methods `inc()`, `dec()`, and `reset()`.\n   - `inc()` increments `count` by 1.\n   - `dec()` decrements only when `count` is greater than 0.\n   - `reset()` sets `count` to 0.\n3. Bind the methods to the buttons with `(click)` in the template.\n4. Bind the disabled state of the decrement button to a derived check, e.g. `isZero` getter returning `count === 0`.\n\nThis keeps the implementation minimal while showing how to wire state, events, and disabled UI in a standalone Angular component.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <main class=\"app\">\n      <section class=\"card\">\n        <h1>Counter</h1>\n        <div class=\"value\">{{ count }}</div>\n        <div class=\"actions\">\n          <button (click)=\"dec()\" [disabled]=\"isZero\" aria-label=\"decrement\">−</button>\n          <button (click)=\"inc()\" aria-label=\"increment\">+</button>\n          <button (click)=\"reset()\" class=\"ghost\" aria-label=\"reset\">Reset</button>\n        </div>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.app{min-height:100vh;display:grid;place-items:center;background:#0a0a0a;color:#e5e7eb;}`,\n    `.card{padding:16px 20px;background:#0b1020;border-radius:12px;border:1px solid #1f2937;display:grid;gap:12px;}`,\n    `.value{font-size:40px;font-weight:800;text-align:center;}`,\n    `.actions{display:flex;gap:8px;justify-content:center;}`,\n    `button{padding:8px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:600;}`,\n    `button[disabled]{opacity:.5;cursor:not-allowed;}`,\n    `.ghost{background:transparent;color:#e5e7eb;border:1px solid #374151;}`\n  ]\n})\nexport class AppComponent {\n  count = 0;\n\n  get isZero(): boolean {\n    return this.count === 0;\n  }\n\n  inc(): void {\n    this.count++;\n  }\n\n  dec(): void {\n    if (!this.isZero) {\n      this.count--;\n    }\n  }\n\n  reset(): void {\n    this.count = 0;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing the count to go below 0 when handling the decrement.",
          "Forgetting to bind the disabled state of the decrement button, which makes the UX unclear.",
          "Mutating state in the template instead of through clear component methods."
        ],
        "techniques": [
          "Using a standalone component with `standalone: true` and `imports` instead of NgModule.",
          "Using a derived getter (`isZero`) for simple view logic instead of duplicating conditions.",
          "Keeping all state and logic colocated in the root component for a small exercise."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-counter.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-counter-starter"
    },
    "companies": [],
    "solutionAsset": "assets/sb/angular/solution/angular-counter-solution.v2.json",
    "access": "free",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Angular Counter Component",
      "description": "Build a counter UI with increment, decrement, and reset actions while preventing values below zero and keeping controls in sync."
    }
  },
  {
    "id": "angular-contact-form-starter",
    "title": "Contact Form (Standalone Component + HTTP)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "forms",
      "http",
      "validation",
      "user-input"
    ],
    "description": {
      "summary": "Build a contact form using an Angular standalone component and reactive forms. You will only work in `src/app/app.component.ts` – the HTML, CSS, and bootstrapping are already set up. On submit, validate the input and send the form data with a POST request to a fake JSON API endpoint, showing loading, success, and error states. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Work only inside the standalone root component in `src/app/app.component.ts` (template and styles are already provided).",
          "Build/configure a reactive form with fields for name, email, and message.",
          "Make all fields required; validate email with a basic email validator.",
          "Disable the submit button while the form is invalid or while a request is in progress.",
          "On valid submit, send a POST request with the form body to `https://jsonplaceholder.typicode.com/posts` using HttpClient.",
          "If the request succeeds, set `successMessage` to `\"Your message has been sent. Thank you!\"`.",
          "If the request fails, set `errorMessage` to `\"Something went wrong. Please try again.\"`.",
          "Track an `isSubmitting` flag so the user cannot trigger multiple requests at the same time."
        ],
        "expectedBehavior": [
          "Initially, the submit button is disabled until the form becomes valid (all required fields filled and email valid).",
          "If the user attempts to submit invalid data, all controls are marked as touched and validation error messages are shown for the affected fields.",
          "On a valid submit, a POST request is sent to `https://jsonplaceholder.typicode.com/posts` and the button is disabled while `isSubmitting` is true.",
          "On success, `isSubmitting` becomes false, `successMessage` is set to `\"Your message has been sent. Thank you!\"`, and the form may optionally be reset.",
          "On error, `isSubmitting` becomes false, `errorMessage` is set to `\"Something went wrong. Please try again.\"`, and the user can fix the issue and resubmit."
        ],
        "implementationNotes": [
          "Configure the reactive form and all request/UX logic inside `AppComponent` in `app.component.ts`. You do not need to change the HTML or CSS files for this exercise.",
          "Use `ReactiveFormsModule` and `FormBuilder` to define the form group for the contact form.",
          "Use Angular's built-in validators such as `Validators.required` and `Validators.email` (and optionally `Validators.minLength` for the message).",
          "Inject `HttpClient` (or use the `inject(HttpClient)` helper) and use `HttpClientModule` to send the POST request.",
          "Clear previous `successMessage` / `errorMessage` at the start of `submit()` so only the latest result is shown.",
          "Call `markAllAsTouched()` on the form before checking validity, so error messages appear when the user submits incomplete data.",
          "Use an `isSubmitting` flag to guard against double submissions and to drive the disabled state of the submit button.",
          "On success, you can reset the form to its initial state while keeping the success message visible."
        ],
        "techFocus": [
          "Standalone component setup with reactive forms",
          "Form validation and UX (disabled submit, inline errors, touched state)",
          "Basic HttpClient usage with a fake POST endpoint and request lifecycle handling",
          "Managing loading, success, and error states in a single component"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise combines a standalone component, reactive forms, and HttpClient. You only need to work in `src/app/app.component.ts`: the HTML and CSS are already wired up to bind to `contactForm`, `isSubmitting`, `successMessage`, and `errorMessage`.\n\nYou define a reactive form with `name`, `email`, and `message` controls, wire up validation, and then send a POST request to the fake endpoint `https://jsonplaceholder.typicode.com/posts` when the user submits. The component tracks an `isSubmitting` flag so you can disable the submit button while the request is in flight, plus `successMessage` and `errorMessage` strings for user feedback.\n\nOn a valid submit, you clear any previous messages, mark all controls as touched, bail out if the form is still invalid, set `isSubmitting` to `true`, and call `http.post(...)` with the form value. On success you show `\"Your message has been sent. Thank you!\"`, reset the form, and re-enable the button. On error you show `\"Something went wrong. Please try again.\"` and let the user resubmit.\n\n**Test cases**\n- With all fields empty, the submit button is disabled.\n- Typing an invalid email keeps the form invalid and disabled.\n- Tapping submit with invalid fields marks controls as touched and shows validation errors.\n- With valid inputs, clicking submit triggers a POST request to `https://jsonplaceholder.typicode.com/posts` and disables the button while `isSubmitting` is `true`.\n- On success, `\"Your message has been sent. Thank you!\"` is shown and the form can optionally reset.\n- On error, `\"Something went wrong. Please try again.\"` is shown and the user can resubmit.",
      "approaches": [
        {
          "title": "Standalone reactive form with HttpClient, status flags, and a fake endpoint",
          "prose": "Use a standalone `AppComponent` that imports `ReactiveFormsModule` and `HttpClientModule`. Inside `app.component.ts`, create a reactive form with `name`, `email`, and `message` controls, all required, and use `Validators.email` (and optionally `Validators.minLength`) for the email and message fields.\n\nUse Angular's function-based DI helpers (`inject(FormBuilder)` and `inject(HttpClient)`) instead of a constructor to avoid any metadata issues in this environment. The template is already set up to use `[formGroup]`, `formControlName`, and to bind the submit button disabled state to `contactForm.invalid || isSubmitting`. It also binds to `successMessage` and `errorMessage` paragraphs.\n\nIn `submit()`, implement the request lifecycle:\n1. Clear previous `successMessage` and `errorMessage`.\n2. Call `this.contactForm.markAllAsTouched()` so validation errors appear.\n3. If the form is invalid, return early.\n4. Set `isSubmitting = true` and send a POST request using `this.http.post('https://jsonplaceholder.typicode.com/posts', this.contactForm.value)`.\n5. In the `next` handler, set `isSubmitting` back to `false`, set `successMessage = 'Your message has been sent. Thank you!'`, and reset the form.\n6. In the `error` handler, set `isSubmitting` back to `false` and `errorMessage = 'Something went wrong. Please try again.'`.\n\nAll logic stays inside `AppComponent`, which keeps this exercise focused on reactive forms + HttpClient without extra services or routing.",
          "codeTs": "import { Component, inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormBuilder, Validators, ReactiveFormsModule } from '@angular/forms';\nimport { HttpClient, HttpClientModule } from '@angular/common/http';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, ReactiveFormsModule, HttpClientModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport default class AppComponent {\n  // Function-based DI to match the SDK environment\n  private fb = inject(FormBuilder);\n  private http = inject(HttpClient);\n\n  // Reactive contact form with basic validation\n  contactForm = this.fb.group({\n    name: ['', [Validators.required]],\n    email: ['', [Validators.required, Validators.email]],\n    message: ['', [Validators.required, Validators.minLength(10)]],\n  });\n\n  isSubmitting = false;\n  successMessage = '';\n  errorMessage = '';\n\n  get f() {\n    return this.contactForm.controls;\n  }\n\n  submit(): void {\n    // Clear previous messages\n    this.successMessage = '';\n    this.errorMessage = '';\n\n    // Show validation errors if form is invalid\n    this.contactForm.markAllAsTouched();\n    if (this.contactForm.invalid) {\n      return;\n    }\n\n    this.isSubmitting = true;\n\n    // Fake JSON API endpoint for this exercise\n    this.http.post('https://jsonplaceholder.typicode.com/posts', this.contactForm.value).subscribe({\n      next: () => {\n        this.isSubmitting = false;\n        this.successMessage = 'Your message has been sent. Thank you!';\n        this.contactForm.reset();\n      },\n      error: () => {\n        this.isSubmitting = false;\n        this.errorMessage = 'Something went wrong. Please try again.';\n      },\n    });\n  }\n}\n\n// Also export a named AppComponent so the bootstrap import always works\nexport { AppComponent };\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting that you only need to modify `src/app/app.component.ts`; the HTML and CSS are already wired to the expected properties.",
          "Not importing `ReactiveFormsModule` and `HttpClientModule` in the standalone component's `imports` array, which would break the form and HttpClient usage.",
          "Allowing the user to submit when the form is invalid or while a previous request is still in flight (missing the `isSubmitting` guard).",
          "Not calling `markAllAsTouched()` before checking validity, which can hide validation errors when the user hits submit on an untouched form.",
          "Hard-coding different success or error messages than the ones specified in the exercise, which may cause tests to fail."
        ],
        "techniques": [
          "Using reactive forms with `FormBuilder` and function-based DI via `inject()`.",
          "Using Angular's built-in validators for required fields, email validation, and minimum length.",
          "Managing loading, success, and error states with simple component properties and a single `submit()` method.",
          "Disabling the submit button based on both form validity and an `isSubmitting` flag.",
          "Using a fake HTTP endpoint (`https://jsonplaceholder.typicode.com/posts`) to simulate a real backend without extra setup."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-contact-form.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-contact-form-starter"
    },
    "companies": [],
    "solutionAsset": "assets/sb/angular/solution/angular-contact-form-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Angular Contact Form with Validation and Submit",
      "description": "Create a contact form that validates required fields, submits data, and shows loading, success, and error feedback states."
    }
  },
  {
    "id": "angular-todo-list-starter",
    "title": "Todo List (Standalone Component with ngFor)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "components",
      "forms",
      "lists",
      "ng-for",
      "state"
    ],
    "description": {
      "summary": "Build a small todo list using an Angular standalone component. Allow users to add tasks, mark them as completed, and remove them. Use `*ngFor` to render the list and simple component state to drive the UI.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Display a text input and an \"Add\" button for creating new todos.",
          "Render the todo items in a list using `*ngFor`.",
          "Each todo item should show a label and a checkbox to toggle completion.",
          "Allow removing a single todo item from the list.",
          "Optionally provide a \"Clear completed\" action to remove all completed todos."
        ],
        "expectedBehavior": [
          "Typing a non-empty value and clicking \"Add\" appends a new todo to the list and clears the input.",
          "Empty or whitespace-only values are ignored (no item is added).",
          "Clicking a todo’s checkbox toggles its completed state.",
          "Completed todos are visually distinguished (e.g. line-through).",
          "Clicking a remove button deletes that specific todo.",
          "If you implement \"Clear completed\", it removes only the completed todos."
        ],
        "implementationNotes": [
          "Keep everything in `AppComponent` (`src/app/app.component.ts` and `app.component.html`). No extra services or components are required.",
          "Use a simple array of objects (e.g. `{ id, text, done }`) to store todos.",
          "Use `*ngFor` to loop over the todo array in the template.",
          "Use `[(ngModel)]` for the input binding and checkbox bindings (remember to import `FormsModule`).",
          "Use click handlers like `(click)=\"addTask()\"` and `(click)=\"removeTask(task)\"` to modify the array."
        ],
        "techFocus": [
          "Standalone component setup with `standalone: true`",
          "Managing in-memory state in a component",
          "Rendering lists with `*ngFor`",
          "Using `[(ngModel)]` for simple form input binding",
          "Basic UX for add / toggle / remove actions"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise models a classic todo list with a single standalone component. You keep all state inside the component: a `newTask` string for the input and a `todos` array (e.g. `{ id, text, done }`). The template binds `newTask` with `[(ngModel)]`, renders `todos` with `*ngFor`, and wires up click handlers to add, toggle, and remove items.\n\nTypical flow:\n- User types into the input; `newTask` is updated via `[(ngModel)]`.\n- Clicking **Add** (or pressing Enter, if you implement it) calls `addTask()`, which trims the text, ignores empties, pushes a new todo into the array, and resets `newTask`.\n- Each todo row shows a checkbox bound to `todo.done` and maybe styled with a `.done` CSS class when complete.\n- Clicking the remove button calls `removeTask(todo)`, which filters that item out.\n- Optionally, a \"Clear completed\" button calls `clearCompleted()` to remove all completed todos.\n\n**Test cases**\n- With an empty input, clicking **Add** does nothing.\n- Typing \"Buy milk\" and clicking **Add** shows a single todo row with that text.\n- Toggling the checkbox marks the item as completed and applies the completed styling.\n- Clicking the remove button deletes that specific row.\n- After completing multiple todos, clicking \"Clear completed\" (if implemented) removes only the completed ones.",
      "approaches": [
        {
          "title": "Standalone component with a local array of todos",
          "prose": "Represent todos as `{ id, text, done }` objects stored in a `todos` array property. Use a simple incremental `nextId` counter for unique ids. The input is bound via `[(ngModel)]=\"newTask\"`. In `addTask()`, trim `newTask`, ignore empties, then push a new object. In the template, use `*ngFor=\"let todo of todos; trackBy: trackById\"` to render each row with a checkbox bound to `todo.done` and a remove button.\n\n`toggleTask(todo)` can simply flip `todo.done = !todo.done`, or you can rely entirely on `[(ngModel)]` on the checkbox and only use handlers for extra behavior. `removeTask(todo)` filters `todos` to drop the item by id. `clearCompleted()` sets `todos` to `todos.filter(t => !t.done)`. This keeps all list and input logic colocated in the root standalone component.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\ninterface Todo {\n  id: number;\n  text: string;\n  done: boolean;\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  newTask = '';\n  todos: Todo[] = [];\n  private nextId = 1;\n\n  get hasTodos(): boolean {\n    return this.todos.length > 0;\n  }\n\n  addTask(): void {\n    const text = this.newTask.trim();\n    if (!text) {\n      return;\n    }\n\n    this.todos = [\n      ...this.todos,\n      { id: this.nextId++, text, done: false }\n    ];\n\n    this.newTask = '';\n  }\n\n  toggleTask(todo: Todo): void {\n    todo.done = !todo.done;\n  }\n\n  removeTask(todo: Todo): void {\n    this.todos = this.todos.filter(t => t.id !== todo.id);\n  }\n\n  clearCompleted(): void {\n    this.todos = this.todos.filter(t => !t.done);\n  }\n\n  trackById(_index: number, todo: Todo): number {\n    return todo.id;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing empty or whitespace-only todos to be added.",
          "Mutating the `todos` array in a way that loses track of identity (e.g. reusing the same id for all items).",
          "Forgetting to import `FormsModule`, which breaks `[(ngModel)]` bindings.",
          "Handling toggle logic only in a click handler but not binding the checkbox correctly."
        ],
        "techniques": [
          "Modeling UI items as simple objects inside a component.",
          "Using `[(ngModel)]` for a controlled input and checkbox bindings.",
          "Rendering lists with `*ngFor` and `trackBy` for better identity handling.",
          "Using pure functions (`filter`, `map`) to derive new arrays when removing or clearing items."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-todo-list.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-todo-list-starter"
    },
    "companies": [],
    "solutionAsset": "assets/sb/angular/solution/angular-todo-list-solution.v2.json",
    "access": "free",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Angular Todo List (Add Toggle Remove)",
      "description": "Create a todo list interface that supports adding tasks, toggling completion, and removing items while keeping list state consistent."
    }
  },
  {
    "id": "angular-image-slider-starter",
    "title": "Image Slider (Standalone Component)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "components",
      "event-binding",
      "ng-for",
      "state",
      "ui"
    ],
    "description": {
      "summary": "Build an image slider with next/prev controls, a current index, and disabled states at bounds. Keep the template state-driven and update the active slide label as the index changes. Concepts: components, event-binding, ng-for.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Keep an in-memory list of slides (each with at least a title and image URL).",
          "Display the currently active slide (image and title).",
          "Provide \"Previous\" and \"Next\" buttons to move between slides.",
          "Disable the \"Previous\" button on the first slide and the \"Next\" button on the last slide.",
          "Render dot indicators for each slide; clicking a dot should jump to that slide.",
          "Display a small \"Slide X of N\" helper text."
        ],
        "expectedBehavior": [
          "Initial view shows the first slide.",
          "Clicking \"Next\" advances to the next slide until the last one; afterwards it stays on the last slide and \"Next\" becomes disabled.",
          "Clicking \"Previous\" moves backwards until the first slide; on the first slide it stays there and \"Previous\" is disabled.",
          "Clicking a dot activates the corresponding slide, updates the main image and title, and updates the \"Slide X of N\" text.",
          "The active slide's dot is visually highlighted."
        ],
        "implementationNotes": [
          "Store slides in a readonly array on the component (e.g. `slides = [...]`).",
          "Track the active slide with a simple numeric index (e.g. `currentIndex = 0`).",
          "Derive the current slide with a getter (e.g. `currentSlide`), and flags like `canGoPrev` / `canGoNext` from the index.",
          "Use template bindings (`(click)`, `[disabled]`, `*ngFor`, `[class.active]`) to wire up the controls and indicators.",
          "No need for routing, services, or external state management; keep everything in the root component."
        ],
        "techFocus": [
          "Standalone component setup",
          "View model with derived state (current slide, canGoPrev/canGoNext)",
          "Template control flow with *ngFor and event bindings",
          "Basic UI state + styling for active / disabled controls"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Model the slider as a small view model on the component: a readonly `slides` array and a `currentIndex` number. Use getters to derive `currentSlide`, `totalSlides`, and convenience flags like `canGoPrev` and `canGoNext`. The template shows the active slide and wires buttons and dot indicators to simple methods that update `currentIndex`.\n\n**Test cases**\n- Initial render shows the first slide, with \"Previous\" disabled and the first dot highlighted.\n- Clicking \"Next\" repeatedly walks through the slides and disables itself on the last slide.\n- Clicking \"Previous\" from the middle moves backward one slide at a time.\n- Clicking a dot jumps directly to that slide and updates the heading, image, and helper text.\n- The slider never goes out of range (no index smaller than 0 or greater than `slides.length - 1`). Key concepts: components, event-binding, ng-for.",
      "approaches": [
        {
          "title": "Standalone component with index-based navigation",
          "prose": "Use a single standalone `AppComponent` that owns the slider state.\n\n1. Define a `Slide` interface (`id`, `title`, `imageUrl`, optional `description`). Keep a `readonly slides: Slide[]` array.\n2. Track the active slide with `currentIndex = 0`.\n3. Expose getters like `currentSlide`, `totalSlides`, `canGoPrev`, and `canGoNext`.\n4. Implement `goTo(index: number)`, `prev()`, and `next()` to clamp `currentIndex` inside `[0, totalSlides - 1]`.\n5. In the template, show the current slide image and title, wire buttons to `prev()` / `next()`, use `[disabled]` for edge cases, and render dot buttons with `*ngFor` and `[class.active]` to highlight the current slide.\n\nThis keeps the logic small and testable while exercising Angular's template bindings and derived state.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ninterface Slide {\n  id: number;\n  title: string;\n  imageUrl: string;\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <main class=\"app\">\n      <section class=\"card\">\n        <h1>Image Slider</h1>\n\n        <figure class=\"frame\" *ngIf=\"currentSlide as slide\">\n          <img class=\"image\" [src]=\"slide.imageUrl\" [alt]=\"slide.title\" />\n          <figcaption class=\"caption\">{{ slide.title }}</figcaption>\n        </figure>\n\n        <div class=\"meta\">\n          Slide {{ currentIndex + 1 }} of {{ totalSlides }}\n        </div>\n\n        <div class=\"actions\">\n          <button (click)=\"prev()\" [disabled]=\"!canGoPrev\">Previous</button>\n          <button (click)=\"next()\" [disabled]=\"!canGoNext\">Next</button>\n        </div>\n\n        <div class=\"dots\">\n          <button\n            *ngFor=\"let slide of slides; let i = index\"\n            type=\"button\"\n            class=\"dot\"\n            [class.active]=\"i === currentIndex\"\n            (click)=\"goTo(i)\"\n            aria-label=\"Go to slide {{ i + 1 }}\"\n          ></button>\n        </div>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.app{min-height:100vh;display:grid;place-items:center;background:#0a0a0a;color:#e5e7eb;}`,\n    `.card{width:100%;max-width:520px;padding:16px 20px;background:#0b1020;border-radius:12px;border:1px solid #1f2937;display:grid;gap:12px;}`,\n    `.frame{margin:0;border-radius:12px;overflow:hidden;border:1px solid #1f2937;background:#020617;}`,\n    `.image{display:block;width:100%;height:240px;object-fit:cover;}`,\n    `.caption{padding:8px 12px;font-size:14px;color:#e5e7eb;background:rgba(15,23,42,.9);}`,\n    `.meta{font-size:12px;color:#9ca3af;text-align:center;}`,\n    `.actions{display:flex;gap:8px;justify-content:center;}`,\n    `button{padding:8px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:600;background:#a3e635;color:#111;}`,\n    `button[disabled]{opacity:.5;cursor:not-allowed;}`,\n    `.dots{display:flex;justify-content:center;gap:6px;margin-top:4px;}`,\n    `.dot{width:8px;height:8px;border-radius:999px;border:none;background:#374151;cursor:pointer;}`,\n    `.dot.active{background:#a3e635;}`\n  ]\n})\nexport class AppComponent {\n  readonly slides: Slide[] = [\n    {\n      id: 1,\n      title: 'Snowflakes glowing under city lights',\n      imageUrl: 'https://images.pexels.com/photos/46253/pexels-photo-46253.jpeg'\n    },\n    {\n      id: 2,\n      title: 'Forest trail in the morning',\n      imageUrl: 'https://images.pexels.com/photos/1563604/pexels-photo-1563604.jpeg'\n    },\n    {\n      id: 3,\n      title: 'City lights at night',\n      imageUrl: 'https://images.pexels.com/photos/220067/pexels-photo-220067.jpeg'\n    }\n  ];\n\n  currentIndex = 0;\n\n  get totalSlides(): number {\n    return this.slides.length;\n  }\n\n  get currentSlide(): Slide | null {\n    return this.slides[this.currentIndex] ?? null;\n  }\n\n  get canGoPrev(): boolean {\n    return this.currentIndex > 0;\n  }\n\n  get canGoNext(): boolean {\n    return this.currentIndex < this.totalSlides - 1;\n  }\n\n  goTo(index: number): void {\n    if (index < 0 || index >= this.totalSlides) return;\n    this.currentIndex = index;\n  }\n\n  prev(): void {\n    if (this.canGoPrev) {\n      this.currentIndex--;\n    }\n  }\n\n  next(): void {\n    if (this.canGoNext) {\n      this.currentIndex++;\n    }\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing `currentIndex` to go out of range (negative or >= slides.length).",
          "Duplicating `slides[currentIndex]` access all over the template instead of using a getter.",
          "Not disabling buttons at the edges, making the UX feel broken."
        ],
        "techniques": [
          "Using a simple numeric index to represent view state.",
          "Deriving convenience getters for current slide and navigation flags.",
          "Using `[class.active]` and `[disabled]` to reflect state in the UI."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-image-slider.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-image-slider-starter"
    },
    "companies": [
      "amazon",
      "google"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-image-slider-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Angular Image Slider with Navigation Controls",
      "description": "Create an image slider with previous and next navigation, boundary-aware controls, and current-slide display updates."
    }
  },
  {
    "id": "angular-tabs-switcher",
    "title": "Angular Tabs / Multi-View Switcher",
    "type": "coding",
    "technology": "angular",
    "difficulty": "easy",
    "importance": 3,
    "tags": [
      "components",
      "state",
      "conditional-rendering",
      "tabs"
    ],
    "description": {
      "summary": "Create an Angular tab switcher using a single activeTab value. Buttons update the value, *ngIf renders only the active panel, and active styles clearly indicate the current tab. Keep labels and click targets accessible. Angular focus: keep activeTab in the component and render with *ngIf. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Render three tabs labeled \"Overview\", \"Details\", and \"Settings\".",
          "Track which tab is currently active and visually highlight it.",
          "Render only the active tab's content at a time."
        ],
        "expectedBehavior": [
          "The initial active tab should be \"Overview\".",
          "Clicking a tab makes it the active tab.",
          "Only the active tab's panel is visible at any time.",
          "The active tab button has a distinct visual style (e.g. underline or background)."
        ],
        "implementationNotes": [
          "Store the currently active tab in a component property.",
          "Use template bindings and event handlers (e.g. `(click)`) to switch tabs.",
          "Use conditional rendering (e.g. `*ngIf`) to show/hide each panel.",
          "You can model the active tab as a union type like `'overview' | 'details' | 'settings'` for extra type safety."
        ],
        "techFocus": [
          "Basic state management in a component",
          "Conditional rendering with `*ngIf`",
          "Simple component composition and layout for tabs"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about modeling a small piece of UI state (which tab is active) and using that state to drive both styles and conditional rendering. Use a single standalone Angular component that owns an `activeTab` property. The tab buttons call a `selectTab(tab)` method, and helper logic like `isActive(tab)` feeds CSS classes and `*ngIf` checks for the content panels.\n\n**Test cases**\n- Initial render shows the Overview panel and its tab appears active.\n- Clicking Details switches the active tab and hides Overview content.\n- Clicking Settings switches again and only the Settings content is visible.\n- Re-clicking an already active tab keeps the same content and styles.",
      "approaches": [
        {
          "title": "Single standalone component with `activeTab` state",
          "prose": "Keep everything in a single `AppComponent` to emphasise basic state management and conditional rendering.\n\n1. Define a `TabId` union type: `'overview' | 'details' | 'settings'`.\n2. Add an `activeTab: TabId = 'overview';` property.\n3. Implement a `selectTab(tab: TabId)` method that simply assigns `this.activeTab = tab;`.\n4. Add a helper `isActive(tab: TabId)` that returns `this.activeTab === tab` and use it in `[class.active]` and `*ngIf` checks.\n5. Structure the template with a header row of buttons for the tabs and three conditional sections for the panels.\n\nThis mirrors real-world tab patterns but stays small enough for a beginner exercise.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ntype TabId = 'overview' | 'details' | 'settings';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <main class=\"shell\">\n      <section class=\"card\">\n        <h1>Tabs / Multi-View Switcher</h1>\n\n        <nav class=\"tabs\">\n          <button\n            class=\"tab\"\n            [class.active]=\"isActive('overview')\"\n            (click)=\"selectTab('overview')\">Overview</button>\n          <button\n            class=\"tab\"\n            [class.active]=\"isActive('details')\"\n            (click)=\"selectTab('details')\">Details</button>\n          <button\n            class=\"tab\"\n            [class.active]=\"isActive('settings')\"\n            (click)=\"selectTab('settings')\">Settings</button>\n        </nav>\n\n        <section class=\"panel\" *ngIf=\"isActive('overview')\">\n          <h2>Overview</h2>\n          <p>Show a short summary or welcome message here.</p>\n        </section>\n\n        <section class=\"panel\" *ngIf=\"isActive('details')\">\n          <h2>Details</h2>\n          <p>Display more detailed information in this panel.</p>\n        </section>\n\n        <section class=\"panel\" *ngIf=\"isActive('settings')\">\n          <h2>Settings</h2>\n          <p>Render some simple settings-like content here.</p>\n        </section>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.shell{min-height:100vh;display:grid;place-items:center;background:#020617;color:#e5e7eb;padding:24px;}`,\n    `.card{width:100%;max-width:560px;background:#020617;border-radius:16px;border:1px solid #1f2937;padding:20px 20px 24px;box-shadow:0 18px 45px rgba(15,23,42,0.8);display:grid;gap:16px;}`,\n    `.card h1{margin:0 0 4px;font-size:20px;font-weight:700;}`,\n    `.tabs{display:flex;gap:8px;padding:4px;background:#020617;border-radius:999px;border:1px solid #1f2937;}`,\n    `.tab{flex:1;padding:8px 10px;border-radius:999px;border:none;background:transparent;color:#9ca3af;font-size:13px;font-weight:600;cursor:pointer;transition:background .15s, color .15s;}`,\n    `.tab.active{background:#e5e7eb;color:#020617;}`,\n    `.panel{margin-top:4px;border-radius:12px;border:1px solid #111827;background:radial-gradient(circle at top left,#111827,#020617);padding:14px 16px;display:grid;gap:4px;}`,\n    `.panel h2{margin:0 0 4px;font-size:16px;font-weight:600;}`,\n    `.panel p{margin:0;font-size:13px;color:#d1d5db;line-height:1.5;}`\n  ]\n})\nexport class AppComponent {\n  activeTab: TabId = 'overview';\n\n  isActive(tab: TabId): boolean {\n    return this.activeTab === tab;\n  }\n\n  selectTab(tab: TabId): void {\n    this.activeTab = tab;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Hard-coding panel visibility without tying it to a single source of truth for the active tab.",
          "Forgetting to visually differentiate the active tab from inactive ones.",
          "Using separate booleans for each tab instead of a single `activeTab` value, which quickly becomes harder to manage."
        ],
        "techniques": [
          "Modeling view state with a union type for clearer intent.",
          "Using helper methods like `isActive` to keep the template clean.",
          "Applying classes conditionally with `[class.active]` to style the active tab."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-tabs.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-tabs-starter"
    },
    "companies": [
      "amazon"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-tabs-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Angular Tabs Switcher with Active Panels",
      "description": "Create a tabs component that switches active panels, updates tab state, and preserves accessible keyboard and focus behavior."
    }
  },
  {
    "id": "angular-filterable-user-list",
    "title": "Angular Filterable / Searchable User List",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "components",
      "state",
      "lists",
      "filtering",
      "forms"
    ],
    "description": {
      "summary": "Filter a user list in Angular by search and role without mutating the original array. Derive results in the template or a getter, and show an empty state when no matches exist. Angular focus: derive filtered lists in a getter or a pure pipe. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Define a fixed in-memory list of users (name, role, active flag).",
          "Render a search input that filters by name (case-insensitive).",
          "Render a role dropdown (e.g. All, Admin, Editor, Viewer) that filters by role.",
          "Render a checkbox that, when checked, shows only active users.",
          "Render the filtered list below the controls."
        ],
        "expectedBehavior": [
          "Initially, all users are shown.",
          "Typing in the search box filters users whose name includes the search text (case-insensitive).",
          "Changing the role dropdown filters by that role (or shows all roles when \"All\" is selected).",
          "Checking the \"Only active\" checkbox hides inactive users.",
          "When no users match the filters, an empty state message is shown."
        ],
        "implementationNotes": [
          "Keep a static `users` array in the component (no HTTP or services needed).",
          "Store `searchTerm`, `selectedRole`, and `showOnlyActive` as component properties.",
          "Expose a derived `filteredUsers` getter that applies all filters based on the current state.",
          "Use template bindings like `[(ngModel)]` to keep inputs in sync with component state.",
          "For a small list, client-side filtering on each render is fine; you can mention this trade-off in discussion."
        ],
        "techFocus": [
          "Standalone component setup",
          "Basic state management for multiple controls",
          "Derived state from a static data source",
          "Template-driven forms (`ngModel`) and list rendering with `*ngFor`"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about maintaining several pieces of UI state (search text, selected role, and an \"only active\" toggle) and deriving a filtered list from them. The original user list never changes; instead, a `filteredUsers` getter applies all filters on top of the static array.\n\n**Test cases**\n- With default state, all users are shown.\n- Typing part of a user's name (case-insensitive) narrows the list to matching users.\n- Selecting a role shows only users with that role, unless \"All\" is selected.\n- Checking \"Only active\" hides inactive users.\n- Combining search, role filter, and active filter works as expected.\n- When filters exclude everything, an empty state row appears.",
      "approaches": [
        {
          "title": "Standalone component with derived `filteredUsers` getter",
          "prose": "Use a single `AppComponent` that is declared as `standalone: true` and imports `CommonModule` and `FormsModule`. Define a static `users` array with a few objects like `{ id, name, role, active }` and keep your UI state in properties such as `searchTerm`, `selectedRole`, and `showOnlyActive`.\n\nImplement a `filteredUsers` getter that:\n1. Normalizes the search term to lower-case.\n2. Filters users whose names contain that term (if any is entered).\n3. Filters by `selectedRole` when a specific role is chosen.\n4. Removes inactive users when `showOnlyActive` is true.\n\nBind the inputs using `[(ngModel)]` so the component state updates as the user types or toggles controls. Use `*ngFor` to render the filtered list, and show a fallback row when `filteredUsers.length === 0`. For a minor performance touch, you can add a `trackByUserId` function to the `*ngFor`.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\ninterface User {\n  id: number;\n  name: string;\n  role: Role;\n  active: boolean;\n}\n\ntype Role = 'admin' | 'editor' | 'viewer';\n\ntype RoleFilter = 'all' | Role;\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  searchTerm = '';\n  selectedRole: RoleFilter = 'all';\n  showOnlyActive = false;\n\n  readonly users: User[] = [\n    { id: 1, name: 'Alice Johnson', role: 'admin', active: true },\n    { id: 2, name: 'Bob Smith', role: 'editor', active: false },\n    { id: 3, name: 'Charlie Kim', role: 'viewer', active: true },\n    { id: 4, name: 'Dana Patel', role: 'editor', active: true },\n    { id: 5, name: 'Elliot Brown', role: 'viewer', active: false }\n  ];\n\n  get filteredUsers(): User[] {\n    const term = this.searchTerm.trim().toLowerCase();\n\n    return this.users.filter(user => {\n      if (term && !user.name.toLowerCase().includes(term)) {\n        return false;\n      }\n\n      if (this.selectedRole !== 'all' && user.role !== this.selectedRole) {\n        return false;\n      }\n\n      if (this.showOnlyActive && !user.active) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  trackByUserId(_: number, user: User): number {\n    return user.id;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating the original `users` array instead of deriving a filtered view.",
          "Forgetting to normalize case when comparing the search term to names.",
          "Applying only one of the filters instead of combining all three.",
          "Doing heavy work directly in the template instead of in a getter or method."
        ],
        "techniques": [
          "Using a standalone component with `CommonModule` and `FormsModule`.",
          "Keeping original data immutable and deriving filtered views.",
          "Using `[(ngModel)]` for simple controlled inputs in Angular.",
          "Using `trackBy` with `*ngFor` for a minor performance improvement."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-filterable-user-list.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-filterable-user-list"
    },
    "companies": [],
    "solutionAsset": "assets/sb/angular/solution/angular-filterable-user-list-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Filterable User List in Angular",
      "description": "Create a user list that filters by search text and role criteria, with clear behavior when no records match."
    }
  },
  {
    "id": "angular-faq-accordion",
    "title": "Angular Accordion / FAQ Component",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "components",
      "inputs",
      "outputs",
      "state",
      "interactivity"
    ],
    "description": {
      "summary": "Build a simple FAQ (accordion) component in Angular using inputs/outputs. Clicking a question should toggle its answer. By default, only one item can be open at a time, but the user can enable a mode where multiple items can stay open. Concepts: components, inputs, outputs. Angular focus: use @Input/@Output for item state and a parent controller for open indexes.",
      "specs": {
        "requirements": [
          "Use a standalone root component and at least one child component for a single FAQ item.",
          "Render a list of 3–4 FAQ items (question + answer) from an in-memory array.",
          "Clicking on a question toggles its answer open/closed.",
          "In the default mode, only one FAQ item can be open at a time.",
          "Add a simple control (e.g. a toggle or checkbox) to switch to 'allow multiple open' mode.",
          "In 'allow multiple open' mode, the user should be able to open more than one FAQ item at once."
        ],
        "expectedBehavior": [
          "Initially all FAQ items are closed.",
          "Clicking a closed question opens its answer.",
          "In single-open mode: opening one item automatically closes any other open item.",
          "Switching to multi-open mode keeps already open items and allows opening others.",
          "Clicking an open question closes its answer in both modes."
        ],
        "implementationNotes": [
          "Keep the data (questions/answers and open state) in the parent component.",
          "Create a child component (e.g. `FaqItemComponent`) that receives `question`, `answer`, and `isOpen` as inputs and emits a `toggle` event when its header is clicked.",
          "Use `*ngFor` in the parent template to render FAQ items.",
          "You can use simple CSS transitions (e.g. `max-height` or `opacity`) for a smooth open/close animation, but this is optional."
        ],
        "techFocus": [
          "Parent → child data flow with `@Input` and `@Output`",
          "Controlled vs uncontrolled state (parent controlling which index is open)",
          "Conditional rendering with `*ngIf` or `ngClass`",
          "Basic UI state toggling and list rendering"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about lifting state up to the parent component and controlling which FAQ items are open. The parent holds an array of FAQ items (question + answer) and a representation of which indexes are currently open. Each child row displays a question and conditionally shows its answer.\n\nIn the default (single-open) mode, the parent keeps at most one index in its open list. When the user clicks a question, the parent either sets that index as the only open one or clears it if it was already open. In multi-open mode, the parent treats the list of open indexes like a set: clicking an item either adds or removes that index.\n\n**Test cases**\n- Initially, all answers are hidden.\n- Click the first question → its answer becomes visible, others stay closed.\n- In single-open mode, clicking a second question closes the first and opens the second.\n- Switch to multi-open mode → currently open item(s) stay open, and you can open additional ones without closing the others.\n- Clicking an open item closes it in both modes. Key concepts: components, inputs, outputs.",
      "approaches": [
        {
          "title": "Parent-controlled open indexes with a child FAQ item component",
          "prose": "Use a standalone `AppComponent` as the parent that owns:\n\n1. A `faqItems` array of plain objects (`{ question, answer }`).\n2. A boolean `allowMultiple` flag controlled by a checkbox or toggle in the UI.\n3. An array `openIndexes: number[]` that stores the indexes of currently open FAQ items.\n\nImplement two methods:\n- `isItemOpen(index: number): boolean` → returns whether the given index is currently open.\n- `onItemToggle(index: number)` → updates `openIndexes` based on `allowMultiple`.\n\nIn single-open mode, `onItemToggle` should behave like a radio group: either an item is the only open one or there are none. In multi-open mode, it behaves like a set: clicking an item toggles its presence in `openIndexes`. The child `FaqItemComponent` is kept dumb – it only receives data and emits a `toggle` event, leaving all state decisions to the parent.",
          "codeTs": "import { Component, EventEmitter, Input, Output } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ninterface FaqItem {\n  question: string;\n  answer: string;\n}\n\n@Component({\n  selector: 'app-faq-item',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <article class=\"faq-item\" [class.open]=\"isOpen\">\n      <button class=\"faq-header\" type=\"button\" (click)=\"toggle.emit()\" aria-expanded=\"{{ isOpen }}\">\n        <span class=\"question\">{{ question }}</span>\n        <span class=\"indicator\">{{ isOpen ? '-' : '+' }}</span>\n      </button>\n      <div class=\"faq-body\" *ngIf=\"isOpen\">\n        <p>{{ answer }}</p>\n      </div>\n    </article>\n  `,\n  styles: [\n    `.faq-item{border-radius:12px;background:#0b1020;border:1px solid #1f2937;overflow:hidden;}`,\n    `.faq-item + .faq-item{margin-top:8px;}`,\n    `.faq-header{width:100%;padding:12px 14px;background:transparent;border:none;display:flex;justify-content:space-between;align-items:center;color:#e5e7eb;cursor:pointer;font-size:14px;}`,\n    `.indicator{font-weight:700;}`,\n    `.faq-body{padding:0 14px 12px;font-size:13px;color:#9ca3af;}`\n  ]\n})\nexport class FaqItemComponent {\n  @Input() question = '';\n  @Input() answer = '';\n  @Input() isOpen = false;\n  @Output() toggle = new EventEmitter<void>();\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, FaqItemComponent],\n  template: `\n    <main class=\"app\">\n      <section class=\"card\">\n        <header class=\"header\">\n          <h1>FAQ</h1>\n          <label class=\"switch\">\n            <input type=\"checkbox\" [checked]=\"allowMultiple\" (change)=\"onToggleAllowMultiple()\" />\n            <span>Allow multiple open</span>\n          </label>\n        </header>\n\n        <div class=\"list\">\n          <app-faq-item\n            *ngFor=\"let item of faqItems; index as i\"\n            [question]=\"item.question\"\n            [answer]=\"item.answer\"\n            [isOpen]=\"isItemOpen(i)\"\n            (toggle)=\"onItemToggle(i)\">\n          </app-faq-item>\n        </div>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.app{min-height:100vh;display:grid;place-items:center;background:#020617;color:#e5e7eb;padding:24px;}`,\n    `.card{width:100%;max-width:520px;background:#020617;border-radius:16px;border:1px solid #1f2937;padding:20px;}`,\n    `.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;}`,\n    `.header h1{font-size:20px;margin:0;}`,\n    `.switch{display:flex;align-items:center;gap:6px;font-size:12px;color:#9ca3af;}`\n  ]\n})\nexport class AppComponent {\n  faqItems: FaqItem[] = [\n    {\n      question: 'Lorem ipsum dolor sit amet?',\n      answer: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus euismod, posuere justo ut, pulvinar neque.'\n    },\n    {\n      question: 'Curabitur blandit tempus porttitor?',\n      answer: 'Curabitur blandit tempus porttitor. Integer posuere erat a ante venenatis dapibus posuere velit aliquet.'\n    },\n    {\n      question: 'Aenean lacinia bibendum nulla sed consectetur?',\n      answer: 'Aenean lacinia bibendum nulla sed consectetur. Cras justo odio, dapibus ac facilisis in, egestas eget quam.'\n    },\n    {\n      question: 'Vivamus sagittis lacus vel augue laoreet rutrum?',\n      answer: 'Vivamus sagittis lacus vel augue laoreet rutrum faucibus dolor auctor. Maecenas faucibus mollis interdum.'\n    }\n  ];\n\n  allowMultiple = false;\n  openIndexes: number[] = [];\n\n  isItemOpen(index: number): boolean {\n    return this.openIndexes.includes(index);\n  }\n\n  onItemToggle(index: number): void {\n    const currentlyOpen = this.isItemOpen(index);\n\n    if (this.allowMultiple) {\n      // Treat as a set\n      this.openIndexes = currentlyOpen\n        ? this.openIndexes.filter(i => i !== index)\n        : [...this.openIndexes, index];\n      return;\n    }\n\n    // Single-open mode\n    if (currentlyOpen) {\n      this.openIndexes = [];\n    } else {\n      this.openIndexes = [index];\n    }\n  }\n\n  onToggleAllowMultiple(): void {\n    this.allowMultiple = !this.allowMultiple;\n    if (!this.allowMultiple && this.openIndexes.length > 1) {\n      // Keep only the first open item in single-open mode\n      this.openIndexes = this.openIndexes.length ? [this.openIndexes[0]] : [];\n    }\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Letting each item manage its own open/closed state, which makes it hard to enforce 'only one open at a time'.",
          "Using index-based state but forgetting to clear other indexes in single-open mode.",
          "Directly mutating the `faqItems` array to store UI-only state instead of keeping a separate `openIndexes` representation."
        ],
        "techniques": [
          "Keeping view data (question/answer) separate from UI state (open indexes).",
          "Using a child component with `@Input`/`@Output` to keep the parent in full control of state.",
          "Deriving `isItemOpen` from an array of indexes instead of storing booleans on each item."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-faq-accordion.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-faq-accordion"
    },
    "solutionAsset": "assets/sb/angular/solution/angular-faq-accordion-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build FAQ Accordion Component in Angular",
      "description": "Create an accordion that expands and collapses FAQ items with configurable single-open or multi-open behavior."
    }
  },
  {
    "id": "angular-pagination-table",
    "title": "Angular Paginated Data Table",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "components",
      "state",
      "pagination",
      "arrays",
      "derived-state"
    ],
    "description": {
      "summary": "Build a simple paginated data table in Angular that shows a static list of users. Display 5 rows per page, with Previous / Next controls and a \"Page X of Y\" indicator. Disable the navigation buttons appropriately on the first and last pages. Concepts: components, state, pagination. Angular focus: keep page index in component state and derive page slices. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Render a static list (20–30 items) of users in a table (id, name, email, role).",
          "Show 5 rows per page.",
          "Add \"Previous\" and \"Next\" buttons to change the current page.",
          "Display the current page and total pages (e.g. \"Page 2 of 5\").",
          "Disable the \"Previous\" button on the first page.",
          "Disable the \"Next\" button on the last page."
        ],
        "expectedBehavior": [
          "Initially, the table shows the first 5 users (page 1).",
          "Clicking \"Next\" advances to the next 5 users, until the last page.",
          "Clicking \"Previous\" goes back one page, until the first page.",
          "On the first page, \"Previous\" is disabled and cannot change the page.",
          "On the last page, \"Next\" is disabled and cannot change the page.",
          "The label \"Page X of Y\" always reflects the state correctly (X is 1-based)."
        ],
        "implementationNotes": [
          "Store the current page index in a component property (e.g. `currentPage = 0`).",
          "Keep the full list in a single readonly array on the component.",
          "Use a derived getter (e.g. `pagedUsers`) that slices the array based on `currentPage` and `pageSize`.",
          "Use additional getters like `isFirstPage` and `isLastPage` to drive button disabled state."
        ],
        "techFocus": [
          "Component-level state for pagination (`currentPage`).",
          "Derived data using `slice(start, end)`.",
          "Handling edge cases in UI state (first/last page).",
          "Clean template bindings for lists (`*ngFor`) and button states (`[disabled]`)."
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise centers around a single state variable: the current page index. The full dataset lives in a static array on the component. From that, you derive everything else: the total number of pages, the slice of users to display, and whether Previous/Next buttons should be disabled.\n\n**Core ideas**\n- Keep `currentPage` as a number (0-based is convenient for array math).\n- Use a constant `pageSize = 5`.\n- Compute `totalPages` with `Math.ceil(users.length / pageSize)`.\n- Derive `pagedUsers` by slicing the big array based on `currentPage` and `pageSize`.\n- Expose small boolean getters like `isFirstPage` and `isLastPage` to keep the template clean.\n\n**Test cases**\n- Initial render → shows the first 5 users, label reads `Page 1 of N`, and Previous is disabled.\n- Clicking Next repeatedly moves through the list in chunks of 5 until the last page, then Next becomes disabled.\n- Clicking Previous from any page > 1 moves back a page until page 1.\n- The label always matches the current page index, and buttons are never enabled when they should be disabled. Key concepts: components, state, pagination.",
      "approaches": [
        {
          "title": "Standalone component with derived pagination slice",
          "prose": "Use a single standalone `AppComponent` that holds the full users array and pagination state.\n\n1. Define a `User` type and a constant `USERS` array with ~20–30 users.\n2. In the component, expose `readonly users = USERS;`, a `pageSize = 5;` and `currentPage = 0;`.\n3. Add getters `totalPages`, `pagedUsers`, `isFirstPage`, and `isLastPage`.\n   - `totalPages` uses `Math.ceil(this.users.length / this.pageSize)`.\n   - `pagedUsers` computes `start = currentPage * pageSize` and `end = start + pageSize` and returns `this.users.slice(start, end)`.\n4. Implement `goToPrevious()` and `goToNext()` so they guard against going before page 0 or past the last page.\n5. In the template, render the table rows with `*ngFor=\"let user of pagedUsers\"` and bind the button `disabled` flags to `isFirstPage` / `isLastPage`.\n\nThis keeps the logic simple, shows a clear separation between state and derived data, and matches how you'd wire pagination in a real-world Angular component.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ntype User = {\n  id: number;\n  name: string;\n  email: string;\n  role: string;\n};\n\nconst USERS: User[] = [\n  { id: 1, name: 'Alice Johnson', email: 'alice@example.com', role: 'Admin' },\n  { id: 2, name: 'Bob Smith', email: 'bob@example.com', role: 'Editor' },\n  { id: 3, name: 'Carla Perez', email: 'carla@example.com', role: 'Viewer' },\n  { id: 4, name: 'David Kim', email: 'david@example.com', role: 'Editor' },\n  { id: 5, name: 'Emma Brown', email: 'emma@example.com', role: 'Viewer' },\n  { id: 6, name: 'Frank Wu', email: 'frank@example.com', role: 'Admin' },\n  { id: 7, name: 'Grace Lee', email: 'grace@example.com', role: 'Viewer' },\n  { id: 8, name: 'Henry Ford', email: 'henry@example.com', role: 'Editor' },\n  { id: 9, name: 'Ivy Stone', email: 'ivy@example.com', role: 'Viewer' },\n  { id: 10, name: 'Jack Ryan', email: 'jack@example.com', role: 'Viewer' },\n  { id: 11, name: 'Karen Diaz', email: 'karen@example.com', role: 'Editor' },\n  { id: 12, name: 'Leo Walker', email: 'leo@example.com', role: 'Viewer' },\n  { id: 13, name: 'Mia Clark', email: 'mia@example.com', role: 'Admin' },\n  { id: 14, name: 'Noah Hall', email: 'noah@example.com', role: 'Viewer' },\n  { id: 15, name: 'Olivia King', email: 'olivia@example.com', role: 'Editor' },\n  { id: 16, name: 'Paul Green', email: 'paul@example.com', role: 'Viewer' },\n  { id: 17, name: 'Quinn Ross', email: 'quinn@example.com', role: 'Viewer' },\n  { id: 18, name: 'Rita Long', email: 'rita@example.com', role: 'Editor' },\n  { id: 19, name: 'Sam Young', email: 'sam@example.com', role: 'Viewer' },\n  { id: 20, name: 'Tina Fox', email: 'tina@example.com', role: 'Viewer' }\n];\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  readonly users = USERS;\n  readonly pageSize = 5;\n  currentPage = 0; // 0-based\n\n  get totalPages(): number {\n    return Math.ceil(this.users.length / this.pageSize) || 1;\n  }\n\n  get pagedUsers(): User[] {\n    const start = this.currentPage * this.pageSize;\n    const end = start + this.pageSize;\n    return this.users.slice(start, end);\n  }\n\n  get isFirstPage(): boolean {\n    return this.currentPage === 0;\n  }\n\n  get isLastPage(): boolean {\n    return this.currentPage >= this.totalPages - 1;\n  }\n\n  goToPrevious(): void {\n    if (!this.isFirstPage) {\n      this.currentPage--;\n    }\n  }\n\n  goToNext(): void {\n    if (!this.isLastPage) {\n      this.currentPage++;\n    }\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Treating `currentPage` as 1-based while doing slice calculations, which makes `start` / `end` off by one.",
          "Forgetting to guard the page change functions, causing `currentPage` to go negative or past the last page.",
          "Computing the slice inline in the template instead of using a getter, which hurts readability and testability.",
          "Not updating the disabled state of the buttons, so users can still click Previous on the first page or Next on the last page."
        ],
        "techniques": [
          "Using a standalone Angular component (`standalone: true`) with `bootstrapApplication`.",
          "Deriving UI data from minimal state (current page + array length).",
          "Using getters for small bits of view logic (page slice, first/last flags).",
          "Keeping the dataset static and focusing purely on pagination behavior."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-pagination-table.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-pagination-table"
    },
    "companies": [],
    "solutionAsset": "assets/sb/angular/solution/angular-pagination-table-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Paginated Data Table in Angular",
      "description": "Create a data table with page navigation that displays only current-page rows and handles first or last page boundaries."
    }
  },
  {
    "id": "angular-theme-toggle",
    "title": "Angular Theme Toggle with Persisted Light/Dark Mode",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "components",
      "services",
      "dependency-injection",
      "state",
      "local-storage",
      "theming"
    ],
    "description": {
      "summary": "Implement an Angular light/dark theme toggle with persistence. Store the theme in localStorage, apply it to the root element, and keep the toggle label/icon in sync across reloads and new sessions. Concepts: components, services, dependency-injection. Angular focus: use a ThemeService to persist theme and apply it to the root element. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Render a main page layout with a simple content card and a theme toggle control in the top-right corner.",
          "Support two themes: \"light\" and \"dark\".",
          "Store the current theme in a dedicated Angular service (global-ish state).",
          "Persist the selected theme in localStorage under a stable key.",
          "On initial load, read the theme from localStorage and apply it before the user interacts.",
          "Apply the theme at the document level by setting `data-theme` on `<html>`, so that the existing CSS can react to it.",
          "You only need to edit TypeScript files: `/src/app/theme.service.ts` and `/src/app/app.component.ts`. All CSS files are already wired to respond to `data-theme` and should be left as-is."
        ],
        "expectedBehavior": [
          "By default, the app starts in light mode if there is no previous theme stored.",
          "If the user toggles to dark mode, the page background, text, and card colors change.",
          "Reloading the page keeps the user’s last theme selection (light or dark).",
          "The toggle UI (label or icon) always reflects the actual current theme.",
          "Switching themes is instant and does not require a full reload."
        ],
        "implementationNotes": [
          "`/src/app/theme.service.ts`: Use an Angular service (e.g. `ThemeService`) to hold global theme state, read/write localStorage, and update the `data-theme` attribute on `<html>`.",
          "`/src/app/app.component.ts`: Inject the service, expose an `isDark` getter based on `themeService.currentTheme`, and wire the toggle button to `themeService.toggleTheme()`.",
          "The CSS in `/src/app/app.component.css` and `/src/styles.css` is already configured: it uses `:root` / `:root[data-theme='dark']` and `:host-context([data-theme='dark'])` rules to switch page, card, and toggle colors when `data-theme` changes.",
          "You do not need to modify any CSS for this exercise; just drive the theme state and `data-theme` from the service.",
          "Avoid duplicating theme logic in multiple components; treat the service as the single source of truth."
        ],
        "techFocus": [
          "Angular services and dependency injection",
          "Global-ish state via a shared service",
          "Side-effects and initialization logic (constructor / app bootstrap)",
          "Using localStorage safely in a browser environment",
          "Simple theming by driving `data-theme` on `<html>` and letting existing CSS respond"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about lifting theme state into a global Angular service and wiring it to both the UI and the DOM. You store the current theme (\"light\" or \"dark\") in a `ThemeService`, read an initial value from localStorage when the service is created, and apply that value to the `<html>` element via a `data-theme` attribute. The root `AppComponent` injects this service, shows a toggle in the top-right corner, and delegates all theme changes to the service. The provided CSS (in `styles.css` and `app.component.css`) already listens to `data-theme` using `:root[data-theme='dark']` and `:host-context([data-theme='dark'])`, so you don't need to touch any styles.\n\n**Test cases**\n- First visit with empty localStorage → app starts in light mode and shows the light theme.\n- Click the toggle once → app switches to dark mode, the page background becomes dark, and the toggle shows dark mode.\n- Reload the page after switching to dark mode → app initializes in dark mode, without a visible flash back to light.\n- Toggle back to light → theme changes immediately and localStorage is updated.\n- The toggle label/icon always matches the active theme. Key concepts: components, services, dependency-injection.",
      "approaches": [
        {
          "title": "Global ThemeService with `data-theme` on `<html>`",
          "prose": "Use a dedicated `ThemeService` as the global source of truth for the theme.\n\n1. Define a `Theme` type alias (`'light' | 'dark'`) and a stable localStorage key.\n2. In the service constructor, read from localStorage; if a value exists, use it; otherwise default to `'light'`. After deciding the initial theme, immediately apply it to `document.documentElement` (e.g. via `setAttribute('data-theme', theme)`).\n3. Expose a `currentTheme` property, a `setTheme(theme)` method, and a `toggleTheme()` helper.\n   - `setTheme(theme)` updates `currentTheme`, writes it to localStorage, and updates the `<html>` `data-theme`.\n   - `toggleTheme()` flips between `'light'` and `'dark'` using `setTheme`.\n4. In `AppComponent`, inject `ThemeService` and expose a getter `isDark` that checks `themeService.currentTheme === 'dark'`.\n5. Bind the toggle button to `onToggleClick()` which calls `themeService.toggleTheme()`. Use `isDark` to set the button label/icon (e.g. show the moon when in dark mode).\n6. The existing CSS in `styles.css` and `app.component.css` uses `:root[data-theme='dark']` and `:host-context([data-theme='dark'])` to change background, text, and card colors based on `data-theme`, so no CSS changes are required.\n\nThis implementation keeps theme state in one place, uses DI for access, and demonstrates a clean separation between state (service), UI (component), and styling (preconfigured CSS that reacts to `data-theme`).",
          "codeTs": "import { Component, inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ThemeService } from './theme.service';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  readonly themeService = inject(ThemeService);\n\n  get isDark(): boolean {\n    return this.themeService.currentTheme === 'dark';\n  }\n\n  onToggleClick(): void {\n    this.themeService.toggleTheme();\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Reading from localStorage too late (e.g. after the first render), causing a visible flash from light to dark.",
          "Forgetting to actually apply the theme to the document (only changing the label but not colors).",
          "Using multiple sources of truth for the theme (e.g. duplicating theme state in both component and service).",
          "Trying to change the CSS instead of driving the existing `data-theme`-based styles from the service."
        ],
        "techniques": [
          "Using an Angular service as a global singleton to hold app-wide state.",
          "Injecting `DOCUMENT` from `@angular/common` to manipulate the root element safely.",
          "Encapsulating side-effects (localStorage reads/writes, DOM attribute updates) inside the service instead of scattering them across components.",
          "Letting preconfigured CSS (`:root[data-theme='dark']` and `:host-context([data-theme='dark'])`) handle visual changes while the service only controls `data-theme`."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-theme-toggle.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-theme-toggle"
    },
    "companies": [],
    "solutionAsset": "assets/sb/angular/solution/angular-theme-toggle-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Angular Theme Toggle with Persistence",
      "description": "Create a theme toggle that applies light or dark mode globally and restores the saved preference on reload."
    }
  },
  {
    "id": "angular-multi-step-form-starter",
    "title": "Multi-step Signup Form (Reactive Forms)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "forms",
      "reactive-forms",
      "validation",
      "components",
      "state"
    ],
    "description": {
      "summary": "Build a 3-step signup flow using Angular reactive forms: basic info, address info, and a summary + submit step. Each step should only allow moving forward when its fields are valid.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Use Angular reactive forms (`FormGroup`, `FormBuilder`, `Validators`) with nested form groups.",
          "Step 1 (Basic info): capture `name` and `email` fields.",
          "Step 2 (Address info): capture `street`, `city`, `country`, and optionally `postalCode`.",
          "Step 3 (Summary): display a read-only summary of all collected values and provide a `Submit` button.",
          "The `Next` button should be disabled unless the current step's group is valid.",
          "Preserve entered values when navigating back and forth between steps.",
          "(Optional) Add a `Back` button to move to the previous step."
        ],
        "expectedBehavior": [
          "The flow starts on Step 1 (Basic info).",
          "On Step 1, `Next` is disabled until both `name` and `email` are valid (required + valid email).",
          "On Step 2, `Next` is disabled until required address fields are valid.",
          "Clicking `Next` on a valid step moves to the next step.",
          "Clicking `Back` moves to the previous step without losing already entered values.",
          "On Step 3, the user sees a summary of all fields and a `Submit` button.",
          "Clicking `Submit` validates the entire form and (for this exercise) logs or otherwise handles the collected data."
        ],
        "implementationNotes": [
          "Use a single top-level `FormGroup` with nested groups like `basic` and `address` to keep form state centralized.",
          "Track the current step with a simple number index (e.g. `currentStep = 0 | 1 | 2`).",
          "Expose convenience getters like `basicGroup` and `addressGroup` for cleaner template bindings.",
          "Use `markAllAsTouched()` before moving forward or submitting, so validation errors show up immediately.",
          "Derive boolean helpers like `isFirstStep`, `isLastStep`, and `canGoNext` in the component instead of scattering conditions in the template."
        ],
        "techFocus": [
          "Angular reactive forms",
          "Grouping related controls with nested `FormGroup`s",
          "Form validation and disabled states",
          "Managing multi-step UI state in a single component",
          "Basic UI architecture for a wizard-like flow"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about centralizing form state with Angular reactive forms and wiring a simple stepper on top of it. A good solution uses a single top-level `FormGroup` with nested groups for each step (`basic`, `address`) and a `currentStep` number to control which UI section is visible.\n\nThe core idea is:\n- Model all fields in one `FormGroup` to avoid juggling separate pieces of state.\n- Use per-step validation by checking only the current group's validity when deciding if the user can go to the next step.\n- Derive booleans for `canGoNext`, `isFirstStep`, and `isLastStep` instead of hard-coding conditions in the template.\n\n**Test cases**\n- Initial load → Step 1 is shown, `Next` is disabled.\n- Fill valid `name` and `email`, click `Next` → moves to Step 2.\n- On Step 2 with invalid address fields → `Next` stays disabled and/or shows validation errors when attempted.\n- After filling valid address, click `Next` → Step 3 shows a summary of all values.\n- Click `Back` from Step 3 → Step 2 is shown with previously entered data intact.\n- Click `Submit` on Step 3 with valid data → form is processed (e.g. logged) and no validation errors are shown.",
      "approaches": [
        {
          "title": "Single reactive FormGroup with nested groups and step index",
          "prose": "Use one top-level reactive `FormGroup` that contains nested groups for each logical step, plus a simple `currentStep` number to control the view.\n\n1. Inject `FormBuilder` and create the form in the constructor or as a class property. For example:\n   - `basic` group with `name` and `email` (required + email validator).\n   - `address` group with `street`, `city`, `country`, and optional `postalCode`.\n2. Keep `currentStep` as a number (0, 1, 2) and derive helpers like `isFirstStep`, `isLastStep`, and `canGoNext`.\n3. When the user clicks `Next`, call `markAllAsTouched()` on the current group's controls. Only move to the next step if that group is valid.\n4. Implement `Back` by simply decrementing `currentStep` when possible.\n5. For `Submit`, mark the whole form as touched, check `form.valid`, and then log or otherwise handle the data.\n\nThis approach keeps all state and rules in one place, and the template becomes mostly a projection of the current step with bindings to the appropriate nested group.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, ReactiveFormsModule],\n  template: `\n    <main class=\"app\">\n      <section class=\"card\" [formGroup]=\"form\">\n        <header class=\"header\">\n          <h1>Multi-step Signup</h1>\n          <p class=\"subtitle\">Step {{ currentStep + 1 }} of 3</p>\n        </header>\n\n        <section class=\"steps\" [ngSwitch]=\"currentStep\">\n          <!-- Step 1: Basic info -->\n          <div *ngSwitchCase=\"0\" formGroupName=\"basic\" class=\"step\">\n            <h2 class=\"step-title\">Basic info</h2>\n            <label class=\"field\">\n              <span>Name</span>\n              <input type=\"text\" formControlName=\"name\" placeholder=\"Jane Doe\" />\n              <small class=\"error\" *ngIf=\"basicGroup.get('name')?.touched && basicGroup.get('name')?.invalid\">\n                Name is required.\n              </small>\n            </label>\n\n            <label class=\"field\">\n              <span>Email</span>\n              <input type=\"email\" formControlName=\"email\" placeholder=\"jane@example.com\" />\n              <small class=\"error\" *ngIf=\"basicGroup.get('email')?.touched && basicGroup.get('email')?.invalid\">\n                Please enter a valid email.\n              </small>\n            </label>\n          </div>\n\n          <!-- Step 2: Address info -->\n          <div *ngSwitchCase=\"1\" formGroupName=\"address\" class=\"step\">\n            <h2 class=\"step-title\">Address</h2>\n            <label class=\"field\">\n              <span>Street</span>\n              <input type=\"text\" formControlName=\"street\" placeholder=\"123 Main St\" />\n              <small class=\"error\" *ngIf=\"addressGroup.get('street')?.touched && addressGroup.get('street')?.invalid\">\n                Street is required.\n              </small>\n            </label>\n\n            <label class=\"field\">\n              <span>City</span>\n              <input type=\"text\" formControlName=\"city\" placeholder=\"Istanbul\" />\n              <small class=\"error\" *ngIf=\"addressGroup.get('city')?.touched && addressGroup.get('city')?.invalid\">\n                City is required.\n              </small>\n            </label>\n\n            <label class=\"field\">\n              <span>Country</span>\n              <input type=\"text\" formControlName=\"country\" placeholder=\"Türkiye\" />\n              <small class=\"error\" *ngIf=\"addressGroup.get('country')?.touched && addressGroup.get('country')?.invalid\">\n                Country is required.\n              </small>\n            </label>\n\n            <label class=\"field\">\n              <span>Postal code (optional)</span>\n              <input type=\"text\" formControlName=\"postalCode\" placeholder=\"34000\" />\n            </label>\n          </div>\n\n          <!-- Step 3: Summary -->\n          <div *ngSwitchCase=\"2\" class=\"step\">\n            <h2 class=\"step-title\">Summary</h2>\n            <div class=\"summary\">\n              <h3>Basic info</h3>\n              <p><strong>Name:</strong> {{ basicGroup.get('name')?.value }}</p>\n              <p><strong>Email:</strong> {{ basicGroup.get('email')?.value }}</p>\n\n              <h3>Address</h3>\n              <p><strong>Street:</strong> {{ addressGroup.get('street')?.value }}</p>\n              <p><strong>City:</strong> {{ addressGroup.get('city')?.value }}</p>\n              <p><strong>Country:</strong> {{ addressGroup.get('country')?.value }}</p>\n              <p><strong>Postal code:</strong> {{ addressGroup.get('postalCode')?.value || '—' }}</p>\n            </div>\n          </div>\n        </section>\n\n        <footer class=\"actions\">\n          <button type=\"button\" class=\"ghost\" (click)=\"prev()\" [disabled]=\"isFirstStep\">\n            Back\n          </button>\n\n          <button\n            *ngIf=\"!isLastStep\"\n            type=\"button\"\n            (click)=\"next()\"\n            [disabled]=\"!canGoNext\"\n          >\n            Next\n          </button>\n\n          <button\n            *ngIf=\"isLastStep\"\n            type=\"button\"\n            class=\"primary\"\n            (click)=\"submit()\"\n          >\n            Submit\n          </button>\n        </footer>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.app{min-height:100vh;display:grid;place-items:center;background:#020617;color:#e5e7eb;padding:24px;}`,\n    `.card{width:100%;max-width:520px;background:#020617;border-radius:16px;border:1px solid #1f2937;padding:20px 20px 16px;display:grid;gap:16px;}`,\n    `.header h1{margin:0;font-size:20px;font-weight:700;}`,\n    `.subtitle{margin:4px 0 0;font-size:13px;color:#9ca3af;}`,\n    `.steps{min-height:260px;}`,\n    `.step{display:grid;gap:12px;}`,\n    `.step-title{margin:0 0 4px;font-size:16px;font-weight:600;}`,\n    `.field{display:grid;gap:4px;font-size:13px;}`,\n    `.field span{color:#e5e7eb;}`,\n    `.field input{border-radius:10px;border:1px solid #374151;background:#020617;padding:8px 10px;color:#e5e7eb;font-size:14px;}`,\n    `.field input:focus{outline:none;border-color:#a3e635;}`,\n    `.error{font-size:11px;color:#f97316;}`,\n    `.summary{display:grid;gap:4px;font-size:14px;}`,\n    `.summary h3{margin:8px 0 2px;font-size:14px;font-weight:600;color:#e5e7eb;}`,\n    `.actions{display:flex;justify-content:space-between;gap:8px;margin-top:4px;}`,\n    `.actions button{border-radius:999px;border:1px solid #374151;background:#020617;color:#e5e7eb;padding:8px 16px;font-size:14px;font-weight:600;cursor:pointer;}`,\n    `.actions button.primary{background:#a3e635;color:#020617;border-color:#a3e635;}`,\n    `.actions button[disabled]{opacity:.5;cursor:not-allowed;}`,\n    `.actions button.ghost{background:transparent;}`\n  ]\n})\nexport class AppComponent {\n  readonly lastStepIndex = 2;\n  currentStep = 0;\n\n  constructor(private fb: FormBuilder) {}\n\n  form: FormGroup = this.fb.group({\n    basic: this.fb.group({\n      name: ['', Validators.required],\n      email: ['', [Validators.required, Validators.email]]\n    }),\n    address: this.fb.group({\n      street: ['', Validators.required],\n      city: ['', Validators.required],\n      country: ['', Validators.required],\n      postalCode: ['']\n    })\n  });\n\n  get basicGroup(): FormGroup {\n    return this.form.get('basic') as FormGroup;\n  }\n\n  get addressGroup(): FormGroup {\n    return this.form.get('address') as FormGroup;\n  }\n\n  get isFirstStep(): boolean {\n    return this.currentStep === 0;\n  }\n\n  get isLastStep(): boolean {\n    return this.currentStep === this.lastStepIndex;\n  }\n\n  get canGoNext(): boolean {\n    if (this.currentStep === 0) {\n      return this.basicGroup.valid;\n    }\n    if (this.currentStep === 1) {\n      return this.addressGroup.valid;\n    }\n    return false;\n  }\n\n  private currentGroup(): FormGroup {\n    if (this.currentStep === 0) return this.basicGroup;\n    if (this.currentStep === 1) return this.addressGroup;\n    return this.form;\n  }\n\n  next(): void {\n    const group = this.currentGroup();\n    group.markAllAsTouched();\n    if (group.invalid) {\n      return;\n    }\n    if (!this.isLastStep) {\n      this.currentStep++;\n    }\n  }\n\n  prev(): void {\n    if (!this.isFirstStep) {\n      this.currentStep--;\n    }\n  }\n\n  submit(): void {\n    this.form.markAllAsTouched();\n    if (this.form.invalid) {\n      return;\n    }\n    console.log('Signup submitted', this.form.value);\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Managing each step as a completely separate form, which makes it harder to submit a single payload at the end.",
          "Allowing `Next` to move forward even when the current step is invalid, causing confusing validation behavior on later steps.",
          "Not marking controls as touched before checking validity, so users never see why they cannot proceed.",
          "Mutating `currentStep` from the template instead of keeping navigation logic in clear methods."
        ],
        "techniques": [
          "Grouping related fields under nested `FormGroup`s (`basic`, `address`) for cleaner validation and payload structure.",
          "Using helper getters (`basicGroup`, `addressGroup`, `canGoNext`, `isFirstStep`, `isLastStep`) to keep templates declarative.",
          "Calling `markAllAsTouched()` before moving forward or submitting to surface validation errors.",
          "Using `ngSwitch` in the template to keep each step's markup focused and easy to read."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-multi-step-form.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-multi-step-form-starter"
    },
    "companies": [],
    "solutionAsset": "assets/sb/angular/solution/angular-multi-step-form-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Multi-Step Signup Form in Angular",
      "description": "Create a multi-step signup flow with step validation, navigation controls, and a final review before submission."
    }
  },
  {
    "id": "angular-shopping-cart-mini",
    "title": "Shopping Cart Mini (Standalone Component)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "components",
      "state",
      "derived-state",
      "arrays",
      "immutability",
      "change-detection"
    ],
    "description": {
      "summary": "Build a small shopping cart UI using an Angular standalone component. Render a product list with \"Add to cart\" buttons and a cart section where you can increase/decrease quantities, remove items, and show derived totals. Concepts: components, state, derived-state.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Render a static product list with name and price for each product.",
          "Each product should have an \"Add to cart\" button.",
          "Render a cart section that lists all items currently in the cart.",
          "Each cart item should show name, unit price, quantity, and line total (price × quantity).",
          "In the cart, allow increasing and decreasing the quantity of an item.",
          "Allow removing an item from the cart entirely.",
          "Show derived totals: overall item count (total quantity) and total price for the entire cart.",
          "Keep the cart state in a nested structure (e.g. an array of `cartItems`)."
        ],
        "expectedBehavior": [
          "Clicking \"Add to cart\" for a product adds it to the cart with quantity 1 (or increments the quantity if it already exists).",
          "Clicking \"+\" in the cart increases that item's quantity by 1.",
          "Clicking \"−\" in the cart decreases that item's quantity by 1; if it reaches 0, the item can be removed or clamped at 1 (depending on your chosen UX).",
          "Clicking \"Remove\" deletes the item from the cart.",
          "Total quantity updates whenever items are added, removed, or their quantities change.",
          "Total price updates whenever items are added, removed, or their quantities change.",
          "UI stays in sync with state without manual DOM manipulation."
        ],
        "implementationNotes": [
          "Use a nested state structure for the cart, e.g. `cartItems: { id, name, price, quantity }[]`.",
          "Prefer immutable-style updates for the cart array (e.g. `map`, `filter`, spread) instead of mutating it in-place. This is good practice for OnPush-style thinking.",
          "Use derived getters like `get totalQty()` and `get totalPrice()` instead of storing totals separately.",
          "Keep the state and update methods on the component; you do not need NgRx or a global store for this exercise.",
          "Use `*ngFor` with `trackBy` for rendering lists of products and cart items."
        ],
        "techFocus": [
          "Standalone component setup",
          "Nested state for cart items",
          "Immutable update patterns (arrays of objects)",
          "Derived state via getters (total quantity, total price)",
          "Template bindings for lists and events",
          "Thinking in terms of OnPush change detection"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Model the cart as an array of items where each item has `id`, `name`, `price`, and `quantity`. Keep this array in the root component and expose derived getters for `totalQty` and `totalPrice`. For updates, always create a new array instead of mutating the existing one (e.g. using `map` and `filter`). The template renders a static product list on the left and a cart summary on the right, wiring buttons to methods like `addToCart`, `increaseQty`, `decreaseQty`, and `removeItem`.\n\n**Key ideas**\n- Nested state: a list of cart items with quantities.\n- Immutable updates: replace `cartItems` with a new array instead of mutating in place.\n- Derived state: compute `totalQty` and `totalPrice` from `cartItems` instead of storing them.\n- Template-driven: the view is a pure function of the current state.",
      "approaches": [
        {
          "title": "Single standalone component with immutable cart updates and derived totals",
          "prose": "Define a constant `PRODUCTS` array and expose it as a public field. For the cart, store `cartItems: CartItem[] = []` where `CartItem` extends the product shape with a `quantity` field. When adding to the cart, check if an item with the same `id` exists; if so, replace it via `map` with an incremented quantity, otherwise append a new item via spread. For increasing and decreasing quantity, use `map` to return a new array, removing items via `filter` when necessary. The `totalQty` and `totalPrice` getters use `reduce` to derive their values from `cartItems`, ensuring they stay consistent without extra bookkeeping. This structure works nicely with OnPush change detection because each update replaces the `cartItems` reference.",
          "codeTs": "interface Product {\n  id: string;\n  name: string;\n  price: number;\n}\n\ninterface CartItem extends Product {\n  quantity: number;\n}\n\nconst PRODUCTS: Product[] = [\n  { id: 'p1', name: 'Wireless Headphones', price: 129.99 },\n  { id: 'p2', name: 'Mechanical Keyboard', price: 89.5 },\n  { id: 'p3', name: 'Ergonomic Mouse', price: 49.99 }\n];\n\n// ... inside AppComponent\nproducts = PRODUCTS;\ncartItems: CartItem[] = [];\n\nget totalQty(): number {\n  return this.cartItems.reduce((sum, item) => sum + item.quantity, 0);\n}\n\nget totalPrice(): number {\n  return this.cartItems.reduce((sum, item) => sum + item.price * item.quantity, 0);\n}\n\naddToCart(product: Product): void {\n  const existing = this.cartItems.find(i => i.id === product.id);\n  if (!existing) {\n    this.cartItems = [\n      ...this.cartItems,\n      { ...product, quantity: 1 }\n    ];\n  } else {\n    this.cartItems = this.cartItems.map(i =>\n      i.id === product.id ? { ...i, quantity: i.quantity + 1 } : i\n    );\n  }\n}\n\nincreaseQty(item: CartItem): void {\n  this.cartItems = this.cartItems.map(i =>\n    i.id === item.id ? { ...i, quantity: i.quantity + 1 } : i\n  );\n}\n\ndecreaseQty(item: CartItem): void {\n  if (item.quantity <= 1) {\n    this.removeItem(item);\n    return;\n  }\n  this.cartItems = this.cartItems.map(i =>\n    i.id === item.id ? { ...i, quantity: i.quantity - 1 } : i\n  );\n}\n\nremoveItem(item: CartItem): void {\n  this.cartItems = this.cartItems.filter(i => i.id !== item.id);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating the existing `cartItems` array (e.g. `push`, `splice`) instead of creating a new array, which can lead to subtle bugs when using OnPush or when reasoning about state changes.",
          "Duplicating products in the cart instead of merging them and increasing `quantity`.",
          "Trying to manually keep track of `totalPrice` and `totalQty` as separate state instead of deriving them from `cartItems`, which can easily drift out of sync.",
          "Not handling the edge case when decreasing quantity to zero (e.g. leaving zero-quantity items in the cart)."
        ],
        "techniques": [
          "Immutable array updates via spread (`[...]`), `map`, and `filter`.",
          "Using TypeScript interfaces to model products and cart items.",
          "Derived getters on the component for totals to keep state single-sourced.",
          "Using `*ngFor` with `trackBy` to render and update lists efficiently."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-shopping-cart.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-shopping-cart"
    },
    "companies": [],
    "solutionAsset": "assets/sb/angular/solution/angular-shopping-cart-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Angular Shopping Cart Component",
      "description": "Create a shopping cart UI that supports adding items, removing items, updating quantities, and showing accurate totals."
    }
  },
  {
    "id": "angular-debounced-search",
    "title": "Angular Debounced Search with Fake API (RxJS)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 2,
    "tags": [
      "angular",
      "rxjs",
      "http",
      "debounce",
      "switchmap",
      "error-handling",
      "async",
      "forms"
    ],
    "description": {
      "summary": "Implement an Angular debounced search using RxJS. Use debounceTime + distinctUntilChanged + switchMap to cancel stale requests, and model loading, error, and empty states so the UI feels like a real search box. This checks reactive streams, cancellation, and UI state coordination. Angular focus: debounce with RxJS debounceTime, distinctUntilChanged, and switchMap cancellation. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Render a search input where the user can type a query.",
          "Do NOT call the fake API on every keystroke; debounce input so the search runs 500ms after the user stops typing.",
          "Perform a fake async search call (e.g. in-memory array) that returns results based on the query text.",
          "Show a loading state while the debounced search request is in flight.",
          "Show an error state when the fake API fails.",
          "Show a list of matching results when the request succeeds.",
          "When the query is cleared, cancel the pending search and clear the results."
        ],
        "expectedBehavior": [
          "Typing quickly in the input does not trigger multiple API calls; only the final value after the user pauses for 500ms is searched.",
          "While a search is running, a small loading label (e.g. \"Searching…\") is visible.",
          "If the fake API throws an error, an error message is displayed and loading is cleared.",
          "On success, results are rendered as a list. Updating the query triggers a new debounced search.",
          "Clearing the query clears both the loading state and the results list.",
          "Subscriptions are cleaned up when the component is destroyed (no memory leaks)."
        ],
        "implementationNotes": [
          "Use RxJS to handle debouncing and cancellation.",
          "A common pattern is a `Subject<string>` for search terms, piped through `debounceTime(500)` and `distinctUntilChanged()`.",
          "Use `switchMap` so that if the user types again while a previous request is in flight, the previous request is cancelled.",
          "Use `tap` to toggle `isLoading` and reset error state before each search.",
          "Use `catchError` to handle errors from the fake API and surface them as UI state.",
          "You can simulate a fake API with an in-memory array and `of(...).pipe(delay(...))`. You may also deliberately throw for specific queries (e.g. \"error\") to test the error state."
        ],
        "techFocus": [
          "Angular standalone component setup",
          "RxJS streams for UI events",
          "debounceTime + distinctUntilChanged",
          "switchMap for cancellable async work",
          "Async loading & error state management",
          "Subscription cleanup with `takeUntil` or `OnDestroy`"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Use a standalone Angular component with a `Subject<string>` for search terms. Pipe it through `debounceTime(500)` and `distinctUntilChanged()` to avoid spamming the fake API, then `switchMap` into a fake search function that returns an observable.\n\nToggle `isLoading` and `error` inside `tap` and `catchError`, and write the results plus loading state into simple component fields for the template. Use `takeUntil` in the pipe and a `destroy$` subject in `ngOnDestroy` to clean up subscriptions.\n\n**Key ideas**\n- Represent user input as a stream (`Subject<string>`).\n- Use `debounceTime` + `distinctUntilChanged` + `switchMap` to control when and how the fake API runs.\n- Keep `results`, `isLoading`, and `error` as simple component state derived from the RxJS pipeline.",
      "approaches": [
        {
          "title": "Subject-based stream with debounce + switchMap",
          "prose": "Create a `searchTerm$ = new Subject<string>()` and emit the raw input value from an `onQueryChange` handler. In `setupSearchStream`, pipe that subject through `debounceTime(500)` and `distinctUntilChanged()` so rapid typing collapses into a single value. Use `tap` before `switchMap` to set `isLoading` and clear `error`, and again after empty inputs to clear results without hitting the API.\n\nInside `switchMap`, call a `fakeApiSearch(term)` that returns an observable created from an in-memory dataset with `of(filtered).pipe(delay(...))`. Use `catchError` to set `error` and recover with an empty array. Finally, subscribe to the pipeline and write the results into `this.results`, clearing `isLoading` when the observable completes."
        }
      ],
      "notes": {
        "pitfalls": [
          "Calling the fake API directly from the input handler without debounce, which causes unnecessary requests.",
          "Using `mergeMap` instead of `switchMap`, so old requests can overwrite newer results.",
          "Forgetting to clear `isLoading` on error, leaving the UI stuck in a loading state.",
          "Not handling the empty-query case (should clear results and avoid calling the API).",
          "Leaking subscriptions by never unsubscribing when the component is destroyed."
        ],
        "techniques": [
          "Subject + RxJS operators for debounced UI events.",
          "Cancellable async work with `switchMap`.",
          "Error handling with `catchError` and safe fallbacks.",
          "Component-level subscription cleanup with `takeUntil` + `ngOnDestroy`."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-debounced-search.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v1:ui:angular:angular-debounced-search"
    },
    "companies": [],
    "solutionAsset": "assets/sb/angular/solution/angular-debounced-search-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Debounced Search in Angular",
      "description": "Create a search input that delays rapid queries and handles loading, empty, success, and error result states."
    }
  },
  {
    "id": "angular-star-rating",
    "title": "Angular Star Rating Widget",
    "type": "coding",
    "technology": "angular",
    "difficulty": "easy",
    "importance": 3,
    "tags": [
      "components",
      "inputs-outputs",
      "event-binding",
      "template-syntax",
      "accessibility"
    ],
    "description": {
      "summary": "Implement a reusable star-rating widget as an Angular standalone component. It should render a row of clickable stars, allow the user to select a rating, and notify the parent when the rating changes. Concepts: components, inputs-outputs, event-binding. Angular focus: use @Input/@Output for a controlled rating component. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Create a standalone `StarRatingComponent` that renders a row of stars.",
          "Support a configurable maximum number of stars via an `@Input()` (e.g. default to 5).",
          "Expose the current rating as an `@Input()` so the parent can control the value.",
          "Emit an event when the user selects a rating so the parent can react (e.g. two-way binding).",
          "Use the widget from a simple `AppComponent` and show the current rating below it."
        ],
        "expectedBehavior": [
          "Stars render from 1 up to the configured `max` (e.g. 5).",
          "Clicking a star sets the rating to that star index (e.g. clicking the 4th star sets rating to 4).",
          "All stars with index less than or equal to the rating appear visually \"filled\".",
          "The parent component sees the updated rating value (e.g. via `[(rating)]` or an output event)."
        ],
        "implementationNotes": [
          "Use `*ngFor` in the star-rating template to loop over an array of star indices.",
          "Use `@Input()` for `max` and `rating`, and an `@Output()` `EventEmitter<number>` for rating changes.",
          "Use class binding (e.g. `[class.filled]=\"star <= rating\"`) to style selected stars.",
          "Prefer a small derived getter (e.g. `stars`) that returns an array like `[1, 2, 3, 4, 5]` for the template.",
          "Add basic ARIA attributes (e.g. `role=\"radiogroup\"`, `aria-label`) for accessibility."
        ],
        "techFocus": [
          "Standalone child components",
          "Inputs & outputs (parent–child communication)",
          "Template loops and class binding",
          "Simple, accessible UI widgets"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise builds a small but reusable UI widget: a star rating control. The key is to keep the rendering logic in the star-rating component and let the parent own the current rating value. The widget exposes `@Input()`s for `max` and `rating`, and an `@Output()` `ratingChange` emitter so the parent can use Angular's two-way binding convention `[(rating)]`.\n\n**Test cases**\n- Initial state: rating is `0` → no stars are filled.\n- Click the 3rd star → rating becomes `3` and three stars appear filled.\n- Click the 5th star → rating becomes `5` and five stars appear filled.\n- Updating the rating from the parent (e.g. `currentRating = 2`) updates the visual state of the widget.\n- When `max` is changed (e.g. to 10), the component renders that many stars.",
      "approaches": [
        {
          "title": "Standalone child component with Input/Output and ngFor",
          "prose": "Encapsulate the star UI into a dedicated `StarRatingComponent` and let a simple `AppComponent` host it.\n\n1. In `StarRatingComponent`, define `@Input() max = 5`, `@Input() rating = 0`, and `@Output() ratingChange = new EventEmitter<number>()`.\n2. Expose a `stars` getter that returns an array `[1, 2, ..., max]` for the template.\n3. Use `*ngFor` to render one button per star. Bind `[class.filled]` when `star <= rating`.\n4. When a star is clicked, update `rating` and emit `ratingChange.emit(newValue)`.\n5. In `AppComponent`, hold a `currentRating` property and bind the widget using `[(rating)]=\"currentRating\"` to wire up two-way binding.\n\nThis approach keeps the widget focused on presentation and simple state, while the parent component controls the rating value and can display or persist it as needed.",
          "codeTs": "import { Component, EventEmitter, Input, Output } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-star-rating',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <div class=\"stars\" role=\"radiogroup\" aria-label=\"Star rating\">\n      <button\n        *ngFor=\"let star of stars\"\n        type=\"button\"\n        class=\"star\"\n        [class.filled]=\"star <= rating\"\n        (click)=\"onRate(star)\"\n        [attr.aria-label]=\"star + ' out of ' + max\"\n        [attr.aria-pressed]=\"star <= rating\"\n      >\n        ★\n      </button>\n    </div>\n  `,\n  styles: [\n    `:host{display:inline-flex;}`,\n    `.stars{display:inline-flex;gap:4px;}`,\n    `.star{background:transparent;border:none;font-size:28px;cursor:pointer;padding:4px;line-height:1;color:#4b5563;transition:transform .1s ease,color .1s ease;}`,\n    `.star.filled{color:#facc15;}`,\n    `.star:focus-visible{outline:2px solid #facc15;outline-offset:2px;}`,\n    `.star:hover{transform:scale(1.1);}`\n  ]\n})\nexport class StarRatingComponent {\n  @Input() max = 5;\n  @Input() rating = 0;\n  @Output() ratingChange = new EventEmitter<number>();\n\n  get stars(): number[] {\n    return Array.from({ length: this.max }, (_, i) => i + 1);\n  }\n\n  onRate(value: number): void {\n    if (value < 1 || value > this.max) {\n      return;\n    }\n    this.rating = value;\n    this.ratingChange.emit(this.rating);\n  }\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, StarRatingComponent],\n  template: `\n    <main style=\"min-height:100vh; background:#0a0a0a; color:#e5e7eb; display:grid; place-items:center; padding:24px;\">\n      <section style=\"width:100%; max-width:420px; display:grid; gap:16px;\">\n        <h1 style=\"margin:0; font-size:20px; font-weight:700;\">Star Rating Widget</h1>\n        <div class=\"panel\">\n          <app-star-rating [(rating)]=\"currentRating\"></app-star-rating>\n          <p class=\"hint\">Current rating: {{ currentRating }} / 5</p>\n        </div>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.panel{background:#0b1020;border:1px solid #1f2937;border-radius:12px;padding:16px;display:grid;gap:12px;}`,\n    `.hint{margin:0;font-size:14px;color:#9ca3af;}`\n  ]\n})\nexport class AppComponent {\n  currentRating = 0;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Hardcoding five stars directly in the template instead of using a loop, which makes `max` difficult to change.",
          "Forgetting to emit `ratingChange`, so the parent never sees the updated rating.",
          "Mutating parent state directly in the child instead of using an `@Output()`.",
          "Not visually differentiating filled vs empty stars, making the rating unclear."
        ],
        "techniques": [
          "Using Angular's two-way binding convention with `@Input() rating` and `@Output() ratingChange`.",
          "Using a derived getter (`stars`) to keep template logic simple.",
          "Building a focused, reusable standalone component that can be dropped into other views."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-star-rating.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-star-rating"
    },
    "companies": [
      "amazon"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-star-rating-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Reusable Star Rating in Angular",
      "description": "Create a star rating component that supports selection, configurable limits, and parent value updates."
    }
  },
  {
    "id": "angular-dynamic-table-starter",
    "title": "Angular Dynamic Table (Rows × Columns)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "easy",
    "importance": 1,
    "tags": [
      "components",
      "dynamic-ui",
      "forms",
      "ng-for",
      "structural-directives",
      "template-syntax"
    ],
    "description": {
      "summary": "Given user input for the number of rows and columns, render a table grid dynamically. Use an Angular standalone component with form bindings and *ngFor loops to generate the table structure. Concepts: components, dynamic-ui, forms. Angular focus: generate rows/cols with *ngFor and template bindings.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Provide two numeric inputs: one for the number of rows and one for the number of columns.",
          "Provide a button (e.g. \"Generate table\" or \"Update\") that rebuilds the table when clicked.",
          "Render an HTML table whose number of rows and columns matches the user-input values.",
          "Each cell should render something simple and visible (e.g. its row/column index like `R1C1`)."
        ],
        "expectedBehavior": [
          "Initially, no table or an empty grid is fine, as long as it appears correctly after the first generate action.",
          "Changing the row or column input and clicking the button updates the table dimensions.",
          "If the user enters non-positive values (0 or negative), the implementation may treat them as 0 and render no rows/columns, or clamp them to a minimum of 1 (either behavior is acceptable as long as it is consistent)."
        ],
        "implementationNotes": [
          "Use regular class properties (e.g. `rowInput`, `colInput`) to store the current input values.",
          "Use additional arrays (e.g. `rows: number[]` and `cols: number[]`) for driving `*ngFor` loops.",
          "Handle the \"Generate\" button by rebuilding these arrays based on the current inputs.",
          "Import and use `FormsModule` to enable `[(ngModel)]` two-way binding for the inputs.",
          "Use nested `*ngFor` loops in the template to generate table rows and cells."
        ],
        "techFocus": [
          "Standalone component setup",
          "Template-driven two-way binding with `[(ngModel)]`",
          "Dynamic UI generation with `*ngFor`",
          "Basic input normalization and state management"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise focuses on dynamic UI generation in Angular. You keep two pieces of input state (`rowInput` and `colInput`) and two arrays (`rows` and `cols`) that drive `*ngFor` loops. When the user clicks a button, you normalize the input values (e.g. clamp at 0 or a sensible maximum) and rebuild `rows` and `cols` accordingly. The table is rendered via nested `*ngFor` loops over these arrays, and each cell prints something simple like its row/column indices.\n\n**Test cases**\n- With `rowInput = 2` and `colInput = 3`, after clicking the generate button, the table has 2 `<tr>` elements and each row has 3 `<td>` elements.\n- Updating `rowInput` to `4` and clicking generate again updates the table to 4 rows.\n- Updating `colInput` to `1` and clicking generate again updates the table to 1 column per row.\n- When rows or columns are set to 0 (or a negative value), the implementation either renders no rows/columns or clamps to at least 1 consistently.",
      "approaches": [
        {
          "title": "Standalone component with inputs and `*ngFor`-driven grid",
          "prose": "Use a single standalone `AppComponent` that holds four key properties: `rowInput`, `colInput`, `rows`, and `cols`.\n\n1. Store the current numeric input values in `rowInput` and `colInput`.\n2. Store arrays used for iteration, e.g. `rows: number[] = []` and `cols: number[] = []`.\n3. Implement a method `updateTable()` that:\n   - Normalizes `rowInput` and `colInput` to non-negative integers (and optionally clamps a maximum).\n   - Rebuilds `rows` and `cols` using `Array.from` and the normalized counts.\n4. Bind the inputs with `[(ngModel)]` and trigger `updateTable()` on a button click.\n5. In the template, use nested `*ngFor` loops to generate table rows and cells, and print a simple label like `R{{ rowIndex + 1 }}C{{ colIndex + 1 }}` inside each `<td>`.\n\nThis keeps the implementation small while clearly demonstrating dynamic UI generation based on user input, two-way binding, and structural directives.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  template: `\n    <main class=\"app\">\n      <section class=\"card\">\n        <h1>Dynamic Table</h1>\n        <p class=\"hint\">Enter rows & columns, then generate a table grid.</p>\n\n        <div class=\"controls\">\n          <label>\n            <span>Rows</span>\n            <input type=\"number\" min=\"0\" [(ngModel)]=\"rowInput\" />\n          </label>\n          <label>\n            <span>Columns</span>\n            <input type=\"number\" min=\"0\" [(ngModel)]=\"colInput\" />\n          </label>\n          <button (click)=\"updateTable()\">Generate table</button>\n        </div>\n\n        <div class=\"preview\" *ngIf=\"rows.length && cols.length; else emptyState\">\n          <table class=\"grid\" aria-label=\"dynamic table\">\n            <tbody>\n              <tr *ngFor=\"let _ of rows; let rowIndex = index\">\n                <td *ngFor=\"let __ of cols; let colIndex = index\">\n                  R{{ rowIndex + 1 }}C{{ colIndex + 1 }}\n                </td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n\n        <ng-template #emptyState>\n          <p class=\"empty\">Set rows & columns, then generate the table.</p>\n        </ng-template>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.app{min-height:100vh;display:grid;place-items:center;background:#020617;color:#e5e7eb;padding:24px;}`,\n    `.card{width:100%;max-width:640px;padding:20px 24px;background:#020617;border-radius:16px;border:1px solid #1f2937;display:grid;gap:16px;}`,\n    `h1{margin:0;font-size:20px;font-weight:700;}`,\n    `.hint{margin:0;font-size:13px;color:#9ca3af;}`,\n    `.controls{display:flex;flex-wrap:wrap;gap:12px;align-items:flex-end;}`,\n    `label{display:flex;flex-direction:column;gap:4px;font-size:13px;}`,\n    `input{background:#020617;border:1px solid #374151;border-radius:10px;padding:6px 10px;color:#e5e7eb;min-width:80px;}`,\n    `button{background:#a3e635;color:#0b1020;border:none;border-radius:10px;padding:8px 14px;font-weight:600;cursor:pointer;}`,\n    `button:hover{filter:brightness(1.05);}`,\n    `.preview{overflow:auto;border-radius:12px;border:1px solid #1f2937;padding:12px;background:#020617;}`,\n    `.grid{width:100%;border-collapse:collapse;}`,\n    `td{border:1px solid #1f2937;padding:6px 10px;font-size:13px;text-align:center;}`,\n    `.empty{margin:0;font-size:13px;color:#9ca3af;}`\n  ]\n})\nexport class AppComponent {\n  rowInput = 3;\n  colInput = 4;\n\n  rows: number[] = [];\n  cols: number[] = [];\n\n  constructor() {\n    this.updateTable();\n  }\n\n  private normalizeCount(raw: number): number {\n    if (!Number.isFinite(raw)) return 0;\n    const n = Math.floor(raw);\n    const clamped = Math.max(0, Math.min(n, 20));\n    return clamped;\n  }\n\n  updateTable(): void {\n    const rows = this.normalizeCount(this.rowInput);\n    const cols = this.normalizeCount(this.colInput);\n\n    this.rows = Array.from({ length: rows }, (_, i) => i);\n    this.cols = Array.from({ length: cols }, (_, i) => i);\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Rendering the table directly from `rowInput`/`colInput` without normalizing them (e.g. allowing negative or non-integer values to break the UI).",
          "Trying to use `*ngFor` over a number directly instead of an iterable array.",
          "Forgetting to import `FormsModule`, which will cause `[(ngModel)]` to fail."
        ],
        "techniques": [
          "Using `Array.from({ length: n })` to create arrays for iteration.",
          "Separating form state (`rowInput`, `colInput`) from derived view state (`rows`, `cols`).",
          "Using nested `*ngFor` loops for grid-like UIs."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-dynamic-table.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-dynamic-table-starter"
    },
    "companies": [],
    "solutionAsset": "assets/sb/angular/solution/angular-dynamic-table-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Dynamic Rows and Columns Table in Angular",
      "description": "Create a table from row and column inputs and render the grid with consistent behavior for valid and invalid values."
    }
  },
  {
    "id": "angular-nested-checkboxes",
    "title": "Nested Checkbox Tree (Standalone Component)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "components",
      "dom",
      "forms",
      "event-binding",
      "state",
      "ui-logic"
    ],
    "description": {
      "summary": "Build a standalone Angular component that renders a parent checkbox with multiple child checkboxes. Toggling the parent should check/uncheck all children. Toggling children should update the parent to checked, unchecked, or indeterminate depending on the child states. Concepts: components, dom, forms. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Render one parent checkbox and several child checkboxes.",
          "Checking the parent selects all children.",
          "Unchecking the parent clears all children.",
          "When children are toggled manually:",
          "- If all are checked → parent becomes checked.",
          "- If none are checked → parent becomes unchecked.",
          "- If some are checked → parent becomes indeterminate.",
          "Use a standalone Angular component.",
          "Use simple arrays or booleans for state (no signals needed)."
        ],
        "expectedBehavior": [
          "Parent reflects the state of the children.",
          "Children reflect parent state when it changes.",
          "Parent enters the indeterminate state when child selection is mixed.",
          "No external libraries or advanced patterns required."
        ],
        "implementationNotes": [
          "Use a boolean array like `[false, false, false]` to track child states.",
          "Bind the parent checkbox’s `indeterminate` property via `@ViewChild` or a template reference.",
          "Use `(change)` event bindings for checkbox toggles.",
          "Derive parent state after each child change."
        ],
        "techFocus": [
          "Standalone components",
          "DOM event handling",
          "State derivation",
          "Working with `indeterminate` on native checkboxes"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This component manages a parent checkbox and multiple child checkboxes. The parent controls all children: checking it selects all children, and unchecking clears them. Children control the parent: if all are selected, the parent is checked; if none are selected, the parent is unchecked; if some are selected, the parent enters the `indeterminate` state.\n\nThis requires:\n- A simple array of booleans for child states.\n- A derived function that recalculates the parent state on every change.\n- Binding `indeterminate` using a template reference (`#parentBox`).",
      "approaches": [
        {
          "title": "Boolean array with derived parent state",
          "prose": "Use an array like `children = [false, false, false]`. The parent is derived based on the number of checked children. When clicking the parent checkbox, the entire array is updated. When children are toggled individually, run a helper that updates the parent checkbox's `checked` and `indeterminate` state. Angular does not have a native `indeterminate` input property — you must assign it manually on the element.",
          "codeTs": "import { Component, ViewChild, ElementRef } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  // Child checkbox states\n  children = [false, false, false];\n\n  @ViewChild('parentBox', { static: true }) parentBox!: ElementRef<HTMLInputElement>;\n\n  // --- Parent toggle ---\n  toggleParent(event: Event): void {\n    const checked = (event.target as HTMLInputElement).checked;\n    this.children = this.children.map(() => checked);\n    this.updateParentState();\n  }\n\n  // --- Child toggle ---\n  toggleChild(index: number): void {\n    this.children[index] = !this.children[index];\n    this.updateParentState();\n  }\n\n  // --- Derive parent state ---\n  private updateParentState(): void {\n    const total = this.children.length;\n    const checkedCount = this.children.filter(x => x).length;\n\n    const parent = this.parentBox.nativeElement;\n\n    if (checkedCount === total) {\n      parent.checked = true;\n      parent.indeterminate = false;\n    } else if (checkedCount === 0) {\n      parent.checked = false;\n      parent.indeterminate = false;\n    } else {\n      parent.checked = false;\n      parent.indeterminate = true;\n    }\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Trying to bind `[indeterminate]` in Angular — it does NOT work because it's not a real DOM property.",
          "Mutating the parent checkbox without using `@ViewChild` — required for indeterminate logic.",
          "Forgetting to recalc parent state after each child toggle."
        ],
        "techniques": [
          "Direct DOM access for `indeterminate`.",
          "Boolean array state management.",
          "Derived UI logic (checked / unchecked / indeterminate)."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-nested-checkboxes.v1.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v1:ui:angular:angular-nested-checkboxes"
    },
    "solutionAsset": "assets/sb/angular/solution/angular-nested-checkboxes-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Nested Checkbox Tree in Angular",
      "description": "Create nested checkbox behavior where parent and child selections stay synchronized, including partial-selection states."
    }
  },
  {
    "id": "angular-autocomplete-search-starter",
    "title": "Autocomplete Search Bar (Standalone Component)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "components",
      "forms",
      "reactive-forms",
      "rxjs",
      "debounce",
      "accessibility",
      "keyboard"
    ],
    "description": {
      "summary": "Build an **autocomplete search bar** in Angular. As the user types, show a dropdown of suggestions filtered from a dataset. Add debounced searching, mouse selection, and keyboard navigation (↑/↓/Enter/Escape). Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Use `ReactiveFormsModule` and a `FormControl` for the input binding.",
          "Show a dropdown of suggestions filtered by the current query (case-insensitive, substring match).",
          "Debounce input changes (e.g. 250–400ms) before searching.",
          "Support mouse selection (mousedown on a suggestion sets the input value and closes dropdown).",
          "Support keyboard navigation: ArrowDown/ArrowUp moves active option, Enter selects, Escape closes.",
          "Close the dropdown when clicking outside the component.",
          "Basic accessibility: use `role=\"combobox\"`, `role=\"listbox\"`, `role=\"option\"`, plus `aria-expanded` and `aria-activedescendant`."
        ],
        "expectedBehavior": [
          "Typing updates suggestions after the debounce delay.",
          "If query is empty/whitespace, dropdown is closed and no suggestions are shown.",
          "ArrowDown from no selection activates the first option; ArrowUp activates the last option.",
          "Enter selects the active option (if any) and closes the dropdown.",
          "Escape closes the dropdown without changing the input.",
          "Clicking outside closes the dropdown."
        ],
        "implementationNotes": [
          "Create a fake async search function `search(q)` that filters a local dataset and returns `of(filtered).pipe(delay(...))`.",
          "In some environments, typed Reactive Forms may not expose `valueChanges` cleanly. Instead, drive the search stream with a `Subject<string>` fed from `(input)` events (and keep the `FormControl` for UI binding).",
          "Build `results$` with `debounceTime` + `distinctUntilChanged` + `switchMap` into `search()`.",
          "Render results via `async` pipe (no imperative subscription required).",
          "Keep the solution in a single component (no need for services)."
        ],
        "techFocus": [
          "Reactive forms input binding (`FormControl` + `ReactiveFormsModule`)",
          "RxJS streams for UI behavior (Subject, debounce, `switchMap`)",
          "Dropdown state + click-outside handling",
          "Keyboard navigation + a11y roles/aria"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Model the query with a `FormControl`, but drive the search pipeline via a `Subject<string>` that receives values from the input `(input)` event. Debounce and dedupe query updates, then `switchMap` into a fake async `search()` that filters a local dataset and returns an RxJS stream (simulated latency via `delay`). Render results with the `async` pipe. Track `isOpen` and `activeIndex` for dropdown visibility and keyboard navigation. Close on outside click using a `HostListener` that checks whether the click target is inside the component root.\n\n**Test cases**\n- Type \"san\" → after debounce, suggestions include \"San Francisco\" / \"San Jose\".\n- Type \"\" (empty) → dropdown closes, no results shown.\n- ArrowDown twice → activeIndex changes accordingly.\n- Enter on active option → input becomes that value, dropdown closes.\n- Escape → dropdown closes.\n- Click outside → dropdown closes.\n- Mouse down on an option → selects it and closes.",
      "approaches": [
        {
          "title": "Subject-driven results$ stream + keyboard navigation + outside click close",
          "prose": "1) Create `queryControl = new FormControl<string>('')` for binding.\n2) Create `searchTerm$ = new Subject<string>()`.\n3) On input: `queryControl.setValue(value)` and `searchTerm$.next(value)`.\n4) Build `results$` from `searchTerm$`:\n   - `startWith(queryControl.value ?? '')`\n   - `map(v => String(v ?? '').trim())`\n   - `debounceTime(300)`\n   - `distinctUntilChanged()`\n   - `tap(q => open/close dropdown + reset activeIndex)`\n   - `switchMap(q => q ? search(q) : of([]))`\n5) Implement `onKeyDown`:\n   - Escape closes\n   - ArrowDown/ArrowUp updates `activeIndex` with wrap-around\n   - Enter selects the active option\n6) Close on outside click using `@HostListener('document:mousedown')` + `ElementRef.contains`.\n7) Use `(mousedown)` on options to avoid losing selection due to input blur ordering.",
          "codeTs": "import { CommonModule } from '@angular/common';\nimport { Component, ElementRef, HostListener, inject } from '@angular/core';\nimport { FormControl, ReactiveFormsModule } from '@angular/forms';\nimport { Subject, of } from 'rxjs';\nimport { debounceTime, delay, distinctUntilChanged, map, startWith, switchMap, tap } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, ReactiveFormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  private readonly host = inject(ElementRef<HTMLElement>);\n\n  readonly listboxId = 'autocomplete-listbox';\n\n  private readonly cities: string[] = [\n    'Amsterdam', 'Ankara', 'Athens', 'Austin',\n    'Barcelona', 'Berlin', 'Boston', 'Brussels',\n    'Chicago', 'Copenhagen',\n    'Dubai',\n    'Edinburgh',\n    'Frankfurt',\n    'Hamburg',\n    'Istanbul', 'Izmir',\n    'London', 'Los Angeles',\n    'Madrid', 'Miami', 'Milan', 'Munich',\n    'New York',\n    'Oslo',\n    'Paris', 'Prague',\n    'Rome',\n    'San Diego', 'San Francisco', 'San Jose', 'Seattle',\n    'Tokyo',\n    'Vienna',\n    'Zurich'\n  ];\n\n  readonly queryControl = new FormControl<string>('');\n\n  isOpen = false;\n  activeIndex = -1;\n\n  private readonly searchTerm$ = new Subject<string>();\n\n  readonly results$ = this.searchTerm$.pipe(\n    startWith(this.queryControl.value ?? ''),\n    map((v: string) => String(v ?? '').trim()),\n    debounceTime(300),\n    distinctUntilChanged(),\n    tap((q: string) => {\n      if (!q) {\n        this.isOpen = false;\n        this.activeIndex = -1;\n      } else {\n        this.isOpen = true;\n        this.activeIndex = -1;\n      }\n    }),\n    switchMap((q: string) => (q ? this.search(q) : of([] as string[])))\n  );\n\n  onInput(value: string): void {\n    this.queryControl.setValue(value);\n    this.searchTerm$.next(value);\n  }\n\n  onFocus(): void {\n    const q = String(this.queryControl.value ?? '').trim();\n    if (q) this.isOpen = true;\n  }\n\n  onKeyDown(ev: KeyboardEvent): void {\n    if (ev.key === 'Escape') {\n      this.isOpen = false;\n      this.activeIndex = -1;\n      return;\n    }\n\n    if (!this.isOpen && (ev.key === 'ArrowDown' || ev.key === 'ArrowUp')) {\n      const q = String(this.queryControl.value ?? '').trim();\n      this.isOpen = !!q;\n    }\n\n    const options = this.host.nativeElement.querySelectorAll('[role=\"option\"]');\n    const len = options.length;\n    if (!this.isOpen || len === 0) return;\n\n    if (ev.key === 'ArrowDown') {\n      ev.preventDefault();\n      this.activeIndex = this.activeIndex < 0 ? 0 : (this.activeIndex + 1) % len;\n      return;\n    }\n\n    if (ev.key === 'ArrowUp') {\n      ev.preventDefault();\n      this.activeIndex = this.activeIndex < 0 ? len - 1 : (this.activeIndex - 1 + len) % len;\n      return;\n    }\n\n    if (ev.key === 'Enter') {\n      if (this.activeIndex >= 0 && this.activeIndex < len) {\n        ev.preventDefault();\n        const el = options[this.activeIndex] as HTMLElement;\n        const text = el.textContent ?? '';\n        this.select(text);\n      }\n      return;\n    }\n  }\n\n  select(value: string): void {\n    this.queryControl.setValue(value);\n    this.isOpen = false;\n    this.activeIndex = -1;\n    this.searchTerm$.next(value);\n  }\n\n  trackByValue(_: number, v: string): string {\n    return v;\n  }\n\n  optionId(i: number): string {\n    return `opt-${i}`;\n  }\n\n  highlight(item: string, queryRaw: unknown): string {\n    const q = String(queryRaw ?? '').trim();\n    if (!q) return this.escapeHtml(item);\n\n    const idx = item.toLowerCase().indexOf(q.toLowerCase());\n    if (idx < 0) return this.escapeHtml(item);\n\n    const before = this.escapeHtml(item.slice(0, idx));\n    const mid = this.escapeHtml(item.slice(idx, idx + q.length));\n    const after = this.escapeHtml(item.slice(idx + q.length));\n    return `${before}<mark>${mid}</mark>${after}`;\n  }\n\n  @HostListener('document:mousedown', ['$event'])\n  onDocMouseDown(ev: MouseEvent): void {\n    const target = ev.target as Node | null;\n    if (!target) return;\n    if (!this.host.nativeElement.contains(target)) {\n      this.isOpen = false;\n      this.activeIndex = -1;\n    }\n  }\n\n  private search(q: string) {\n    const needle = q.toLowerCase();\n    const filtered = this.cities\n      .filter(c => c.toLowerCase().includes(needle))\n      .slice(0, 8);\n\n    return of(filtered).pipe(delay(150));\n  }\n\n  private escapeHtml(s: string): string {\n    return s\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\\\"/g, '&quot;')\n      .replace(/'/g, '&#39;');\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting `debounceTime` + `switchMap` (can cause too many searches and stale results).",
          "Not trimming the query (whitespace should behave like empty).",
          "Using `(click)` on options (can lose selection due to event ordering when the input blurs).",
          "Not handling wrap-around behavior for arrow navigation.",
          "Missing ARIA roles/attributes, making it harder for assistive tech."
        ],
        "techniques": [
          "Drive the RxJS pipeline with a `Subject<string>` fed by `(input)` events to avoid `valueChanges` typing/environment issues.",
          "Prefer `async` pipe for results rendering.",
          "Use `HostListener('document:mousedown')` to close on outside click.",
          "Wrap-around navigation using modulo arithmetic."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-autocomplete-search.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-autocomplete-search-starter"
    },
    "companies": [
      "apple"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-autocomplete-search-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Angular Autocomplete Search Component",
      "description": "Create an autocomplete input that shows matching suggestions, supports keyboard and mouse selection, and handles open or close states."
    }
  },
  {
    "id": "angular-transfer-list",
    "title": "Angular Transfer List (Select + Move Between Two Lists)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "components",
      "state",
      "forms",
      "lists",
      "immutability"
    ],
    "description": {
      "summary": "Build a dual-list transfer UI in Angular. Users select items in one list and move them to the other via buttons. Preserve order, clear selection after transfer, disable buttons when nothing is selected, and keep the UI consistent. Consider edge cases like large lists and keyboard selection; test accessibility and performance with many items. Angular focus: manage selection arrays and use *ngFor with checkbox bindings. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Render two lists: Top and Bottom.",
          "Each list renders items with a checkbox for selection.",
          "Provide two transfer buttons between lists: \"↓\" moves selected Top items to Bottom; \"↑\" moves selected Bottom items to Top.",
          "Disable \"↓\" when no Top items are selected; disable \"↑\" when no Bottom items are selected.",
          "After transfer, moved items must be unselected in the destination list.",
          "Preserve item order within each list (append moved items to the end of destination list)."
        ],
        "expectedBehavior": [
          "Selecting items in Top and clicking \"↓\" removes them from Top and appends them to Bottom.",
          "Selecting items in Bottom and clicking \"↑\" removes them from Bottom and appends them to Top.",
          "If nothing is selected in a list, its transfer button is disabled and does nothing.",
          "Selections are independent per list and are cleared for moved items after transfer."
        ],
        "implementationNotes": [
          "Use Angular standalone root component.",
          "Model items with an `id` and `label` so selection tracking is stable.",
          "Track selection using `Set<string>` (TopSelected, BottomSelected).",
          "Implement pure transfer logic: compute `moved` + `remaining` from source; `dest = [...dest, ...moved]`.",
          "Keep templates simple: *ngFor + (change) for checkbox toggles."
        ],
        "techFocus": [
          "Standalone component state",
          "Checkbox event handling",
          "Selection sets",
          "Moving items between arrays"
        ]
      }
    },
    "starterCodeHint": "Track selections with `Set<string>` per list. On transfer, split source into (moved, remaining) by `selected.has(item.id)`, then append moved to destination and clear selection set.",
    "solutionBlock": {
      "overview": "A transfer list has two collections and selection state for each side. The key is to move selected items while preserving order, then clear selection to avoid stale UI. This models real admin UIs where items are assigned between groups or buckets and selection state must be consistent.",
      "approaches": [
        {
          "title": "Two arrays + two selection sets",
          "prose": "Maintain topItems and bottomItems arrays plus Set selections. On transfer, split the source list into moved and remaining using the selection set, append moved to the destination, update both lists immutably, and reset the selection set. Disable the transfer button when the selection set is empty to prevent no-op clicks."
        }
      ],
      "notes": {
        "pitfalls": [
          "Tracking selection by index (breaks when lists change). Use stable `id` instead.",
          "Forgetting to clear selection after transfer.",
          "Mutating arrays in place in a way that makes logic hard to follow; prefer building new arrays."
        ],
        "techniques": [
          "Use `Set` for O(1) selection toggles.",
          "Split arrays into `moved` and `remaining` for clean transfer logic."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-transfer-list.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-transfer-list"
    },
    "companies": [
      "meta"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-transfer-list-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Angular Transfer List Component",
      "description": "Create a transfer list UI that moves selected items between two lists while preserving expected ordering and selection behavior."
    }
  },
  {
    "id": "angular-tictactoe-starter",
    "title": "Tic-Tac-Toe (Standalone Component)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "easy",
    "importance": 5,
    "tags": [
      "components",
      "state",
      "event-binding",
      "ng-for",
      "conditional-rendering",
      "control-flow"
    ],
    "description": {
      "summary": "Build a 3x3 Tic-Tac-Toe game in an Angular standalone component. Alternate X/O turns, prevent overwrites, detect wins and draws, and offer a reset to start a new game. Concepts: components, state, event-binding.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Render a 3×3 board (9 cells).",
          "Alternate turns between players 'X' and 'O'.",
          "Clicking a cell places the current player's mark (only if the cell is empty and the game is not over).",
          "Detect a winner (3 in a row) and stop further moves.",
          "Detect a draw when the board is full and there is no winner.",
          "Show a status text (next player / winner / draw).",
          "Include a 'Reset' button to restart the game."
        ],
        "expectedBehavior": [
          "Initial state shows an empty board and indicates 'Next: X'.",
          "Clicking an empty cell places the current player's mark and switches turns.",
          "Clicking an already-filled cell does nothing.",
          "When a player wins, status shows 'Winner: X' or 'Winner: O' and moves stop.",
          "When the board fills with no winner, status shows 'Draw' and moves stop.",
          "Reset clears the board, sets the next player to 'X', and clears winner/draw."
        ],
        "implementationNotes": [
          "Keep everything inside a single root standalone component.",
          "Model the board as an array of 9 values (`'X' | 'O' | null`).",
          "Use `*ngFor` to render the 9 cells.",
          "Use a helper function to compute the winner based on winning line indices."
        ],
        "techFocus": [
          "Standalone component setup",
          "Component state management",
          "Event binding",
          "Rendering lists with *ngFor",
          "Basic game logic"
        ]
      }
    },
    "starterCodeHint": "Store the board as an array of 9 cells and render it with *ngFor. On click, if the cell is empty and there is no winner, place the current player's mark and switch turns. Compute winner by checking the 8 winning line combinations.",
    "solutionBlock": {
      "overview": "Use a 9-cell board (`('X'|'O'|null)[]`) and a `currentPlayer` flag. Each click attempts to place a mark if the game is still active and the cell is empty. After each move, compute winner by checking the 8 winning line combinations; if none and the board has no empty cells, it's a draw. Provide a reset that restores initial state.\n\n**Test cases**\n- Start → status is `Next: X`.\n- Place X then O → turns alternate.\n- Clicking a filled cell → no change.\n- Winning line (e.g., 0-1-2) → status becomes `Winner: X` and further clicks do nothing.\n- Full board with no winner → status becomes `Draw`.\n- Reset → clears everything.",
      "approaches": [
        {
          "title": "Single standalone component with board array + winner helper",
          "prose": "Keep `board` as a 9-cell array, `currentPlayer`, and `winner` or `gameOver` state in the component. Render the cells with `*ngFor`. On click, ignore filled cells or finished games, place the current mark, check the 8 winning line combinations, and then toggle the player if no winner. Add a reset method to clear the board and set the player back to X.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ntype Cell = 'X' | 'O' | null;\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <main class=\"page\">\n      <section class=\"card\">\n        <h1 class=\"title\">Tic-Tac-Toe</h1>\n        <p class=\"subtitle\">Two players take turns. First to 3 in a row wins.</p>\n\n        <div class=\"status\" aria-live=\"polite\">{{ status }}</div>\n\n        <div class=\"board\" role=\"grid\" aria-label=\"tic tac toe board\">\n          <button\n            class=\"cell\"\n            *ngFor=\"let cell of board; let i = index\"\n            type=\"button\"\n            (click)=\"play(i)\"\n            [disabled]=\"isGameOver || cell !== null\"\n            [attr.aria-label]=\"'cell ' + i\"\n          >\n            {{ cell ?? '' }}\n          </button>\n        </div>\n\n        <div class=\"actions\">\n          <button class=\"ghost\" type=\"button\" (click)=\"reset()\">Reset</button>\n        </div>\n      </section>\n    </main>\n  `,\n  styles: [\n    `:host{display:block}`,\n    `.page{min-height:100vh;display:grid;place-items:center;padding:24px;background:#0a0a0a;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}`,\n    `.card{width:100%;max-width:520px;background:#0b1020;border:1px solid #1f2937;border-radius:14px;padding:18px;display:grid;gap:14px;}`,\n    `.title{margin:0;font-size:18px;font-weight:800;}`,\n    `.subtitle{margin:0;color:#9ca3af;font-size:12px;}`,\n    `.status{padding:10px 12px;border:1px solid #1f2937;border-radius:12px;background:#0a0f1e;font-weight:700;}`,\n    `.board{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;}`,\n    `.cell{aspect-ratio:1/1;border-radius:14px;border:1px solid rgba(31,41,55,.7);background:#0a0f1e;color:#e5e7eb;font-size:34px;font-weight:900;cursor:pointer;display:grid;place-items:center;}`,\n    `.cell:disabled{opacity:.55;cursor:not-allowed;}`,\n    `.actions{display:flex;justify-content:flex-end;}`,\n    `.ghost{background:transparent;color:#e5e7eb;border:1px solid #374151;border-radius:12px;padding:10px 14px;font-weight:800;cursor:pointer;}`\n  ]\n})\nexport class AppComponent {\n  board: Cell[] = Array.from({ length: 9 }, () => null);\n  currentPlayer: 'X' | 'O' = 'X';\n  winner: 'X' | 'O' | null = null;\n\n  get isDraw(): boolean {\n    return !this.winner && this.board.every((c) => c !== null);\n  }\n\n  get isGameOver(): boolean {\n    return !!this.winner || this.isDraw;\n  }\n\n  get status(): string {\n    if (this.winner) return `Winner: ${this.winner}`;\n    if (this.isDraw) return 'Draw';\n    return `Next: ${this.currentPlayer}`;\n  }\n\n  play(i: number): void {\n    if (this.isGameOver) return;\n    if (this.board[i] !== null) return;\n\n    const next = this.board.slice();\n    next[i] = this.currentPlayer;\n    this.board = next;\n\n    const w = this.calculateWinner(this.board);\n    if (w) {\n      this.winner = w;\n      return;\n    }\n\n    if (!this.isDraw) {\n      this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';\n    }\n  }\n\n  reset(): void {\n    this.board = Array.from({ length: 9 }, () => null);\n    this.currentPlayer = 'X';\n    this.winner = null;\n  }\n\n  private calculateWinner(b: Cell[]): 'X' | 'O' | null {\n    const lines: number[][] = [\n      [0, 1, 2],\n      [3, 4, 5],\n      [6, 7, 8],\n      [0, 3, 6],\n      [1, 4, 7],\n      [2, 5, 8],\n      [0, 4, 8],\n      [2, 4, 6]\n    ];\n\n    for (const [a, c, d] of lines) {\n      const v = b[a];\n      if (v && v === b[c] && v === b[d]) return v;\n    }\n\n    return null;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing moves after the game is over (winner/draw).",
          "Allowing overwriting a filled cell.",
          "Computing winner incorrectly (missing diagonal lines).",
          "Mutating the board array in-place instead of creating a new array."
        ],
        "techniques": [
          "Render the board with `*ngFor` using indices.",
          "Keep game-over logic derived from `winner` and board fullness.",
          "Use a fixed list of winning line index triples."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-tictactoe.v1.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-tictactoe-starter"
    },
    "companies": [
      "amazon"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-tictactoe-solution.v1.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Tic Tac Toe Game in Angular",
      "description": "Create a tic tac toe game that tracks turns, detects wins or draws, blocks invalid moves, and supports restart."
    }
  },
  {
    "id": "angular-like-button",
    "title": "Like Button (Facebook-style Toggle)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "easy",
    "importance": 5,
    "tags": [
      "components",
      "event-binding",
      "state",
      "conditional-rendering",
      "styling"
    ],
    "description": {
      "summary": "Create a Like button with toggle state and a counter in Angular. Clicking should increment on like, decrement on unlike, and never allow the count to drop below zero. The template should reflect state immediately and apply an active class when liked. Concepts: components, event binding, state, conditional rendering, styling. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Render a Like button with an icon, label, and a like count.",
          "Clicking the button toggles the liked state.",
          "When liked becomes true, increase the count by 1; when unliked, decrease by 1.",
          "Update the button visual style based on liked state.",
          "Prevent the count from going below 0."
        ],
        "expectedBehavior": [
          "Initial state: not liked, count shows the initial value.",
          "First click: becomes liked, count increases by 1, button turns 'active'.",
          "Second click: becomes unliked, count decreases by 1, button returns to normal.",
          "Count never becomes negative."
        ],
        "implementationNotes": [
          "Use component class properties for state (`liked`, `count`).",
          "Use `(click)` event binding to toggle.",
          "Use `[class.active]` (or `[ngClass]`) to change styles."
        ],
        "techFocus": [
          "Standalone component setup",
          "State in a component class",
          "Event binding",
          "Conditional class binding"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Store `liked` and `count` on the component. The click handler flips `liked` and updates the count by +1 or -1, clamping at zero. Bind the button class to `liked` so the UI responds to state changes. This mirrors common toggle-with-count UI patterns. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "Single standalone component with class-based state",
          "prose": "In `AppComponent`, define `liked = false` and `count = 0`. Implement `toggleLike()` to update both values, using `Math.max(0, count - 1)` when unliking. In the template, bind `(click)` to the handler, display the count, and use `[class.active]=\"liked\"` (or `[ngClass]`) to style the active state. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to decrement on unlike (toggle only changes style).",
          "Letting count become negative.",
          "Mutating state in template expressions instead of using a method."
        ],
        "techniques": [
          "Use a single click handler to keep logic centralized.",
          "Use derived UI from state (class binding)."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-like-button.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-like-button"
    },
    "companies": [
      "amazon"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-like-button-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Angular Like Button with Counter",
      "description": "Create a like button that toggles state and updates count while keeping labels and totals consistent with user actions."
    }
  },
  {
    "id": "angular-input-output-two-way",
    "title": "Reusable Child Component with @Input/@Output (Two-way Binding)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "easy",
    "importance": 5,
    "tags": [
      "components",
      "inputs-outputs",
      "binding",
      "event-binding",
      "template-syntax"
    ],
    "description": {
      "summary": "Expose a value input and a valueChange output to support two-way binding, and keep the child component stateless so the parent owns the source of truth. Concepts: components, inputs outputs, binding, event binding, template syntax.",
      "specs": {
        "requirements": [
          "Create a reusable child component (standalone) that receives `value` via @Input.",
          "Child must emit changes via @Output so the parent can react.",
          "Implement two-way binding pattern: `value` + `valueChange` (so parent can use `[(value)]`).",
          "Parent component must demonstrate:",
          "  - Property binding: `[label]=\"...\"` and `[value]=\"...\"`",
          "  - Event binding: `(valueChange)=\"...\"` or `[(value)]=\"...\"`",
          "UI should include an input + a button inside the child. Child emits updated value when user edits input or presses button."
        ],
        "expectedBehavior": [
          "Typing in the child input updates the parent's state (via two-way binding).",
          "Clicking child button emits an event that the parent logs/increments a counter.",
          "Parent can also update the value programmatically and child reflects it."
        ],
        "implementationNotes": [
          "Use standalone components.",
          "Use a classic `@Input() value` + `@Output() valueChange = new EventEmitter<...>()` for two-way binding.",
          "Avoid FormsModule; use plain `(input)` event handling for simplicity.",
          "Keep everything minimal: two components + one small UI."
        ],
        "techFocus": [
          "@Input / @Output",
          "EventEmitter",
          "Two-way binding convention `value` + `valueChange`",
          "Property binding & event binding",
          "Parent-child communication"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Angular’s two-way binding is syntactic sugar for [value] and (valueChange). The child emits updates and the parent updates its own state. This keeps data flow explicit and testable. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "Two-way binding via value/valueChange + submit output",
          "prose": "Define @Input() value and @Output() valueChange. Emit valueChange when the user edits. In the parent, use [(value)] to wire it up. Avoid mutating @Input inside the child, and keep validation in the parent if needed. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting the exact naming convention `value` + `valueChange` required for `[(value)]`.",
          "Mutating @Input directly inside child instead of emitting changes to the parent.",
          "Not reflecting parent updates back into child (fixed by using `value` as source of truth)."
        ],
        "techniques": [
          "Two-way binding convention in Angular custom components.",
          "Event emitter for parent notification.",
          "Property + event binding in templates."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-input-output-two-way.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-input-output-two-way"
    },
    "solutionAsset": "assets/sb/angular/solution/angular-input-output-two-way-solution.v2.json",
    "companies": [
      "google"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Implement Angular Two-Way Binding with Input/Output",
      "description": "Create parent-child value synchronization using Input and Output contracts with predictable update flow and event behavior."
    }
  },
  {
    "id": "angular-progress-bar-thresholds",
    "title": "Angular Progress Bar (0–100 with Threshold Colors)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "easy",
    "importance": 5,
    "tags": [
      "components",
      "event-binding",
      "state",
      "styling",
      "derived-state"
    ],
    "description": {
      "summary": "Build an Angular progress bar for values 0–100 with +10/−10 controls. Clamp the value, show the percentage, and change the fill color based on thresholds (red/orange/green) to reflect status and urgency. Concepts: components, event binding, state, styling, derived state. Angular focus: use [ngStyle]/[ngClass] to map thresholds to styles. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Render a progress bar where the fill represents a progress value from 0 to 100.",
          "Provide \"-10%\" and \"+10%\" buttons to decrease/increase progress by 10.",
          "Clamp progress so it never goes below 0 or above 100.",
          "Change the bar color based on thresholds (red/orange/green).",
          "Display the current progress percentage (e.g., \"40%\")."
        ],
        "expectedBehavior": [
          "Initial progress starts at 0%.",
          "Clicking \"+10%\" increases progress by 10 up to 100.",
          "Clicking \"-10%\" decreases progress by 10 down to 0.",
          "Progress never renders below 0% or above 100%.",
          "Bar color changes by thresholds (example: <34 red, 34–66 orange, >66 green)."
        ],
        "implementationNotes": [
          "Store progress as a number (e.g., `progress = 0`).",
          "Use `(click)` bindings for buttons.",
          "Bind fill width using `[style.width.%]=\"progress\"`.",
          "Compute a derived class for the fill color via a getter (e.g., `barClass`).",
          "Avoid using literal '@Input' / '@Output' text in Angular templates; Angular 17+ may interpret '@' as block syntax. Use '&#64;Input' if needed."
        ],
        "techFocus": [
          "Standalone component setup",
          "Local state in component",
          "Event binding",
          "Style/property binding",
          "Derived UI state (threshold class)"
        ]
      }
    },
    "starterCodeHint": "Implement `inc()` and `dec()` to add/subtract 10 and clamp. Bind `[style.width.%]` to progress and return a threshold-based class string from `barClass`.",
    "solutionBlock": {
      "overview": "Use a single progress value in the component and derive width, label, and color from it. The bar should clamp between 0 and 100, display the percentage, and change color based on thresholds. This keeps the UI declarative, avoids duplicated state, and makes the component easy to test. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls Use derived state to compute the color class from the numeric value and keep styling declarative in the template.",
      "approaches": [
        {
          "title": "Standalone component with clamped progress and threshold class",
          "prose": "Store progress = 0. Create inc/dec handlers that clamp values using Math.min/Math.max. Bind the fill width with [style.width.%]=progress and expose a getter that returns a color class based on thresholds. Render the numeric percentage so users always see the exact value and the color change is obvious. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates This emphasizes component styling plus derived state rather than mutating DOM classes directly."
        }
      ],
      "notes": {
        "pitfalls": [
          "Not clamping (value goes <0 or >100).",
          "Using `[style.width]` without `%` (wrong CSS).",
          "Hardcoding color logic in multiple places instead of a derived getter."
        ],
        "techniques": [
          "Use `[style.width.%]` for percent-based widths.",
          "Use a getter for threshold-based UI state.",
          "Keep minimal state + methods in one standalone component."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-progress-bar-thresholds.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-progress-bar-thresholds"
    },
    "companies": [],
    "solutionAsset": "assets/sb/angular/solution/angular-progress-bar-thresholds-solution.v2.json",
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Angular Progress Bar with Threshold Colors",
      "description": "Create a progress bar that updates from user actions, enforces valid range limits, and changes visual style by value thresholds."
    }
  },
  {
    "id": "angular-nested-comments",
    "title": "Nested Comments (Infinite Replies)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "components",
      "recursion",
      "tree",
      "forms",
      "state"
    ],
    "description": {
      "summary": "Build a nested comments panel that supports infinite-depth replies. Users can add top-level comments and reply to any comment. Clicking Reply should open an input only for that specific comment (others unaffected). Render comments hierarchically with indentation. Concepts: components, recursion, tree. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Use a standalone Angular root component.",
          "Users can add top-level comments via a textarea + Add button.",
          "Each comment shows a Reply button.",
          "Clicking Reply opens a reply input ONLY under that comment.",
          "Users can submit a reply, which becomes a child comment under the parent.",
          "Support infinite nesting depth (replies can be replied to).",
          "Render nested replies with visible indentation."
        ],
        "expectedBehavior": [
          "Submitting a top-level comment adds it to the list.",
          "Clicking Reply on one comment toggles only that comment’s reply input.",
          "Submitting a reply appends a child comment under the correct parent.",
          "Replies can be nested indefinitely.",
          "UI indentation increases with depth."
        ],
        "implementationNotes": [
          "Keep all state in the root component (no child components required).",
          "Use a tree structure: Comment = { id, text, children: Comment[] }.",
          "Track which comment is currently being replied to using `activeReplyId` (or similar).",
          "Use a single `replyDraft` string bound to the active reply input.",
          "Render recursively using an `ng-template` and `ngTemplateOutlet`."
        ],
        "techFocus": [
          "Standalone component",
          "State modeling (tree)",
          "Recursive template rendering",
          "UI state isolation (activeReplyId)",
          "Basic forms (ngModel)"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Model comments as a tree. Use one input for adding top-level comments and a second input for replying. Store `activeReplyId` to ensure only one reply input is open at a time (and only under the clicked comment). Render the tree recursively via an `ng-template` with `ngTemplateOutlet`, passing `depth` to compute indentation.\n\n**Test cases**\n- Add a top-level comment → it appears in the list.\n- Click Reply on comment A → reply input appears only under A.\n- Click Reply on comment B → input moves to B; A’s input disappears.\n- Submit a reply under A → reply is added to A.children.\n- Reply to a reply (depth 2+) → nested indentation increases and tree stays correct.",
      "approaches": [
        {
          "title": "Single component + recursive template (ngTemplateOutlet)",
          "prose": "1) Define a `CommentNode` type with `children: CommentNode[]`.\n2) Store `comments: CommentNode[]`.\n3) Use `activeReplyId: string | null` + `replyDraft: string` to control reply UI.\n4) `openReply(id)` sets activeReplyId and clears replyDraft.\n5) `submitReply(parentId)` finds the node in the tree and pushes a new child.\n6) Render recursively using an `ng-template` that calls itself via `ngTemplateOutlet`, passing `nodes` and `depth`.\n7) Apply indentation via `[style.marginLeft.px]=\"depth * 16\"`.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\ntype CommentNode = {\n  id: string;\n  text: string;\n  children: CommentNode[];\n};\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  comments: CommentNode[] = [];\n\n  topDraft = '';\n\n  activeReplyId: string | null = null;\n  replyDraft = '';\n\n  private nextId = 1;\n  private makeId(): string {\n    return String(this.nextId++);\n  }\n\n  addTop(): void {\n    const text = this.topDraft.trim();\n    if (!text) return;\n\n    this.comments.unshift({ id: this.makeId(), text, children: [] });\n    this.topDraft = '';\n  }\n\n  openReply(id: string): void {\n    // only that comment gets the input (others unaffected)\n    this.activeReplyId = id;\n    this.replyDraft = '';\n  }\n\n  cancelReply(): void {\n    this.activeReplyId = null;\n    this.replyDraft = '';\n  }\n\n  submitReply(parentId: string): void {\n    const text = this.replyDraft.trim();\n    if (!text) return;\n\n    const parent = this.findById(this.comments, parentId);\n    if (!parent) return;\n\n    parent.children.push({ id: this.makeId(), text, children: [] });\n    this.cancelReply();\n  }\n\n  private findById(nodes: CommentNode[], id: string): CommentNode | null {\n    for (const n of nodes) {\n      if (n.id === id) return n;\n      const found = this.findById(n.children, id);\n      if (found) return found;\n    }\n    return null;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using per-node booleans for reply inputs (hard to manage as tree grows).",
          "Mutating the wrong branch because parent lookup is incorrect.",
          "Trying to render recursively without `ngTemplateOutlet` (Angular doesn’t allow direct component recursion unless you create a child component)."
        ],
        "techniques": [
          "Tree structure + DFS lookup for insertion.",
          "`activeReplyId` to isolate reply UI to a single target comment.",
          "Recursive rendering with `ng-template` + `ngTemplateOutlet`."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-nested-comments.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-nested-comments"
    },
    "solutionAsset": "assets/sb/angular/solution/angular-nested-comments-solution.v2.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Nested Comments UI in Angular",
      "description": "Create a nested comments interface that supports replying at any level and renders thread hierarchy correctly."
    }
  },
  {
    "id": "angular-dynamic-counter-buttons",
    "title": "Angular Dynamic Counter Buttons (Grow-on-Click)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "components",
      "event-binding",
      "state",
      "ng-for",
      "arrays"
    ],
    "description": {
      "summary": "In Angular, users should be able to add or remove step buttons dynamically, and each button should update the counter by its own step value. Concepts: components, event binding, state, ng for, arrays. Angular focus: store step buttons in arrays and render with *ngFor. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
      "specs": {
        "requirements": [
          "Use a standalone Angular root component.",
          "Initially render exactly 1 counter button with value 0.",
          "Clicking any button increments ONLY that button’s value by 1.",
          "After each click, append a NEW button at the bottom with value 0.",
          "All buttons keep their own values independently."
        ],
        "expectedBehavior": [
          "Initial UI: one button showing 0.",
          "Click first button once → first becomes 1, and a second button (0) appears below.",
          "Click second button twice → second becomes 2, and two more new buttons (0, 0) are appended over those clicks.",
          "Existing button values never reset when new buttons appear."
        ],
        "implementationNotes": [
          "Store button values in an array like `counts: number[]`.",
          "Render buttons with `*ngFor`.",
          "On click: increment `counts[i]` and then `counts.push(0)`.",
          "Keep styling consistent with your dark UI theme (섭: explicit text color)."
        ],
        "techFocus": [
          "Array state in Angular components",
          "*ngFor rendering",
          "Event binding with parameters",
          "Simple immutable vs mutable updates (either is acceptable here)"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This combines list state and counter state. Keep step values in an array, render buttons for each, and update the count on click. Inputs should update the steps array immutably to keep change detection predictable. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "Standalone component + counts[] array",
          "prose": "Use a count variable plus an array of steps. Render buttons with *ngFor, update count += step, and add new steps via a form input. Validate input and prevent empty steps to keep UX clean and avoid NaN. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Incrementing all buttons instead of just the clicked one.",
          "Appending the new 0 before incrementing (still works but can confuse beginners).",
          "Not using explicit text colors in CSS, causing unreadable dark-on-dark labels."
        ],
        "techniques": [
          "Index-based updates in arrays",
          "Rendering dynamic lists with *ngFor",
          "Keeping UI readable on dark background with explicit colors"
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-dynamic-counter-buttons.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-dynamic-counter-buttons"
    },
    "solutionAsset": "assets/sb/angular/solution/angular-dynamic-counter-buttons-solution.v2.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Dynamic Counter Buttons in Angular",
      "description": "Create a counter interface with configurable step buttons that can be added or removed and still update shared state correctly."
    }
  },
  {
    "id": "angular-chips-input-autocomplete",
    "title": "Invite Chips Input (Tags + Autocomplete)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "components",
      "forms",
      "state",
      "event-handlers",
      "autocomplete",
      "keyboard",
      "accessibility",
      "ui-components"
    ],
    "description": {
      "summary": "Build a Material-like invite field in Angular. As users type, show autocomplete suggestions, convert selections into removable chips, and support keyboard shortcuts (Enter/comma/backspace).",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Render an input that creates chips below/inside the field.",
          "Show autocomplete suggestions filtered from a fixed users list.",
          "Exclude already-selected users from suggestions.",
          "Clicking a suggestion creates a chip and clears the input.",
          "Pressing Enter or comma creates/selects a chip.",
          "Backspace on empty input removes the last chip.",
          "Each chip has a remove button that updates state correctly.",
          "Support ArrowUp/ArrowDown + Enter keyboard navigation in the suggestion list."
        ],
        "expectedBehavior": [
          "Typing \"al\" surfaces matching user suggestions (name or email).",
          "Selecting \"Alice\" adds one chip and it no longer appears in suggestions.",
          "Typing custom text and pressing comma adds a custom chip.",
          "Pressing Enter with an active suggestion selects that suggestion.",
          "Pressing Enter/comma with no active suggestion adds a custom chip.",
          "Pressing backspace on empty input removes the most recently added chip."
        ],
        "implementationNotes": [
          "Model selected chips as an array of `{ id, label, value }`.",
          "Use a normalized id for custom chips (for example `custom-<slug>`).",
          "Prevent duplicates by id or case-insensitive value match.",
          "Use `(mousedown)` for suggestion selection to avoid blur race conditions.",
          "Keep combobox/listbox/option roles and active-descendant wiring for accessibility."
        ],
        "techFocus": [
          "Angular standalone components",
          "Template event binding + local state",
          "Derived suggestion filtering",
          "Keyboard interaction state",
          "Accessible combobox patterns"
        ]
      }
    },
    "starterCodeHint": "Implement TODOs in app.component.ts: derive suggestions, wire keyboard behavior (arrow/enter/comma/backspace), prevent duplicates, and support suggestion selection + custom chips.",
    "solutionBlock": {
      "overview": "Keep `chips`, `query`, `isOpen`, and `activeIndex` in component state. Derive suggestions from query + selected chips. Handle Enter/comma for add/select, Arrow keys for navigation, Backspace for last-chip delete, and outside click for dropdown close.",
      "approaches": [
        {
          "title": "Single standalone component with derived suggestions and keyboard UX",
          "prose": "Use a getter to filter a static dataset by query while excluding already selected chips. Add a helper that inserts chips only when unique. In `handleKeyDown`, map ArrowUp/ArrowDown to active option movement, Enter/comma to select/create, and Backspace (when input is empty) to remove the last chip. Use `@HostListener(document:mousedown)` to close the dropdown on outside clicks."
        }
      ],
      "notes": {
        "pitfalls": [
          "Using `(click)` instead of `(mousedown)` on suggestions can lose selection because blur runs first.",
          "Not normalizing text for duplicate checks leads to repeated chips with casing differences.",
          "Not resetting `activeIndex` when query changes causes stale keyboard focus."
        ],
        "techniques": [
          "Derived data via getter for suggestions.",
          "Stable keyboard interaction with `activeIndex` state.",
          "Case-insensitive de-duplication by id/value."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-chips-input-autocomplete.v1.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v1:ui:angular:angular-chips-input-autocomplete"
    },
    "solutionAsset": "assets/sb/angular/solution/angular-chips-input-autocomplete-solution.v1.json",
    "companies": [
      "amazon",
      "airbnb"
    ],
    "access": "premium",
    "updatedAt": "2026-02-09",
    "seo": {
      "title": "Build Angular Chips Input with Autocomplete",
      "description": "Create an input that lets users add and remove chips, shows matching suggestions, and handles keyboard interaction states."
    }
  },
  {
    "id": "angular-chessboard-click-highlight",
    "title": "Angular Chessboard Click/Highlight (N×N Board)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "components",
      "state",
      "event-handlers",
      "grid",
      "dom",
      "accessibility"
    ],
    "description": {
      "summary": "Build an interactive N×N chessboard in Angular. Clicking a cell should highlight it and clear the previous selection. Add a size control so users can change board dimensions.",
      "specs": {
        "requirements": [
          "Render an N×N chessboard with alternating light/dark squares.",
          "Add a numeric size input and clamp size between 2 and 20.",
          "Clicking a cell highlights it and removes highlight from the previously selected cell.",
          "Show selected cell coordinates (row/column) in a status region.",
          "Keep keyboard focus visibility and proper grid semantics."
        ],
        "expectedBehavior": [
          "Initial board renders at size 8×8.",
          "Changing board size updates the grid and clears previous selection.",
          "Clicking one cell activates only that cell.",
          "Status text updates to the selected row/column.",
          "If nothing is selected, status shows no selection."
        ],
        "implementationNotes": [
          "Use standalone component state for `size` and `selectedKey`.",
          "Compute rows/columns from the current size.",
          "Use class binding for dark/light and active styles.",
          "Keep logic deterministic and avoid external libraries."
        ],
        "techFocus": [
          "Angular standalone components",
          "Event handling and local state",
          "Grid rendering with nested *ngFor",
          "Accessible interaction patterns"
        ]
      }
    },
    "starterCodeHint": "Implement TODOs in app.component.ts: clamp size input (2..20), reset selection when size changes, and activate only the clicked cell.",
    "solutionBlock": {
      "overview": "Track `size` and `selectedKey` in component state. On size change, parse and clamp the input, then clear selection. On cell click, derive a stable key from row/col and store it. Use class bindings to render checkerboard colors and active state.",
      "approaches": [
        {
          "title": "Standalone component with derived grid and selected-key state",
          "prose": "Store `size` and `selectedKey` in the root standalone component. Build rows with `Array.from({ length: size })`, render nested loops, and map each cell to a unique key like `row-col`. On click, assign the clicked key; on size input, clamp within bounds and reset selection so state is always valid."
        }
      ],
      "notes": {
        "pitfalls": [
          "Not clamping board size can break layout and state assumptions.",
          "Tracking selection by array index alone becomes brittle after size changes.",
          "Forgetting to clear selection on resize can leave stale coordinates."
        ],
        "techniques": [
          "Derived arrays for grid rendering",
          "Stable key modeling for selected cell",
          "Simple ARIA roles for grid and gridcell semantics"
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-chessboard-click-highlight.v1.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v1:ui:angular:angular-chessboard-click-highlight"
    },
    "solutionAsset": "assets/sb/angular/solution/angular-chessboard-click-highlight-solution.v1.json",
    "companies": [
      "amazon",
      "microsoft"
    ],
    "access": "premium",
    "updatedAt": "2026-02-09",
    "seo": {
      "title": "Build Interactive N x N Chessboard in Angular",
      "description": "Create an n by n chessboard UI where selecting a cell updates highlight state and supports board-size changes."
    }
  },
  {
    "id": "angular-snake-game",
    "title": "Angular Snake Game (Grid + Food + Collision)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "components",
      "state",
      "event-handlers",
      "timers",
      "grid",
      "dom"
    ],
    "description": {
      "summary": "Build a Snake game in Angular using a grid board. Support keyboard controls, food spawning, score updates, and game-over handling for wall/body collisions.",
      "specs": {
        "requirements": [
          "Render a fixed-size board (for example 14×14) with snake body and food cells.",
          "Move the snake using Arrow keys (optionally WASD).",
          "Run game ticks on an interval while the game is running.",
          "Eating food should grow the snake and increment score.",
          "Colliding with walls or snake body should end the game.",
          "Provide Start/Pause and Reset controls.",
          "Expose score and current snake length in the UI.",
          "Keep keyboard interactions stable (no reverse-direction bug)."
        ],
        "expectedBehavior": [
          "Initial state shows a short snake, one food cell, and score 0.",
          "Press Start to begin movement; snake advances one cell per tick.",
          "When head reaches food, score increases and snake length grows by 1.",
          "Pressing opposite direction immediately should be ignored for safety.",
          "Hitting boundary or own body stops the game and shows game-over state.",
          "Reset returns to initial state with a new food position."
        ],
        "implementationNotes": [
          "Store snake as ordered coordinates, with index 0 as the head.",
          "Track both current direction and pending direction to avoid race conditions.",
          "Use Set/string keys for fast cell occupancy checks.",
          "Generate food only on free cells that are not occupied by snake.",
          "Clear interval correctly on pause, game over, and destroy."
        ],
        "techFocus": [
          "Angular standalone components",
          "Interval lifecycle management",
          "Keyboard event handling with HostListener",
          "Immutable updates for moving/growing arrays"
        ]
      }
    },
    "starterCodeHint": "Implement TODOs in app.component.ts: keyboard direction updates, game loop movement, collision checks, food growth, and reset flow.",
    "solutionBlock": {
      "overview": "Keep snake coordinates, direction, pendingDirection, food, score, and run state in component state. Tick with setInterval, prepend next head, and pop tail unless food is eaten. End the game on wall/body collision.",
      "approaches": [
        {
          "title": "Single standalone component with deterministic game-loop state",
          "prose": "On each tick, compute the next head from current direction. Validate collisions before mutating state. If food is eaten, keep the tail (grow) and spawn new food on a free cell. Otherwise remove tail for standard movement. Use HostListener key mapping and block immediate opposite-direction turns."
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing immediate reverse direction can cause instant self-collision artifacts.",
          "Forgetting interval cleanup leads to duplicate timers and speed glitches.",
          "Spawning food without excluding snake cells can make unreachable food."
        ],
        "techniques": [
          "Occupancy keys like `x,y` for constant-time lookups.",
          "Pending direction buffer to avoid same-tick race conditions.",
          "Deterministic tick flow with explicit collision branches."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-snake-game.v1.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v1:ui:angular:angular-snake-game"
    },
    "solutionAsset": "assets/sb/angular/solution/angular-snake-game-solution.v1.json",
    "companies": [
      "amazon",
      "microsoft"
    ],
    "access": "premium",
    "updatedAt": "2026-02-09",
    "seo": {
      "title": "Build Snake Game in Angular",
      "description": "Create a snake game interface with movement, food collection, scoring, and clear game-over behavior for collisions."
    }
  }
]
