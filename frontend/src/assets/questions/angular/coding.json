[
  {
    "id": "angular-counter-starter",
    "title": "Counter (Standalone Component)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "beginner",
    "importance": 3,
    "tags": [
      "components",
      "event-binding",
      "state"
    ],
    "description": {
      "summary": "Build a simple counter using an Angular standalone component. Add increment, decrement, and reset buttons. Disable the decrement button when the counter is at zero.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Display the current count value.",
          "Provide \"+\", \"-\", and \"Reset\" buttons.",
          "Disable the decrement button when the count is 0."
        ],
        "expectedBehavior": [
          "Clicking \"+\" increases the count by 1.",
          "Clicking \"-\" decreases the count by 1, but never below 0.",
          "Clicking \"Reset\" sets the count back to 0."
        ],
        "implementationNotes": [
          "Use a regular class property (e.g. `count = 0`) to store state.",
          "Use template event bindings like `(click)=\"...\"` for button actions.",
          "No need for child components, signals, or advanced patterns in this starter."
        ],
        "techFocus": [
          "Standalone component setup",
          "Basic state management in a component",
          "Event binding and conditional disabling"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise requires a single piece of state: the number of times the user has interacted with the counter. Store it in a component property (e.g. `count = 0`) on a standalone root component. Use three buttons wired with Angular event bindings to increment, decrement, and reset that state. Guard the decrement so the value never drops below zero and expose a simple derived flag to control the disabled state of the \"-\" button.\n\n**Test cases**\n- Click \"+\" once → count becomes `1`.\n- Click \"+\" multiple times → count increases by 1 on each click.\n- With count at `0`, \"-\" is disabled and clicking it does nothing.\n- From a positive value, clicking \"-\" decreases the count by 1, but never below `0`.\n- From a positive value, clicking \"Reset\" sets count back to `0` and disables \"-\" again.",
      "approaches": [
        {
          "title": "Standalone component with internal state and guarded decrement",
          "prose": "Use a single standalone `AppComponent` that holds the `count` state.\n\n1. Declare `count = 0` as a class property.\n2. Add methods `inc()`, `dec()`, and `reset()`.\n   - `inc()` increments `count` by 1.\n   - `dec()` decrements only when `count` is greater than 0.\n   - `reset()` sets `count` to 0.\n3. Bind the methods to the buttons with `(click)` in the template.\n4. Bind the disabled state of the decrement button to a derived check, e.g. `isZero` getter returning `count === 0`.\n\nThis keeps the implementation minimal while showing how to wire state, events, and disabled UI in a standalone Angular component.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <main class=\"app\">\n      <section class=\"card\">\n        <h1>Counter</h1>\n        <div class=\"value\">{{ count }}</div>\n        <div class=\"actions\">\n          <button (click)=\"dec()\" [disabled]=\"isZero\" aria-label=\"decrement\">−</button>\n          <button (click)=\"inc()\" aria-label=\"increment\">+</button>\n          <button (click)=\"reset()\" class=\"ghost\" aria-label=\"reset\">Reset</button>\n        </div>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.app{min-height:100vh;display:grid;place-items:center;background:#0a0a0a;color:#e5e7eb;}`,\n    `.card{padding:16px 20px;background:#0b1020;border-radius:12px;border:1px solid #1f2937;display:grid;gap:12px;}`,\n    `.value{font-size:40px;font-weight:800;text-align:center;}`,\n    `.actions{display:flex;gap:8px;justify-content:center;}`,\n    `button{padding:8px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:600;}`,\n    `button[disabled]{opacity:.5;cursor:not-allowed;}`,\n    `.ghost{background:transparent;color:#e5e7eb;border:1px solid #374151;}`\n  ]\n})\nexport class AppComponent {\n  count = 0;\n\n  get isZero(): boolean {\n    return this.count === 0;\n  }\n\n  inc(): void {\n    this.count++;\n  }\n\n  dec(): void {\n    if (!this.isZero) {\n      this.count--;\n    }\n  }\n\n  reset(): void {\n    this.count = 0;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing the count to go below 0 when handling the decrement.",
          "Forgetting to bind the disabled state of the decrement button, which makes the UX unclear.",
          "Mutating state in the template instead of through clear component methods."
        ],
        "techniques": [
          "Using a standalone component with `standalone: true` and `imports` instead of NgModule.",
          "Using a derived getter (`isZero`) for simple view logic instead of duplicating conditions.",
          "Keeping all state and logic colocated in the root component for a small exercise."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-counter.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-counter-starter"
    },
    "companies": [
      "google",
      "meta",
      "uber"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-counter-solution.v2.json"
  },
  {
    "id": "angular-contact-form-starter",
    "title": "Contact Form (Standalone Component + HTTP)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "forms",
      "http",
      "validation",
      "user-input"
    ],
    "description": {
      "summary": "Build a contact form using an Angular standalone component and reactive forms. You will only work in `src/app/app.component.ts` – the HTML, CSS, and bootstrapping are already set up. On submit, validate the input and send the form data with a POST request to a fake JSON API endpoint, showing loading, success, and error states.",
      "specs": {
        "requirements": [
          "Work only inside the standalone root component in `src/app/app.component.ts` (template and styles are already provided).",
          "Build/configure a reactive form with fields for name, email, and message.",
          "Make all fields required; validate email with a basic email validator.",
          "Disable the submit button while the form is invalid or while a request is in progress.",
          "On valid submit, send a POST request with the form body to `https://jsonplaceholder.typicode.com/posts` using HttpClient.",
          "If the request succeeds, set `successMessage` to `\"Your message has been sent. Thank you!\"`.",
          "If the request fails, set `errorMessage` to `\"Something went wrong. Please try again.\"`.",
          "Track an `isSubmitting` flag so the user cannot trigger multiple requests at the same time."
        ],
        "expectedBehavior": [
          "Initially, the submit button is disabled until the form becomes valid (all required fields filled and email valid).",
          "If the user attempts to submit invalid data, all controls are marked as touched and validation error messages are shown for the affected fields.",
          "On a valid submit, a POST request is sent to `https://jsonplaceholder.typicode.com/posts` and the button is disabled while `isSubmitting` is true.",
          "On success, `isSubmitting` becomes false, `successMessage` is set to `\"Your message has been sent. Thank you!\"`, and the form may optionally be reset.",
          "On error, `isSubmitting` becomes false, `errorMessage` is set to `\"Something went wrong. Please try again.\"`, and the user can fix the issue and resubmit."
        ],
        "implementationNotes": [
          "Configure the reactive form and all request/UX logic inside `AppComponent` in `app.component.ts`. You do not need to change the HTML or CSS files for this exercise.",
          "Use `ReactiveFormsModule` and `FormBuilder` to define the form group for the contact form.",
          "Use Angular's built-in validators such as `Validators.required` and `Validators.email` (and optionally `Validators.minLength` for the message).",
          "Inject `HttpClient` (or use the `inject(HttpClient)` helper) and use `HttpClientModule` to send the POST request.",
          "Clear previous `successMessage` / `errorMessage` at the start of `submit()` so only the latest result is shown.",
          "Call `markAllAsTouched()` on the form before checking validity, so error messages appear when the user submits incomplete data.",
          "Use an `isSubmitting` flag to guard against double submissions and to drive the disabled state of the submit button.",
          "On success, you can reset the form to its initial state while keeping the success message visible."
        ],
        "techFocus": [
          "Standalone component setup with reactive forms",
          "Form validation and UX (disabled submit, inline errors, touched state)",
          "Basic HttpClient usage with a fake POST endpoint and request lifecycle handling",
          "Managing loading, success, and error states in a single component"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise combines a standalone component, reactive forms, and HttpClient. You only need to work in `src/app/app.component.ts`: the HTML and CSS are already wired up to bind to `contactForm`, `isSubmitting`, `successMessage`, and `errorMessage`.\n\nYou define a reactive form with `name`, `email`, and `message` controls, wire up validation, and then send a POST request to the fake endpoint `https://jsonplaceholder.typicode.com/posts` when the user submits. The component tracks an `isSubmitting` flag so you can disable the submit button while the request is in flight, plus `successMessage` and `errorMessage` strings for user feedback.\n\nOn a valid submit, you clear any previous messages, mark all controls as touched, bail out if the form is still invalid, set `isSubmitting` to `true`, and call `http.post(...)` with the form value. On success you show `\"Your message has been sent. Thank you!\"`, reset the form, and re-enable the button. On error you show `\"Something went wrong. Please try again.\"` and let the user resubmit.\n\n**Test cases**\n- With all fields empty, the submit button is disabled.\n- Typing an invalid email keeps the form invalid and disabled.\n- Tapping submit with invalid fields marks controls as touched and shows validation errors.\n- With valid inputs, clicking submit triggers a POST request to `https://jsonplaceholder.typicode.com/posts` and disables the button while `isSubmitting` is `true`.\n- On success, `\"Your message has been sent. Thank you!\"` is shown and the form can optionally reset.\n- On error, `\"Something went wrong. Please try again.\"` is shown and the user can resubmit.",
      "approaches": [
        {
          "title": "Standalone reactive form with HttpClient, status flags, and a fake endpoint",
          "prose": "Use a standalone `AppComponent` that imports `ReactiveFormsModule` and `HttpClientModule`. Inside `app.component.ts`, create a reactive form with `name`, `email`, and `message` controls, all required, and use `Validators.email` (and optionally `Validators.minLength`) for the email and message fields.\n\nUse Angular's function-based DI helpers (`inject(FormBuilder)` and `inject(HttpClient)`) instead of a constructor to avoid any metadata issues in this environment. The template is already set up to use `[formGroup]`, `formControlName`, and to bind the submit button disabled state to `contactForm.invalid || isSubmitting`. It also binds to `successMessage` and `errorMessage` paragraphs.\n\nIn `submit()`, implement the request lifecycle:\n1. Clear previous `successMessage` and `errorMessage`.\n2. Call `this.contactForm.markAllAsTouched()` so validation errors appear.\n3. If the form is invalid, return early.\n4. Set `isSubmitting = true` and send a POST request using `this.http.post('https://jsonplaceholder.typicode.com/posts', this.contactForm.value)`.\n5. In the `next` handler, set `isSubmitting` back to `false`, set `successMessage = 'Your message has been sent. Thank you!'`, and reset the form.\n6. In the `error` handler, set `isSubmitting` back to `false` and `errorMessage = 'Something went wrong. Please try again.'`.\n\nAll logic stays inside `AppComponent`, which keeps this exercise focused on reactive forms + HttpClient without extra services or routing.",
          "codeTs": "import { Component, inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormBuilder, Validators, ReactiveFormsModule } from '@angular/forms';\nimport { HttpClient, HttpClientModule } from '@angular/common/http';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, ReactiveFormsModule, HttpClientModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport default class AppComponent {\n  // Function-based DI to match the SDK environment\n  private fb = inject(FormBuilder);\n  private http = inject(HttpClient);\n\n  // Reactive contact form with basic validation\n  contactForm = this.fb.group({\n    name: ['', [Validators.required]],\n    email: ['', [Validators.required, Validators.email]],\n    message: ['', [Validators.required, Validators.minLength(10)]],\n  });\n\n  isSubmitting = false;\n  successMessage = '';\n  errorMessage = '';\n\n  get f() {\n    return this.contactForm.controls;\n  }\n\n  submit(): void {\n    // Clear previous messages\n    this.successMessage = '';\n    this.errorMessage = '';\n\n    // Show validation errors if form is invalid\n    this.contactForm.markAllAsTouched();\n    if (this.contactForm.invalid) {\n      return;\n    }\n\n    this.isSubmitting = true;\n\n    // Fake JSON API endpoint for this exercise\n    this.http.post('https://jsonplaceholder.typicode.com/posts', this.contactForm.value).subscribe({\n      next: () => {\n        this.isSubmitting = false;\n        this.successMessage = 'Your message has been sent. Thank you!';\n        this.contactForm.reset();\n      },\n      error: () => {\n        this.isSubmitting = false;\n        this.errorMessage = 'Something went wrong. Please try again.';\n      },\n    });\n  }\n}\n\n// Also export a named AppComponent so the bootstrap import always works\nexport { AppComponent };\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting that you only need to modify `src/app/app.component.ts`; the HTML and CSS are already wired to the expected properties.",
          "Not importing `ReactiveFormsModule` and `HttpClientModule` in the standalone component's `imports` array, which would break the form and HttpClient usage.",
          "Allowing the user to submit when the form is invalid or while a previous request is still in flight (missing the `isSubmitting` guard).",
          "Not calling `markAllAsTouched()` before checking validity, which can hide validation errors when the user hits submit on an untouched form.",
          "Hard-coding different success or error messages than the ones specified in the exercise, which may cause tests to fail."
        ],
        "techniques": [
          "Using reactive forms with `FormBuilder` and function-based DI via `inject()`.",
          "Using Angular's built-in validators for required fields, email validation, and minimum length.",
          "Managing loading, success, and error states with simple component properties and a single `submit()` method.",
          "Disabling the submit button based on both form validity and an `isSubmitting` flag.",
          "Using a fake HTTP endpoint (`https://jsonplaceholder.typicode.com/posts`) to simulate a real backend without extra setup."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-contact-form.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-contact-form-starter"
    },
    "companies": [
      "google",
      "meta",
      "airbnb"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-contact-form-solution.v2.json"
  },
  {
    "id": "angular-todo-list-starter",
    "title": "Todo List (Standalone Component with ngFor)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "components",
      "state",
      "lists",
      "ngFor",
      "forms"
    ],
    "description": {
      "summary": "Build a small todo list using an Angular standalone component. Allow users to add tasks, mark them as completed, and remove them. Use `*ngFor` to render the list and simple component state to drive the UI.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Display a text input and an \"Add\" button for creating new todos.",
          "Render the todo items in a list using `*ngFor`.",
          "Each todo item should show a label and a checkbox to toggle completion.",
          "Allow removing a single todo item from the list.",
          "Optionally provide a \"Clear completed\" action to remove all completed todos."
        ],
        "expectedBehavior": [
          "Typing a non-empty value and clicking \"Add\" appends a new todo to the list and clears the input.",
          "Empty or whitespace-only values are ignored (no item is added).",
          "Clicking a todo’s checkbox toggles its completed state.",
          "Completed todos are visually distinguished (e.g. line-through).",
          "Clicking a remove button deletes that specific todo.",
          "If you implement \"Clear completed\", it removes only the completed todos."
        ],
        "implementationNotes": [
          "Keep everything in `AppComponent` (`src/app/app.component.ts` and `app.component.html`). No extra services or components are required.",
          "Use a simple array of objects (e.g. `{ id, text, done }`) to store todos.",
          "Use `*ngFor` to loop over the todo array in the template.",
          "Use `[(ngModel)]` for the input binding and checkbox bindings (remember to import `FormsModule`).",
          "Use click handlers like `(click)=\"addTask()\"` and `(click)=\"removeTask(task)\"` to modify the array."
        ],
        "techFocus": [
          "Standalone component setup with `standalone: true`",
          "Managing in-memory state in a component",
          "Rendering lists with `*ngFor`",
          "Using `[(ngModel)]` for simple form input binding",
          "Basic UX for add / toggle / remove actions"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise models a classic todo list with a single standalone component. You keep all state inside the component: a `newTask` string for the input and a `todos` array (e.g. `{ id, text, done }`). The template binds `newTask` with `[(ngModel)]`, renders `todos` with `*ngFor`, and wires up click handlers to add, toggle, and remove items.\n\nTypical flow:\n- User types into the input; `newTask` is updated via `[(ngModel)]`.\n- Clicking **Add** (or pressing Enter, if you implement it) calls `addTask()`, which trims the text, ignores empties, pushes a new todo into the array, and resets `newTask`.\n- Each todo row shows a checkbox bound to `todo.done` and maybe styled with a `.done` CSS class when complete.\n- Clicking the remove button calls `removeTask(todo)`, which filters that item out.\n- Optionally, a \"Clear completed\" button calls `clearCompleted()` to remove all completed todos.\n\n**Test cases**\n- With an empty input, clicking **Add** does nothing.\n- Typing \"Buy milk\" and clicking **Add** shows a single todo row with that text.\n- Toggling the checkbox marks the item as completed and applies the completed styling.\n- Clicking the remove button deletes that specific row.\n- After completing multiple todos, clicking \"Clear completed\" (if implemented) removes only the completed ones.",
      "approaches": [
        {
          "title": "Standalone component with a local array of todos",
          "prose": "Represent todos as `{ id, text, done }` objects stored in a `todos` array property. Use a simple incremental `nextId` counter for unique ids. The input is bound via `[(ngModel)]=\"newTask\"`. In `addTask()`, trim `newTask`, ignore empties, then push a new object. In the template, use `*ngFor=\"let todo of todos; trackBy: trackById\"` to render each row with a checkbox bound to `todo.done` and a remove button.\n\n`toggleTask(todo)` can simply flip `todo.done = !todo.done`, or you can rely entirely on `[(ngModel)]` on the checkbox and only use handlers for extra behavior. `removeTask(todo)` filters `todos` to drop the item by id. `clearCompleted()` sets `todos` to `todos.filter(t => !t.done)`. This keeps all list and input logic colocated in the root standalone component.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\ninterface Todo {\n  id: number;\n  text: string;\n  done: boolean;\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  newTask = '';\n  todos: Todo[] = [];\n  private nextId = 1;\n\n  get hasTodos(): boolean {\n    return this.todos.length > 0;\n  }\n\n  addTask(): void {\n    const text = this.newTask.trim();\n    if (!text) {\n      return;\n    }\n\n    this.todos = [\n      ...this.todos,\n      { id: this.nextId++, text, done: false }\n    ];\n\n    this.newTask = '';\n  }\n\n  toggleTask(todo: Todo): void {\n    todo.done = !todo.done;\n  }\n\n  removeTask(todo: Todo): void {\n    this.todos = this.todos.filter(t => t.id !== todo.id);\n  }\n\n  clearCompleted(): void {\n    this.todos = this.todos.filter(t => !t.done);\n  }\n\n  trackById(_index: number, todo: Todo): number {\n    return todo.id;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing empty or whitespace-only todos to be added.",
          "Mutating the `todos` array in a way that loses track of identity (e.g. reusing the same id for all items).",
          "Forgetting to import `FormsModule`, which breaks `[(ngModel)]` bindings.",
          "Handling toggle logic only in a click handler but not binding the checkbox correctly."
        ],
        "techniques": [
          "Modeling UI items as simple objects inside a component.",
          "Using `[(ngModel)]` for a controlled input and checkbox bindings.",
          "Rendering lists with `*ngFor` and `trackBy` for better identity handling.",
          "Using pure functions (`filter`, `map`) to derive new arrays when removing or clearing items."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-todo-list.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-todo-list-starter"
    },
    "companies": [
      "google",
      "meta",
      "airbnb"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-todo-list-solution.v2.json"
  },
  {
    "id": "angular-image-slider-starter",
    "title": "Image Slider (Standalone Component)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "components",
      "state",
      "event-binding",
      "ngFor",
      "ui"
    ],
    "description": {
      "summary": "Build an image slider in an Angular standalone component. Show one slide at a time with next/previous buttons and clickable dot indicators.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Keep an in-memory list of slides (each with at least a title and image URL).",
          "Display the currently active slide (image and title).",
          "Provide \"Previous\" and \"Next\" buttons to move between slides.",
          "Disable the \"Previous\" button on the first slide and the \"Next\" button on the last slide.",
          "Render dot indicators for each slide; clicking a dot should jump to that slide.",
          "Display a small \"Slide X of N\" helper text."
        ],
        "expectedBehavior": [
          "Initial view shows the first slide.",
          "Clicking \"Next\" advances to the next slide until the last one; afterwards it stays on the last slide and \"Next\" becomes disabled.",
          "Clicking \"Previous\" moves backwards until the first slide; on the first slide it stays there and \"Previous\" is disabled.",
          "Clicking a dot activates the corresponding slide, updates the main image and title, and updates the \"Slide X of N\" text.",
          "The active slide's dot is visually highlighted."
        ],
        "implementationNotes": [
          "Store slides in a readonly array on the component (e.g. `slides = [...]`).",
          "Track the active slide with a simple numeric index (e.g. `currentIndex = 0`).",
          "Derive the current slide with a getter (e.g. `currentSlide`), and flags like `canGoPrev` / `canGoNext` from the index.",
          "Use template bindings (`(click)`, `[disabled]`, `*ngFor`, `[class.active]`) to wire up the controls and indicators.",
          "No need for routing, services, or external state management; keep everything in the root component."
        ],
        "techFocus": [
          "Standalone component setup",
          "View model with derived state (current slide, canGoPrev/canGoNext)",
          "Template control flow with *ngFor and event bindings",
          "Basic UI state + styling for active / disabled controls"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Model the slider as a small view model on the component: a readonly `slides` array and a `currentIndex` number. Use getters to derive `currentSlide`, `totalSlides`, and convenience flags like `canGoPrev` and `canGoNext`. The template shows the active slide and wires buttons and dot indicators to simple methods that update `currentIndex`.\n\n**Test cases**\n- Initial render shows the first slide, with \"Previous\" disabled and the first dot highlighted.\n- Clicking \"Next\" repeatedly walks through the slides and disables itself on the last slide.\n- Clicking \"Previous\" from the middle moves backward one slide at a time.\n- Clicking a dot jumps directly to that slide and updates the heading, image, and helper text.\n- The slider never goes out of range (no index smaller than 0 or greater than `slides.length - 1`).",
      "approaches": [
        {
          "title": "Standalone component with index-based navigation",
          "prose": "Use a single standalone `AppComponent` that owns the slider state.\n\n1. Define a `Slide` interface (`id`, `title`, `imageUrl`, optional `description`). Keep a `readonly slides: Slide[]` array.\n2. Track the active slide with `currentIndex = 0`.\n3. Expose getters like `currentSlide`, `totalSlides`, `canGoPrev`, and `canGoNext`.\n4. Implement `goTo(index: number)`, `prev()`, and `next()` to clamp `currentIndex` inside `[0, totalSlides - 1]`.\n5. In the template, show the current slide image and title, wire buttons to `prev()` / `next()`, use `[disabled]` for edge cases, and render dot buttons with `*ngFor` and `[class.active]` to highlight the current slide.\n\nThis keeps the logic small and testable while exercising Angular's template bindings and derived state.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ninterface Slide {\n  id: number;\n  title: string;\n  imageUrl: string;\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <main class=\"app\">\n      <section class=\"card\">\n        <h1>Image Slider</h1>\n\n        <figure class=\"frame\" *ngIf=\"currentSlide as slide\">\n          <img class=\"image\" [src]=\"slide.imageUrl\" [alt]=\"slide.title\" />\n          <figcaption class=\"caption\">{{ slide.title }}</figcaption>\n        </figure>\n\n        <div class=\"meta\">\n          Slide {{ currentIndex + 1 }} of {{ totalSlides }}\n        </div>\n\n        <div class=\"actions\">\n          <button (click)=\"prev()\" [disabled]=\"!canGoPrev\">Previous</button>\n          <button (click)=\"next()\" [disabled]=\"!canGoNext\">Next</button>\n        </div>\n\n        <div class=\"dots\">\n          <button\n            *ngFor=\"let slide of slides; let i = index\"\n            type=\"button\"\n            class=\"dot\"\n            [class.active]=\"i === currentIndex\"\n            (click)=\"goTo(i)\"\n            aria-label=\"Go to slide {{ i + 1 }}\"\n          ></button>\n        </div>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.app{min-height:100vh;display:grid;place-items:center;background:#0a0a0a;color:#e5e7eb;}`,\n    `.card{width:100%;max-width:520px;padding:16px 20px;background:#0b1020;border-radius:12px;border:1px solid #1f2937;display:grid;gap:12px;}`,\n    `.frame{margin:0;border-radius:12px;overflow:hidden;border:1px solid #1f2937;background:#020617;}`,\n    `.image{display:block;width:100%;height:240px;object-fit:cover;}`,\n    `.caption{padding:8px 12px;font-size:14px;color:#e5e7eb;background:rgba(15,23,42,.9);}`,\n    `.meta{font-size:12px;color:#9ca3af;text-align:center;}`,\n    `.actions{display:flex;gap:8px;justify-content:center;}`,\n    `button{padding:8px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:600;background:#a3e635;color:#111;}`,\n    `button[disabled]{opacity:.5;cursor:not-allowed;}`,\n    `.dots{display:flex;justify-content:center;gap:6px;margin-top:4px;}`,\n    `.dot{width:8px;height:8px;border-radius:999px;border:none;background:#374151;cursor:pointer;}`,\n    `.dot.active{background:#a3e635;}`\n  ]\n})\nexport class AppComponent {\n  readonly slides: Slide[] = [\n    {\n      id: 1,\n      title: 'Snowflakes glowing under city lights',\n      imageUrl: 'https://images.pexels.com/photos/46253/pexels-photo-46253.jpeg'\n    },\n    {\n      id: 2,\n      title: 'Forest trail in the morning',\n      imageUrl: 'https://images.pexels.com/photos/1563604/pexels-photo-1563604.jpeg'\n    },\n    {\n      id: 3,\n      title: 'City lights at night',\n      imageUrl: 'https://images.pexels.com/photos/220067/pexels-photo-220067.jpeg'\n    }\n  ];\n\n  currentIndex = 0;\n\n  get totalSlides(): number {\n    return this.slides.length;\n  }\n\n  get currentSlide(): Slide | null {\n    return this.slides[this.currentIndex] ?? null;\n  }\n\n  get canGoPrev(): boolean {\n    return this.currentIndex > 0;\n  }\n\n  get canGoNext(): boolean {\n    return this.currentIndex < this.totalSlides - 1;\n  }\n\n  goTo(index: number): void {\n    if (index < 0 || index >= this.totalSlides) return;\n    this.currentIndex = index;\n  }\n\n  prev(): void {\n    if (this.canGoPrev) {\n      this.currentIndex--;\n    }\n  }\n\n  next(): void {\n    if (this.canGoNext) {\n      this.currentIndex++;\n    }\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing `currentIndex` to go out of range (negative or >= slides.length).",
          "Duplicating `slides[currentIndex]` access all over the template instead of using a getter.",
          "Not disabling buttons at the edges, making the UX feel broken."
        ],
        "techniques": [
          "Using a simple numeric index to represent view state.",
          "Deriving convenience getters for current slide and navigation flags.",
          "Using `[class.active]` and `[disabled]` to reflect state in the UI."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-image-slider.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-image-slider-starter"
    },
    "companies": [
      "google",
      "meta",
      "airbnb"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-image-slider-solution.v2.json"
  },
  {
    "id": "angular-tabs-switcher",
    "title": "Tabs / Multi-View Switcher",
    "type": "coding",
    "technology": "angular",
    "difficulty": "beginner",
    "importance": 3,
    "tags": [
      "components",
      "state",
      "conditional-rendering",
      "tabs"
    ],
    "description": {
      "summary": "Build a simple tabbed interface with three tabs (\"Overview\", \"Details\", \"Settings\") that controls which content is visible.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Render three tabs labeled \"Overview\", \"Details\", and \"Settings\".",
          "Track which tab is currently active and visually highlight it.",
          "Render only the active tab's content at a time."
        ],
        "expectedBehavior": [
          "The initial active tab should be \"Overview\".",
          "Clicking a tab makes it the active tab.",
          "Only the active tab's panel is visible at any time.",
          "The active tab button has a distinct visual style (e.g. underline or background)."
        ],
        "implementationNotes": [
          "Store the currently active tab in a component property.",
          "Use template bindings and event handlers (e.g. `(click)`) to switch tabs.",
          "Use conditional rendering (e.g. `*ngIf`) to show/hide each panel.",
          "You can model the active tab as a union type like `'overview' | 'details' | 'settings'` for extra type safety."
        ],
        "techFocus": [
          "Basic state management in a component",
          "Conditional rendering with `*ngIf`",
          "Simple component composition and layout for tabs"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about modeling a small piece of UI state (which tab is active) and using that state to drive both styles and conditional rendering. Use a single standalone Angular component that owns an `activeTab` property. The tab buttons call a `selectTab(tab)` method, and helper logic like `isActive(tab)` feeds CSS classes and `*ngIf` checks for the content panels.\n\n**Test cases**\n- Initial render shows the Overview panel and its tab appears active.\n- Clicking Details switches the active tab and hides Overview content.\n- Clicking Settings switches again and only the Settings content is visible.\n- Re-clicking an already active tab keeps the same content and styles.",
      "approaches": [
        {
          "title": "Single standalone component with `activeTab` state",
          "prose": "Keep everything in a single `AppComponent` to emphasise basic state management and conditional rendering.\n\n1. Define a `TabId` union type: `'overview' | 'details' | 'settings'`.\n2. Add an `activeTab: TabId = 'overview';` property.\n3. Implement a `selectTab(tab: TabId)` method that simply assigns `this.activeTab = tab;`.\n4. Add a helper `isActive(tab: TabId)` that returns `this.activeTab === tab` and use it in `[class.active]` and `*ngIf` checks.\n5. Structure the template with a header row of buttons for the tabs and three conditional sections for the panels.\n\nThis mirrors real-world tab patterns but stays small enough for a beginner exercise.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ntype TabId = 'overview' | 'details' | 'settings';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <main class=\"shell\">\n      <section class=\"card\">\n        <h1>Tabs / Multi-View Switcher</h1>\n\n        <nav class=\"tabs\">\n          <button\n            class=\"tab\"\n            [class.active]=\"isActive('overview')\"\n            (click)=\"selectTab('overview')\">Overview</button>\n          <button\n            class=\"tab\"\n            [class.active]=\"isActive('details')\"\n            (click)=\"selectTab('details')\">Details</button>\n          <button\n            class=\"tab\"\n            [class.active]=\"isActive('settings')\"\n            (click)=\"selectTab('settings')\">Settings</button>\n        </nav>\n\n        <section class=\"panel\" *ngIf=\"isActive('overview')\">\n          <h2>Overview</h2>\n          <p>Show a short summary or welcome message here.</p>\n        </section>\n\n        <section class=\"panel\" *ngIf=\"isActive('details')\">\n          <h2>Details</h2>\n          <p>Display more detailed information in this panel.</p>\n        </section>\n\n        <section class=\"panel\" *ngIf=\"isActive('settings')\">\n          <h2>Settings</h2>\n          <p>Render some simple settings-like content here.</p>\n        </section>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.shell{min-height:100vh;display:grid;place-items:center;background:#020617;color:#e5e7eb;padding:24px;}`,\n    `.card{width:100%;max-width:560px;background:#020617;border-radius:16px;border:1px solid #1f2937;padding:20px 20px 24px;box-shadow:0 18px 45px rgba(15,23,42,0.8);display:grid;gap:16px;}`,\n    `.card h1{margin:0 0 4px;font-size:20px;font-weight:700;}`,\n    `.tabs{display:flex;gap:8px;padding:4px;background:#020617;border-radius:999px;border:1px solid #1f2937;}`,\n    `.tab{flex:1;padding:8px 10px;border-radius:999px;border:none;background:transparent;color:#9ca3af;font-size:13px;font-weight:600;cursor:pointer;transition:background .15s, color .15s;}`,\n    `.tab.active{background:#e5e7eb;color:#020617;}`,\n    `.panel{margin-top:4px;border-radius:12px;border:1px solid #111827;background:radial-gradient(circle at top left,#111827,#020617);padding:14px 16px;display:grid;gap:4px;}`,\n    `.panel h2{margin:0 0 4px;font-size:16px;font-weight:600;}`,\n    `.panel p{margin:0;font-size:13px;color:#d1d5db;line-height:1.5;}`\n  ]\n})\nexport class AppComponent {\n  activeTab: TabId = 'overview';\n\n  isActive(tab: TabId): boolean {\n    return this.activeTab === tab;\n  }\n\n  selectTab(tab: TabId): void {\n    this.activeTab = tab;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Hard-coding panel visibility without tying it to a single source of truth for the active tab.",
          "Forgetting to visually differentiate the active tab from inactive ones.",
          "Using separate booleans for each tab instead of a single `activeTab` value, which quickly becomes harder to manage."
        ],
        "techniques": [
          "Modeling view state with a union type for clearer intent.",
          "Using helper methods like `isActive` to keep the template clean.",
          "Applying classes conditionally with `[class.active]` to style the active tab."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-tabs.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-tabs-starter"
    },
    "companies": [
      "google",
      "meta",
      "uber"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-tabs-solution.v2.json"
  }
]