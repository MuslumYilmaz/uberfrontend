[
  {
    "id": "angular-counter-starter",
    "title": "Counter (Standalone Component)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "beginner",
    "importance": 3,
    "tags": [
      "components",
      "event-binding",
      "state"
    ],
    "description": {
      "summary": "Build a simple counter using an Angular standalone component. Add increment, decrement, and reset buttons. Disable the decrement button when the counter is at zero.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Display the current count value.",
          "Provide \"+\", \"-\", and \"Reset\" buttons.",
          "Disable the decrement button when the count is 0."
        ],
        "expectedBehavior": [
          "Clicking \"+\" increases the count by 1.",
          "Clicking \"-\" decreases the count by 1, but never below 0.",
          "Clicking \"Reset\" sets the count back to 0."
        ],
        "implementationNotes": [
          "Use a regular class property (e.g. `count = 0`) to store state.",
          "Use template event bindings like `(click)=\"...\"` for button actions.",
          "No need for child components, signals, or advanced patterns in this starter."
        ],
        "techFocus": [
          "Standalone component setup",
          "Basic state management in a component",
          "Event binding and conditional disabling"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise requires a single piece of state: the number of times the user has interacted with the counter. Store it in a component property (e.g. `count = 0`) on a standalone root component. Use three buttons wired with Angular event bindings to increment, decrement, and reset that state. Guard the decrement so the value never drops below zero and expose a simple derived flag to control the disabled state of the \"-\" button.\n\n**Test cases**\n- Click \"+\" once → count becomes `1`.\n- Click \"+\" multiple times → count increases by 1 on each click.\n- With count at `0`, \"-\" is disabled and clicking it does nothing.\n- From a positive value, clicking \"-\" decreases the count by 1, but never below `0`.\n- From a positive value, clicking \"Reset\" sets count back to `0` and disables \"-\" again.",
      "approaches": [
        {
          "title": "Standalone component with internal state and guarded decrement",
          "prose": "Use a single standalone `AppComponent` that holds the `count` state.\n\n1. Declare `count = 0` as a class property.\n2. Add methods `inc()`, `dec()`, and `reset()`.\n   - `inc()` increments `count` by 1.\n   - `dec()` decrements only when `count` is greater than 0.\n   - `reset()` sets `count` to 0.\n3. Bind the methods to the buttons with `(click)` in the template.\n4. Bind the disabled state of the decrement button to a derived check, e.g. `isZero` getter returning `count === 0`.\n\nThis keeps the implementation minimal while showing how to wire state, events, and disabled UI in a standalone Angular component.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <main class=\"app\">\n      <section class=\"card\">\n        <h1>Counter</h1>\n        <div class=\"value\">{{ count }}</div>\n        <div class=\"actions\">\n          <button (click)=\"dec()\" [disabled]=\"isZero\" aria-label=\"decrement\">−</button>\n          <button (click)=\"inc()\" aria-label=\"increment\">+</button>\n          <button (click)=\"reset()\" class=\"ghost\" aria-label=\"reset\">Reset</button>\n        </div>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.app{min-height:100vh;display:grid;place-items:center;background:#0a0a0a;color:#e5e7eb;}`,\n    `.card{padding:16px 20px;background:#0b1020;border-radius:12px;border:1px solid #1f2937;display:grid;gap:12px;}`,\n    `.value{font-size:40px;font-weight:800;text-align:center;}`,\n    `.actions{display:flex;gap:8px;justify-content:center;}`,\n    `button{padding:8px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:600;}`,\n    `button[disabled]{opacity:.5;cursor:not-allowed;}`,\n    `.ghost{background:transparent;color:#e5e7eb;border:1px solid #374151;}`\n  ]\n})\nexport class AppComponent {\n  count = 0;\n\n  get isZero(): boolean {\n    return this.count === 0;\n  }\n\n  inc(): void {\n    this.count++;\n  }\n\n  dec(): void {\n    if (!this.isZero) {\n      this.count--;\n    }\n  }\n\n  reset(): void {\n    this.count = 0;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing the count to go below 0 when handling the decrement.",
          "Forgetting to bind the disabled state of the decrement button, which makes the UX unclear.",
          "Mutating state in the template instead of through clear component methods."
        ],
        "techniques": [
          "Using a standalone component with `standalone: true` and `imports` instead of NgModule.",
          "Using a derived getter (`isZero`) for simple view logic instead of duplicating conditions.",
          "Keeping all state and logic colocated in the root component for a small exercise."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-counter.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-counter-starter"
    },
    "companies": [
      "google",
      "meta",
      "uber"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-counter-solution.v2.json"
  },
  {
    "id": "angular-contact-form-starter",
    "title": "Contact Form (Standalone Component + HTTP)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "forms",
      "http",
      "validation",
      "user-input"
    ],
    "description": {
      "summary": "Build a contact form using an Angular standalone component and reactive forms. You will only work in `src/app/app.component.ts` – the HTML, CSS, and bootstrapping are already set up. On submit, validate the input and send the form data with a POST request to a fake JSON API endpoint, showing loading, success, and error states.",
      "specs": {
        "requirements": [
          "Work only inside the standalone root component in `src/app/app.component.ts` (template and styles are already provided).",
          "Build/configure a reactive form with fields for name, email, and message.",
          "Make all fields required; validate email with a basic email validator.",
          "Disable the submit button while the form is invalid or while a request is in progress.",
          "On valid submit, send a POST request with the form body to `https://jsonplaceholder.typicode.com/posts` using HttpClient.",
          "If the request succeeds, set `successMessage` to `\"Your message has been sent. Thank you!\"`.",
          "If the request fails, set `errorMessage` to `\"Something went wrong. Please try again.\"`.",
          "Track an `isSubmitting` flag so the user cannot trigger multiple requests at the same time."
        ],
        "expectedBehavior": [
          "Initially, the submit button is disabled until the form becomes valid (all required fields filled and email valid).",
          "If the user attempts to submit invalid data, all controls are marked as touched and validation error messages are shown for the affected fields.",
          "On a valid submit, a POST request is sent to `https://jsonplaceholder.typicode.com/posts` and the button is disabled while `isSubmitting` is true.",
          "On success, `isSubmitting` becomes false, `successMessage` is set to `\"Your message has been sent. Thank you!\"`, and the form may optionally be reset.",
          "On error, `isSubmitting` becomes false, `errorMessage` is set to `\"Something went wrong. Please try again.\"`, and the user can fix the issue and resubmit."
        ],
        "implementationNotes": [
          "Configure the reactive form and all request/UX logic inside `AppComponent` in `app.component.ts`. You do not need to change the HTML or CSS files for this exercise.",
          "Use `ReactiveFormsModule` and `FormBuilder` to define the form group for the contact form.",
          "Use Angular's built-in validators such as `Validators.required` and `Validators.email` (and optionally `Validators.minLength` for the message).",
          "Inject `HttpClient` (or use the `inject(HttpClient)` helper) and use `HttpClientModule` to send the POST request.",
          "Clear previous `successMessage` / `errorMessage` at the start of `submit()` so only the latest result is shown.",
          "Call `markAllAsTouched()` on the form before checking validity, so error messages appear when the user submits incomplete data.",
          "Use an `isSubmitting` flag to guard against double submissions and to drive the disabled state of the submit button.",
          "On success, you can reset the form to its initial state while keeping the success message visible."
        ],
        "techFocus": [
          "Standalone component setup with reactive forms",
          "Form validation and UX (disabled submit, inline errors, touched state)",
          "Basic HttpClient usage with a fake POST endpoint and request lifecycle handling",
          "Managing loading, success, and error states in a single component"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise combines a standalone component, reactive forms, and HttpClient. You only need to work in `src/app/app.component.ts`: the HTML and CSS are already wired up to bind to `contactForm`, `isSubmitting`, `successMessage`, and `errorMessage`.\n\nYou define a reactive form with `name`, `email`, and `message` controls, wire up validation, and then send a POST request to the fake endpoint `https://jsonplaceholder.typicode.com/posts` when the user submits. The component tracks an `isSubmitting` flag so you can disable the submit button while the request is in flight, plus `successMessage` and `errorMessage` strings for user feedback.\n\nOn a valid submit, you clear any previous messages, mark all controls as touched, bail out if the form is still invalid, set `isSubmitting` to `true`, and call `http.post(...)` with the form value. On success you show `\"Your message has been sent. Thank you!\"`, reset the form, and re-enable the button. On error you show `\"Something went wrong. Please try again.\"` and let the user resubmit.\n\n**Test cases**\n- With all fields empty, the submit button is disabled.\n- Typing an invalid email keeps the form invalid and disabled.\n- Tapping submit with invalid fields marks controls as touched and shows validation errors.\n- With valid inputs, clicking submit triggers a POST request to `https://jsonplaceholder.typicode.com/posts` and disables the button while `isSubmitting` is `true`.\n- On success, `\"Your message has been sent. Thank you!\"` is shown and the form can optionally reset.\n- On error, `\"Something went wrong. Please try again.\"` is shown and the user can resubmit.",
      "approaches": [
        {
          "title": "Standalone reactive form with HttpClient, status flags, and a fake endpoint",
          "prose": "Use a standalone `AppComponent` that imports `ReactiveFormsModule` and `HttpClientModule`. Inside `app.component.ts`, create a reactive form with `name`, `email`, and `message` controls, all required, and use `Validators.email` (and optionally `Validators.minLength`) for the email and message fields.\n\nUse Angular's function-based DI helpers (`inject(FormBuilder)` and `inject(HttpClient)`) instead of a constructor to avoid any metadata issues in this environment. The template is already set up to use `[formGroup]`, `formControlName`, and to bind the submit button disabled state to `contactForm.invalid || isSubmitting`. It also binds to `successMessage` and `errorMessage` paragraphs.\n\nIn `submit()`, implement the request lifecycle:\n1. Clear previous `successMessage` and `errorMessage`.\n2. Call `this.contactForm.markAllAsTouched()` so validation errors appear.\n3. If the form is invalid, return early.\n4. Set `isSubmitting = true` and send a POST request using `this.http.post('https://jsonplaceholder.typicode.com/posts', this.contactForm.value)`.\n5. In the `next` handler, set `isSubmitting` back to `false`, set `successMessage = 'Your message has been sent. Thank you!'`, and reset the form.\n6. In the `error` handler, set `isSubmitting` back to `false` and `errorMessage = 'Something went wrong. Please try again.'`.\n\nAll logic stays inside `AppComponent`, which keeps this exercise focused on reactive forms + HttpClient without extra services or routing.",
          "codeTs": "import { Component, inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormBuilder, Validators, ReactiveFormsModule } from '@angular/forms';\nimport { HttpClient, HttpClientModule } from '@angular/common/http';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, ReactiveFormsModule, HttpClientModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport default class AppComponent {\n  // Function-based DI to match the SDK environment\n  private fb = inject(FormBuilder);\n  private http = inject(HttpClient);\n\n  // Reactive contact form with basic validation\n  contactForm = this.fb.group({\n    name: ['', [Validators.required]],\n    email: ['', [Validators.required, Validators.email]],\n    message: ['', [Validators.required, Validators.minLength(10)]],\n  });\n\n  isSubmitting = false;\n  successMessage = '';\n  errorMessage = '';\n\n  get f() {\n    return this.contactForm.controls;\n  }\n\n  submit(): void {\n    // Clear previous messages\n    this.successMessage = '';\n    this.errorMessage = '';\n\n    // Show validation errors if form is invalid\n    this.contactForm.markAllAsTouched();\n    if (this.contactForm.invalid) {\n      return;\n    }\n\n    this.isSubmitting = true;\n\n    // Fake JSON API endpoint for this exercise\n    this.http.post('https://jsonplaceholder.typicode.com/posts', this.contactForm.value).subscribe({\n      next: () => {\n        this.isSubmitting = false;\n        this.successMessage = 'Your message has been sent. Thank you!';\n        this.contactForm.reset();\n      },\n      error: () => {\n        this.isSubmitting = false;\n        this.errorMessage = 'Something went wrong. Please try again.';\n      },\n    });\n  }\n}\n\n// Also export a named AppComponent so the bootstrap import always works\nexport { AppComponent };\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting that you only need to modify `src/app/app.component.ts`; the HTML and CSS are already wired to the expected properties.",
          "Not importing `ReactiveFormsModule` and `HttpClientModule` in the standalone component's `imports` array, which would break the form and HttpClient usage.",
          "Allowing the user to submit when the form is invalid or while a previous request is still in flight (missing the `isSubmitting` guard).",
          "Not calling `markAllAsTouched()` before checking validity, which can hide validation errors when the user hits submit on an untouched form.",
          "Hard-coding different success or error messages than the ones specified in the exercise, which may cause tests to fail."
        ],
        "techniques": [
          "Using reactive forms with `FormBuilder` and function-based DI via `inject()`.",
          "Using Angular's built-in validators for required fields, email validation, and minimum length.",
          "Managing loading, success, and error states with simple component properties and a single `submit()` method.",
          "Disabling the submit button based on both form validity and an `isSubmitting` flag.",
          "Using a fake HTTP endpoint (`https://jsonplaceholder.typicode.com/posts`) to simulate a real backend without extra setup."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-contact-form.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-contact-form-starter"
    },
    "companies": [
      "google",
      "meta",
      "airbnb"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-contact-form-solution.v2.json"
  },
  {
    "id": "angular-todo-list-starter",
    "title": "Todo List (Standalone Component with ngFor)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "components",
      "state",
      "lists",
      "ngFor",
      "forms"
    ],
    "description": {
      "summary": "Build a small todo list using an Angular standalone component. Allow users to add tasks, mark them as completed, and remove them. Use `*ngFor` to render the list and simple component state to drive the UI.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Display a text input and an \"Add\" button for creating new todos.",
          "Render the todo items in a list using `*ngFor`.",
          "Each todo item should show a label and a checkbox to toggle completion.",
          "Allow removing a single todo item from the list.",
          "Optionally provide a \"Clear completed\" action to remove all completed todos."
        ],
        "expectedBehavior": [
          "Typing a non-empty value and clicking \"Add\" appends a new todo to the list and clears the input.",
          "Empty or whitespace-only values are ignored (no item is added).",
          "Clicking a todo’s checkbox toggles its completed state.",
          "Completed todos are visually distinguished (e.g. line-through).",
          "Clicking a remove button deletes that specific todo.",
          "If you implement \"Clear completed\", it removes only the completed todos."
        ],
        "implementationNotes": [
          "Keep everything in `AppComponent` (`src/app/app.component.ts` and `app.component.html`). No extra services or components are required.",
          "Use a simple array of objects (e.g. `{ id, text, done }`) to store todos.",
          "Use `*ngFor` to loop over the todo array in the template.",
          "Use `[(ngModel)]` for the input binding and checkbox bindings (remember to import `FormsModule`).",
          "Use click handlers like `(click)=\"addTask()\"` and `(click)=\"removeTask(task)\"` to modify the array."
        ],
        "techFocus": [
          "Standalone component setup with `standalone: true`",
          "Managing in-memory state in a component",
          "Rendering lists with `*ngFor`",
          "Using `[(ngModel)]` for simple form input binding",
          "Basic UX for add / toggle / remove actions"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise models a classic todo list with a single standalone component. You keep all state inside the component: a `newTask` string for the input and a `todos` array (e.g. `{ id, text, done }`). The template binds `newTask` with `[(ngModel)]`, renders `todos` with `*ngFor`, and wires up click handlers to add, toggle, and remove items.\n\nTypical flow:\n- User types into the input; `newTask` is updated via `[(ngModel)]`.\n- Clicking **Add** (or pressing Enter, if you implement it) calls `addTask()`, which trims the text, ignores empties, pushes a new todo into the array, and resets `newTask`.\n- Each todo row shows a checkbox bound to `todo.done` and maybe styled with a `.done` CSS class when complete.\n- Clicking the remove button calls `removeTask(todo)`, which filters that item out.\n- Optionally, a \"Clear completed\" button calls `clearCompleted()` to remove all completed todos.\n\n**Test cases**\n- With an empty input, clicking **Add** does nothing.\n- Typing \"Buy milk\" and clicking **Add** shows a single todo row with that text.\n- Toggling the checkbox marks the item as completed and applies the completed styling.\n- Clicking the remove button deletes that specific row.\n- After completing multiple todos, clicking \"Clear completed\" (if implemented) removes only the completed ones.",
      "approaches": [
        {
          "title": "Standalone component with a local array of todos",
          "prose": "Represent todos as `{ id, text, done }` objects stored in a `todos` array property. Use a simple incremental `nextId` counter for unique ids. The input is bound via `[(ngModel)]=\"newTask\"`. In `addTask()`, trim `newTask`, ignore empties, then push a new object. In the template, use `*ngFor=\"let todo of todos; trackBy: trackById\"` to render each row with a checkbox bound to `todo.done` and a remove button.\n\n`toggleTask(todo)` can simply flip `todo.done = !todo.done`, or you can rely entirely on `[(ngModel)]` on the checkbox and only use handlers for extra behavior. `removeTask(todo)` filters `todos` to drop the item by id. `clearCompleted()` sets `todos` to `todos.filter(t => !t.done)`. This keeps all list and input logic colocated in the root standalone component.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\ninterface Todo {\n  id: number;\n  text: string;\n  done: boolean;\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  newTask = '';\n  todos: Todo[] = [];\n  private nextId = 1;\n\n  get hasTodos(): boolean {\n    return this.todos.length > 0;\n  }\n\n  addTask(): void {\n    const text = this.newTask.trim();\n    if (!text) {\n      return;\n    }\n\n    this.todos = [\n      ...this.todos,\n      { id: this.nextId++, text, done: false }\n    ];\n\n    this.newTask = '';\n  }\n\n  toggleTask(todo: Todo): void {\n    todo.done = !todo.done;\n  }\n\n  removeTask(todo: Todo): void {\n    this.todos = this.todos.filter(t => t.id !== todo.id);\n  }\n\n  clearCompleted(): void {\n    this.todos = this.todos.filter(t => !t.done);\n  }\n\n  trackById(_index: number, todo: Todo): number {\n    return todo.id;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing empty or whitespace-only todos to be added.",
          "Mutating the `todos` array in a way that loses track of identity (e.g. reusing the same id for all items).",
          "Forgetting to import `FormsModule`, which breaks `[(ngModel)]` bindings.",
          "Handling toggle logic only in a click handler but not binding the checkbox correctly."
        ],
        "techniques": [
          "Modeling UI items as simple objects inside a component.",
          "Using `[(ngModel)]` for a controlled input and checkbox bindings.",
          "Rendering lists with `*ngFor` and `trackBy` for better identity handling.",
          "Using pure functions (`filter`, `map`) to derive new arrays when removing or clearing items."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-todo-list.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-todo-list-starter"
    },
    "companies": [
      "google",
      "meta",
      "airbnb"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-todo-list-solution.v2.json"
  },
  {
    "id": "angular-image-slider-starter",
    "title": "Image Slider (Standalone Component)",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "components",
      "state",
      "event-binding",
      "ngFor",
      "ui"
    ],
    "description": {
      "summary": "Build an image slider in an Angular standalone component. Show one slide at a time with next/previous buttons and clickable dot indicators.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Keep an in-memory list of slides (each with at least a title and image URL).",
          "Display the currently active slide (image and title).",
          "Provide \"Previous\" and \"Next\" buttons to move between slides.",
          "Disable the \"Previous\" button on the first slide and the \"Next\" button on the last slide.",
          "Render dot indicators for each slide; clicking a dot should jump to that slide.",
          "Display a small \"Slide X of N\" helper text."
        ],
        "expectedBehavior": [
          "Initial view shows the first slide.",
          "Clicking \"Next\" advances to the next slide until the last one; afterwards it stays on the last slide and \"Next\" becomes disabled.",
          "Clicking \"Previous\" moves backwards until the first slide; on the first slide it stays there and \"Previous\" is disabled.",
          "Clicking a dot activates the corresponding slide, updates the main image and title, and updates the \"Slide X of N\" text.",
          "The active slide's dot is visually highlighted."
        ],
        "implementationNotes": [
          "Store slides in a readonly array on the component (e.g. `slides = [...]`).",
          "Track the active slide with a simple numeric index (e.g. `currentIndex = 0`).",
          "Derive the current slide with a getter (e.g. `currentSlide`), and flags like `canGoPrev` / `canGoNext` from the index.",
          "Use template bindings (`(click)`, `[disabled]`, `*ngFor`, `[class.active]`) to wire up the controls and indicators.",
          "No need for routing, services, or external state management; keep everything in the root component."
        ],
        "techFocus": [
          "Standalone component setup",
          "View model with derived state (current slide, canGoPrev/canGoNext)",
          "Template control flow with *ngFor and event bindings",
          "Basic UI state + styling for active / disabled controls"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Model the slider as a small view model on the component: a readonly `slides` array and a `currentIndex` number. Use getters to derive `currentSlide`, `totalSlides`, and convenience flags like `canGoPrev` and `canGoNext`. The template shows the active slide and wires buttons and dot indicators to simple methods that update `currentIndex`.\n\n**Test cases**\n- Initial render shows the first slide, with \"Previous\" disabled and the first dot highlighted.\n- Clicking \"Next\" repeatedly walks through the slides and disables itself on the last slide.\n- Clicking \"Previous\" from the middle moves backward one slide at a time.\n- Clicking a dot jumps directly to that slide and updates the heading, image, and helper text.\n- The slider never goes out of range (no index smaller than 0 or greater than `slides.length - 1`).",
      "approaches": [
        {
          "title": "Standalone component with index-based navigation",
          "prose": "Use a single standalone `AppComponent` that owns the slider state.\n\n1. Define a `Slide` interface (`id`, `title`, `imageUrl`, optional `description`). Keep a `readonly slides: Slide[]` array.\n2. Track the active slide with `currentIndex = 0`.\n3. Expose getters like `currentSlide`, `totalSlides`, `canGoPrev`, and `canGoNext`.\n4. Implement `goTo(index: number)`, `prev()`, and `next()` to clamp `currentIndex` inside `[0, totalSlides - 1]`.\n5. In the template, show the current slide image and title, wire buttons to `prev()` / `next()`, use `[disabled]` for edge cases, and render dot buttons with `*ngFor` and `[class.active]` to highlight the current slide.\n\nThis keeps the logic small and testable while exercising Angular's template bindings and derived state.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ninterface Slide {\n  id: number;\n  title: string;\n  imageUrl: string;\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <main class=\"app\">\n      <section class=\"card\">\n        <h1>Image Slider</h1>\n\n        <figure class=\"frame\" *ngIf=\"currentSlide as slide\">\n          <img class=\"image\" [src]=\"slide.imageUrl\" [alt]=\"slide.title\" />\n          <figcaption class=\"caption\">{{ slide.title }}</figcaption>\n        </figure>\n\n        <div class=\"meta\">\n          Slide {{ currentIndex + 1 }} of {{ totalSlides }}\n        </div>\n\n        <div class=\"actions\">\n          <button (click)=\"prev()\" [disabled]=\"!canGoPrev\">Previous</button>\n          <button (click)=\"next()\" [disabled]=\"!canGoNext\">Next</button>\n        </div>\n\n        <div class=\"dots\">\n          <button\n            *ngFor=\"let slide of slides; let i = index\"\n            type=\"button\"\n            class=\"dot\"\n            [class.active]=\"i === currentIndex\"\n            (click)=\"goTo(i)\"\n            aria-label=\"Go to slide {{ i + 1 }}\"\n          ></button>\n        </div>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.app{min-height:100vh;display:grid;place-items:center;background:#0a0a0a;color:#e5e7eb;}`,\n    `.card{width:100%;max-width:520px;padding:16px 20px;background:#0b1020;border-radius:12px;border:1px solid #1f2937;display:grid;gap:12px;}`,\n    `.frame{margin:0;border-radius:12px;overflow:hidden;border:1px solid #1f2937;background:#020617;}`,\n    `.image{display:block;width:100%;height:240px;object-fit:cover;}`,\n    `.caption{padding:8px 12px;font-size:14px;color:#e5e7eb;background:rgba(15,23,42,.9);}`,\n    `.meta{font-size:12px;color:#9ca3af;text-align:center;}`,\n    `.actions{display:flex;gap:8px;justify-content:center;}`,\n    `button{padding:8px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:600;background:#a3e635;color:#111;}`,\n    `button[disabled]{opacity:.5;cursor:not-allowed;}`,\n    `.dots{display:flex;justify-content:center;gap:6px;margin-top:4px;}`,\n    `.dot{width:8px;height:8px;border-radius:999px;border:none;background:#374151;cursor:pointer;}`,\n    `.dot.active{background:#a3e635;}`\n  ]\n})\nexport class AppComponent {\n  readonly slides: Slide[] = [\n    {\n      id: 1,\n      title: 'Snowflakes glowing under city lights',\n      imageUrl: 'https://images.pexels.com/photos/46253/pexels-photo-46253.jpeg'\n    },\n    {\n      id: 2,\n      title: 'Forest trail in the morning',\n      imageUrl: 'https://images.pexels.com/photos/1563604/pexels-photo-1563604.jpeg'\n    },\n    {\n      id: 3,\n      title: 'City lights at night',\n      imageUrl: 'https://images.pexels.com/photos/220067/pexels-photo-220067.jpeg'\n    }\n  ];\n\n  currentIndex = 0;\n\n  get totalSlides(): number {\n    return this.slides.length;\n  }\n\n  get currentSlide(): Slide | null {\n    return this.slides[this.currentIndex] ?? null;\n  }\n\n  get canGoPrev(): boolean {\n    return this.currentIndex > 0;\n  }\n\n  get canGoNext(): boolean {\n    return this.currentIndex < this.totalSlides - 1;\n  }\n\n  goTo(index: number): void {\n    if (index < 0 || index >= this.totalSlides) return;\n    this.currentIndex = index;\n  }\n\n  prev(): void {\n    if (this.canGoPrev) {\n      this.currentIndex--;\n    }\n  }\n\n  next(): void {\n    if (this.canGoNext) {\n      this.currentIndex++;\n    }\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing `currentIndex` to go out of range (negative or >= slides.length).",
          "Duplicating `slides[currentIndex]` access all over the template instead of using a getter.",
          "Not disabling buttons at the edges, making the UX feel broken."
        ],
        "techniques": [
          "Using a simple numeric index to represent view state.",
          "Deriving convenience getters for current slide and navigation flags.",
          "Using `[class.active]` and `[disabled]` to reflect state in the UI."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-image-slider.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-image-slider-starter"
    },
    "companies": [
      "google",
      "meta",
      "airbnb"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-image-slider-solution.v2.json"
  },
  {
    "id": "angular-tabs-switcher",
    "title": "Tabs / Multi-View Switcher",
    "type": "coding",
    "technology": "angular",
    "difficulty": "beginner",
    "importance": 3,
    "tags": [
      "components",
      "state",
      "conditional-rendering",
      "tabs"
    ],
    "description": {
      "summary": "Build a simple tabbed interface with three tabs (\"Overview\", \"Details\", \"Settings\") that controls which content is visible.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Render three tabs labeled \"Overview\", \"Details\", and \"Settings\".",
          "Track which tab is currently active and visually highlight it.",
          "Render only the active tab's content at a time."
        ],
        "expectedBehavior": [
          "The initial active tab should be \"Overview\".",
          "Clicking a tab makes it the active tab.",
          "Only the active tab's panel is visible at any time.",
          "The active tab button has a distinct visual style (e.g. underline or background)."
        ],
        "implementationNotes": [
          "Store the currently active tab in a component property.",
          "Use template bindings and event handlers (e.g. `(click)`) to switch tabs.",
          "Use conditional rendering (e.g. `*ngIf`) to show/hide each panel.",
          "You can model the active tab as a union type like `'overview' | 'details' | 'settings'` for extra type safety."
        ],
        "techFocus": [
          "Basic state management in a component",
          "Conditional rendering with `*ngIf`",
          "Simple component composition and layout for tabs"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about modeling a small piece of UI state (which tab is active) and using that state to drive both styles and conditional rendering. Use a single standalone Angular component that owns an `activeTab` property. The tab buttons call a `selectTab(tab)` method, and helper logic like `isActive(tab)` feeds CSS classes and `*ngIf` checks for the content panels.\n\n**Test cases**\n- Initial render shows the Overview panel and its tab appears active.\n- Clicking Details switches the active tab and hides Overview content.\n- Clicking Settings switches again and only the Settings content is visible.\n- Re-clicking an already active tab keeps the same content and styles.",
      "approaches": [
        {
          "title": "Single standalone component with `activeTab` state",
          "prose": "Keep everything in a single `AppComponent` to emphasise basic state management and conditional rendering.\n\n1. Define a `TabId` union type: `'overview' | 'details' | 'settings'`.\n2. Add an `activeTab: TabId = 'overview';` property.\n3. Implement a `selectTab(tab: TabId)` method that simply assigns `this.activeTab = tab;`.\n4. Add a helper `isActive(tab: TabId)` that returns `this.activeTab === tab` and use it in `[class.active]` and `*ngIf` checks.\n5. Structure the template with a header row of buttons for the tabs and three conditional sections for the panels.\n\nThis mirrors real-world tab patterns but stays small enough for a beginner exercise.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ntype TabId = 'overview' | 'details' | 'settings';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <main class=\"shell\">\n      <section class=\"card\">\n        <h1>Tabs / Multi-View Switcher</h1>\n\n        <nav class=\"tabs\">\n          <button\n            class=\"tab\"\n            [class.active]=\"isActive('overview')\"\n            (click)=\"selectTab('overview')\">Overview</button>\n          <button\n            class=\"tab\"\n            [class.active]=\"isActive('details')\"\n            (click)=\"selectTab('details')\">Details</button>\n          <button\n            class=\"tab\"\n            [class.active]=\"isActive('settings')\"\n            (click)=\"selectTab('settings')\">Settings</button>\n        </nav>\n\n        <section class=\"panel\" *ngIf=\"isActive('overview')\">\n          <h2>Overview</h2>\n          <p>Show a short summary or welcome message here.</p>\n        </section>\n\n        <section class=\"panel\" *ngIf=\"isActive('details')\">\n          <h2>Details</h2>\n          <p>Display more detailed information in this panel.</p>\n        </section>\n\n        <section class=\"panel\" *ngIf=\"isActive('settings')\">\n          <h2>Settings</h2>\n          <p>Render some simple settings-like content here.</p>\n        </section>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.shell{min-height:100vh;display:grid;place-items:center;background:#020617;color:#e5e7eb;padding:24px;}`,\n    `.card{width:100%;max-width:560px;background:#020617;border-radius:16px;border:1px solid #1f2937;padding:20px 20px 24px;box-shadow:0 18px 45px rgba(15,23,42,0.8);display:grid;gap:16px;}`,\n    `.card h1{margin:0 0 4px;font-size:20px;font-weight:700;}`,\n    `.tabs{display:flex;gap:8px;padding:4px;background:#020617;border-radius:999px;border:1px solid #1f2937;}`,\n    `.tab{flex:1;padding:8px 10px;border-radius:999px;border:none;background:transparent;color:#9ca3af;font-size:13px;font-weight:600;cursor:pointer;transition:background .15s, color .15s;}`,\n    `.tab.active{background:#e5e7eb;color:#020617;}`,\n    `.panel{margin-top:4px;border-radius:12px;border:1px solid #111827;background:radial-gradient(circle at top left,#111827,#020617);padding:14px 16px;display:grid;gap:4px;}`,\n    `.panel h2{margin:0 0 4px;font-size:16px;font-weight:600;}`,\n    `.panel p{margin:0;font-size:13px;color:#d1d5db;line-height:1.5;}`\n  ]\n})\nexport class AppComponent {\n  activeTab: TabId = 'overview';\n\n  isActive(tab: TabId): boolean {\n    return this.activeTab === tab;\n  }\n\n  selectTab(tab: TabId): void {\n    this.activeTab = tab;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Hard-coding panel visibility without tying it to a single source of truth for the active tab.",
          "Forgetting to visually differentiate the active tab from inactive ones.",
          "Using separate booleans for each tab instead of a single `activeTab` value, which quickly becomes harder to manage."
        ],
        "techniques": [
          "Modeling view state with a union type for clearer intent.",
          "Using helper methods like `isActive` to keep the template clean.",
          "Applying classes conditionally with `[class.active]` to style the active tab."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-tabs.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-tabs-starter"
    },
    "companies": [
      "google",
      "meta",
      "uber"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-tabs-solution.v2.json"
  },
  {
    "id": "angular-filterable-user-list",
    "title": "Filterable / Searchable User List",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "components",
      "state",
      "lists",
      "filtering",
      "forms"
    ],
    "description": {
      "summary": "Build an Angular standalone component that renders a list of users with a search box, role filter, and \"only active\" checkbox.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Define a fixed in-memory list of users (name, role, active flag).",
          "Render a search input that filters by name (case-insensitive).",
          "Render a role dropdown (e.g. All, Admin, Editor, Viewer) that filters by role.",
          "Render a checkbox that, when checked, shows only active users.",
          "Render the filtered list below the controls."
        ],
        "expectedBehavior": [
          "Initially, all users are shown.",
          "Typing in the search box filters users whose name includes the search text (case-insensitive).",
          "Changing the role dropdown filters by that role (or shows all roles when \"All\" is selected).",
          "Checking the \"Only active\" checkbox hides inactive users.",
          "When no users match the filters, an empty state message is shown."
        ],
        "implementationNotes": [
          "Keep a static `users` array in the component (no HTTP or services needed).",
          "Store `searchTerm`, `selectedRole`, and `showOnlyActive` as component properties.",
          "Expose a derived `filteredUsers` getter that applies all filters based on the current state.",
          "Use template bindings like `[(ngModel)]` to keep inputs in sync with component state.",
          "For a small list, client-side filtering on each render is fine; you can mention this trade-off in discussion."
        ],
        "techFocus": [
          "Standalone component setup",
          "Basic state management for multiple controls",
          "Derived state from a static data source",
          "Template-driven forms (`ngModel`) and list rendering with `*ngFor`"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about maintaining several pieces of UI state (search text, selected role, and an \"only active\" toggle) and deriving a filtered list from them. The original user list never changes; instead, a `filteredUsers` getter applies all filters on top of the static array.\n\n**Test cases**\n- With default state, all users are shown.\n- Typing part of a user's name (case-insensitive) narrows the list to matching users.\n- Selecting a role shows only users with that role, unless \"All\" is selected.\n- Checking \"Only active\" hides inactive users.\n- Combining search, role filter, and active filter works as expected.\n- When filters exclude everything, an empty state row appears.",
      "approaches": [
        {
          "title": "Standalone component with derived `filteredUsers` getter",
          "prose": "Use a single `AppComponent` that is declared as `standalone: true` and imports `CommonModule` and `FormsModule`. Define a static `users` array with a few objects like `{ id, name, role, active }` and keep your UI state in properties such as `searchTerm`, `selectedRole`, and `showOnlyActive`.\n\nImplement a `filteredUsers` getter that:\n1. Normalizes the search term to lower-case.\n2. Filters users whose names contain that term (if any is entered).\n3. Filters by `selectedRole` when a specific role is chosen.\n4. Removes inactive users when `showOnlyActive` is true.\n\nBind the inputs using `[(ngModel)]` so the component state updates as the user types or toggles controls. Use `*ngFor` to render the filtered list, and show a fallback row when `filteredUsers.length === 0`. For a minor performance touch, you can add a `trackByUserId` function to the `*ngFor`.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\ninterface User {\n  id: number;\n  name: string;\n  role: Role;\n  active: boolean;\n}\n\ntype Role = 'admin' | 'editor' | 'viewer';\n\ntype RoleFilter = 'all' | Role;\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  searchTerm = '';\n  selectedRole: RoleFilter = 'all';\n  showOnlyActive = false;\n\n  readonly users: User[] = [\n    { id: 1, name: 'Alice Johnson', role: 'admin', active: true },\n    { id: 2, name: 'Bob Smith', role: 'editor', active: false },\n    { id: 3, name: 'Charlie Kim', role: 'viewer', active: true },\n    { id: 4, name: 'Dana Patel', role: 'editor', active: true },\n    { id: 5, name: 'Elliot Brown', role: 'viewer', active: false }\n  ];\n\n  get filteredUsers(): User[] {\n    const term = this.searchTerm.trim().toLowerCase();\n\n    return this.users.filter(user => {\n      if (term && !user.name.toLowerCase().includes(term)) {\n        return false;\n      }\n\n      if (this.selectedRole !== 'all' && user.role !== this.selectedRole) {\n        return false;\n      }\n\n      if (this.showOnlyActive && !user.active) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  trackByUserId(_: number, user: User): number {\n    return user.id;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating the original `users` array instead of deriving a filtered view.",
          "Forgetting to normalize case when comparing the search term to names.",
          "Applying only one of the filters instead of combining all three.",
          "Doing heavy work directly in the template instead of in a getter or method."
        ],
        "techniques": [
          "Using a standalone component with `CommonModule` and `FormsModule`.",
          "Keeping original data immutable and deriving filtered views.",
          "Using `[(ngModel)]` for simple controlled inputs in Angular.",
          "Using `trackBy` with `*ngFor` for a minor performance improvement."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-filterable-user-list.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-filterable-user-list"
    },
    "companies": [
      "google",
      "meta",
      "uber"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-filterable-user-list-solution.v2.json"
  },
  {
    "id": "angular-faq-accordion",
    "title": "Accordion / FAQ Component",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "components",
      "inputs",
      "outputs",
      "state",
      "interactivity"
    ],
    "description": {
      "summary": "Build a simple FAQ (accordion) component in Angular that renders 3–4 questions. Clicking a question should toggle its answer. By default, only one item can be open at a time, but the user can enable a mode where multiple items can stay open.",
      "specs": {
        "requirements": [
          "Use a standalone root component and at least one child component for a single FAQ item.",
          "Render a list of 3–4 FAQ items (question + answer) from an in-memory array.",
          "Clicking on a question toggles its answer open/closed.",
          "In the default mode, only one FAQ item can be open at a time.",
          "Add a simple control (e.g. a toggle or checkbox) to switch to 'allow multiple open' mode.",
          "In 'allow multiple open' mode, the user should be able to open more than one FAQ item at once."
        ],
        "expectedBehavior": [
          "Initially all FAQ items are closed.",
          "Clicking a closed question opens its answer.",
          "In single-open mode: opening one item automatically closes any other open item.",
          "Switching to multi-open mode keeps already open items and allows opening others.",
          "Clicking an open question closes its answer in both modes."
        ],
        "implementationNotes": [
          "Keep the data (questions/answers and open state) in the parent component.",
          "Create a child component (e.g. `FaqItemComponent`) that receives `question`, `answer`, and `isOpen` as inputs and emits a `toggle` event when its header is clicked.",
          "Use `*ngFor` in the parent template to render FAQ items.",
          "You can use simple CSS transitions (e.g. `max-height` or `opacity`) for a smooth open/close animation, but this is optional."
        ],
        "techFocus": [
          "Parent → child data flow with `@Input` and `@Output`",
          "Controlled vs uncontrolled state (parent controlling which index is open)",
          "Conditional rendering with `*ngIf` or `ngClass`",
          "Basic UI state toggling and list rendering"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about lifting state up to the parent component and controlling which FAQ items are open. The parent holds an array of FAQ items (question + answer) and a representation of which indexes are currently open. Each child row displays a question and conditionally shows its answer.\n\nIn the default (single-open) mode, the parent keeps at most one index in its open list. When the user clicks a question, the parent either sets that index as the only open one or clears it if it was already open. In multi-open mode, the parent treats the list of open indexes like a set: clicking an item either adds or removes that index.\n\n**Test cases**\n- Initially, all answers are hidden.\n- Click the first question → its answer becomes visible, others stay closed.\n- In single-open mode, clicking a second question closes the first and opens the second.\n- Switch to multi-open mode → currently open item(s) stay open, and you can open additional ones without closing the others.\n- Clicking an open item closes it in both modes.",
      "approaches": [
        {
          "title": "Parent-controlled open indexes with a child FAQ item component",
          "prose": "Use a standalone `AppComponent` as the parent that owns:\n\n1. A `faqItems` array of plain objects (`{ question, answer }`).\n2. A boolean `allowMultiple` flag controlled by a checkbox or toggle in the UI.\n3. An array `openIndexes: number[]` that stores the indexes of currently open FAQ items.\n\nImplement two methods:\n- `isItemOpen(index: number): boolean` → returns whether the given index is currently open.\n- `onItemToggle(index: number)` → updates `openIndexes` based on `allowMultiple`.\n\nIn single-open mode, `onItemToggle` should behave like a radio group: either an item is the only open one or there are none. In multi-open mode, it behaves like a set: clicking an item toggles its presence in `openIndexes`. The child `FaqItemComponent` is kept dumb – it only receives data and emits a `toggle` event, leaving all state decisions to the parent.",
          "codeTs": "import { Component, EventEmitter, Input, Output } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ninterface FaqItem {\n  question: string;\n  answer: string;\n}\n\n@Component({\n  selector: 'app-faq-item',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <article class=\"faq-item\" [class.open]=\"isOpen\">\n      <button class=\"faq-header\" type=\"button\" (click)=\"toggle.emit()\" aria-expanded=\"{{ isOpen }}\">\n        <span class=\"question\">{{ question }}</span>\n        <span class=\"indicator\">{{ isOpen ? '-' : '+' }}</span>\n      </button>\n      <div class=\"faq-body\" *ngIf=\"isOpen\">\n        <p>{{ answer }}</p>\n      </div>\n    </article>\n  `,\n  styles: [\n    `.faq-item{border-radius:12px;background:#0b1020;border:1px solid #1f2937;overflow:hidden;}`,\n    `.faq-item + .faq-item{margin-top:8px;}`,\n    `.faq-header{width:100%;padding:12px 14px;background:transparent;border:none;display:flex;justify-content:space-between;align-items:center;color:#e5e7eb;cursor:pointer;font-size:14px;}`,\n    `.indicator{font-weight:700;}`,\n    `.faq-body{padding:0 14px 12px;font-size:13px;color:#9ca3af;}`\n  ]\n})\nexport class FaqItemComponent {\n  @Input() question = '';\n  @Input() answer = '';\n  @Input() isOpen = false;\n  @Output() toggle = new EventEmitter<void>();\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, FaqItemComponent],\n  template: `\n    <main class=\"app\">\n      <section class=\"card\">\n        <header class=\"header\">\n          <h1>FAQ</h1>\n          <label class=\"switch\">\n            <input type=\"checkbox\" [checked]=\"allowMultiple\" (change)=\"onToggleAllowMultiple()\" />\n            <span>Allow multiple open</span>\n          </label>\n        </header>\n\n        <div class=\"list\">\n          <app-faq-item\n            *ngFor=\"let item of faqItems; index as i\"\n            [question]=\"item.question\"\n            [answer]=\"item.answer\"\n            [isOpen]=\"isItemOpen(i)\"\n            (toggle)=\"onItemToggle(i)\">\n          </app-faq-item>\n        </div>\n      </section>\n    </main>\n  `,\n  styles: [\n    `.app{min-height:100vh;display:grid;place-items:center;background:#020617;color:#e5e7eb;padding:24px;}`,\n    `.card{width:100%;max-width:520px;background:#020617;border-radius:16px;border:1px solid #1f2937;padding:20px;}`,\n    `.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;}`,\n    `.header h1{font-size:20px;margin:0;}`,\n    `.switch{display:flex;align-items:center;gap:6px;font-size:12px;color:#9ca3af;}`\n  ]\n})\nexport class AppComponent {\n  faqItems: FaqItem[] = [\n    {\n      question: 'Lorem ipsum dolor sit amet?',\n      answer: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus euismod, posuere justo ut, pulvinar neque.'\n    },\n    {\n      question: 'Curabitur blandit tempus porttitor?',\n      answer: 'Curabitur blandit tempus porttitor. Integer posuere erat a ante venenatis dapibus posuere velit aliquet.'\n    },\n    {\n      question: 'Aenean lacinia bibendum nulla sed consectetur?',\n      answer: 'Aenean lacinia bibendum nulla sed consectetur. Cras justo odio, dapibus ac facilisis in, egestas eget quam.'\n    },\n    {\n      question: 'Vivamus sagittis lacus vel augue laoreet rutrum?',\n      answer: 'Vivamus sagittis lacus vel augue laoreet rutrum faucibus dolor auctor. Maecenas faucibus mollis interdum.'\n    }\n  ];\n\n  allowMultiple = false;\n  openIndexes: number[] = [];\n\n  isItemOpen(index: number): boolean {\n    return this.openIndexes.includes(index);\n  }\n\n  onItemToggle(index: number): void {\n    const currentlyOpen = this.isItemOpen(index);\n\n    if (this.allowMultiple) {\n      // Treat as a set\n      this.openIndexes = currentlyOpen\n        ? this.openIndexes.filter(i => i !== index)\n        : [...this.openIndexes, index];\n      return;\n    }\n\n    // Single-open mode\n    if (currentlyOpen) {\n      this.openIndexes = [];\n    } else {\n      this.openIndexes = [index];\n    }\n  }\n\n  onToggleAllowMultiple(): void {\n    this.allowMultiple = !this.allowMultiple;\n    if (!this.allowMultiple && this.openIndexes.length > 1) {\n      // Keep only the first open item in single-open mode\n      this.openIndexes = this.openIndexes.length ? [this.openIndexes[0]] : [];\n    }\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Letting each item manage its own open/closed state, which makes it hard to enforce 'only one open at a time'.",
          "Using index-based state but forgetting to clear other indexes in single-open mode.",
          "Directly mutating the `faqItems` array to store UI-only state instead of keeping a separate `openIndexes` representation."
        ],
        "techniques": [
          "Keeping view data (question/answer) separate from UI state (open indexes).",
          "Using a child component with `@Input`/`@Output` to keep the parent in full control of state.",
          "Deriving `isItemOpen` from an array of indexes instead of storing booleans on each item."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-faq-accordion.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-faq-accordion"
    },
    "solutionAsset": "assets/sb/angular/solution/angular-faq-accordion-solution.v2.json"
  },
  {
    "id": "angular-pagination-table",
    "title": "Paginated Data Table",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "components",
      "state",
      "pagination",
      "arrays",
      "derived-state"
    ],
    "description": {
      "summary": "Build a simple paginated data table in Angular that shows a static list of users. Display 5 rows per page, with Previous / Next controls and a \"Page X of Y\" indicator. Disable the navigation buttons appropriately on the first and last pages.",
      "specs": {
        "requirements": [
          "Use a standalone Angular component as the root component.",
          "Render a static list (20–30 items) of users in a table (id, name, email, role).",
          "Show 5 rows per page.",
          "Add \"Previous\" and \"Next\" buttons to change the current page.",
          "Display the current page and total pages (e.g. \"Page 2 of 5\").",
          "Disable the \"Previous\" button on the first page.",
          "Disable the \"Next\" button on the last page."
        ],
        "expectedBehavior": [
          "Initially, the table shows the first 5 users (page 1).",
          "Clicking \"Next\" advances to the next 5 users, until the last page.",
          "Clicking \"Previous\" goes back one page, until the first page.",
          "On the first page, \"Previous\" is disabled and cannot change the page.",
          "On the last page, \"Next\" is disabled and cannot change the page.",
          "The label \"Page X of Y\" always reflects the state correctly (X is 1-based)."
        ],
        "implementationNotes": [
          "Store the current page index in a component property (e.g. `currentPage = 0`).",
          "Keep the full list in a single readonly array on the component.",
          "Use a derived getter (e.g. `pagedUsers`) that slices the array based on `currentPage` and `pageSize`.",
          "Use additional getters like `isFirstPage` and `isLastPage` to drive button disabled state."
        ],
        "techFocus": [
          "Component-level state for pagination (`currentPage`).",
          "Derived data using `slice(start, end)`.",
          "Handling edge cases in UI state (first/last page).",
          "Clean template bindings for lists (`*ngFor`) and button states (`[disabled]`)."
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise centers around a single state variable: the current page index. The full dataset lives in a static array on the component. From that, you derive everything else: the total number of pages, the slice of users to display, and whether Previous/Next buttons should be disabled.\n\n**Core ideas**\n- Keep `currentPage` as a number (0-based is convenient for array math).\n- Use a constant `pageSize = 5`.\n- Compute `totalPages` with `Math.ceil(users.length / pageSize)`.\n- Derive `pagedUsers` by slicing the big array based on `currentPage` and `pageSize`.\n- Expose small boolean getters like `isFirstPage` and `isLastPage` to keep the template clean.\n\n**Test cases**\n- Initial render → shows the first 5 users, label reads `Page 1 of N`, and Previous is disabled.\n- Clicking Next repeatedly moves through the list in chunks of 5 until the last page, then Next becomes disabled.\n- Clicking Previous from any page > 1 moves back a page until page 1.\n- The label always matches the current page index, and buttons are never enabled when they should be disabled.",
      "approaches": [
        {
          "title": "Standalone component with derived pagination slice",
          "prose": "Use a single standalone `AppComponent` that holds the full users array and pagination state.\n\n1. Define a `User` type and a constant `USERS` array with ~20–30 users.\n2. In the component, expose `readonly users = USERS;`, a `pageSize = 5;` and `currentPage = 0;`.\n3. Add getters `totalPages`, `pagedUsers`, `isFirstPage`, and `isLastPage`.\n   - `totalPages` uses `Math.ceil(this.users.length / this.pageSize)`.\n   - `pagedUsers` computes `start = currentPage * pageSize` and `end = start + pageSize` and returns `this.users.slice(start, end)`.\n4. Implement `goToPrevious()` and `goToNext()` so they guard against going before page 0 or past the last page.\n5. In the template, render the table rows with `*ngFor=\"let user of pagedUsers\"` and bind the button `disabled` flags to `isFirstPage` / `isLastPage`.\n\nThis keeps the logic simple, shows a clear separation between state and derived data, and matches how you'd wire pagination in a real-world Angular component.",
          "codeTs": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ntype User = {\n  id: number;\n  name: string;\n  email: string;\n  role: string;\n};\n\nconst USERS: User[] = [\n  { id: 1, name: 'Alice Johnson', email: 'alice@example.com', role: 'Admin' },\n  { id: 2, name: 'Bob Smith', email: 'bob@example.com', role: 'Editor' },\n  { id: 3, name: 'Carla Perez', email: 'carla@example.com', role: 'Viewer' },\n  { id: 4, name: 'David Kim', email: 'david@example.com', role: 'Editor' },\n  { id: 5, name: 'Emma Brown', email: 'emma@example.com', role: 'Viewer' },\n  { id: 6, name: 'Frank Wu', email: 'frank@example.com', role: 'Admin' },\n  { id: 7, name: 'Grace Lee', email: 'grace@example.com', role: 'Viewer' },\n  { id: 8, name: 'Henry Ford', email: 'henry@example.com', role: 'Editor' },\n  { id: 9, name: 'Ivy Stone', email: 'ivy@example.com', role: 'Viewer' },\n  { id: 10, name: 'Jack Ryan', email: 'jack@example.com', role: 'Viewer' },\n  { id: 11, name: 'Karen Diaz', email: 'karen@example.com', role: 'Editor' },\n  { id: 12, name: 'Leo Walker', email: 'leo@example.com', role: 'Viewer' },\n  { id: 13, name: 'Mia Clark', email: 'mia@example.com', role: 'Admin' },\n  { id: 14, name: 'Noah Hall', email: 'noah@example.com', role: 'Viewer' },\n  { id: 15, name: 'Olivia King', email: 'olivia@example.com', role: 'Editor' },\n  { id: 16, name: 'Paul Green', email: 'paul@example.com', role: 'Viewer' },\n  { id: 17, name: 'Quinn Ross', email: 'quinn@example.com', role: 'Viewer' },\n  { id: 18, name: 'Rita Long', email: 'rita@example.com', role: 'Editor' },\n  { id: 19, name: 'Sam Young', email: 'sam@example.com', role: 'Viewer' },\n  { id: 20, name: 'Tina Fox', email: 'tina@example.com', role: 'Viewer' }\n];\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  readonly users = USERS;\n  readonly pageSize = 5;\n  currentPage = 0; // 0-based\n\n  get totalPages(): number {\n    return Math.ceil(this.users.length / this.pageSize) || 1;\n  }\n\n  get pagedUsers(): User[] {\n    const start = this.currentPage * this.pageSize;\n    const end = start + this.pageSize;\n    return this.users.slice(start, end);\n  }\n\n  get isFirstPage(): boolean {\n    return this.currentPage === 0;\n  }\n\n  get isLastPage(): boolean {\n    return this.currentPage >= this.totalPages - 1;\n  }\n\n  goToPrevious(): void {\n    if (!this.isFirstPage) {\n      this.currentPage--;\n    }\n  }\n\n  goToNext(): void {\n    if (!this.isLastPage) {\n      this.currentPage++;\n    }\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Treating `currentPage` as 1-based while doing slice calculations, which makes `start` / `end` off by one.",
          "Forgetting to guard the page change functions, causing `currentPage` to go negative or past the last page.",
          "Computing the slice inline in the template instead of using a getter, which hurts readability and testability.",
          "Not updating the disabled state of the buttons, so users can still click Previous on the first page or Next on the last page."
        ],
        "techniques": [
          "Using a standalone Angular component (`standalone: true`) with `bootstrapApplication`.",
          "Deriving UI data from minimal state (current page + array length).",
          "Using getters for small bits of view logic (page slice, first/last flags).",
          "Keeping the dataset static and focusing purely on pagination behavior."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-pagination-table.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-pagination-table"
    },
    "companies": [
      "google",
      "meta",
      "uber"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-pagination-table-solution.v2.json"
  },
  {
    "id": "angular-theme-toggle",
    "title": "Theme Toggle with Persisted Light/Dark Mode",
    "type": "coding",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "components",
      "services",
      "dependency-injection",
      "state",
      "local-storage",
      "theming"
    ],
    "description": {
      "summary": "Add a global light/dark theme toggle in the top-right of the page. The selected theme should be stored in localStorage and restored when the page reloads.",
      "specs": {
        "requirements": [
          "Render a main page layout with a simple content card and a theme toggle control in the top-right corner.",
          "Support two themes: \"light\" and \"dark\".",
          "Store the current theme in a dedicated Angular service (global-ish state).",
          "Persist the selected theme in localStorage under a stable key.",
          "On initial load, read the theme from localStorage and apply it before the user interacts.",
          "Apply the theme at the document level by setting `data-theme` on `<html>`, so that the existing CSS can react to it.",
          "You only need to edit TypeScript files: `/src/app/theme.service.ts` and `/src/app/app.component.ts`. All CSS files are already wired to respond to `data-theme` and should be left as-is."
        ],
        "expectedBehavior": [
          "By default, the app starts in light mode if there is no previous theme stored.",
          "If the user toggles to dark mode, the page background, text, and card colors change.",
          "Reloading the page keeps the user’s last theme selection (light or dark).",
          "The toggle UI (label or icon) always reflects the actual current theme.",
          "Switching themes is instant and does not require a full reload."
        ],
        "implementationNotes": [
          "`/src/app/theme.service.ts`: Use an Angular service (e.g. `ThemeService`) to hold global theme state, read/write localStorage, and update the `data-theme` attribute on `<html>`.",
          "`/src/app/app.component.ts`: Inject the service, expose an `isDark` getter based on `themeService.currentTheme`, and wire the toggle button to `themeService.toggleTheme()`.",
          "The CSS in `/src/app/app.component.css` and `/src/styles.css` is already configured: it uses `:root` / `:root[data-theme='dark']` and `:host-context([data-theme='dark'])` rules to switch page, card, and toggle colors when `data-theme` changes.",
          "You do not need to modify any CSS for this exercise; just drive the theme state and `data-theme` from the service.",
          "Avoid duplicating theme logic in multiple components; treat the service as the single source of truth."
        ],
        "techFocus": [
          "Angular services and dependency injection",
          "Global-ish state via a shared service",
          "Side-effects and initialization logic (constructor / app bootstrap)",
          "Using localStorage safely in a browser environment",
          "Simple theming by driving `data-theme` on `<html>` and letting existing CSS respond"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about lifting theme state into a global Angular service and wiring it to both the UI and the DOM. You store the current theme (\"light\" or \"dark\") in a `ThemeService`, read an initial value from localStorage when the service is created, and apply that value to the `<html>` element via a `data-theme` attribute. The root `AppComponent` injects this service, shows a toggle in the top-right corner, and delegates all theme changes to the service. The provided CSS (in `styles.css` and `app.component.css`) already listens to `data-theme` using `:root[data-theme='dark']` and `:host-context([data-theme='dark'])`, so you don't need to touch any styles.\n\n**Test cases**\n- First visit with empty localStorage → app starts in light mode and shows the light theme.\n- Click the toggle once → app switches to dark mode, the page background becomes dark, and the toggle shows dark mode.\n- Reload the page after switching to dark mode → app initializes in dark mode, without a visible flash back to light.\n- Toggle back to light → theme changes immediately and localStorage is updated.\n- The toggle label/icon always matches the active theme.",
      "approaches": [
        {
          "title": "Global ThemeService with `data-theme` on `<html>`",
          "prose": "Use a dedicated `ThemeService` as the global source of truth for the theme.\n\n1. Define a `Theme` type alias (`'light' | 'dark'`) and a stable localStorage key.\n2. In the service constructor, read from localStorage; if a value exists, use it; otherwise default to `'light'`. After deciding the initial theme, immediately apply it to `document.documentElement` (e.g. via `setAttribute('data-theme', theme)`).\n3. Expose a `currentTheme` property, a `setTheme(theme)` method, and a `toggleTheme()` helper.\n   - `setTheme(theme)` updates `currentTheme`, writes it to localStorage, and updates the `<html>` `data-theme`.\n   - `toggleTheme()` flips between `'light'` and `'dark'` using `setTheme`.\n4. In `AppComponent`, inject `ThemeService` and expose a getter `isDark` that checks `themeService.currentTheme === 'dark'`.\n5. Bind the toggle button to `onToggleClick()` which calls `themeService.toggleTheme()`. Use `isDark` to set the button label/icon (e.g. show the moon when in dark mode).\n6. The existing CSS in `styles.css` and `app.component.css` uses `:root[data-theme='dark']` and `:host-context([data-theme='dark'])` to change background, text, and card colors based on `data-theme`, so no CSS changes are required.\n\nThis implementation keeps theme state in one place, uses DI for access, and demonstrates a clean separation between state (service), UI (component), and styling (preconfigured CSS that reacts to `data-theme`).",
          "codeTs": "import { Component, inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ThemeService } from './theme.service';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  readonly themeService = inject(ThemeService);\n\n  get isDark(): boolean {\n    return this.themeService.currentTheme === 'dark';\n  }\n\n  onToggleClick(): void {\n    this.themeService.toggleTheme();\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Reading from localStorage too late (e.g. after the first render), causing a visible flash from light to dark.",
          "Forgetting to actually apply the theme to the document (only changing the label but not colors).",
          "Using multiple sources of truth for the theme (e.g. duplicating theme state in both component and service).",
          "Trying to change the CSS instead of driving the existing `data-theme`-based styles from the service."
        ],
        "techniques": [
          "Using an Angular service as a global singleton to hold app-wide state.",
          "Injecting `DOCUMENT` from `@angular/common` to manipulate the root element safely.",
          "Encapsulating side-effects (localStorage reads/writes, DOM attribute updates) inside the service instead of scattering them across components.",
          "Letting preconfigured CSS (`:root[data-theme='dark']` and `:host-context([data-theme='dark'])`) handle visual changes while the service only controls `data-theme`."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/angular/question/angular-theme-toggle.v2.json",
      "openFile": "/src/app/app.component.ts",
      "storageKey": "v2:ui:angular:angular-theme-toggle"
    },
    "companies": [
      "google",
      "meta",
      "uber"
    ],
    "solutionAsset": "assets/sb/angular/solution/angular-theme-toggle-solution.v2.json"
  }
]