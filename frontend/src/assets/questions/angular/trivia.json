[
  {
    "id": "angular-lifecycle-constructor-oninit-afterviewinit-dom",
    "title": "What’s the difference between constructor, ngOnInit, and ngAfterViewInit, and which one is correct for DOM/ViewChild access?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "constructor is for DI + trivial class setup, ngOnInit is for initialization that depends on inputs/bindings, and ngAfterViewInit is for work that needs the component view (DOM, ViewChild). For DOM/ViewChild access, ngAfterViewInit is usually correct—except @ViewChild({ static: true }) cases which are available earlier.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>These run at different moments in the component lifecycle. The right hook depends on what you need: DI only (constructor), inputs/bindings (ngOnInit), or the rendered view / ViewChild / DOM (ngAfterViewInit)."
        },
        {
          "type": "list",
          "columns": [
            "Hook",
            "When it runs",
            "What it’s for",
            "DOM / ViewChild availability"
          ],
          "rows": [
            [
              "<code>constructor</code>",
              "When the class instance is created (before Angular initializes bindings).",
              "Dependency injection + minimal field initialization (no Angular-dependent logic).",
              "❌ Not safe for DOM. View is not created. ViewChild not resolved."
            ],
            [
              "<code>ngOnInit()</code>",
              "Once, after Angular sets data-bound inputs (after first <code>ngOnChanges</code>).",
              "Initialization that depends on inputs, services, starting streams, fetching data.",
              "⚠️ Usually not for DOM. ViewChild only if <code>@ViewChild({ static: true })</code>."
            ],
            [
              "<code>ngAfterViewInit()</code>",
              "Once, after Angular finishes creating the component’s view + child views.",
              "Work that needs the rendered view: <code>@ViewChild</code>, DOM measurements, focus, 3rd-party widgets init.",
              "✅ Safe for DOM/ViewChild (default <code>static: false</code>)."
            ]
          ],
          "caption": "Constructor vs ngOnInit vs ngAfterViewInit"
        },
        {
          "type": "text",
          "text": "<strong>Which one is correct for DOM / ViewChild?</strong><br><br><strong>Use <code>ngAfterViewInit()</code> for DOM/ViewChild access in most cases.</strong> That’s when Angular guarantees the view exists and view queries (default <code>static: false</code>) are resolved."
        },
        {
          "type": "text",
          "text": "<strong>Important nuance: <code>@ViewChild</code> static option</strong><br><br><code>@ViewChild(..., { static: true })</code> resolves earlier (before/at init), so it can be used in <code>ngOnInit()</code> <em>if</em> the element is always present (not inside <code>*ngIf</code>/<code>*ngFor</code>). Default is <code>static: false</code>, which is available in <code>ngAfterViewInit()</code>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { AfterViewInit, Component, ElementRef, OnInit, ViewChild } from '@angular/core';\n\n@Component({\n  selector: 'app-demo',\n  template: `\n    <input #nameInput />\n    <!-- If this input were under *ngIf, static:true would be wrong -->\n  `\n})\nexport class DemoComponent implements OnInit, AfterViewInit {\n  // Case A (common): default static:false => available in ngAfterViewInit\n  @ViewChild('nameInput') nameInput?: ElementRef<HTMLInputElement>;\n\n  // Case B: static:true => available in ngOnInit (ONLY if always present)\n  // @ViewChild('nameInput', { static: true }) nameInput!: ElementRef<HTMLInputElement>;\n\n  constructor(/* inject services here */) {\n    // DI only. No DOM.\n  }\n\n  ngOnInit(): void {\n    // Good: init that depends on @Input() or services.\n    // If using static:true, you *can* access nameInput here.\n  }\n\n  ngAfterViewInit(): void {\n    // Safe place for DOM/ViewChild\n    this.nameInput?.nativeElement.focus();\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "Correct hook",
            "Why"
          ],
          "rows": [
            [
              "Read <code>@Input()</code> values, set up streams, start API calls",
              "<code>ngOnInit</code>",
              "Inputs are set; component is initialized."
            ],
            [
              "Access <code>@ViewChild</code> / measure DOM / focus element",
              "<code>ngAfterViewInit</code>",
              "View is created; queries are resolved."
            ],
            [
              "ViewChild element is always present (not under *ngIf/*ngFor) and you need it early",
              "<code>ngOnInit</code> + <code>@ViewChild({ static: true })</code>",
              "Static query resolves before init."
            ],
            [
              "Access projected content via <code>@ContentChild</code>",
              "<code>ngAfterContentInit</code>",
              "Projected content is initialized (different from the view)."
            ]
          ],
          "caption": "Picking the right lifecycle hook"
        },
        {
          "type": "text",
          "text": "<strong>Common pitfall</strong><br><br>If you change a bound value inside <code>ngAfterViewInit</code>, you can trigger <code>ExpressionChangedAfterItHasBeenCheckedError</code> in dev mode. Fix by avoiding sync bound mutations there, or scheduling them (microtask) / triggering a follow-up change detection deliberately (advanced)."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>constructor</code> = DI + minimal setup. <code>ngOnInit</code> = initialization that depends on inputs/bindings. <code>ngAfterViewInit</code> = anything that needs the rendered view (DOM, <code>ViewChild</code>). For DOM/ViewChild access, <strong>ngAfterViewInit is the default correct choice</strong>, with the exception of <code>@ViewChild({ static: true })</code> when the element is guaranteed to exist."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "lifecycle",
      "components",
      "hooks",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular constructor vs ngOnInit vs ngAfterViewInit",
      "description": "Learn what each hook is for, when inputs and view are ready, and why DOM/ViewChild access usually belongs in ngAfterViewInit except static ViewChild cases."
    }
  },
  {
    "id": "angular-vs-angularjs",
    "title": "What is the difference between Angular and AngularJS?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "AngularJS (1.x) and Angular (2+) share a name but are different frameworks. Angular (2+) is a rewrite with TypeScript, components, RxJS-first patterns, modern tooling, and a different rendering/change-detection model. Explain the practical differences and why migration is non-trivial.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core distinction</strong><br><br><strong>AngularJS (1.x)</strong> = JavaScript + controllers/scopes + digest cycle (watchers).<br><strong>Angular (2+)</strong> = TypeScript + components + dependency injection + RxJS + build-time tooling (CLI/compiler).<br><br>They are <strong>not</strong> backward-compatible; a real migration is usually a refactor/rewrite, not an upgrade."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "AngularJS (1.x)",
            "Angular (2+)"
          ],
          "rows": [
            [
              "Language",
              "JavaScript (ES5/ES6)",
              "TypeScript-first (still outputs JS)"
            ],
            [
              "UI model",
              "Controllers + $scope",
              "Components + Inputs/Outputs"
            ],
            [
              "Change detection",
              "Digest cycle + watchers per binding",
              "Change detection over component tree (optimizable via OnPush, trackBy, etc.)"
            ],
            [
              "Dependency injection",
              "DI exists but older style",
              "Modern DI system with providers, hierarchical injectors"
            ],
            [
              "Templates",
              "Directives + expressions like {{ }}",
              "Declarative templates + structural directives like *ngIf/*ngFor"
            ],
            [
              "Routing",
              "Typically ngRoute/ui-router (external)",
              "Built-in Angular Router"
            ],
            [
              "Async patterns",
              "Promises/callbacks (plus $q)",
              "RxJS Observables are a core primitive"
            ],
            [
              "Tooling/build",
              "Manual/grunt/gulp-era setups",
              "Angular CLI + compiler + bundlers/test integration"
            ],
            [
              "Rendering/compilation",
              "Runtime heavy; template compilation differs by mode",
              "AOT/JIT options, modern compiler pipeline"
            ],
            [
              "Status",
              "Legacy / end-of-life ecosystem",
              "Actively maintained framework"
            ]
          ],
          "caption": "Interview-relevant differences (practical, not marketing)"
        },
        {
          "type": "text",
          "text": "<strong>Why Angular was a rewrite</strong><br><br>AngularJS scaled poorly when apps grew: lots of watchers + digest cycles made performance and maintainability harder. Angular (2+) moved to a component model, stronger typing, and a modern compilation/tooling pipeline to make large apps more predictable."
        },
        {
          "type": "list",
          "columns": [
            "What interviewers typically want to hear"
          ],
          "rows": [
            [
              "“Same name, different framework. Angular is a rewrite; not an upgrade.”"
            ],
            [
              "“AngularJS: $scope + digest loop; Angular: component tree + change detection.”"
            ],
            [
              "“Angular is TypeScript-first with strong DI + CLI + RxJS patterns.”"
            ],
            [
              "“Migration is non-trivial: architecture changes (controllers→components, services, routing, forms, async model).”"
            ]
          ]
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- AngularJS: directives + controller + scope -->\n<div ng-app=\"app\" ng-controller=\"MainCtrl as vm\">\n  <h1>{{ vm.message }}</h1>\n</div>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Angular (2+): component class + template\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: `<h1>{{ message }}</h1>`,\n})\nexport class AppComponent {\n  message = 'Hello';\n}"
        },
        {
          "type": "list",
          "columns": [
            "Migration notes (real-world)"
          ],
          "rows": [
            [
              "Simple “upgrade” doesn’t exist; you either rewrite incrementally or build a hybrid app (ngUpgrade) for a period."
            ],
            [
              "Main shifts: controllers/scopes → components + services; digest watchers → change detection; promise-heavy code → observable-friendly APIs."
            ],
            [
              "Testing/tooling also changes: Karma/Jasmine setups may differ, CLI conventions become the default, and build pipelines change."
            ]
          ]
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>AngularJS (1.x) is the legacy framework built around controllers/<code>$scope</code> and the digest cycle (watchers). Angular (2+) is a TypeScript-first, component-based rewrite with modern DI, RxJS-first async patterns, and CLI/compiler tooling. Same name, different architecture—migration is typically a refactor/rewrite rather than an “upgrade”."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "angularjs",
      "frameworks",
      "history",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular vs AngularJS: Key Differences and Migration Reality",
      "description": "Compare AngularJS (1.x) and Angular (2+) across architecture, TypeScript, tooling, and change detection, and why migration means real rewrites."
    }
  },
  {
    "id": "angular-component-vs-service-responsibilities",
    "title": "What responsibilities belong inside an Angular component vs a service?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Angular components should focus on UI/presentation and user interactions, while services should hold reusable logic, business rules, and side effects (HTTP, caching, state). Clean separation keeps components thin, improves testability, and avoids duplicated logic across the app.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Use <strong>components</strong> for rendering + wiring UI events to actions. Use <strong>services</strong> for reusable logic and side effects (HTTP, caching, state, orchestration). A good component reads like a “view model composer”, not a mini back-end."
        },
        {
          "type": "list",
          "columns": [
            "Area",
            "Component (belongs here)",
            "Service (belongs here)"
          ],
          "rows": [
            [
              "UI rendering",
              "Template bindings, UI composition, structural directives, view-only formatting",
              "No DOM/template concerns"
            ],
            [
              "User interaction",
              "Click handlers, form submit handlers, mapping UI events → intent/actions",
              "Input validation rules that are reusable across screens"
            ],
            [
              "State",
              "Ephemeral UI state (open/closed, selected tab, local filters, loading flags for UI)",
              "Shared/stateful app logic (cache, session data, cross-component state), facades"
            ],
            [
              "Business rules",
              "Minimal (only what’s needed to connect UI to rules)",
              "Core rules (pricing logic, permission checks, normalization, mapping DTO→domain)"
            ],
            [
              "Data access",
              "Never call low-level APIs directly (avoid HttpClient usage in components)",
              "HTTP calls, retries, error mapping, caching, request dedupe"
            ],
            [
              "Reusability",
              "Rare (components can be reusable, but should avoid app-specific business logic)",
              "High (same service can be used by multiple components)"
            ],
            [
              "Testing",
              "Shallow: assert template bindings + event wiring + observable usage",
              "Deep: unit test rules/side effects without rendering"
            ]
          ],
          "caption": "Component vs Service responsibilities"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>If the code depends on <strong>how something is shown</strong> (DOM, template state, view events) → component. If it depends on <strong>what something means</strong> (rules, data fetching, caching, orchestration) → service."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// user.service.ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, shareReplay } from 'rxjs';\n\nexport interface UserDto { id: string; name: string; }\nexport interface User { id: string; displayName: string; }\n\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private users$?: Observable<User[]>;\n\n  constructor(private http: HttpClient) {}\n\n  getUsers(): Observable<User[]> {\n    // Cache + dedupe requests for this session\n    this.users$ ??= this.http.get<UserDto[]>('/api/users').pipe(\n      // Business mapping belongs here (or a dedicated mapper)\n      // so multiple components get consistent data.\n      // Keep mapping pure.\n      // DTO -> domain model:\n      // (If mapping grows, extract to a pure function.)\n      shareReplay({ bufferSize: 1, refCount: true })\n    ) as unknown as Observable<User[]>;\n\n    return this.users$;\n  }\n}"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// user-list.component.ts\nimport { Component, ChangeDetectionStrategy } from '@angular/core';\nimport { Observable, map, startWith } from 'rxjs';\nimport { UserService, User } from './user.service';\n\n@Component({\n  selector: 'app-user-list',\n  templateUrl: './user-list.component.html',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserListComponent {\n  // UI state belongs here\n  readonly search = '';\n\n  // Data stream comes from a service\n  readonly users$: Observable<User[]> = this.userService.getUsers();\n\n  // UI-only derived state can be computed in the component\n  // (keep it cheap; heavy transforms should be in a service/facade)\n  readonly viewModel$ = this.users$.pipe(\n    map(users => ({\n      users,\n      total: users.length\n    })),\n    startWith({ users: [], total: 0 })\n  );\n\n  constructor(private userService: UserService) {}\n\n  onRefreshClick(): void {\n    // UI intent: trigger refresh.\n    // If refresh needs side-effects (invalidate cache), expose that from the service.\n    // e.g. this.userService.invalidateUsersCache();\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "Common mistake",
            "Why it hurts",
            "Fix"
          ],
          "rows": [
            [
              "HttpClient calls inside components",
              "Duplicates logic, makes components hard to test and reuse",
              "Move data access to a service/facade"
            ],
            [
              "Business rules in templates (complex expressions)",
              "Hard to read, hard to test, runs every CD cycle",
              "Compute in TS (component for UI-only, service for reusable rules)"
            ],
            [
              "Services manipulating the DOM",
              "Breaks separation, complicates SSR/testing",
              "Keep DOM work in components/directives; services stay UI-agnostic"
            ],
            [
              "“God component” that owns everything",
              "Becomes unmaintainable; PRs become risky",
              "Extract services + presentational components; keep the container thin"
            ]
          ],
          "caption": "Typical boundary violations"
        },
        {
          "type": "text",
          "text": "<strong>Extra nuance: service scope</strong><br><br>Most services are singletons (<code>providedIn: 'root'</code>). If you need per-component instance state (e.g., a wizard session), provide the service at the component level via <code>providers: [WizardStateService]</code> so each component instance gets its own copy."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Keep components focused on UI + event wiring + lightweight view-model shaping. Put reusable logic, side effects, data access, and business rules into services (or facades). This separation improves testability, reuse, and long-term maintainability."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "components",
      "services",
      "architecture",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Component vs Service Responsibilities",
      "description": "Understand what belongs in components versus services, how to keep UI layers thin, and where to place business logic, HTTP calls, caching, and state."
    }
  },
  {
    "id": "angular-component-metadata",
    "title": "What metadata does @Component provide, and why does Angular need it?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "The @Component decorator attaches metadata to a TypeScript class so Angular can treat it as a component. This metadata tells Angular how to render the view (template + styles), how to match it in HTML (selector), what dependencies it can use (imports/providers), and how to run it (change detection, encapsulation, host bindings). Angular needs this because a plain class doesn’t contain enough information to compile and instantiate a UI component.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>@Component({...})</code> is configuration for Angular’s compiler/runtime. It turns a plain class into something Angular can: (1) match in templates, (2) compile into render instructions, and (3) instantiate with the right DI scope and runtime behavior."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, ChangeDetectionStrategy, ViewEncapsulation } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  standalone: true,\n  imports: [],\n  template: `\n    <article class=\"card\">\n      <h3>{{ name }}</h3>\n    </article>\n  `,\n  styles: [`.card { padding: 12px; }`],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.Emulated,\n  providers: [],\n  host: { '[class.highlight]': 'highlight' }\n})\nexport class UserCardComponent {\n  name = 'Ada';\n  highlight = false;\n}"
        },
        {
          "type": "list",
          "columns": [
            "Metadata field",
            "What it tells Angular",
            "Why it matters"
          ],
          "rows": [
            [
              "<code>selector</code>",
              "How this component is referenced in templates (e.g. <code>&lt;app-user-card&gt;</code>).",
              "Without it, Angular can’t match your class to an element in the DOM/template."
            ],
            [
              "<code>template</code> / <code>templateUrl</code>",
              "The view structure to compile and render.",
              "Angular compiles it into efficient render instructions; the class alone has no view."
            ],
            [
              "<code>styles</code> / <code>styleUrls</code>",
              "The component’s CSS.",
              "Angular can scope/apply styles according to encapsulation settings."
            ],
            [
              "<code>standalone</code> + <code>imports</code>",
              "Which directives/pipes/components are available in this template (standalone world).",
              "Defines template dependency scope; missing imports means compile/runtime errors."
            ],
            [
              "<code>providers</code>",
              "DI providers scoped to this component subtree.",
              "Controls service lifetime/scope (component-level instances vs root singletons)."
            ],
            [
              "<code>changeDetection</code>",
              "How Angular runs change detection for this component.",
              "Affects performance + update semantics (e.g., <code>OnPush</code> vs default)."
            ],
            [
              "<code>encapsulation</code>",
              "How styles are scoped (Emulated/None/ShadowDom).",
              "Prevents style bleeding (or intentionally allows it)."
            ],
            [
              "<code>host</code> / <code>hostDirectives</code>",
              "Host bindings/listeners and composition on the host element.",
              "Lets Angular wire DOM behavior without manual imperative DOM code."
            ],
            [
              "<code>animations</code>",
              "Animation triggers available for this component.",
              "Angular needs to register triggers so the runtime can execute them."
            ]
          ],
          "caption": "Common @Component metadata and what each part configures"
        },
        {
          "type": "text",
          "text": "<strong>Why Angular needs this metadata</strong><br><br>A component is not “just a class” in Angular. Angular must know: (1) what DOM tag/selector maps to this class, (2) what template to compile, (3) what dependencies are allowed in that template, (4) what DI scope to use, and (5) how to run runtime behaviors like change detection and style scoping. None of that is inferable reliably from TypeScript code alone."
        },
        {
          "type": "list",
          "columns": [
            "Angular uses metadata to...",
            "Concrete outcome"
          ],
          "rows": [
            [
              "Compile templates (AOT/JIT) into render instructions",
              "Fast runtime rendering; template errors are caught early in AOT builds."
            ],
            [
              "Create an internal component definition (Ivy)",
              "Angular generates internal definitions (e.g., the compiled component factory/definition) that drive creation + updates."
            ],
            [
              "Resolve template dependency scope",
              "Standalone <code>imports</code> (or NgModule declarations/imports) decide what directives/pipes are legal in the template."
            ],
            [
              "Build the DI boundary",
              "Component-level <code>providers</code> create a scoped injector for the component subtree."
            ],
            [
              "Apply runtime policies",
              "<code>OnPush</code>, encapsulation, host bindings, animations all change runtime behavior."
            ]
          ],
          "caption": "What Angular actually does with @Component metadata"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>@Component</code> metadata is the contract between your class and Angular’s compiler/runtime: how to find it (<code>selector</code>), how to render it (<code>template</code>/<code>styles</code>), what it can use (<code>imports</code>/<code>providers</code>), and how it behaves (<code>changeDetection</code>/<code>encapsulation</code>/<code>host</code>). Angular needs it because the framework must compile and instantiate UI components deterministically."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "components",
      "decorators",
      "metadata",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular @Component Metadata: What It Defines and Why",
      "description": "Learn what selector, template, styles, imports, and providers metadata do, and why Angular needs this configuration to compile and instantiate components."
    }
  },
  {
    "id": "angular-ngmodules-vs-standalone",
    "title": "What problems do NgModules solve that standalone components don’t?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Standalone components remove the need for NgModules for most app composition, routing, and DI setup. NgModules still solve a few practical problems: packaging legacy (non-standalone) declarations, consuming module-based third-party libraries (forRoot/forChild), and providing a single import/export “bundle” boundary that some teams and libraries still rely on. Covers: angular, modules, standalone, architecture, basics.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Standalone components shift Angular’s \"template dependency scope\" from <code>@NgModule</code> to the component itself (<code>imports</code> on the component). For modern apps, that removes most reasons to create feature/shared modules.<br><br>NgModules still matter mainly as a <strong>packaging + compatibility layer</strong> for legacy declarables and module-based libraries/config APIs."
        },
        {
          "type": "list",
          "columns": [
            "Problem / need",
            "NgModule solves it by...",
            "Standalone status"
          ],
          "rows": [
            [
              "Using non-standalone directives/pipes/components (legacy code or older libs)",
              "Declaring them once and exporting them via a module",
              "Standalone cannot directly import non-standalone declarables; you import the NgModule that exports them."
            ],
            [
              "Module-style library configuration (forRoot/forChild patterns)",
              "Returning <code>ModuleWithProviders</code> and wiring providers through module imports",
              "Standalone supports this mostly via <code>importProvidersFrom(SomeModule.forRoot(...))</code>, but the library still forces the NgModule shape."
            ],
            [
              "Single “bundle import” for a large set of template dependencies",
              "One <code>SharedModule</code> re-exports many imports/exports so feature code imports one thing",
              "Standalone can mimic with a shared array/const, but there’s no first-class “export scope” container like NgModule exports."
            ],
            [
              "Gradual migration in an existing NgModule app",
              "You can convert leaf components to standalone while keeping module boundaries intact",
              "Standalone is great for incremental migration, but NgModules remain the glue during the transition."
            ],
            [
              "Team convention: explicit public API surface (exports) for a domain",
              "Exports define what the rest of the app can use from that domain",
              "Standalone relies on regular TS exports + per-component imports; you lose the explicit “exports list” mechanism."
            ]
          ],
          "caption": "Where NgModules still provide value in a standalone-first Angular world"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// legacy-shared.module.ts\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { LegacyHighlightDirective } from './legacy-highlight.directive';\nimport { LegacyDatePipe } from './legacy-date.pipe';\n\n@NgModule({\n  declarations: [LegacyHighlightDirective, LegacyDatePipe],\n  imports: [CommonModule],\n  exports: [CommonModule, LegacyHighlightDirective, LegacyDatePipe]\n})\nexport class LegacySharedModule {}\n"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// standalone component consuming legacy declarations via NgModule\nimport { Component } from '@angular/core';\nimport { LegacySharedModule } from './legacy-shared.module';\n\n@Component({\n  standalone: true,\n  selector: 'app-user-card',\n  imports: [LegacySharedModule],\n  template: `\n    <div legacyHighlight>\n      {{ today | legacyDate }}\n    </div>\n  `\n})\nexport class UserCardComponent {\n  today = new Date();\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "If you’re fully standalone, do this instead",
            "Why it’s the equivalent"
          ],
          "rows": [
            [
              "Create reusable import bundles as constants (not modules)",
              "Gives you “one name” to import across many standalone components without an NgModule exports list."
            ],
            [
              "Prefer provider functions (<code>provideRouter</code>, <code>provideHttpClient</code>, etc.)",
              "Moves app configuration to bootstrap/route providers and reduces NgModule-only configuration patterns."
            ]
          ],
          "caption": "Standalone alternatives to common “SharedModule” patterns"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// shared-imports.ts (standalone-friendly)\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\n\nexport const SHARED_IMPORTS = [CommonModule, RouterModule] as const;\n\n// any.component.ts\nimport { Component } from '@angular/core';\nimport { SHARED_IMPORTS } from './shared-imports';\n\n@Component({\n  standalone: true,\n  imports: [...SHARED_IMPORTS],\n  template: `...`\n})\nexport class AnyComponent {}\n"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Module-based library config still shows up a lot\nimport { bootstrapApplication, importProvidersFrom } from '@angular/core';\nimport { AppComponent } from './app.component';\nimport { TranslateModule } from 'some-translate-lib';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    importProvidersFrom(TranslateModule.forRoot({ defaultLang: 'en' }))\n  ]\n});\n"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Standalone components cover most of what NgModules were used for (composition, routing, DI setup). NgModules still “win” mainly for <strong>legacy/non-standalone declarations</strong> and <strong>module-shaped third-party APIs</strong> (especially <code>forRoot</code>/<code>forChild</code>). In a greenfield app with modern libs, you usually don’t need to write new NgModules."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Practical notes</strong>\n\nWatch for edge case behavior, common pitfalls, and trade-offs between clarity and performance. Mention accessibility and testing considerations when the concept affects UI output or event timing."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "modules",
      "standalone",
      "architecture",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular NgModules vs Standalone: What Still Needs Modules?",
      "description": "Understand what standalone components replace, which legacy and library scenarios still rely on NgModules, and how to choose boundaries during migration."
    }
  },
  {
    "id": "angular-appmodule-standalone-changes",
    "title": "AppModule in the standalone era: what moved to components, bootstrapApplication, and route providers?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "With standalone, AppModule is no longer the central “assembly point”. Template scope moves from NgModule declarations/imports to each standalone component’s imports, and app-wide configuration moves to bootstrapApplication(...) (or an ApplicationConfig) and route-level providers. AppModule often disappears in greenfield apps, but NgModules still exist for legacy code and module-shaped libraries. The trade-off is simpler bootstrapping versus managing provider scope per component; test DI boundaries when migrating.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Standalone changes Angular’s composition model:<br><br><strong>Before</strong>: AppModule declared what exists and what templates can use.<br><strong>Now</strong>: standalone components declare their own template dependencies (<code>imports</code>), and app-wide wiring happens in <code>bootstrapApplication</code> (or <code>ApplicationConfig</code>) + route providers."
        },
        {
          "type": "list",
          "columns": [
            "AppModule responsibility (NgModule-era)",
            "Standalone replacement (where it moved)",
            "Concrete example"
          ],
          "rows": [
            [
              "Bootstrapping",
              "main.ts uses <code>bootstrapApplication</code>",
              "<code>bootstrapApplication(AppComponent, appConfig)</code>"
            ],
            [
              "Template dependency scope (CommonModule/Router/Material/etc.)",
              "Standalone component <code>imports</code> (or feature route component imports)",
              "<code>@Component({ standalone:true, imports:[NgIf, NgFor, RouterOutlet] })</code>"
            ],
            [
              "Global providers via module imports",
              "Provider functions + environment providers",
              "<code>provideRouter</code>, <code>provideHttpClient</code>, <code>provideAnimations</code>"
            ],
            [
              "Feature modules for routing + lazy loading",
              "Standalone routes + <code>loadComponent</code> (and route-level providers)",
              "<code>{ path:'admin', loadComponent: () => import(...), providers:[...] }</code>"
            ],
            [
              "Legacy declarables packaging",
              "Still NgModules (compat layer)",
              "Standalone components import the legacy NgModule that exports them"
            ]
          ],
          "caption": "What “moved out of AppModule” and where it lives now"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// NgModule-era (classic)\n// main.ts\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app/app.module';\n\nplatformBrowserDynamic().bootstrapModule(AppModule).catch(console.error);\n\n// app.module.ts\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\nimport { RouterModule } from '@angular/router';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule, HttpClientModule, RouterModule.forRoot([])],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Standalone-era (modern)\n// app.config.ts\nimport { ApplicationConfig } from '@angular/core';\nimport { provideRouter } from '@angular/router';\nimport { provideHttpClient, withInterceptors } from '@angular/common/http';\nimport { provideAnimations } from '@angular/platform-browser/animations';\nimport { routes } from './app.routes';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter(routes),\n    provideHttpClient(\n      withInterceptors([\n        // (req, next) => next(req)\n      ])\n    ),\n    provideAnimations()\n  ]\n};\n\n// main.ts\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { AppComponent } from './app.component';\nimport { appConfig } from './app.config';\n\nbootstrapApplication(AppComponent, appConfig).catch(console.error);"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// app.component.ts (standalone root)\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [RouterOutlet],\n  template: `<router-outlet></router-outlet>`\n})\nexport class AppComponent {}"
        },
        {
          "type": "list",
          "columns": [
            "Interview hotspot: “Where do global things go now?”",
            "Standalone answer"
          ],
          "rows": [
            [
              "RouterModule.forRoot(...)",
              "<code>provideRouter(routes)</code> in <code>bootstrapApplication</code> / <code>ApplicationConfig</code>"
            ],
            [
              "HttpClientModule",
              "<code>provideHttpClient(...)</code> (interceptors via <code>withInterceptors</code>/<code>withInterceptorsFromDi</code>)"
            ],
            [
              "BrowserAnimationsModule",
              "<code>provideAnimations()</code> (or <code>provideNoopAnimations()</code>)"
            ],
            [
              "Feature-scoped providers",
              "Route-level <code>providers: [...]</code> (scoped to that route subtree)"
            ],
            [
              "Module-only libraries (forRoot/NgModules)",
              "Use <code>importProvidersFrom(SomeLibModule.forRoot(...))</code> (or keep AppModule if simpler)"
            ]
          ],
          "caption": "This is the practical “AppModule replacement” map interviewers look for"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Route-level providers (feature scoping without a feature module)\nimport { Routes } from '@angular/router';\nimport { provideHttpClient } from '@angular/common/http';\n\nexport const routes: Routes = [\n  {\n    path: 'admin',\n    loadComponent: () => import('./admin/admin.page').then(m => m.AdminPage),\n    providers: [\n      // providers here are scoped to the admin route subtree\n      provideHttpClient()\n    ]\n  }\n];"
        },
        {
          "type": "list",
          "columns": [
            "Common standalone migration pitfall",
            "What breaks",
            "Fix"
          ],
          "rows": [
            [
              "Forgetting template imports (NgIf/NgFor/AsyncPipe/etc.)",
              "Template compile errors: “Can’t bind to ...” / unknown directive/pipe",
              "Import the standalone directive/pipe (e.g. <code>NgIf</code>, <code>NgFor</code>, <code>AsyncPipe</code>) or import a legacy NgModule that exports them"
            ],
            [
              "Mixing module config patterns blindly",
              "Duplicate providers / unexpected multiple instances",
              "Prefer provider functions at bootstrap/route; use <code>importProvidersFrom</code> only when the library forces NgModule shape"
            ],
            [
              "Assuming NgModules are “gone”",
              "Legacy libs/declarables can’t be imported directly",
              "Keep NgModules as a compatibility/container layer where needed"
            ]
          ],
          "caption": "What experienced Angular devs call out quickly"
        },
        {
          "type": "list",
          "columns": [
            "Do you still need AppModule?",
            "Answer"
          ],
          "rows": [
            [
              "Greenfield standalone app",
              "Usually no — AppModule can disappear entirely."
            ],
            [
              "Incremental migration from a large NgModule app",
              "Often yes (temporarily) — convert routes/components gradually while keeping AppModule as glue."
            ],
            [
              "Library ecosystem is NgModule-heavy (forRoot/exported modules)",
              "You might still avoid AppModule, but you’ll rely on <code>importProvidersFrom(...)</code> and some NgModules as adapters."
            ]
          ],
          "caption": "The senior answer is “AppModule becomes optional; NgModules become mostly compatibility/packaging.”"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Standalone doesn’t delete NgModules, but it removes the need for an AppModule as the app’s “wiring center”. Template scope moves to standalone component <code>imports</code>. App-wide wiring moves to <code>bootstrapApplication</code> (or <code>ApplicationConfig</code>) and can be further scoped via route-level providers. AppModule becomes optional: common to remove in new apps, common to keep temporarily during migrations."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Migrating a legacy Angular app to standalone components, you move imports and providers from AppModule into each feature component.<br><br><strong>Common pitfalls</strong><br><ul><li>Forgetting to add required imports to a standalone component.</li><li>Provider scope changes causing unexpected singleton behavior.</li><li>Mixing module-based libraries without clear boundaries.</li></ul><strong>Trade-off or test tip</strong><br>Standalone simplifies bootstrapping but shifts responsibility to each component. Test DI scopes and route-level providers after migration.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "modules",
      "standalone",
      "migration",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Standalone Era: What Replaces AppModule?",
      "description": "See what moved from AppModule to bootstrapApplication, route providers, and component imports, plus DI-scope pitfalls to test when migrating existing apps."
    }
  },
  {
    "id": "angular-template-compilation-and-binding",
    "title": "How does Angular compile templates and bind them to component state?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Angular turns your component template into generated render/update instructions (AOT or JIT). At runtime, change detection re-runs the update phase so bindings (text, properties, attributes, events) stay in sync with the component instance (state). Covers: angular, templates, compilation, data binding, basics.",
    "seo": {
      "title": "Angular Template Compilation and Binding",
      "description": "Learn how Angular compiles templates into render and update instructions, then keeps bindings synced with component state through change detection."
    },
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Angular does <strong>two big jobs</strong>:<br>1) <strong>Compile</strong> the template into efficient instructions (Ivy) + type-check it.<br>2) <strong>Run change detection</strong> to execute the template’s <em>update</em> instructions, keeping the DOM synced with the component instance."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "What happens",
            "Why it matters"
          ],
          "rows": [
            [
              "Template parse",
              "HTML + Angular syntax become an internal AST (elements, bindings, directives, pipes).",
              "Angular understands what must be created vs updated."
            ],
            [
              "Template scope resolution",
              "Figure out which directives/pipes/components are legal (standalone <code>imports</code> or NgModule scope).",
              "Missing imports become compile errors."
            ],
            [
              "Template type-checking",
              "Angular generates TS type-check blocks so your bindings are checked by TypeScript.",
              "Catches <code>user.nmae</code> / wrong input types at build time (AOT)."
            ],
            [
              "Code generation (Ivy)",
              "Compiler emits a template function with <em>create</em> and <em>update</em> phases (instructions).",
              "Runtime is fast: no string templates, no regex, minimal DOM work."
            ],
            [
              "Bundling (AOT) or runtime compile (JIT)",
              "AOT ships generated JS; JIT compiles in the browser (dev-style).",
              "AOT = smaller/faster startup + earlier errors."
            ]
          ],
          "caption": "What “compiling an Angular template” actually means"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, signal } from '@angular/core';\n\n@Component({\n  selector: 'app-counter',\n  standalone: true,\n  template: `\n    <h3>Hello, {{ name }}</h3>\n    <button [disabled]=\"count() >= 3\" (click)=\"inc()\">\n      Count: {{ count() }}\n    </button>\n  `\n})\nexport class CounterComponent {\n  name = 'Ada';\n  count = signal(0);\n\n  inc() {\n    this.count.update(v => v + 1);\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>What the compiler roughly generates (simplified)</strong><br><br>Angular creates a <code>template(rf, ctx)</code> function. <code>rf</code> is a flag: create vs update. <code>ctx</code> is the component instance."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "function CounterComponent_Template(rf: number, ctx: CounterComponent) {\n  if (rf & 1) {\n    // CREATE phase: create DOM nodes + wire listeners once\n    // ɵɵelementStart(0, 'h3');\n    // ɵɵtext(1);\n    // ɵɵelementEnd();\n    // ɵɵelementStart(2, 'button');\n    // ɵɵlistener('click', () => ctx.inc());\n    // ɵɵtext(3);\n    // ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    // UPDATE phase: re-evaluate bindings and patch DOM as needed\n    // ɵɵtextInterpolate1('Hello, ', ctx.name, '');\n    // ɵɵproperty('disabled', ctx.count() >= 3);\n    // ɵɵtextInterpolate1('Count: ', ctx.count(), '');\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "Binding in template",
            "Compiled into",
            "When it runs"
          ],
          "rows": [
            [
              "Interpolation <code>{{ x }}</code>",
              "Text update instruction (set text node value).",
              "Every change detection update pass."
            ],
            [
              "Property binding <code>[disabled]=\"expr\"</code>",
              "Property update instruction (set DOM property).",
              "Every update pass; only patches if value changed."
            ],
            [
              "Attribute/class/style bindings",
              "Dedicated attribute/class/style instructions.",
              "Every update pass; optimized diffs."
            ],
            [
              "Event binding <code>(click)=\"fn()\"</code>",
              "Listener instruction storing a callback referencing <code>ctx</code>.",
              "Listener is created once; runs on events."
            ],
            [
              "Directive/component inputs",
              "Input set instructions calling directive/component input setters.",
              "Every update pass when values change."
            ]
          ],
          "caption": "How template syntax becomes runtime work"
        },
        {
          "type": "text",
          "text": "<strong>How the template “binds to component state”</strong><br><br>Bindings read from the component instance (<code>ctx</code>). When state changes, Angular runs change detection and re-executes the template’s <em>update</em> phase, re-reading <code>ctx</code> and patching the DOM."
        },
        {
          "type": "list",
          "columns": [
            "What triggers an update pass",
            "Typical examples"
          ],
          "rows": [
            [
              "User events",
              "click/input/submit handlers run, state changes, Angular checks affected views."
            ],
            [
              "Async completion",
              "timers, HTTP responses, observable emissions, promise resolution (via zone or explicit scheduling)."
            ],
            [
              "Manual signals / APIs",
              "signals update, <code>markForCheck()</code>, <code>detectChanges()</code> (advanced cases)."
            ],
            [
              "Input changes from parent",
              "Parent updates child input binding; child updates in the next pass."
            ]
          ],
          "caption": "Change detection is the bridge between state changes and DOM updates"
        },
        {
          "type": "list",
          "columns": [
            "AOT vs JIT",
            "AOT (build-time)",
            "JIT (runtime)"
          ],
          "rows": [
            [
              "When compiled",
              "During build; ships compiled instructions.",
              "In the browser; compiles templates at runtime."
            ],
            [
              "Startup performance",
              "Better (no runtime compilation cost).",
              "Worse (extra work at runtime)."
            ],
            [
              "Error timing",
              "More errors caught earlier (type-check + template checks).",
              "Some errors appear later (at runtime)."
            ],
            [
              "Typical usage",
              "Production builds.",
              "Dev workflows / special cases."
            ]
          ],
          "caption": "Both end up with the same Ivy-style instructions; the main difference is when they’re produced"
        },
        {
          "type": "list",
          "columns": [
            "Practical implications (interview-relevant)",
            "What to say"
          ],
          "rows": [
            [
              "Templates are not “magic strings”",
              "They compile to create/update instructions; update phase re-runs on CD."
            ],
            [
              "Keep templates cheap",
              "Avoid heavy computations in bindings; move to component and cache/derive."
            ],
            [
              "OnPush changes behavior",
              "OnPush reduces checks; updates happen on input reference change, events, async, or explicit marking."
            ],
            [
              "Structural directives change the tree",
              "<code>*ngIf</code>/<code>*ngFor</code> compile into embedded views; creation/destruction is real DOM work."
            ]
          ],
          "caption": "What this means for performance and architecture"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Angular compiles templates into Ivy render instructions with a <em>create</em> and <em>update</em> phase. The <em>update</em> phase re-reads values from the component instance and patches the DOM during change detection, which is how bindings stay synced with component state."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Practical notes</strong>\n\nWatch for edge case behavior, common pitfalls, and trade-offs between clarity and performance. Mention accessibility and testing considerations when the concept affects UI output or event timing."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "templates",
      "compilation",
      "data-binding",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "angular-data-binding",
    "title": "Angular data binding: interpolation, property/attribute/class/style, events, and two-way ([(...)])",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Data binding is how Angular connects component state (TS) to the template (HTML) and back. It’s mostly one-way (component ➜ view via interpolation/property bindings, view ➜ component via event bindings). Two-way binding is optional syntactic sugar that combines both directions (commonly via forms/ngModel or custom @Input/@Output pairs).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Angular templates are declarative. You bind values into the DOM and bind events back into the component. Angular then keeps the DOM synced by re-running the template update phase during change detection (triggered by events, async work, input changes, etc.)."
        },
        {
          "type": "list",
          "columns": [
            "Binding kind",
            "Direction",
            "What it binds to",
            "Syntax",
            "Example"
          ],
          "rows": [
            [
              "Interpolation",
              "Component ➜ View",
              "Text nodes / attribute text",
              "<code>{{ expr }}</code>",
              "<code>&lt;h1&gt;Hello {{ user.name }}&lt;/h1&gt;</code>"
            ],
            [
              "Property binding",
              "Component ➜ View",
              "DOM <em>properties</em> (not HTML attributes)",
              "<code>[prop]=\"expr\"</code>",
              "<code>&lt;button [disabled]=\"loading\"&gt;Save&lt;/button&gt;</code>"
            ],
            [
              "Attribute binding",
              "Component ➜ View",
              "HTML attributes (incl. ARIA, non-property attrs)",
              "<code>[attr.name]=\"expr\"</code>",
              "<code>&lt;div [attr.aria-label]=\"label\"&gt;&lt;/div&gt;</code>"
            ],
            [
              "Class binding",
              "Component ➜ View",
              "CSS classes",
              "<code>[class.foo]=\"expr\"</code>",
              "<code>&lt;li [class.active]=\"isActive\"&gt;...&lt;/li&gt;</code>"
            ],
            [
              "Style binding",
              "Component ➜ View",
              "Inline styles (+ units)",
              "<code>[style.width.px]=\"n\"</code>",
              "<code>&lt;div [style.opacity]=\"alpha\"&gt;&lt;/div&gt;</code>"
            ],
            [
              "Event binding",
              "View ➜ Component",
              "DOM events or child <code>@Output</code>",
              "<code>(event)=\"stmt\"</code>",
              "<code>&lt;input (input)=\"onInput($event)\"&gt;</code>"
            ],
            [
              "Two-way binding",
              "Both",
              "Property + event (banana-in-a-box)",
              "<code>[(x)]=\"expr\"</code>",
              "<code>&lt;input [(ngModel)]=\"name\"&gt;</code>"
            ]
          ],
          "caption": "Angular binding types you’re expected to know in interviews (including attr/class/style prefixes)."
        },
        {
          "type": "text",
          "text": "<strong>Property vs Attribute (common interview trap)</strong><br><br><strong>[disabled]</strong> sets the DOM property (actual runtime behavior). <strong>[attr.disabled]</strong> sets/removes the HTML attribute string. For ARIA and many “string-only” attributes, you typically use <code>[attr.*]</code>. For real element state, use property binding."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<h2>{{ title }}</h2>\n\n<img [src]=\"avatarUrl\" [alt]=\"userName\" />\n\n<button type=\"button\" [disabled]=\"isSaving\" (click)=\"save()\">\n  Save\n</button>\n\n<input\n  [value]=\"query\"\n  (input)=\"query = ($event.target as HTMLInputElement).value\"\n  [attr.aria-label]=\"'Search'\"\n/>\n\n<div [class.error]=\"hasError\" [style.width.px]=\"panelWidth\"></div>"
        },
        {
          "type": "text",
          "text": "<strong>Two-way binding is just sugar</strong><br><br><code>[(x)]</code> expands to <code>[x]</code> + <code>(xChange)</code> for custom components. In forms, <code>[(ngModel)]</code> is provided by template-driven forms (requires importing <code>FormsModule</code>)."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-rating',\n  template: `\n    <button type=\"button\" (click)=\"set(1)\">1</button>\n    <button type=\"button\" (click)=\"set(2)\">2</button>\n    <button type=\"button\" (click)=\"set(3)\">3</button>\n    <span>Current: {{ value }}</span>\n  `\n})\nexport class RatingComponent {\n  @Input() value = 0;\n  @Output() valueChange = new EventEmitter<number>();\n\n  set(v: number) {\n    this.valueChange.emit(v);\n  }\n}\n\n// parent template usage:\n// <app-rating [(value)]=\"rating\"></app-rating>\n// expands to:\n// <app-rating [value]=\"rating\" (valueChange)=\"rating = $event\"></app-rating>"
        },
        {
          "type": "list",
          "columns": [
            "What makes the UI update?",
            "Interview-safe answer"
          ],
          "rows": [
            [
              "User events",
              "Template events run handlers, state changes, then Angular checks affected views."
            ],
            [
              "Async work (HTTP/timers/observables/promises)",
              "Angular typically schedules change detection (Zone-based apps) or you trigger it explicitly in zoneless setups."
            ],
            [
              "Parent input changes",
              "When parent re-renders and updates an input binding, child updates in the next check."
            ]
          ],
          "caption": "Data binding + change detection are inseparable: bindings update during change detection passes."
        },
        {
          "type": "list",
          "columns": [
            "Common pitfall",
            "What goes wrong",
            "Fix"
          ],
          "rows": [
            [
              "Heavy expressions in templates",
              "They run often during change detection and can cause jank",
              "Move work to TS and bind to a field/signal/observable result"
            ],
            [
              "No <code>FormsModule</code> but using <code>[(ngModel)]</code>",
              "Template compile/runtime errors",
              "Import <code>FormsModule</code> (or use Reactive Forms)"
            ],
            [
              "Using attribute binding for real element state",
              "<code>[attr.disabled]</code> doesn’t behave like <code>[disabled]</code> in all cases",
              "Prefer property binding for element state"
            ],
            [
              "Trying to use two-way binding everywhere",
              "Harder to reason about state flow in complex apps",
              "Prefer one-way data flow + explicit events; use two-way mainly for form-like controls"
            ]
          ],
          "caption": "These are the things seniors call out quickly."
        },
        {
          "type": "list",
          "columns": [
            "Summary"
          ],
          "rows": [
            [
              "Data binding connects TS state and HTML templates; Angular syncs the DOM via change detection."
            ],
            [
              "Know the full surface area: interpolation, property, attr/class/style, event, and two-way binding."
            ],
            [
              "Two-way binding is syntactic sugar: <code>[(x)]</code> = <code>[x]</code> + <code>(xChange)</code>."
            ],
            [
              "Interview nuance: property vs attribute binding, and when to use <code>[attr.*]</code>, <code>[class.*]</code>, <code>[style.*]</code>."
            ]
          ]
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "data-binding",
      "templates",
      "basics",
      "components"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Data Binding Explained: One-Way, Events, and Two-Way",
      "description": "Learn interpolation, property/attribute/class/style bindings, event bindings, and two-way patterns so component state and templates stay predictable."
    }
  },
  {
    "id": "angular-interpolation-vs-property-binding",
    "title": "Interpolation vs property binding in Angular: what actually gets updated (text vs DOM property), and what bugs does it prevent?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Explain the practical difference: interpolation ({{ }}) writes strings into text nodes (and can do string attribute interpolation), while property binding ([...]) sets real DOM properties (booleans/numbers/objects) and is the correct choice for element state (disabled, checked, value, src). Include the common interview trap: interpolation in boolean-ish attributes can produce wrong behavior. Property binding avoids string coercion edge cases; test boolean attributes and template performance.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Both are <strong>one-way</strong> bindings (component → view), but they update <strong>different DOM targets</strong>:<br>• <strong>Interpolation</strong> updates <strong>text</strong> (and when used inside attributes, it results in a <strong>string attribute value</strong>).<br>• <strong>Property binding</strong> updates a <strong>DOM property</strong> (real runtime state) and keeps the correct type (boolean/number/object).<br><br>Interview framing: <strong>use interpolation for display text</strong>; <strong>use property binding for element state</strong>."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Interpolation {{ }}",
            "Property binding [ ]"
          ],
          "rows": [
            [
              "What it updates",
              "Text nodes (and string attribute interpolation)",
              "DOM properties (runtime state)"
            ],
            [
              "Type behavior",
              "Always becomes a string",
              "Keeps the real type (boolean/number/object)"
            ],
            [
              "Best for",
              "Displaying values in text",
              "Element state/behavior (disabled, checked, value, src, class/style...)"
            ],
            [
              "Where it can appear",
              "Text content, and inside attribute strings",
              "On a property-like target: [disabled], [value], [src], [class.x], [style.*]"
            ],
            [
              "Common trap",
              "Boolean-ish attributes become strings and can behave “always on”",
              "Correct boolean semantics (true/false)"
            ]
          ],
          "caption": "The difference is not syntax — it’s which DOM target you update."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Interpolation = display text -->\n<h1>Welcome, {{ userName }}!</h1>\n<p>Score: {{ score + 10 }}</p>\n\n<!-- Property binding = real element state -->\n<button type=\"button\" [disabled]=\"isDisabled\">Submit</button>\n<img [src]=\"profileImageUrl\" [alt]=\"userName\" />\n<input [value]=\"query\" (input)=\"query = ($event.target as HTMLInputElement).value\" />"
        },
        {
          "type": "text",
          "text": "<strong>Interview trap: boolean attributes</strong><br><br>HTML boolean attributes behave by <strong>presence</strong>. If you do interpolation inside the attribute, you often end up with a string attribute that’s still “present”, which can be wrong."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ❌ Bug-prone: string attribute interpolation -->\n<!-- disabled=\"false\" still counts as present in many cases -->\n<button disabled=\"{{ isDisabled }}\">Submit</button>\n\n<!-- ✅ Correct: sets the DOM property boolean -->\n<button [disabled]=\"isDisabled\">Submit</button>\n\n<!-- Another common case: form controls -->\n<!-- ❌ Sets attribute string; can desync from actual runtime value -->\n<input value=\"{{ name }}\" />\n\n<!-- ✅ Sets the DOM property (or better: use forms) -->\n<input [value]=\"name\" />"
        },
        {
          "type": "text",
          "text": "<strong>Property vs attribute binding (quick nuance seniors mention)</strong><br><br><strong>[prop]</strong> sets a DOM property (real behavior). <strong>[attr.name]</strong> sets/removes an HTML attribute string. For ARIA and non-property attrs, use <code>[attr.*]</code>."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Real element state: property binding -->\n<button [disabled]=\"loading\">Save</button>\n\n<!-- ARIA: attribute binding -->\n<div [attr.aria-label]=\"label\"></div>\n\n<!-- Class/style are also bindings (properties managed by Angular) -->\n<div [class.active]=\"isActive\" [style.width.px]=\"width\"></div>"
        },
        {
          "type": "list",
          "columns": [
            "Common pitfall",
            "What goes wrong",
            "Fix"
          ],
          "rows": [
            [
              "Using interpolation for element state (disabled/checked/selected)",
              "String attribute semantics cause incorrect behavior",
              "Use property binding: [disabled], [checked], [selected]"
            ],
            [
              "Binding heavy expressions in templates",
              "Runs frequently during change detection; performance/jank risk",
              "Compute in TS (cached field/signal/observable) and bind the result"
            ],
            [
              "Confusing property vs attribute targets",
              "ARIA / non-property attributes don’t work as expected with [prop]",
              "Use [attr.*] for ARIA/attributes; [prop] for state"
            ]
          ],
          "caption": "What interviewers actually probe: correctness + DOM semantics."
        },
        {
          "type": "list",
          "columns": [
            "Summary"
          ],
          "rows": [
            [
              "Interpolation ({{ }}) is for rendering text; it produces strings (and attribute interpolation is still string-based)."
            ],
            [
              "Property binding ([prop]) sets real DOM properties and preserves types; use it for element state (disabled, value, checked, src)."
            ],
            [
              "Know the nuance: [attr.*] is for attributes (especially ARIA); [class.*]/[style.*] are the right tools for styling."
            ]
          ]
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>You need to disable a submit button and bind a numeric input value from component state.<br><br><strong>Common pitfalls</strong><br><ul><li>Using interpolation for boolean attributes, resulting in \"false\" strings.</li><li>Binding strings instead of real DOM properties.</li><li>Inconsistent updates when values are objects or arrays.</li></ul><strong>Trade-off or test tip</strong><br>Property binding is correct for DOM properties. Test by toggling booleans and verifying real DOM values.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "templates",
      "binding",
      "interpolation",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular interpolation vs property binding",
      "description": "Understand what {{ }} interpolation updates versus [prop] binding, how Angular writes text nodes vs DOM properties, and which choice avoids template bugs."
    }
  },
  {
    "id": "angular-event-binding-dom-vs-output-change-detection",
    "title": "How does Angular event binding work (DOM events vs @Output events), and what are the common pitfalls?",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 5,
    "description": "Angular event binding uses the (event) syntax to listen to either native DOM events (click, input, submit, keydown, etc.) or custom events emitted by child components via @Output(). When the event fires, Angular runs the bound template statement/method with access to $event, and (in typical setups) triggers change detection for affected views. Events trigger change detection, so test performance under rapid input and large templates.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>(event)=\"...\"</code> attaches a listener from the template to a template statement (usually a component method). It’s <strong>one-way</strong>: <em>view ➜ component</em>. The event can be a <strong>native DOM event</strong> or a <strong>custom event</strong> emitted by a child component (<code>@Output()</code>)."
        },
        {
          "type": "list",
          "columns": [
            "Event source",
            "Template syntax",
            "What $event is",
            "Typical use"
          ],
          "rows": [
            [
              "Native DOM event",
              "<code>(click)</code>, <code>(input)</code>, <code>(submit)</code>, <code>(keydown)</code>…",
              "A DOM <code>Event</code> / <code>MouseEvent</code> / <code>KeyboardEvent</code>…",
              "User interactions on elements"
            ],
            [
              "Child component @Output",
              "<code>(saved)</code>, <code>(closed)</code>…",
              "Whatever the child <code>emit(...)</code>s",
              "Child ➜ parent communication"
            ]
          ],
          "caption": "DOM events vs component custom events"
        },
        {
          "type": "text",
          "text": "<strong>Basic syntax</strong><br><br>Angular uses parentheses to bind an event name to a handler. Use <code>$event</code> to access the event payload."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<button type=\"button\" (click)=\"inc()\">+</button>\n\n<input\n  type=\"text\"\n  (input)=\"onInput(($event.target as HTMLInputElement).value)\"\n/>\n\n<form (submit)=\"onSubmit($event)\">\n  <button type=\"submit\">Save</button>\n</form>\n\n<!-- key filtering -->\n<input (keyup.enter)=\"save()\" (keydown.escape)=\"cancel()\" />"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-demo',\n  templateUrl: './demo.component.html'\n})\nexport class DemoComponent {\n  count = 0;\n\n  inc(): void {\n    this.count += 1;\n  }\n\n  onInput(value: string): void {\n    // avoid event: any; pass the extracted value\n    console.log('value:', value);\n  }\n\n  onSubmit(e: SubmitEvent): void {\n    e.preventDefault();\n    // submit logic\n  }\n\n  save(): void {}\n  cancel(): void {}\n}"
        },
        {
          "type": "text",
          "text": "<strong>Custom events with @Output()</strong><br><br>Child emits; parent listens with the same <code>(event)</code> syntax. The payload type is whatever you emit (and should be typed)."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, EventEmitter, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `<button type=\"button\" (click)=\"save()\">Save</button>`\n})\nexport class ChildComponent {\n  @Output() saved = new EventEmitter<{ id: string }>();\n\n  save(): void {\n    this.saved.emit({ id: 'u1' });\n  }\n}\n\n// parent.html\n// <app-child (saved)=\"onSaved($event)\"></app-child>\n\n// parent.ts\n// onSaved(payload: { id: string }) { ... }"
        },
        {
          "type": "list",
          "columns": [
            "Interview-grade pitfalls",
            "What goes wrong",
            "Fix"
          ],
          "rows": [
            [
              "Using <code>any</code> for events",
              "You lose type safety and misuse <code>target</code>/<code>key</code> easily",
              "Use concrete types (e.g. <code>KeyboardEvent</code>) and/or pass extracted values"
            ],
            [
              "Heavy logic in template statements",
              "Hard to test/read; can run often and become brittle",
              "Keep templates thin; call a method and do logic in TS"
            ],
            [
              "Forgetting default browser behavior",
              "Forms reload page; links navigate unexpectedly",
              "Use <code>(submit)</code> with <code>preventDefault()</code> or proper button types"
            ],
            [
              "Event propagation surprises",
              "Nested clicks trigger parent handlers unexpectedly",
              "Use <code>$event.stopPropagation()</code> where appropriate (sparingly)"
            ],
            [
              "OnPush expectations",
              "UI doesn’t update when state changes outside Angular awareness",
              "Events in templates normally trigger checks; for external sources use signals/async pipe or <code>markForCheck()</code>"
            ],
            [
              "Using EventEmitter outside @Output",
              "Misused as a general event bus; awkward lifecycle and ownership",
              "Use RxJS Subjects/services for cross-component events; keep EventEmitter for outputs"
            ]
          ],
          "caption": "What seniors mention in interviews"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>(event)</code> binds template events to component logic. For DOM events, <code>$event</code> is a DOM event object; for <code>@Output()</code>, <code>$event</code> is the emitted payload. Keep handlers typed, keep templates thin, and be deliberate about default behaviors and propagation."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A parent listens to a child component's <code>@Output</code> and a native button click in the same template.<br><br><strong>Common pitfalls</strong><br><ul><li>Forgetting to pass or use <code>$event</code>.</li><li>Misnaming outputs and silently missing events.</li><li>Expensive handlers causing performance issues under rapid input.</li></ul><strong>Trade-off or test tip</strong><br>Events trigger change detection. Test with rapid clicks and consider OnPush for performance.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "events",
      "binding",
      "outputs",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Event Binding: DOM Events vs @Output Events",
      "description": "Understand how (event) bindings pass $event, how child @Output emits differ from native events, and why rapid events can trigger costly change detection."
    }
  },
  {
    "id": "angular-directives",
    "title": "Angular directives: structural vs attribute vs components — and what the * syntax really does",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "A directive is a class that Angular attaches to an element (or an &lt;ng-template&gt;) to add behavior, change styling, or control whether a chunk of template exists at all. Interview focus: the 3 directive categories, how structural directives desugar from * syntax into &lt;ng-template&gt;, and how to build safe custom directives (HostBinding/HostListener, Renderer2, TemplateRef/ViewContainerRef). Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>A <strong>directive</strong> is a class that Angular instantiates when it matches a selector in a template. The directive can:<br>• add behavior (listen to events, update host properties)<br>• change styling (classes/styles/attributes)<br>• <strong>control the DOM tree</strong> by creating/destroying embedded views (structural directives)."
        },
        {
          "type": "list",
          "columns": [
            "Category",
            "What it does",
            "How it shows up",
            "Typical examples"
          ],
          "rows": [
            [
              "<strong>Component</strong>",
              "A directive <em>with its own template</em>.",
              "Used as an element/tag.",
              "<code>&lt;app-user-card&gt;</code>"
            ],
            [
              "<strong>Attribute directive</strong>",
              "Changes host element behavior/appearance <em>without</em> changing DOM structure.",
              "Used as an attribute selector.",
              "<code>[ngClass]</code>, <code>[ngStyle]</code>, <code>formControlName</code>"
            ],
            [
              "<strong>Structural directive</strong>",
              "Adds/removes a block of template by creating/destroying an <em>embedded view</em>.",
              "Usually appears with <code>*</code> microsyntax.",
              "<code>*ngIf</code>, <code>*ngFor</code>, <code>*ngSwitchCase</code>"
            ]
          ],
          "caption": "The 3 directive types (components are also directives)"
        },
        {
          "type": "text",
          "text": "<strong>What the <code>*</code> really means (microsyntax)</strong><br><br><code>*</code> is just syntax sugar. Angular rewrites it into an <code>&lt;ng-template&gt;</code> and binds inputs to the directive on that template."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Shorthand -->\n<div *ngIf=\"isAdmin\">Admin</div>\n\n<!-- Rough desugaring -->\n<ng-template [ngIf]=\"isAdmin\">\n  <div>Admin</div>\n</ng-template>\n\n<!-- With else -->\n<div *ngIf=\"isAdmin; else notAdmin\">Admin</div>\n<ng-template #notAdmin>Not admin</ng-template>"
        },
        {
          "type": "list",
          "columns": [
            "Structural directives are special because…",
            "Concrete consequence"
          ],
          "rows": [
            [
              "They operate on <code>TemplateRef</code> + <code>ViewContainerRef</code>",
              "They can create/destroy DOM, component instances, listeners, and run <code>ngOnDestroy</code> on teardown."
            ],
            [
              "Only one <code>*</code> per host element",
              "Because the host becomes an <code>&lt;ng-template&gt;</code>. Use <code>&lt;ng-container&gt;</code> to combine."
            ]
          ],
          "caption": "Interview nuance: * directives change the component tree, not just visibility"
        },
        {
          "type": "text",
          "text": "<strong>Custom attribute directive (typical interview example)</strong><br><br>Use <code>HostBinding</code>/<code>HostListener</code> (or <code>Renderer2</code>) to affect the host. Avoid direct DOM where possible (SSR/testing safety)."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Directive, HostBinding, HostListener, Input } from '@angular/core';\n\n@Directive({\n  selector: '[appHighlight]',\n  standalone: true\n})\nexport class HighlightDirective {\n  @Input() appHighlight = 'yellow';\n\n  @HostBinding('style.backgroundColor') private bg = '';\n\n  @HostListener('mouseenter') onEnter() {\n    this.bg = this.appHighlight;\n  }\n\n  @HostListener('mouseleave') onLeave() {\n    this.bg = '';\n  }\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<p [appHighlight]=\"'gold'\">Hover me</p>"
        },
        {
          "type": "text",
          "text": "<strong>Custom structural directive (the “real” senior signal)</strong><br><br>Structural directives control a <em>template block</em>. They inject <code>TemplateRef</code> (what to render) and <code>ViewContainerRef</code> (where to render)."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';\n\n@Directive({\n  selector: '[appIf]',\n  standalone: true\n})\nexport class AppIfDirective {\n  private hasView = false;\n\n  constructor(\n    private tpl: TemplateRef<unknown>,\n    private vcr: ViewContainerRef\n  ) {}\n\n  @Input() set appIf(condition: boolean) {\n    if (condition && !this.hasView) {\n      this.vcr.createEmbeddedView(this.tpl);\n      this.hasView = true;\n      return;\n    }\n\n    if (!condition && this.hasView) {\n      this.vcr.clear();\n      this.hasView = false;\n    }\n  }\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<div *appIf=\"isVisible\">Visible</div>\n\n<!-- desugars to -->\n<ng-template [appIf]=\"isVisible\">\n  <div>Visible</div>\n</ng-template>"
        },
        {
          "type": "list",
          "columns": [
            "Pitfall",
            "What goes wrong",
            "Better approach"
          ],
          "rows": [
            [
              "Direct DOM mutation in directives",
              "Breaks SSR/testing; can bypass Angular rendering assumptions",
              "Prefer HostBinding/HostListener or Renderer2; keep DOM work minimal"
            ],
            [
              "Using structural directive when you need state preserved",
              "It destroys/recreates component instances (state resets, subscriptions re-run)",
              "Use <code>[hidden]</code>/CSS when you must keep the instance alive"
            ],
            [
              "Multiple <code>*</code> on one element",
              "Template rewrite conflict",
              "Wrap with <code>&lt;ng-container&gt;</code> or split elements"
            ],
            [
              "Heavy work in directives without OnPush-friendly patterns",
              "Unnecessary change detection / jank in large views",
              "Keep directives small; push heavy logic to services/facades; use async/signal patterns"
            ]
          ],
          "caption": "Common directive mistakes interviewers see"
        },
        {
          "type": "list",
          "columns": [
            "Interview one-liners to say"
          ],
          "rows": [
            [
              "“Components are directives with templates; attribute directives modify the host; structural directives create/destroy embedded views.”"
            ],
            [
              "“The * is syntax sugar for <ng-template> + directive inputs.”"
            ],
            [
              "“Structural directives use TemplateRef and ViewContainerRef to manage embedded views.”"
            ],
            [
              "“Prefer HostBinding/HostListener (or Renderer2) over direct DOM access.”"
            ]
          ]
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Directives are Angular’s way to attach behavior to templates. Attribute directives change an existing element; structural directives change the rendered tree by creating/destroying embedded views; components are directives with templates. The key senior detail: <code>*</code> desugars into <code>&lt;ng-template&gt;</code>, and structural directives are basically <code>TemplateRef</code> + <code>ViewContainerRef</code> orchestration."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "directives",
      "templates",
      "basics",
      "components"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Directives Explained: Structural, Attribute, and * Syntax",
      "description": "Learn the three directive types, how * syntax desugars to ng-template, and when to use HostBinding/HostListener or TemplateRef/ViewContainerRef APIs."
    }
  },
  {
    "id": "angular-structural-vs-attribute-directives",
    "title": "Structural vs Attribute Directives in Angular: what changes the DOM tree (and what does * actually mean)?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Structural directives change the rendered template tree by creating/destroying embedded views (real DOM + component instances). Attribute directives do not change the tree; they modify an existing element’s properties/classes/styles/behavior. Key interview nuance: the * syntax is just sugar for &lt;ng-template&gt; + directive inputs. Structural directives change the DOM tree, so test lifecycle, performance, and accessibility side effects.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><strong>Structural</strong> directives decide whether a block of template exists at all (create/destroy an embedded view). <strong>Attribute</strong> directives keep the element in place and only change the host element’s behavior/appearance (classes/styles/attrs/listeners)."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Structural directives",
            "Attribute directives"
          ],
          "rows": [
            [
              "What they change",
              "The <em>template structure</em> (create/destroy/move embedded views).",
              "The <em>host element</em> (styles/classes/attributes/behavior)."
            ],
            [
              "DOM impact",
              "✅ Real DOM nodes and component/directive instances are created/destroyed.",
              "❌ No tree changes; the same element stays in the DOM."
            ],
            [
              "Typical syntax",
              "<code>*ngIf</code>, <code>*ngFor</code>, <code>*ngSwitchCase</code> (microsyntax).",
              "<code>[ngClass]</code>, <code>[ngStyle]</code>, <code>[class.x]</code>, custom attribute directives."
            ],
            [
              "How it works internally",
              "Uses <code>TemplateRef</code> + <code>ViewContainerRef</code> to manage <em>embedded views</em>.",
              "Uses <code>HostBinding</code>/<code>HostListener</code> (or <code>Renderer2</code>) to affect the host."
            ],
            [
              "Lifecycle/state implication",
              "Destroying the view runs <code>ngOnDestroy</code> and resets component state on next show.",
              "State is preserved because the instance isn’t destroyed."
            ]
          ],
          "caption": "Structural vs attribute directives (interview framing)"
        },
        {
          "type": "text",
          "text": "<strong>The <code>*</code> is syntax sugar</strong><br><br>Angular rewrites <code>*</code> into an <code>&lt;ng-template&gt;</code> and attaches the directive there. That’s why structural directives operate on templates (not “just visibility”)."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Shorthand -->\n<div *ngIf=\"isAdmin\">Admin</div>\n\n<!-- Rough desugaring -->\n<ng-template [ngIf]=\"isAdmin\">\n  <div>Admin</div>\n</ng-template>\n\n<!-- Combining multiple conditions: use ng-container -->\n<ng-container *ngIf=\"isAdmin\">\n  <div *ngFor=\"let item of items\">{{ item }}</div>\n</ng-container>"
        },
        {
          "type": "text",
          "text": "<strong>Attribute directive example (preferred pattern)</strong><br><br>Attribute directives typically bind to the host element instead of imperatively touching the DOM."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Directive, HostBinding, HostListener, Input } from '@angular/core';\n\n@Directive({\n  selector: '[appHighlight]',\n  standalone: true\n})\nexport class HighlightDirective {\n  @Input() appHighlight = 'gold';\n\n  @HostBinding('style.backgroundColor') private bg = '';\n\n  @HostListener('mouseenter') onEnter() { this.bg = this.appHighlight; }\n  @HostListener('mouseleave') onLeave() { this.bg = ''; }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Structural directive example (what seniors mention)</strong><br><br>Structural directives render a <em>template block</em> by creating/destroying an embedded view via <code>ViewContainerRef</code>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';\n\n@Directive({\n  selector: '[appIf]',\n  standalone: true\n})\nexport class AppIfDirective {\n  private hasView = false;\n\n  constructor(\n    private tpl: TemplateRef<unknown>,\n    private vcr: ViewContainerRef\n  ) {}\n\n  @Input() set appIf(condition: boolean) {\n    if (condition && !this.hasView) {\n      this.vcr.createEmbeddedView(this.tpl);\n      this.hasView = true;\n      return;\n    }\n\n    if (!condition && this.hasView) {\n      this.vcr.clear();\n      this.hasView = false;\n    }\n  }\n}\n\n// usage: <div *appIf=\"isVisible\">...</div>"
        },
        {
          "type": "list",
          "columns": [
            "Gotcha",
            "What happens",
            "What to do instead"
          ],
          "rows": [
            [
              "“*ngIf just hides it”",
              "False: it destroys/creates the view (state resets, subscriptions re-run).",
              "Use <code>[hidden]</code> / CSS when you must preserve instance state."
            ],
            [
              "Multiple <code>*</code> on one element",
              "Only one structural directive can own the host rewrite to <code>&lt;ng-template&gt;</code>.",
              "Wrap with <code>&lt;ng-container&gt;</code> or split elements."
            ],
            [
              "Direct DOM access in directives",
              "Can break SSR/testing and bypass Angular abstractions.",
              "Prefer <code>HostBinding</code>/<code>HostListener</code> or <code>Renderer2</code> if needed."
            ]
          ],
          "caption": "Common interview pitfalls"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><strong>Structural</strong> directives change the rendered tree by creating/destroying embedded views (real lifecycle + state effects). <strong>Attribute</strong> directives keep the tree and modify the host element’s behavior/appearance. The <code>*</code> is just sugar for <code>&lt;ng-template&gt;</code> + directive inputs—knowing that is the senior signal."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Use <code>*ngIf</code> to conditionally render a panel and <code>[ngClass]</code> to style it.<br><br><strong>Common pitfalls</strong><br><ul><li>Assuming structural directives only hide elements (they remove them).</li><li>Losing component state when DOM nodes are destroyed.</li><li>Overusing <code>*ngIf</code> for show/hide instead of <code>[hidden]</code>.</li></ul><strong>Trade-off or test tip</strong><br>Structural directives save work but reset state. Test with toggling and lifecycle hooks.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "directives",
      "structural",
      "attribute",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Structural vs Attribute Directives in Angular",
      "description": "See how structural directives create/destroy views while attribute directives modify elements, and what * syntax means for lifecycle and DOM updates."
    }
  },
  {
    "id": "angular-ngif-dom-lifecycle",
    "title": "How does *ngIf affect the DOM and component lifecycle?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "*ngIf is a structural directive that conditionally creates and destroys an embedded view. That means DOM nodes, component instances, directives, listeners, and template bindings inside the *ngIf block are actually created when the condition becomes true and destroyed when it becomes false.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>*ngIf</code> does not “hide” elements. It <strong>adds/removes</strong> a chunk of template by creating/destroying an <em>embedded view</em> (<code>EmbeddedViewRef</code>) in a <code>ViewContainerRef</code>. When the view is removed, Angular destroys everything inside it (components, directives, pipes, listeners) and runs <code>ngOnDestroy</code>."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Shorthand -->\n<app-child *ngIf=\"show\"></app-child>\n\n<!-- Roughly equivalent to -->\n<ng-template [ngIf]=\"show\">\n  <app-child></app-child>\n</ng-template>"
        },
        {
          "type": "list",
          "columns": [
            "When condition flips",
            "DOM result",
            "Instance result",
            "Lifecycle impact"
          ],
          "rows": [
            [
              "false → true",
              "Nodes are inserted into the DOM",
              "New component/directive instances are created",
              "constructor → (ngOnChanges) → ngOnInit → view/content hooks"
            ],
            [
              "true → false",
              "Nodes are removed from the DOM",
              "Instances are destroyed",
              "ngOnDestroy runs; subscriptions/cleanup should happen here"
            ],
            [
              "true → true (condition stays true)",
              "DOM stays",
              "Same instances stay",
              "Normal change detection updates bindings"
            ]
          ],
          "caption": "What *ngIf actually changes"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// child.component.ts\nimport { Component, OnDestroy, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `Child is alive`\n})\nexport class ChildComponent implements OnInit, OnDestroy {\n  constructor() {\n    console.log('child: constructor');\n  }\n\n  ngOnInit(): void {\n    console.log('child: ngOnInit');\n  }\n\n  ngOnDestroy(): void {\n    console.log('child: ngOnDestroy');\n  }\n}\n\n// parent template\n// <button (click)=\"show = !show\">toggle</button>\n// <app-child *ngIf=\"show\"></app-child>"
        },
        {
          "type": "list",
          "columns": [
            "Topic",
            "*ngIf behavior",
            "Practical consequence"
          ],
          "rows": [
            [
              "Component state",
              "Reset on every re-create",
              "Local fields, form state, and child component state are lost on hide/show"
            ],
            [
              "Subscriptions/listeners",
              "Destroyed view stops emitting into template",
              "If you subscribe manually, you must unsubscribe in ngOnDestroy (or use async pipe / takeUntilDestroyed)"
            ],
            [
              "DI scope",
              "Component-level providers are torn down with the view",
              "A service provided in the component gets a fresh instance on next show"
            ],
            [
              "View queries",
              "ViewChild/ContentChild inside the block disappear",
              "References become undefined when view is destroyed; guard access"
            ],
            [
              "Change detection cost",
              "Removed subtree is not checked",
              "Hiding heavy UI with *ngIf can reduce CD + DOM updates"
            ]
          ],
          "caption": "Key implications interviewers care about"
        },
        {
          "type": "list",
          "columns": [
            "Technique",
            "Does it remove from DOM?",
            "Does it destroy component instances?",
            "When to prefer"
          ],
          "rows": [
            [
              "*ngIf",
              "Yes",
              "Yes",
              "When you want real teardown (free resources, remove listeners, skip CD)"
            ],
            [
              "[hidden] / CSS (display:none)",
              "No",
              "No",
              "When you need to preserve state and avoid re-creation cost"
            ],
            [
              "ng-container + else template",
              "Same as *ngIf",
              "Same as *ngIf",
              "When you want clean conditional branching without extra wrapper DOM"
            ]
          ],
          "caption": "*ngIf vs hiding"
        },
        {
          "type": "list",
          "columns": [
            "Common gotcha",
            "What happens",
            "Fix"
          ],
          "rows": [
            [
              "Toggling a form with *ngIf",
              "User input resets on every hide/show",
              "Use [hidden] if you must preserve state, or persist the form model outside the child"
            ],
            [
              "Expensive init in ngOnInit",
              "Runs every time the view is recreated",
              "Cache in a service/facade, or keep component alive and just hide it"
            ],
            [
              "Memory leaks",
              "Manual subscriptions keep running if not cleaned up",
              "Use async pipe, takeUntilDestroyed(), or ngOnDestroy cleanup"
            ]
          ],
          "caption": "Practical pitfalls"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>*ngIf</code> creates/destroys an embedded view. True = build DOM + instantiate components/directives and run init hooks. False = remove DOM + destroy instances and run <code>ngOnDestroy</code>. Use it when you want real teardown and to skip change detection for that subtree; use hiding when you need to keep state alive."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "directives",
      "ngif",
      "lifecycle",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular *ngIf and DOM lifecycle behavior",
      "description": "Understand how *ngIf creates and destroys views, what happens to component instances and subscriptions, and how it differs from merely hiding elements."
    }
  },
  {
    "id": "angular-ngfor-trackby",
    "title": "Why is trackBy important in *ngFor, and what breaks without it?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "trackBy tells Angular how to uniquely identify items in an *ngFor list so it can reuse existing DOM nodes and component instances when the array changes. Without it (or with a bad trackBy), Angular may destroy and recreate rows unnecessarily, which hurts performance and can reset UI state like input values, focus, and child component state. TrackBy preserves DOM state and performance; test with reorders and large lists.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>*ngFor</code> maintains a list of embedded views (DOM + directives + child components). <code>trackBy</code> defines each item's identity so Angular can do efficient diffs: <strong>move/update</strong> existing views instead of <strong>destroy/recreate</strong> them."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<ul>\n  <li *ngFor=\"let user of users; trackBy: trackByUserId\">\n    <app-user-row [user]=\"user\"></app-user-row>\n  </li>\n</ul>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "type User = { id: string; name: string };\n\nexport class UsersComponent {\n  users: User[] = [\n    { id: 'u1', name: 'Ada' },\n    { id: 'u2', name: 'Linus' }\n  ];\n\n  trackByUserId(index: number, user: User): string {\n    return user.id;\n  }\n\n  // Common real-world cause of problems: new object references on refresh\n  refreshFromApiLike(): void {\n    // Same ids, but NEW objects => without trackBy, Angular treats them as new items\n    this.users = this.users.map(u => ({ ...u }));\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "What trackBy controls",
            "What Angular can do",
            "Why it matters"
          ],
          "rows": [
            [
              "Item identity",
              "Match old items to new items across changes",
              "Prevents treating “same logical item” as a brand-new row"
            ],
            [
              "DOM reuse",
              "Reuse existing DOM nodes and directives",
              "Avoids heavy DOM churn and layout/repaint work"
            ],
            [
              "Component instance reuse",
              "Keep child component instances for the same logical item",
              "Preserves child state and avoids repeated ngOnInit/ngOnDestroy"
            ],
            [
              "Row movement",
              "Move existing views when sorting/reordering",
              "Keeps UI stable instead of flickering or re-initializing"
            ]
          ],
          "caption": "trackBy lets Angular perform a stable, minimal update of the rendered list"
        },
        {
          "type": "list",
          "columns": [
            "Without trackBy (or with unstable identity)",
            "What breaks / degrades",
            "Typical symptom"
          ],
          "rows": [
            [
              "Array recreated with new object references",
              "Rows are destroyed + recreated even if ids are the same",
              "Inputs reset, focus/caret jumps, child state resets"
            ],
            [
              "Expensive child rows (components, heavy templates)",
              "More DOM work + more lifecycle work",
              "Scroll jank, CPU spikes, visible flicker on updates"
            ],
            [
              "UI state stored in the DOM (focus, selection, <input> value while typing)",
              "DOM state is lost on re-create",
              "User is typing and the caret jumps / typed text disappears"
            ],
            [
              "3rd-party widgets inside rows (charts, editors)",
              "Widgets get torn down and rebuilt",
              "Re-initialization costs + lost internal widget state"
            ],
            [
              "Bad trackBy (random, Date.now, returning a new object)",
              "Identity changes every check => Angular rebuilds everything",
              "Worst-case: every CD cycle behaves like a full rerender"
            ]
          ],
          "caption": "Most “trackBy bugs” show up when you refresh data or rebuild arrays (common with immutability patterns)"
        },
        {
          "type": "list",
          "columns": [
            "TrackBy choice",
            "When it's correct",
            "When it causes bugs"
          ],
          "rows": [
            [
              "Stable unique id (recommended)",
              "Items have a real unique key (id, uuid, slug)",
              "Rarely; only if the id is not actually unique/stable"
            ],
            [
              "Composite key (e.g., `${type}:${id}`)",
              "Multiple item types share the same id space",
              "If any part of the composite can change over time"
            ],
            [
              "Value itself (primitives)",
              "List is strings/numbers and values are unique/stable",
              "If values can repeat (duplicates) => identity collisions"
            ],
            [
              "Index (avoid unless list is static)",
              "List never reorders/inserts/removes, only updates values in-place",
              "On insert/reorder, state sticks to the wrong row (wrong input value on wrong item)"
            ]
          ],
          "caption": "Key rule: identity must represent the logical item, not its current position"
        },
        {
          "type": "text",
          "text": "<strong>Extra note</strong><br><br>Modern Angular also has <code>@for</code> with a <code>track</code> expression (same concept): <code>@for (user of users; track user.id) { ... }</code>. The principle is identical: stable identity => stable DOM + preserved state."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>trackBy</code> is important because it gives Angular a stable key per item so it can reuse and move existing rows instead of recreating them. Without it (especially when data refresh creates new object references), you pay in performance and you lose UI state (inputs, focus, child component state). Use a stable unique id; avoid index unless the list is truly static."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A table with editable rows should preserve input focus when new data arrives from the server.<br><br><strong>Common pitfalls</strong><br><ul><li>Using index as trackBy, which breaks on reorders.</li><li>Returning non-unique ids, causing UI glitches.</li><li>Skipping trackBy and forcing full DOM re-creation.</li></ul><strong>Trade-off or test tip</strong><br>TrackBy improves performance but requires stable ids. Test by reordering and verifying focus retention.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "directives",
      "ngfor",
      "performance",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular *ngFor trackBy: Why It Matters for Performance",
      "description": "Understand how trackBy preserves DOM nodes and component state during list updates, and what breaks when keys are unstable, missing, or index-based."
    }
  },
  {
    "id": "angular-services",
    "title": "What is an Angular service, how does DI provide it (providedIn/providers), and why do teams use services?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "In Angular, a “service” is just a class that becomes useful when it’s provided through Angular’s dependency injection (DI). Services are used to centralize reusable logic and side effects (HTTP, caching, orchestration, shared state) so components stay focused on UI + event wiring. Service scope is controlled by where you provide it (root/module/component), which determines lifetime and instance sharing.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>An Angular <strong>service</strong> is typically a plain TypeScript class that you register with Angular’s <strong>dependency injection</strong> system. DI creates the instance and injects it where needed. The value is not the class itself — it’s the <strong>lifetime + sharing + testability</strong> you get from DI and a clean separation from UI code."
        },
        {
          "type": "list",
          "columns": [
            "What it is",
            "What it is NOT"
          ],
          "rows": [
            [
              "A DI-provided class used by components/directives/other services",
              "A special Angular-only construct (it’s still “just a class”)"
            ],
            [
              "A place for reusable logic + side effects (HTTP, caching, orchestration)",
              "A place for DOM manipulation (that belongs in components/directives)"
            ],
            [
              "A unit that’s easy to mock in tests",
              "A global mutable “god object” used everywhere without boundaries"
            ]
          ],
          "caption": "Interview framing: define service via DI + responsibilities"
        },
        {
          "type": "text",
          "text": "<strong>Why teams use services</strong><br><br>To keep components thin and predictable: components render + translate UI events into intent; services own reusable logic and side effects. This improves <strong>reuse</strong>, <strong>testability</strong>, and <strong>maintainability</strong> in large apps."
        },
        {
          "type": "list",
          "columns": [
            "Typical responsibility",
            "Why it belongs in a service"
          ],
          "rows": [
            [
              "HTTP/data access (repositories)",
              "Centralizes endpoints, retries, error mapping, DTO→domain mapping"
            ],
            [
              "Caching + request de-duplication",
              "Prevents duplicate calls across multiple consumers"
            ],
            [
              "Cross-component state (facade/store wrapper)",
              "Makes sharing state explicit; reduces tight coupling between components"
            ],
            [
              "Business rules / normalization",
              "One source of truth; easier to unit test than template/component code"
            ],
            [
              "App orchestration (multi-step flows)",
              "Keeps complex flows out of UI layer; promotes clean boundaries"
            ]
          ],
          "caption": "What interviewers expect: services for side effects + shared logic"
        },
        {
          "type": "text",
          "text": "<strong>How a service gets an instance: providers and scope</strong><br><br>Service lifetime is determined by <strong>where it’s provided</strong>. Angular DI is hierarchical: child injectors can override parent providers."
        },
        {
          "type": "list",
          "columns": [
            "Provide it where",
            "Instance lifetime",
            "When to use"
          ],
          "rows": [
            [
              "<code>@Injectable({ providedIn: 'root' })</code>",
              "Singleton for the app (tree-shakeable provider)",
              "Most services (API clients, facades, shared utilities)"
            ],
            [
              "Feature/module providers (module-based apps)",
              "Usually singleton per module injector (depending on module loading)",
              "Legacy module setups; some library patterns"
            ],
            [
              "Component <code>providers: [...]</code>",
              "New instance per component instance (and its subtree)",
              "Per-screen/wizard state that must reset when component is destroyed"
            ]
          ],
          "caption": "Scope is an interview hot-spot: root vs component providers"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, catchError, map, of, shareReplay } from 'rxjs';\n\ntype UserDto = { id: string; name: string };\nexport type User = { id: string; displayName: string };\n\n@Injectable({ providedIn: 'root' })\nexport class UsersService {\n  private readonly apiUrl = '/api/users';\n  private users$?: Observable<User[]>;\n\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Cache + dedupe: multiple subscribers share one request.\n   * If you need refresh, expose an explicit invalidation method.\n   */\n  getUsers(): Observable<User[]> {\n    this.users$ ??= this.http.get<UserDto[]>(this.apiUrl).pipe(\n      map(dtos => dtos.map(d => ({ id: d.id, displayName: d.name })) as User),\n      // In real apps, prefer a typed error strategy (domain errors) over swallowing.\n      catchError(() => of([])),\n      shareReplay({ bufferSize: 1, refCount: true })\n    );\n\n    return this.users$;\n  }\n\n  invalidateUsersCache(): void {\n    this.users$ = undefined;\n  }\n}"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { ChangeDetectionStrategy, Component, inject } from '@angular/core';\nimport { AsyncPipe, NgFor } from '@angular/common';\nimport { UsersService } from './users.service';\n\n@Component({\n  selector: 'app-users',\n  standalone: true,\n  imports: [NgFor, AsyncPipe],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <button type=\"button\" (click)=\"refresh()\">Refresh</button>\n\n    <ul>\n      <li *ngFor=\"let u of (users$ | async)\">\n        {{ u.displayName }}\n      </li>\n    </ul>\n  `\n})\nexport class UsersComponent {\n  private readonly usersService = inject(UsersService);\n  readonly users$ = this.usersService.getUsers();\n\n  refresh(): void {\n    this.usersService.invalidateUsersCache();\n    // reassign stream (simple pattern); in larger apps use a facade/store.\n    (this as any).users$ = this.usersService.getUsers();\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Component-scoped service example (per-instance state)</strong><br><br>If you need state that resets when a component is destroyed (wizard/session), provide the service at the component level."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class WizardStateService {\n  step = 1;\n  data: Record<string, unknown> = {};\n\n  reset(): void {\n    this.step = 1;\n    this.data = {};\n  }\n}\n\n// component.ts\n// @Component({\n//   ...\n//   providers: [WizardStateService]\n// })\n// export class CheckoutWizardComponent {\n//   constructor(public wizard: WizardStateService) {}\n// }"
        },
        {
          "type": "list",
          "columns": [
            "Common pitfall",
            "What breaks",
            "Fix"
          ],
          "rows": [
            [
              "Putting HttpClient calls in components",
              "Duplicated logic, harder tests, messy lifecycles",
              "Move data access + mapping + error policy into a service/facade"
            ],
            [
              "Using a root singleton as a dumping ground for random mutable state",
              "Hidden coupling and hard-to-debug state leaks across screens",
              "Keep state ownership explicit (facade/store); use component-scoped services for per-screen state"
            ],
            [
              "Services touching DOM directly",
              "SSR/testing issues; breaks separation of concerns",
              "DOM work belongs in components/directives (Renderer2 if needed)"
            ],
            [
              "Subjects never completed / manual subscriptions everywhere",
              "Leaks and unpredictable behavior",
              "Prefer <code>async</code> pipe, <code>takeUntilDestroyed()</code>, or centralized streams in facades"
            ]
          ],
          "caption": "Pitfalls seniors mention quickly"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Angular services are DI-provided classes used to centralize reusable logic and side effects. The key interview points are: <strong>(1)</strong> services are “just classes” + DI providers, <strong>(2)</strong> scope/lifetime depends on where you provide them (root vs component), and <strong>(3)</strong> services keep components focused on UI, improving reuse and testability."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "services",
      "dependency-injection",
      "architecture",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Services and DI: providedIn, providers, and Scope",
      "description": "Learn what an Angular service should own, how DI scope changes instance lifetime, and when to provide in root, route, module, or component."
    }
  },
  {
    "id": "angular-dependency-injection",
    "title": "What is dependency injection in Angular?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Angular dependency injection (DI) is the framework mechanism that creates and supplies dependencies (services/config/values) to classes (components, directives, pipes, other services) based on providers. Instead of constructing dependencies manually, you register providers (how to build a value for a token) and Angular resolves them through a hierarchical injector tree. Interview focus: provider configuration, token types (class vs InjectionToken), scoping/lifetime (root vs component), and common pitfalls (multiple instances, circular deps, Optional/Self/SkipSelf). DI affects testability and architecture; test with mocks and scope providers carefully.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>DI is how Angular <strong>finds</strong> and <strong>creates</strong> what your class needs. You request a dependency by token (usually a class), and Angular returns an instance/value based on the closest matching <strong>provider</strong> in the injector hierarchy."
        },
        {
          "type": "list",
          "columns": [
            "Term",
            "What it is",
            "What interviewers expect you to say"
          ],
          "rows": [
            [
              "<strong>Token</strong>",
              "The lookup key for a dependency (class type or <code>InjectionToken</code>).",
              "“Angular resolves dependencies by token; classes are tokens, but for primitives/objects you use <code>InjectionToken</code>.”"
            ],
            [
              "<strong>Provider</strong>",
              "A rule that tells Angular how to produce a value for a token (<code>useClass/useValue/useFactory/useExisting</code>).",
              "“Providers map token → value/instance creation strategy.”"
            ],
            [
              "<strong>Injector</strong>",
              "A container that holds providers and can resolve tokens. Injectors form a tree.",
              "“Resolution walks up the injector tree; the closest provider wins.”"
            ],
            [
              "<strong>Scope / lifetime</strong>",
              "Where the provider is registered determines whether you get one shared instance or many.",
              "“Root providers are app-singletons; component providers create per-component instances.”"
            ]
          ],
          "caption": "DI vocabulary (the minimum you should be fluent with)"
        },
        {
          "type": "text",
          "text": "<strong>How resolution works (hierarchical)</strong><br><br>When Angular needs a dependency, it checks the current injector (e.g., component injector), and if not found it walks up to parent injectors until it finds a provider. If multiple levels provide the same token, the <strong>nearest</strong> one is used."
        },
        {
          "type": "list",
          "columns": [
            "Where you provide",
            "Instance behavior",
            "Typical use"
          ],
          "rows": [
            [
              "<code>@Injectable({ providedIn: 'root' })</code>",
              "One instance for the whole app (tree-shakeable).",
              "Most services (API clients, facades, shared utilities)."
            ],
            [
              "<code>providers: [...]</code> on a component",
              "New instance per component instance (and its subtree).",
              "Per-screen/wizard state that must reset on destroy."
            ],
            [
              "Route/environment providers (standalone bootstrap)",
              "Scoped to an environment injector (app-wide or route subtree).",
              "App configuration + feature-level provider scoping in standalone apps."
            ]
          ],
          "caption": "Scope/lifetime is a top Angular interview hotspot"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, Injectable, inject } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nexport class UsersService {\n  getUsers() { return ['Ada', 'Linus']; }\n}\n\n@Component({\n  selector: 'app-users',\n  standalone: true,\n  template: `{{ users.join(', ') }}`\n})\nexport class UsersComponent {\n  // Option A: constructor injection\n  // constructor(private usersService: UsersService) {}\n\n  // Option B: inject() (same timing category as constructor)\n  private readonly usersService = inject(UsersService);\n\n  users = this.usersService.getUsers();\n}"
        },
        {
          "type": "text",
          "text": "<strong>Providers: the 4 shapes you must know</strong><br><br>These are the practical knobs that control what DI returns for a token."
        },
        {
          "type": "list",
          "columns": [
            "Provider type",
            "What it does",
            "When to use"
          ],
          "rows": [
            [
              "<code>useClass</code>",
              "Instantiate a class when the token is requested.",
              "Swap implementations (e.g., mock vs real)."
            ],
            [
              "<code>useValue</code>",
              "Return a constant value/object.",
              "Config objects, feature flags, small immutable values."
            ],
            [
              "<code>useFactory</code>",
              "Call a factory function (can depend on other injections).",
              "Computed config, environment-dependent setup."
            ],
            [
              "<code>useExisting</code>",
              "Alias one token to another (same instance).",
              "Expose one implementation under multiple tokens."
            ]
          ],
          "caption": "Provider shapes"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { InjectionToken } from '@angular/core';\n\nexport type AppConfig = { apiBaseUrl: string };\nexport const APP_CONFIG = new InjectionToken<AppConfig>('APP_CONFIG');\n\n// Example provider (standalone bootstrap or module providers)\n// { provide: APP_CONFIG, useValue: { apiBaseUrl: '/api' } }\n"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, Inject, Injectable } from '@angular/core';\nimport { APP_CONFIG, AppConfig } from './app-config.token';\n\n@Injectable({ providedIn: 'root' })\nexport class ApiClient {\n  constructor(@Inject(APP_CONFIG) private cfg: AppConfig) {}\n\n  url(path: string) {\n    return `${this.cfg.apiBaseUrl}${path}`;\n  }\n}\n\n@Component({\n  selector: 'app-demo',\n  standalone: true,\n  template: `...`,\n  providers: [\n    { provide: APP_CONFIG, useValue: { apiBaseUrl: '/v2' } }\n  ]\n})\nexport class DemoComponent {\n  constructor(public api: ApiClient) {}\n}"
        },
        {
          "type": "text",
          "text": "<strong>Multi providers (common in real apps)</strong><br><br>Some tokens accept multiple values. Angular collects them into an array when <code>multi: true</code> is used (classic example: HTTP interceptors)."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { HTTP_INTERCEPTORS, HttpInterceptorFn } from '@angular/common/http';\n\nexport const authInterceptor: HttpInterceptorFn = (req, next) => {\n  const authReq = req.clone({ setHeaders: { Authorization: 'Bearer token' } });\n  return next(authReq);\n};\n\n// provider\n// { provide: HTTP_INTERCEPTORS, useValue: authInterceptor, multi: true }\n"
        },
        {
          "type": "list",
          "columns": [
            "Common pitfall",
            "Symptom",
            "Fix"
          ],
          "rows": [
            [
              "Accidentally creating multiple instances",
              "Stateful service resets unexpectedly or differs between components.",
              "Understand scope: root vs component providers; avoid providing the same service at many component levels unless you want per-instance state."
            ],
            [
              "Using the wrong token for non-classes",
              "Runtime DI error: “No provider for X” (or injecting <code>string</code>/<code>Object</code> doesn’t work).",
              "Use <code>InjectionToken</code> for primitives/config and inject via <code>@Inject(TOKEN)</code>."
            ],
            [
              "Circular dependencies",
              "Runtime error or partially-initialized services.",
              "Refactor responsibilities; extract shared logic; consider factory indirection only as a last resort."
            ],
            [
              "Optional dependency not marked",
              "DI throws when provider is absent.",
              "Use <code>@Optional()</code> (or provide a default via factory/value)."
            ],
            [
              "Resolution surprises in a hierarchy",
              "You think you’re getting the root singleton, but a child injector overrides it.",
              "Know “closest provider wins”; use <code>@SkipSelf()</code>/<code>@Self()</code> intentionally when needed."
            ]
          ],
          "caption": "Pitfalls seniors mention quickly"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Angular DI resolves dependencies by <strong>token</strong> using <strong>providers</strong> in a <strong>hierarchical injector tree</strong> (closest provider wins). Providers define how to create a value (<code>useClass</code>/<code>useValue</code>/<code>useFactory</code>/<code>useExisting</code>). Where you provide controls lifetime (root singleton vs component-scoped). For non-class deps use <code>InjectionToken</code>. Multi providers collect values into arrays (e.g., interceptors). Common pitfalls are accidental multiple instances, wrong tokens, and circular deps."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Inject a logging service and an API client across multiple features, then swap a mock in tests.<br><br><strong>Common pitfalls</strong><br><ul><li>Providing a service at the wrong level and creating extra instances.</li><li>Circular dependencies causing runtime errors.</li><li>Hard-coding dependencies that make testing hard.</li></ul><strong>Trade-off or test tip</strong><br>DI improves testability but needs clear provider scope. Test with mocks and verify singleton behavior.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "dependency-injection",
      "services",
      "architecture",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Dependency Injection Explained: Providers, Tokens, Scope",
      "description": "Learn how Angular DI resolves providers in the injector hierarchy, when to provide in root or component scope, and how to prevent duplicate instances."
    }
  },
  {
    "id": "angular-ngoninit-vs-constructor",
    "title": "Constructor vs ngOnInit(): DI timing, @Input timing, and what belongs where",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Constructor runs when the class instance is created (mainly for DI + trivial field setup). ngOnInit() runs once after Angular has set initial @Input() bindings (after the first ngOnChanges). Put Angular-dependent initialization (inputs, data streams, side effects) in ngOnInit, not in the constructor. Covers: angular, lifecycle, hooks, components, basics.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>constructor</code> is a TypeScript/class instantiation step (good for dependency injection + trivial setup). <code>ngOnInit()</code> is an Angular lifecycle hook (good for initialization that depends on Angular bindings like <code>@Input()</code>, and for starting side effects like data loading)."
        },
        {
          "type": "list",
          "columns": [
            "Runs when",
            "Typical first-render order"
          ],
          "rows": [
            [
              "Component creation",
              "<code>constructor → ngOnChanges? → ngOnInit → ngAfterViewInit</code>"
            ]
          ],
          "caption": "Constructor is earliest; ngOnInit happens after the first input binding pass."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "constructor",
            "ngOnInit()"
          ],
          "rows": [
            [
              "Who calls it?",
              "TypeScript runtime (class instantiation)",
              "Angular (lifecycle hook)"
            ],
            [
              "Dependency injection",
              "✅ Yes (primary use)",
              "✅ Yes (DI already done)"
            ],
            [
              "@Input() values available?",
              "❌ Not reliably (bindings not applied yet)",
              "✅ Yes (initial bindings are applied)"
            ],
            [
              "Good for",
              "Assigning injected services to fields; lightweight defaults",
              "Starting streams, fetching data, initializing based on inputs, wiring subscriptions"
            ],
            [
              "Avoid",
              "Heavy work, subscriptions, API calls, reading inputs, touching DOM/ViewChild",
              "Direct DOM/ViewChild access (usually use <code>ngAfterViewInit</code>)"
            ]
          ],
          "caption": "What belongs where (interview version)"
        },
        {
          "type": "text",
          "text": "<strong>Why interviewers care</strong><br><br>Putting side effects in the constructor makes component instantiation do \"real work\" before Angular finishes binding and before tests can set up spies. Putting Angular-dependent logic in <code>ngOnInit</code> is predictable: bindings are ready, and in tests it usually runs on <code>fixture.detectChanges()</code>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, Input, OnChanges, OnInit, SimpleChanges } from '@angular/core';\n\n@Component({\n  selector: 'app-user',\n  template: `User id: {{ userId }}`\n})\nexport class UserComponent implements OnChanges, OnInit {\n  @Input() userId!: string;\n\n  constructor() {\n    // At this point Angular hasn't applied @Input bindings yet.\n    console.log('constructor userId =', this.userId); // often undefined\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['userId']) {\n      console.log('ngOnChanges userId =', changes['userId'].currentValue);\n    }\n  }\n\n  ngOnInit(): void {\n    // Safe: initial @Input bindings already applied.\n    console.log('ngOnInit userId =', this.userId);\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "Common pitfall",
            "What breaks",
            "Fix"
          ],
          "rows": [
            [
              "Calling APIs/subscribing in the constructor",
              "Runs before inputs are set; harder to test (spies not set up yet); surprise side effects on instantiation",
              "Move to <code>ngOnInit</code> (or a facade/service triggered from init)"
            ],
            [
              "Reading <code>@Input()</code> in the constructor",
              "You often read default/undefined instead of the parent-provided value",
              "Use <code>ngOnInit</code> for initial value; use <code>ngOnChanges</code> (or an input setter) for reacting to changes"
            ],
            [
              "Accessing <code>@ViewChild</code> / DOM in <code>ngOnInit</code>",
              "View may not exist yet; <code>ViewChild</code> can be undefined (default <code>static:false</code>)",
              "Use <code>ngAfterViewInit</code> (or <code>@ViewChild({ static: true })</code> only when the element is always present)"
            ],
            [
              "Using <code>inject()</code> and assuming it behaves like ngOnInit",
              "<code>inject()</code> runs during instantiation (same timing category as constructor)",
              "Treat it like constructor-time DI; still do initialization in <code>ngOnInit</code>"
            ]
          ],
          "caption": "What senior candidates mention"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>constructor</code> = DI + trivial setup (no inputs, no side effects). <code>ngOnInit</code> = initialization that depends on Angular bindings (<code>@Input</code>) and starting side effects (streams/data loading). If you must react to input changes over time, use <code>ngOnChanges</code> (or an input setter). DOM/ViewChild work usually belongs in <code>ngAfterViewInit</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Practical notes</strong>\n\nWatch for edge case behavior, common pitfalls, and trade-offs between clarity and performance. Mention accessibility and testing considerations when the concept affects UI output or event timing."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "lifecycle",
      "hooks",
      "components",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Constructor vs ngOnInit in Angular: Timing and Responsibilities",
      "description": "Understand when constructor runs versus ngOnInit, what can safely use @Input values, and where to place DI setup, side effects, and initialization logic."
    }
  },
  {
    "id": "angular-pipes",
    "title": "Angular pipes: built-in, async pipe, and pure vs impure (performance + pitfalls)",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Angular pipes transform values in templates using the | operator (formatting, slicing, mapping) without mutating the source. Most pipes are pure (run only when input reference/primitive changes). The async pipe is special: it subscribes/unsubscribes automatically and triggers view updates.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>A pipe is a reusable <em>template-level</em> transformer: it takes an input value and returns a derived value for display. It should be side-effect free and should not mutate the input."
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "What it means in practice"
          ],
          "rows": [
            [
              "Syntax",
              "<code>{{ value | pipeName:arg1:arg2 }}</code> (you can pass parameters)"
            ],
            [
              "Chaining",
              "<code>{{ value | pipeA | pipeB }}</code> (output of A becomes input of B)"
            ],
            [
              "Where it runs",
              "In Angular’s change detection update phase (template evaluation)."
            ],
            [
              "What it’s for",
              "Formatting + small/cheap view transforms; not heavy computation or side effects."
            ]
          ],
          "caption": "How pipes show up in real templates"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<p>{{ today | date:'fullDate' }}</p>\n<p>{{ username | uppercase }}</p>\n<p>{{ price | currency:'EUR':'symbol':'1.2-2' }}</p>\n<p>{{ completion | percent:'1.0-0' }}</p>\n<pre>{{ user | json }}</pre>"
        },
        {
          "type": "list",
          "columns": [
            "Built-in pipe",
            "Typical use"
          ],
          "rows": [
            [
              "<code>date</code>",
              "Date/time formatting (uses locale + optional timezone)"
            ],
            [
              "<code>currency</code>",
              "Money formatting (currency code, display, digitsInfo)"
            ],
            [
              "<code>number</code> / <code>decimal</code>",
              "Numeric formatting with digitsInfo"
            ],
            [
              "<code>percent</code>",
              "Percent formatting"
            ],
            [
              "<code>json</code>",
              "Debug display of objects (not for production UI)"
            ],
            [
              "<code>slice</code>",
              "Substrings / subarrays in templates (keep usage cheap)"
            ],
            [
              "<code>keyvalue</code>",
              "Iterate object maps in templates"
            ],
            [
              "<code>async</code>",
              "Subscribe to Observable/Promise and render latest value safely"
            ]
          ],
          "caption": "Common built-ins interviewers expect you to mention"
        },
        {
          "type": "text",
          "text": "<strong>The async pipe is the one that matters most in real apps</strong><br><br><code>async</code> subscribes/unsubscribes automatically, avoids manual subscription leaks, and marks the view for update when a new value arrives (works great with <code>OnPush</code>)."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { ChangeDetectionStrategy, Component } from '@angular/core';\nimport { AsyncPipe, NgIf } from '@angular/common';\nimport { Observable, timer, map } from 'rxjs';\n\n@Component({\n  selector: 'app-demo',\n  standalone: true,\n  imports: [NgIf, AsyncPipe],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <p *ngIf=\"count$ | async as count\">Count: {{ count }}</p>\n  `\n})\nexport class DemoComponent {\n  readonly count$: Observable<number> = timer(0, 1000).pipe(map(t => t));\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Pure vs impure pipes (performance hotspot)</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Type",
            "When it runs",
            "Pros",
            "Cons / risk"
          ],
          "rows": [
            [
              "Pure (default)",
              "Only when input changes by value (primitives) or by reference (objects/arrays/functions).",
              "Fast; avoids re-running on every CD pass.",
              "If you mutate arrays/objects in place, the pipe may not re-run (because reference didn’t change)."
            ],
            [
              "Impure (<code>pure: false</code>)",
              "Every change detection cycle.",
              "Can react to in-place mutation or time-varying global state.",
              "Can become very expensive and cause jank; use sparingly."
            ]
          ],
          "caption": "Most Angular pipe interview questions are really about change detection cost"
        },
        {
          "type": "text",
          "text": "<strong>Classic pure-pipe gotcha</strong><br><br>If you do <code>items.push(...)</code>, the array reference stays the same, so a pure pipe may not run again. Prefer immutable updates (<code>items = [...items, newItem]</code>) or move the logic out of the template."
        },
        {
          "type": "text",
          "text": "<strong>Custom pipes: keep them pure + small</strong><br><br>Custom pipes are great for reusable formatting/transforms. Keep them deterministic, no side effects, no DOM, no HTTP. In modern Angular you can make them <code>standalone</code> and import them directly."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'titleCaseWords',\n  standalone: true\n})\nexport class TitleCaseWordsPipe implements PipeTransform {\n  transform(value: string | null | undefined): string {\n    if (!value) return '';\n    return value\n      .trim()\n      .split(/\\s+/)\n      .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())\n      .join(' ');\n  }\n}\n"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component } from '@angular/core';\nimport { TitleCaseWordsPipe } from './title-case-words.pipe';\n\n@Component({\n  selector: 'app-user',\n  standalone: true,\n  imports: [TitleCaseWordsPipe],\n  template: `{{ name | titleCaseWords }}`\n})\nexport class UserComponent {\n  name = 'ada lovelace';\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Pitfall",
            "What goes wrong",
            "Better approach"
          ],
          "rows": [
            [
              "Heavy work inside a pipe used in big lists",
              "Even pure pipes can run often enough to hurt if the transform is expensive.",
              "Precompute in TS, memoize by key, or transform upstream in RxJS/store selectors."
            ],
            [
              "Using an impure pipe to “fix” mutation",
              "Runs every CD cycle; can tank performance.",
              "Prefer immutable state updates or move logic out of template."
            ],
            [
              "Doing side effects in pipes",
              "Unpredictable behavior; multiple calls; hard to test.",
              "Keep pipes pure; side effects belong in services/effects/components."
            ],
            [
              "Manual subscribe in component just to render",
              "Leaks/unsubscribe complexity; extra state variables.",
              "Use <code>async</code> pipe in template."
            ],
            [
              "Calling methods in templates instead of pipes",
              "Method is executed every CD pass; can be worse than a pure pipe.",
              "Use pure pipes for cheap transforms, or cache results explicitly."
            ]
          ],
          "caption": "What senior candidates mention quickly"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Pipes are template transformers used via <code>|</code>. Default is pure: runs when inputs change by value/reference (fast, but mutation-in-place can fool it). Impure pipes run every CD cycle (use rarely). The <code>async</code> pipe is key: it manages subscriptions and keeps templates clean—especially with <code>OnPush</code>."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "pipes",
      "templates",
      "basics",
      "transformations"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Pipes Explained: Built-In, Async, Pure vs Impure",
      "description": "Learn how Angular pipes transform template values, how async pipe manages subscriptions, and when impure pipes hurt performance in change detection."
    }
  },
  {
    "id": "angular-custom-two-way-binding",
    "title": "How would you implement two-way binding for a custom component (Input/Output naming convention), and what can go wrong?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Custom two-way binding uses an @Input() value and a paired @Output() valueChange event. The binding syntax [(value)] listens to valueChange and updates value. Mismatched names or missing emitters break the binding. Covers: angular, two way binding, input, output, components, forms.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>[(x)]</code> works only if Angular can find:<br>• <code>@Input() x</code><br>• <code>@Output() xChange</code><br><br>Then this:<br><code>&lt;app-cmp [(x)]=&quot;state&quot;&gt;&lt;/app-cmp&gt;</code><br>is equivalent to:<br><code>&lt;app-cmp [x]=&quot;state&quot; (xChange)=&quot;state = $event&quot;&gt;&lt;/app-cmp&gt;</code>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, EventEmitter, Input, Output, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-text-input',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <label>\n      <span class=\"sr-only\">Name</span>\n      <input\n        [value]=\"value\"\n        (input)=\"onInput(($event.target as HTMLInputElement).value)\"\n      />\n    </label>\n  `\n})\nexport class TextInputComponent {\n  @Input() value = '';\n  @Output() valueChange = new EventEmitter<string>();\n\n  onInput(next: string): void {\n    // Do NOT rely on mutating @Input() to update parent.\n    // Always emit the change.\n    this.valueChange.emit(next);\n  }\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- parent.component.html -->\n<app-text-input [(value)]=\"name\"></app-text-input>\n\n<p>Preview: {{ name }}</p>"
        },
        {
          "type": "text",
          "text": "<strong>Aliasing still works (but names must still match)</strong><br><br>If you alias the input name, the output alias must be <em>that alias</em> + <code>Change</code>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-toggle',\n  template: `\n    <button type=\"button\" (click)=\"toggle()\">\n      {{ checked ? 'ON' : 'OFF' }}\n    </button>\n  `\n})\nexport class ToggleComponent {\n  @Input('checked') checked = false;\n  @Output('checkedChange') checkedChange = new EventEmitter<boolean>();\n\n  toggle(): void {\n    this.checkedChange.emit(!this.checked);\n  }\n}\n\n// usage:\n// <app-toggle [(checked)]=\"isEnabled\"></app-toggle>"
        },
        {
          "type": "list",
          "columns": [
            "What can go wrong",
            "Symptom",
            "Fix"
          ],
          "rows": [
            [
              "Naming mismatch (e.g., @Output() valueChanged instead of valueChange)",
              "[(value)] fails to compile / template error",
              "Use exact convention: input <prop> + output <prop>Change (or matching aliases)"
            ],
            [
              "You mutate the @Input() and forget to emit",
              "Child UI updates, parent state does not",
              "Treat @Input as read-only; emit through the Output for parent updates"
            ],
            [
              "Emitting at the wrong time (during init hooks)",
              "ExpressionChangedAfterItHasBeenCheckedError / flicker",
              "Emit from user actions or schedule (e.g., queueMicrotask/setTimeout) if you must emit after init"
            ],
            [
              "Two sources of truth (internal state diverges from input)",
              "UI shows stale value or “snaps back”",
              "Render from the @Input; if you keep local state, sync it carefully in ngOnChanges"
            ],
            [
              "Using [(...)] with a non-assignable expression",
              "Template error: can't assign to expression",
              "Bind to a writable field: [(value)]=\"name\" (not \"getName()\" / pipes / literals)"
            ],
            [
              "Objects/arrays are mutated instead of replaced (especially with OnPush patterns)",
              "Hard-to-debug stale UI / shared state side effects",
              "Emit new references (immutable updates) or clearly own mutation boundaries"
            ],
            [
              "Using custom two-way binding for form controls when you really need Angular Forms integration",
              "ngModel / reactive forms don’t work properly (touched/dirty/validation)",
              "Implement ControlValueAccessor for true form controls"
            ]
          ],
          "caption": "Common pitfalls with custom two-way binding"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Custom two-way binding is just <code>[prop]</code> + <code>(propChange)</code>. Implement <code>@Input() prop</code> and <code>@Output() propChange</code>, emit on user interaction, avoid mutating inputs as your update mechanism, and use ControlValueAccessor when the component is a real form control."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> <strong>Practical notes</strong>\n\nWatch for edge case behavior, common pitfalls, and trade-offs between clarity and performance. Mention accessibility and testing considerations when the concept affects UI output or event timing."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "two-way-binding",
      "input",
      "output",
      "components",
      "forms"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Custom Two-Way Binding in Angular: Input/Output Pattern",
      "description": "Implement [(value)] with @Input value and @Output valueChange, follow naming rules, and prevent broken bindings from missing emits or mismatched names."
    }
  },
  {
    "id": "angular-lifecycle-hooks",
    "title": "Angular lifecycle hooks: when do they run, and what should you put in each?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Angular lifecycle hooks are framework callbacks on components/directives that run at specific moments (creation, input changes, content/view init + checks, destruction). Interviewers care less about memorizing names and more about choosing the correct hook for inputs, DOM/ViewChild, content projection, change-detection edge cases, and cleanup. Framework focus: Angular templates + standalone components, @Input/@Output, and RxJS/async pipe patterns.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Hooks are <em>Angular-called</em> methods that let you run code at predictable lifecycle points. The practical skill is picking the right hook:<br>• <strong>Inputs changed?</strong> <code>ngOnChanges</code><br>• <strong>Initialize once?</strong> <code>ngOnInit</code><br>• <strong>Projected content?</strong> <code>ngAfterContent*</code><br>• <strong>DOM / ViewChild?</strong> <code>ngAfterViewInit</code><br>• <strong>Cleanup?</strong> <code>ngOnDestroy</code>"
        },
        {
          "type": "list",
          "columns": [
            "Hook",
            "When it runs",
            "Frequency",
            "What it’s for"
          ],
          "rows": [
            [
              "<code>constructor</code>",
              "Class instantiation (before Angular bindings)",
              "Once",
              "DI + minimal field setup. No inputs, no DOM."
            ],
            [
              "<code>ngOnChanges(changes)</code>",
              "After an <code>@Input</code> binding changes",
              "Many times (or zero if no inputs)",
              "React to input changes; validate/normalize; derive state from inputs."
            ],
            [
              "<code>ngOnInit()</code>",
              "After first <code>ngOnChanges</code> (or after first binding setup)",
              "Once",
              "Initialization that depends on inputs/services; start streams; fetch data."
            ],
            [
              "<code>ngDoCheck()</code>",
              "During every change detection run",
              "Many times",
              "Rare: custom change tracking when default checks aren’t enough (use carefully)."
            ],
            [
              "<code>ngAfterContentInit()</code>",
              "After projected content (<code>&lt;ng-content&gt;</code>) is set",
              "Once",
              "Work that needs <code>@ContentChild</code>/<code>@ContentChildren</code> to exist."
            ],
            [
              "<code>ngAfterContentChecked()</code>",
              "After every check of projected content",
              "Many times",
              "Rare: respond to projected content changes (avoid heavy work)."
            ],
            [
              "<code>ngAfterViewInit()</code>",
              "After component view + child views are created",
              "Once",
              "Safe DOM/ViewChild access; measure/focus; init 3rd-party widgets."
            ],
            [
              "<code>ngAfterViewChecked()</code>",
              "After every check of the component view",
              "Many times",
              "Rare: respond after view checks (avoid state writes here)."
            ],
            [
              "<code>ngOnDestroy()</code>",
              "Right before Angular destroys the instance",
              "Once",
              "Cleanup: subscriptions, timers, listeners, 3rd-party teardown."
            ]
          ],
          "caption": "Lifecycle hooks, timing, and intent"
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "Correct hook",
            "Why"
          ],
          "rows": [
            [
              "Initialize streams / fetch data",
              "<code>ngOnInit</code>",
              "Runs once when bindings are ready."
            ],
            [
              "Derive state from <code>@Input()</code> changes",
              "<code>ngOnChanges</code>",
              "You get <code>SimpleChanges</code> with prev/current values."
            ],
            [
              "Access <code>@ViewChild</code> / DOM measurements / focus",
              "<code>ngAfterViewInit</code>",
              "View is guaranteed to exist (default <code>static: false</code>)."
            ],
            [
              "Access projected content via <code>@ContentChild</code>",
              "<code>ngAfterContentInit</code>",
              "Projected content is initialized (different from the view)."
            ],
            [
              "Tear down subscriptions, intervals, 3rd-party widgets",
              "<code>ngOnDestroy</code>",
              "Last guaranteed cleanup point."
            ]
          ],
          "caption": "Picking the right hook (what interviewers actually test)"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import {\n  AfterContentChecked,\n  AfterContentInit,\n  AfterViewChecked,\n  AfterViewInit,\n  Component,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  SimpleChanges,\n  ViewChild,\n  ElementRef,\n} from '@angular/core';\n\n@Component({\n  selector: 'app-life',\n  template: `\n    <p #p>Hello</p>\n    <ng-content></ng-content>\n  `\n})\nexport class LifeComponent\n  implements\n    OnChanges,\n    OnInit,\n    AfterContentInit,\n    AfterContentChecked,\n    AfterViewInit,\n    AfterViewChecked,\n    OnDestroy {\n\n  @Input() value = 0;\n  @ViewChild('p') p?: ElementRef<HTMLParagraphElement>;\n\n  constructor() {\n    console.log('constructor');\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['value']) {\n      console.log('ngOnChanges', changes['value'].previousValue, '->', changes['value'].currentValue);\n    }\n  }\n\n  ngOnInit(): void {\n    console.log('ngOnInit');\n  }\n\n  ngAfterContentInit(): void {\n    console.log('ngAfterContentInit');\n  }\n\n  ngAfterContentChecked(): void {\n    console.log('ngAfterContentChecked');\n  }\n\n  ngAfterViewInit(): void {\n    console.log('ngAfterViewInit');\n    // Safe: ViewChild available (default static:false)\n    this.p?.nativeElement.focus?.();\n  }\n\n  ngAfterViewChecked(): void {\n    console.log('ngAfterViewChecked');\n  }\n\n  ngOnDestroy(): void {\n    console.log('ngOnDestroy');\n  }\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Execution order (practical)</strong><br><br><strong>First render (typical)</strong>:<br><code>constructor → ngOnChanges? → ngOnInit → ngAfterContentInit → ngAfterContentChecked → ngAfterViewInit → ngAfterViewChecked</code><br><br><strong>Later change-detection cycles</strong>:<br><code>ngOnChanges? → ngDoCheck → ngAfterContentChecked → ngAfterViewChecked</code><br><br><em>Note:</em> <code>ngOnChanges</code> only runs for <code>@Input</code> changes from the parent binding; it won’t fire just because you mutated an object in-place without changing the input reference."
        },
        {
          "type": "list",
          "columns": [
            "Pitfall (interview-grade)",
            "What happens",
            "Fix"
          ],
          "rows": [
            [
              "Mutating bindings in <code>ngAfterViewInit</code>/<code>ngAfterViewChecked</code>",
              "Dev mode can throw <code>ExpressionChangedAfterItHasBeenCheckedError</code>",
              "Avoid sync bound writes there; schedule (microtask) or refactor logic earlier."
            ],
            [
              "Forgetting cleanup",
              "Intervals/subscriptions keep running after navigation",
              "Use <code>ngOnDestroy</code>, <code>async</code> pipe, or <code>takeUntilDestroyed</code>."
            ],
            [
              "Heavy work in <code>ngAfterViewChecked</code>/<code>ngDoCheck</code>",
              "Runs often → perf issues, jank",
              "Keep these hooks rare and cheap; prefer pure derivations and OnPush patterns."
            ],
            [
              "Expecting <code>ngOnChanges</code> on internal mutations",
              "No call if input reference doesn’t change",
              "Use immutable updates (new reference) or manual detection logic if needed."
            ],
            [
              "Confusing content vs view",
              "Using <code>@ViewChild</code> when you needed <code>@ContentChild</code> (or vice versa)",
              "Use <code>AfterView*</code> for view; <code>AfterContent*</code> for projection."
            ]
          ],
          "caption": "Common lifecycle bugs seniors mention"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, DestroyRef, inject, OnInit } from '@angular/core';\nimport { interval } from 'rxjs';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\n\n@Component({\n  selector: 'app-clean',\n  template: `...`\n})\nexport class CleanComponent implements OnInit {\n  private readonly destroyRef = inject(DestroyRef);\n\n  ngOnInit(): void {\n    // Auto-cleanup when the component is destroyed.\n    interval(1000)\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe(v => console.log(v));\n  }\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Lifecycle hooks are Angular callbacks around creation, binding updates, view/content init + checks, and teardown. For interviews: know <code>ngOnChanges</code> (inputs), <code>ngOnInit</code> (init once), <code>ngAfterViewInit</code> (DOM/ViewChild), and <code>ngOnDestroy</code> (cleanup), plus the content-vs-view distinction and the common pitfalls."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "lifecycle",
      "hooks",
      "components",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Lifecycle Hooks: Order, Use Cases, and Pitfalls",
      "description": "See when each hook runs, what belongs in ngOnChanges, ngOnInit, ngAfterViewInit, and ngOnDestroy, and how to prevent DOM timing and cleanup bugs."
    }
  },
  {
    "id": "angular-input-output",
    "title": "How do @Input() and @Output() work in Angular, and what pitfalls do seniors mention in interviews?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "@Input() defines an API for data flowing from parent → child via property binding. @Output() defines an API for events flowing from child → parent via EventEmitter (or newer output helpers). Interviewers expect you to explain timing (updates over time), typing, OnPush/immutability implications, and when NOT to use EventEmitter (cross-component event bus).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>@Input()</code> is the child component’s <strong>public data API</strong>. The parent binds values into it: <em>parent ➜ child</em>.<br><br><code>@Output()</code> is the child component’s <strong>public event API</strong>. The child emits typed events and the parent listens: <em>child ➜ parent</em>."
        },
        {
          "type": "list",
          "columns": [
            "Decorator",
            "Direction",
            "Template syntax",
            "What it really is"
          ],
          "rows": [
            [
              "<code>@Input()</code>",
              "Parent ➜ Child",
              "<code>[prop]=\"expr\"</code>",
              "A bindable property on the child (Angular sets it during change detection)."
            ],
            [
              "<code>@Output()</code>",
              "Child ➜ Parent",
              "<code>(event)=\"handler($event)\"</code>",
              "An EventEmitter the parent listens to (payload is whatever the child emits)."
            ]
          ],
          "caption": "Mental model: Inputs are values, Outputs are events"
        },
        {
          "type": "text",
          "text": "<strong>Typical pattern: pass data down, emit intent up</strong><br><br>Child receives the current value via <code>@Input</code> and emits user intent via <code>@Output</code> (don’t mutate parent state directly)."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, EventEmitter, Input, Output, ChangeDetectionStrategy } from '@angular/core';\n\ntype User = { id: string; name: string; email: string };\n\n@Component({\n  selector: 'app-user-card',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <article>\n      <h3>{{ user.name }}</h3>\n      <p>{{ user.email }}</p>\n      <button type=\"button\" (click)=\"select()\">Select</button>\n    </article>\n  `\n})\nexport class UserCardComponent {\n  @Input({ required: true }) user!: User;\n\n  @Output() readonly selected = new EventEmitter<string>();\n\n  select(): void {\n    this.selected.emit(this.user.id);\n  }\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<app-user-card\n  [user]=\"selectedUser\"\n  (selected)=\"onUserSelected($event)\"\n></app-user-card>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "onUserSelected(userId: string): void {\n  // parent owns the state update\n  console.log('Selected:', userId);\n}"
        },
        {
          "type": "text",
          "text": "<strong>Inputs change over time</strong><br><br>Interviewers often ask how you react when an input changes after the first render. The correct answers are: <code>ngOnChanges</code>, an <code>@Input</code> setter, or (in newer Angular) signals-based inputs."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';\n\ntype User = { id: string; name: string };\n\n@Component({\n  selector: 'app-user-badge',\n  template: `{{ display }}`\n})\nexport class UserBadgeComponent implements OnChanges {\n  @Input() user?: User;\n  display = '—';\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['user']) {\n      this.display = this.user ? `${this.user.name} (${this.user.id})` : '—';\n    }\n  }\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Custom two-way binding (banana-in-a-box)</strong><br><br>If you name an output <code>xChange</code> next to an input <code>x</code>, Angular enables <code>[(x)]</code> syntax. This is a common interview topic (and a common place to make naming mistakes)."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-counter',\n  template: `\n    <button type=\"button\" (click)=\"dec()\">-</button>\n    <span>{{ value }}</span>\n    <button type=\"button\" (click)=\"inc()\">+</button>\n  `\n})\nexport class CounterComponent {\n  @Input() value = 0;\n  @Output() readonly valueChange = new EventEmitter<number>();\n\n  inc(): void { this.valueChange.emit(this.value + 1); }\n  dec(): void { this.valueChange.emit(this.value - 1); }\n}\n\n// parent template:\n// <app-counter [(value)]=\"count\"></app-counter>\n"
        },
        {
          "type": "list",
          "columns": [
            "Pitfall (interview-grade)",
            "What goes wrong",
            "Fix"
          ],
          "rows": [
            [
              "Mutating an <code>@Input()</code> object in the child",
              "With <code>OnPush</code> and immutability, UI updates become unpredictable and state ownership is violated",
              "Treat inputs as read-only; emit intent and let parent update state (new reference)"
            ],
            [
              "Using <code>EventEmitter</code> as an app-wide event bus",
              "Tight coupling + unclear ownership + lifecycle surprises",
              "Use a service with RxJS (Subject/Observable) or a store for cross-component events"
            ],
            [
              "Heavy logic in template bindings/handlers",
              "Hard to test, noisy templates, can run often",
              "Keep template thin; call a method and do logic in TS"
            ],
            [
              "Unstable identity with OnPush (mutating arrays/objects in place)",
              "Child doesn’t re-render because reference didn’t change",
              "Prefer immutable updates (new array/object) or explicit <code>markForCheck()</code> when needed"
            ],
            [
              "Wrong naming for two-way (<code>valueChanged</code> instead of <code>valueChange</code>)",
              "<code>[(value)]</code> doesn’t work; parent needs manual wiring",
              "Use the exact <code>x</code> + <code>xChange</code> naming convention"
            ]
          ],
          "caption": "What senior candidates usually mention quickly"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>@Input</code> defines the child’s data API (parent ➜ child). <code>@Output</code> defines the child’s event API (child ➜ parent). In interviews, emphasize: typed payloads, reacting to input changes correctly, OnPush + immutability behavior, and using EventEmitter only for component outputs (not as a global event bus)."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "components",
      "inputs",
      "outputs",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "@Input and @Output in Angular: Data Flow and Pitfalls",
      "description": "Understand parent-to-child inputs and child-to-parent outputs, update timing, and common mistakes with EventEmitter, OnPush, and mutable object references."
    }
  },
  {
    "id": "angular-observables-rxjs",
    "title": "Observables in Angular: what they are, why RxJS matters, and how to use them correctly (async pipe, cancellation, operators)",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "In Angular, most async APIs expose RxJS Observables (HttpClient, form valueChanges, router events). An Observable is a lazy stream that can emit 0..N values over time and supports cancellation via unsubscribe. Interview focus: cold vs hot streams, subscription/teardown, avoiding memory leaks, and composing streams with operators instead of nested subscribes.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><strong>Observable</strong> (RxJS) = a lazy stream of values over time. Nothing happens until you <code>subscribe()</code>. It can emit <code>next</code> values, then either <code>complete</code> or <code>error</code>. <strong>Unsubscribe</strong> triggers teardown (cancels ongoing work like HTTP requests). Angular uses RxJS Observables as the default async primitive."
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "What it means",
            "Why interviewers care"
          ],
          "rows": [
            [
              "Lazy",
              "No execution until subscribed.",
              "Explains why pipelines do nothing unless subscribed/async-piped."
            ],
            [
              "0..N values",
              "Can emit many values over time (unlike Promise).",
              "Fits UI/event streams (input, websockets, router events)."
            ],
            [
              "Teardown (unsubscribe)",
              "Subscription can be disposed; producer stops work.",
              "Memory leak + cancel-in-flight HTTP are real-world issues."
            ],
            [
              "Operators",
              "Use <code>pipe(map, switchMap, ...)</code> to transform/compose streams.",
              "Senior signal: composition over nested subscribes."
            ]
          ],
          "caption": "What an Observable is (the interview-grade version)"
        },
        {
          "type": "text",
          "text": "<strong>Angular ↔ RxJS relationship</strong><br><br>RxJS provides the Observable implementation and operators. Angular exposes Observables in core APIs (most notably <code>HttpClient</code>, reactive forms <code>valueChanges</code>/<code>statusChanges</code>, and <code>Router.events</code>)."
        },
        {
          "type": "list",
          "columns": [
            "Angular API",
            "What you get",
            "Typical pattern"
          ],
          "rows": [
            [
              "HttpClient",
              "Cold Observable (per subscription), usually completes after one response.",
              "Compose with operators + consume via <code>async</code> pipe."
            ],
            [
              "Reactive Forms",
              "<code>valueChanges</code> is a hot-ish event stream (user-driven).",
              "Debounce + distinct + switchMap (typeahead/search)."
            ],
            [
              "Router",
              "<code>events</code> stream with many event types.",
              "Filter to <code>NavigationEnd</code>, map to route data, etc."
            ]
          ],
          "caption": "Where Observables show up in Angular"
        },
        {
          "type": "text",
          "text": "<strong>Cold vs hot (senior interview hotspot)</strong><br><br><strong>Cold</strong> = each subscriber triggers a new execution (e.g., HTTP request per subscribe). <strong>Hot</strong> = source exists independently and subscribers tap into it (e.g., DOM events, Subjects). If you want to share one execution across many subscribers, you must <strong>multicast</strong> (e.g., <code>shareReplay</code>)."
        },
        {
          "type": "list",
          "columns": [
            "Type",
            "Example",
            "Behavior"
          ],
          "rows": [
            [
              "Cold",
              "<code>this.http.get(...)</code>",
              "Each subscribe can re-run the request (unless shared)."
            ],
            [
              "Hot",
              "<code>fromEvent(button, 'click')</code> / <code>Subject</code>",
              "Emits regardless of who listens; subscribers see emissions while subscribed."
            ],
            [
              "Shared",
              "<code>http$.pipe(shareReplay(...))</code>",
              "One execution, cached value(s) shared to multiple subscribers."
            ]
          ],
          "caption": "Cold vs hot vs shared streams"
        },
        {
          "type": "text",
          "text": "<strong>Best practice in Angular components</strong><br><br><strong>Prefer <code>async</code> pipe</strong> over manual subscriptions. It subscribes/unsubscribes automatically with the view lifecycle, which prevents leaks and works well with OnPush."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { ChangeDetectionStrategy, Component, inject } from '@angular/core';\nimport { AsyncPipe, NgFor } from '@angular/common';\nimport { HttpClient } from '@angular/common/http';\nimport { catchError, map, of, shareReplay } from 'rxjs';\n\ntype User = { id: number; name: string };\n\n@Component({\n  selector: 'app-users',\n  standalone: true,\n  imports: [NgFor, AsyncPipe],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <ul>\n      <li *ngFor=\"let u of (users$ | async)\">{{ u.name }}</li>\n    </ul>\n  `\n})\nexport class UsersComponent {\n  private http = inject(HttpClient);\n\n  // Cold source (HTTP) -> shared + cached for this component instance\n  readonly users$ = this.http.get<User[]>('/api/users').pipe(\n    catchError(() => of([] as User[])),\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Operator choice: switchMap vs mergeMap vs concatMap vs exhaustMap</strong><br><br>When you map to an Observable (HTTP, dialogs, etc.), you get a “higher-order” stream. Picking the right flattening operator is a common interview probe."
        },
        {
          "type": "list",
          "columns": [
            "Operator",
            "Behavior",
            "When to use"
          ],
          "rows": [
            [
              "<code>switchMap</code>",
              "Cancels previous inner stream when a new value arrives.",
              "Typeahead/search, route changes, latest-only UI."
            ],
            [
              "<code>mergeMap</code>",
              "Runs inners concurrently.",
              "Fire-and-forget or parallel requests (with care)."
            ],
            [
              "<code>concatMap</code>",
              "Queues inners, runs one at a time in order.",
              "Ordered writes (save steps), rate-limited sequences."
            ],
            [
              "<code>exhaustMap</code>",
              "Ignores new values while an inner is running.",
              "Prevent double-submit, login button, “ignore spam clicks”."
            ]
          ],
          "caption": "Flattening operators (the senior-friendly mental model)"
        },
        {
          "type": "text",
          "text": "<strong>Example: typeahead done correctly</strong><br><br>Debounce user input, avoid duplicate queries, cancel in-flight requests, and keep errors from killing the stream."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, ChangeDetectionStrategy, inject } from '@angular/core';\nimport { FormControl, ReactiveFormsModule } from '@angular/forms';\nimport { AsyncPipe, NgFor } from '@angular/common';\nimport { HttpClient } from '@angular/common/http';\nimport { catchError, debounceTime, distinctUntilChanged, filter, of, startWith, switchMap } from 'rxjs';\n\ntype User = { id: number; name: string };\n\n@Component({\n  selector: 'app-user-search',\n  standalone: true,\n  imports: [ReactiveFormsModule, NgFor, AsyncPipe],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <input [formControl]=\"q\" placeholder=\"Search users\" />\n\n    <ul>\n      <li *ngFor=\"let u of (results$ | async)\">{{ u.name }}</li>\n    </ul>\n  `\n})\nexport class UserSearchComponent {\n  private http = inject(HttpClient);\n  readonly q = new FormControl('', { nonNullable: true });\n\n  readonly results$ = this.q.valueChanges.pipe(\n    startWith(this.q.value),\n    debounceTime(250),\n    mapTrim,\n    filter(v => v.length >= 2),\n    distinctUntilChanged(),\n    switchMap(v =>\n      this.http.get<User[]>(`/api/users?q=${encodeURIComponent(v)}`).pipe(\n        catchError(() => of([] as User[]))\n      )\n    )\n  );\n}\n\nfunction mapTrim(source$: any) {\n  return source$.pipe((v: string) => v.trim());\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Subscription management (avoid leaks)</strong><br><br>If you must manually subscribe (imperative side effects), ensure teardown. In modern Angular, <code>takeUntilDestroyed()</code> is the clean default; otherwise unsubscribe in <code>ngOnDestroy</code>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, DestroyRef, inject } from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { fromEvent, map } from 'rxjs';\n\n@Component({\n  selector: 'app-resize-log',\n  standalone: true,\n  template: `Resize listener active (check console)`\n})\nexport class ResizeLogComponent {\n  private destroyRef = inject(DestroyRef);\n\n  constructor() {\n    fromEvent(window, 'resize').pipe(\n      map(() => window.innerWidth),\n      takeUntilDestroyed(this.destroyRef)\n    ).subscribe(w => console.log('width', w));\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "Common mistake",
            "Why it’s bad",
            "Fix"
          ],
          "rows": [
            [
              "Nested subscribes",
              "Hard to cancel, hard to handle errors, messy control flow.",
              "Use operators (<code>switchMap/concatMap</code>) and return a stream."
            ],
            [
              "Manual subscribe in components for display data",
              "Leak risk + extra state + OnPush pain.",
              "Expose <code>vm$</code> and render with <code>async</code> pipe."
            ],
            [
              "Using <code>shareReplay(1)</code> everywhere blindly",
              "Can keep values alive longer than intended; refCount matters.",
              "Use <code>shareReplay({ bufferSize: 1, refCount: true })</code> for component-scoped caching; be deliberate in services."
            ],
            [
              "Letting errors terminate long-lived streams",
              "One error can kill <code>valueChanges</code>-based pipelines.",
              "Handle with <code>catchError</code> and return a safe fallback."
            ]
          ],
          "caption": "What interviewers see most often in real Angular codebases"
        },
        {
          "type": "list",
          "columns": [
            "Observable vs Promise",
            "Observable",
            "Promise"
          ],
          "rows": [
            [
              "Values",
              "0..N over time",
              "Single resolution"
            ],
            [
              "Execution",
              "Lazy (starts on subscribe)",
              "Eager (starts immediately)"
            ],
            [
              "Cancellation",
              "Yes (unsubscribe triggers teardown)",
              "No built-in cancellation"
            ],
            [
              "Composition",
              "Operators + stream algebra",
              "then/catch/finally (less expressive for streams)"
            ]
          ],
          "caption": "Quick comparison (keep it practical)"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Observables are RxJS streams used throughout Angular. Key points: they’re lazy, can emit multiple values, and support teardown via unsubscribe. In Angular, prefer composition with operators + <code>async</code> pipe (or <code>takeUntilDestroyed</code> for imperative subscriptions). Know cold vs hot and pick the right flattening operator (<code>switchMap/mergeMap/concatMap/exhaustMap</code>) to control cancellation and concurrency."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "rxjs",
      "observables",
      "async",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Observables and RxJS: Async Pipe, Operators, Cancellation",
      "description": "Learn how Observables work, when streams are cold or hot, how async pipe manages subscriptions, and how operators prevent nested subscribes and leaks."
    }
  },
  {
    "id": "angular-routing",
    "title": "What is Angular routing and how do you define routes?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Angular routing is a feature that allows navigation between different views or components in a single-page application (SPA). Routes are defined using the RouterModule and configured with path-component mappings in a routing module.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Angular’s routing system enables navigation between different views or components without reloading the page. It turns your Angular application into a single-page application (SPA) — meaning that instead of fetching new HTML pages from the server, it dynamically updates the view based on the URL."
        },
        {
          "type": "text",
          "text": "<strong>How Routing Works</strong><br>The Angular Router maps URL paths to specific components. When the browser’s address changes, Angular determines which component to display by matching the URL with a defined route configuration."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: app-routing.module.ts\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { AboutComponent } from './about/about.component';\nimport { ContactComponent } from './contact/contact.component';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent }, // default route\n  { path: 'about', component: AboutComponent },\n  { path: 'contact', component: ContactComponent },\n  { path: '**', redirectTo: '' } // wildcard route for 404s\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}"
        },
        {
          "type": "text",
          "text": "<strong>Defining Routes</strong><br>Each route is defined as an object in the <code>Routes</code> array with at least a <code>path</code> and a <code>component</code> property:<ul><li><strong>path</strong> – the URL segment (e.g., 'about').</li><li><strong>component</strong> – the component to render when the path is matched.</li></ul>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- app.component.html -->\n<nav>\n  <a routerLink=\"/\">Home</a>\n  <a routerLink=\"/about\">About</a>\n  <a routerLink=\"/contact\">Contact</a>\n</nav>\n\n<!-- Placeholder for route content -->\n<router-outlet></router-outlet>"
        },
        {
          "type": "text",
          "text": "<strong>RouterModule Methods</strong><br><ul><li><code>RouterModule.forRoot(routes)</code> – used in the root module for application-wide routing.</li><li><code>RouterModule.forChild(routes)</code> – used in feature modules for modular routing setups.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Navigation Methods</strong><br>Angular provides two main ways to navigate:<ul><li>Declaratively with <code>routerLink</code> in templates.</li><li>Programmatically with <code>Router.navigate()</code> in TypeScript.</li></ul>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: programmatic navigation\nimport { Router } from '@angular/router';\n\nconstructor(private router: Router) {}\n\ngoToAbout() {\n  this.router.navigate(['/about']);\n}"
        },
        {
          "type": "text",
          "text": "<strong>Route Parameters</strong><br>Routes can also include dynamic parameters, allowing you to create routes that depend on variable data (e.g., user IDs)."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example with route parameters\n{ path: 'user/:id', component: UserDetailComponent }"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Accessing route parameter in component\nimport { ActivatedRoute } from '@angular/router';\n\nconstructor(private route: ActivatedRoute) {}\n\nngOnInit() {\n  const id = this.route.snapshot.paramMap.get('id');\n  console.log('User ID:', id);\n}"
        },
        {
          "type": "text",
          "text": "<strong>Benefits of Angular Routing</strong><br><ul><li>Enables smooth client-side navigation without page reloads.</li><li>Improves performance and user experience.</li><li>Supports route guards, parameters, and lazy loading for scalability.</li><li>Allows nested and child routes for modular app structures.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Angular routing as a GPS — it maps URLs to the right components so users can navigate your app fluidly without ever leaving the page."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Angular routing manages navigation between components in SPAs.</li><li>Routes are defined using <code>RouterModule</code> and configured in a routing module.</li><li><code>routerLink</code> and <code>Router.navigate()</code> are used for navigation.</li><li>Dynamic routes, guards, and lazy loading enhance flexibility.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "routing",
      "navigation",
      "router",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Routing Explained: Route Config, RouterLink, Navigation",
      "description": "Understand how Angular Router maps paths to components, configures child routes and guards, and enables SPA navigation without full page reloads."
    }
  },
  {
    "id": "angular-lazy-loading",
    "title": "What is lazy loading in Angular?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Lazy loading in Angular is a technique that loads feature modules only when they are needed, rather than at application startup. It improves performance by reducing the initial bundle size and speeding up the first load.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Lazy loading in Angular is an optimization strategy that helps improve performance by loading specific parts of the application only when required. Instead of downloading all modules and components when the app starts, Angular fetches feature modules on demand — typically when the user navigates to a particular route."
        },
        {
          "type": "text",
          "text": "<strong>How It Works</strong><br>By default, Angular eagerly loads all modules at startup. With lazy loading, feature modules are split into separate chunks, and Angular loads them only when their routes are accessed. This reduces the initial load time and makes the application faster and more efficient."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: Setting up lazy loading in app-routing.module.ts\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\n\nconst routes: Routes = [\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\n  { path: 'home', loadChildren: () => import('./home/home.module').then(m => m.HomeModule) },\n  { path: 'products', loadChildren: () => import('./products/products.module').then(m => m.ProductsModule) }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}"
        },
        {
          "type": "text",
          "text": "In this example, the <code>home</code> and <code>products</code> feature modules are not loaded until the user navigates to their respective routes. Each module is fetched dynamically using the <code>loadChildren</code> property."
        },
        {
          "type": "text",
          "text": "<strong>Creating a Lazy-Loaded Module</strong><br>Use the Angular CLI to generate a module with routing configured for lazy loading:<br><code>ng generate module products --route products --module app.module</code>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: products-routing.module.ts\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { ProductListComponent } from './product-list/product-list.component';\n\nconst routes: Routes = [\n  { path: '', component: ProductListComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class ProductsRoutingModule {}"
        },
        {
          "type": "text",
          "text": "<strong>Benefits of Lazy Loading</strong><br><ul><li>Reduces initial bundle size for faster application startup.</li><li>Improves overall app performance by loading only necessary modules.</li><li>Enhances scalability — new modules can be added easily without affecting initial load time.</li><li>Better user experience on slower networks or large applications.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Eager Loading vs Lazy Loading</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Eager Loading",
            "Lazy Loading"
          ],
          "rows": [
            [
              "When Loaded",
              "All modules loaded at startup.",
              "Modules loaded on demand when needed."
            ],
            [
              "Performance",
              "Slower initial load, faster subsequent navigation.",
              "Faster initial load, modules loaded asynchronously."
            ],
            [
              "Use Case",
              "Small or simple applications.",
              "Large-scale or modular applications."
            ]
          ],
          "caption": "Comparison between Eager and Lazy Loading"
        },
        {
          "type": "text",
          "text": "<strong>Preloading Strategy</strong><br>Angular also provides a hybrid approach called <strong>preloading</strong>, where lazily loaded modules are fetched in the background after the app loads. You can enable it using the <code>PreloadAllModules</code> strategy:"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { PreloadAllModules, RouterModule } from '@angular/router';\n\nRouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules });"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of lazy loading as packing your app into ‘mini-bundles’ — instead of loading everything upfront, Angular loads each bundle only when the user needs it."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Lazy loading defers loading feature modules until needed.</li><li>Improves performance by reducing the initial bundle size.</li><li>Configured via <code>loadChildren</code> in the routing module.</li><li>Ideal for large, modular, and enterprise-level applications.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "routing",
      "lazy-loading",
      "performance",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Lazy Loading: Route-Based Code Splitting Basics",
      "description": "Learn how lazy-loaded routes reduce initial bundle size, improve first-load performance, and what to watch for with preloading and shared dependencies."
    }
  },
  {
    "id": "angular-change-detection-strategies",
    "title": "What are change detection strategies in Angular, and how do they work?",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 1,
    "description": "Change detection in Angular is the mechanism that keeps the view in sync with the component’s data. Angular provides two strategies — Default and OnPush — to determine when and how it checks for changes and updates the DOM.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Change detection in Angular is the process by which the framework synchronizes the application's data model (component properties) with the view (DOM). Whenever the data changes, Angular determines what parts of the view need to be updated and efficiently re-renders them. This is one of the most critical mechanisms in Angular’s performance model."
        },
        {
          "type": "text",
          "text": "<strong>How Change Detection Works</strong><br>Angular maintains a tree of components, each associated with a change detector. Whenever a change occurs (for example, a user event, async call, or timer), Angular traverses this tree and checks if the component’s data bindings have changed. If a change is detected, the DOM is updated accordingly."
        },
        {
          "type": "text",
          "text": "<strong>Change Detection Strategies</strong><br>Angular provides two strategies to control how and when the change detection mechanism runs:"
        },
        {
          "type": "list",
          "columns": [
            "Strategy",
            "Description"
          ],
          "rows": [
            [
              "<code>ChangeDetectionStrategy.Default</code>",
              "This is the default strategy. Angular checks every component in the component tree during every change detection cycle, whether or not its input data has changed. It’s simple but less efficient for large applications."
            ],
            [
              "<code>ChangeDetectionStrategy.OnPush</code>",
              "With this strategy, Angular only checks the component and its children when specific conditions occur — such as when an @Input() reference changes, an event originates from inside the component, or you manually trigger detection. This makes the app faster and more predictable."
            ]
          ],
          "caption": "Angular Change Detection Strategies"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `<p>{{ user.name }}</p>`,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserCardComponent {\n  user = { name: 'Alice' };\n}"
        },
        {
          "type": "text",
          "text": "In the example above, the component uses the <code>OnPush</code> strategy. Angular will only re-check this component when the <code>user</code> reference changes — not when you mutate its properties (e.g., <code>user.name = 'Bob'</code>)."
        },
        {
          "type": "text",
          "text": "<strong>When Does Angular Trigger Change Detection?</strong><br>Angular triggers change detection automatically in response to various async events, such as:<ul><li>User interactions (clicks, input changes, etc.)</li><li>Promises and Observables completing</li><li>setTimeout() and setInterval() callbacks</li><li>XHR or fetch responses</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Manually Controlling Change Detection</strong><br>For performance-sensitive applications, developers can control change detection manually using the <code>ChangeDetectorRef</code> API."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { ChangeDetectorRef, Component } from '@angular/core';\n\n@Component({ selector: 'app-demo', template: `{{ counter }}` })\nexport class DemoComponent {\n  counter = 0;\n  constructor(private cd: ChangeDetectorRef) {}\n\n  increment() {\n    this.counter++;\n    this.cd.detectChanges(); // manually trigger change detection\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Performance Considerations</strong><br><ul><li><code>Default</code> is simpler and sufficient for smaller apps but can become costly for large component trees.</li><li><code>OnPush</code> is more performant and should be used when components depend on immutable data or pure inputs.</li><li>Manual detection control (using <code>ChangeDetectorRef</code>) is useful for advanced optimization scenarios.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Angular change detection as a 'smart mirror' — by default it checks everything for changes, but with <code>OnPush</code> you tell it to look only when you know something has changed."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Change detection keeps the UI in sync with data changes.</li><li>Two strategies exist — Default (checks all) and OnPush (checks only when inputs or events trigger).</li><li>OnPush provides better performance for immutable and reactive data flows.</li><li>Developers can use <code>ChangeDetectorRef</code> for fine-grained control.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "change-detection",
      "performance",
      "basics",
      "components"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 2,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Change Detection: Default vs OnPush Strategy",
      "description": "Compare Default and OnPush change detection, understand when Angular checks views, and avoid stale UI bugs with immutable updates and proper trigger paths."
    }
  },
  {
    "id": "angular-zonejs-change-detection",
    "title": "How does Angular’s Zone.js help in change detection?",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 1,
    "description": "Zone.js is a library used by Angular to automatically track and intercept asynchronous operations such as events, promises, and timers. It notifies Angular whenever an async event completes so the framework can trigger change detection automatically.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Zone.js is a powerful library that Angular uses under the hood to manage asynchronous operations and automatically trigger change detection. Without it, developers would have to manually inform Angular every time something asynchronous (like an event, timer, or HTTP call) modifies the application state."
        },
        {
          "type": "text",
          "text": "<strong>What Is a Zone?</strong><br>A 'zone' is like an execution context that keeps track of all asynchronous tasks (e.g., setTimeout, event listeners, Promises). Zone.js patches these APIs so it can detect when they start and finish. Once an async task completes, Zone.js notifies Angular, which then runs the change detection cycle to update the UI."
        },
        {
          "type": "text",
          "text": "<strong>How Angular Uses Zone.js</strong><br>Angular creates a special zone called the <code>NgZone</code>. It wraps all asynchronous operations inside this zone. When an async event completes, Zone.js calls Angular’s internal mechanism to check for data changes and refresh the view."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, NgZone } from '@angular/core';\n\n@Component({ selector: 'app-zone-demo', template: `<p>{{ counter }}</p>` })\nexport class ZoneDemoComponent {\n  counter = 0;\n  constructor(private zone: NgZone) {\n    this.zone.runOutsideAngular(() => {\n      setInterval(() => {\n        this.counter++;\n        // Update runs outside Angular zone, so UI won't update automatically\n      }, 1000);\n    });\n  }\n\n  startDetection() {\n    this.zone.run(() => {\n      console.log('Entering Angular Zone');\n    });\n  }\n}"
        },
        {
          "type": "text",
          "text": "In this example:<ul><li><code>runOutsideAngular()</code> executes code without triggering change detection.</li><li><code>run()</code> brings execution back into the Angular zone, enabling automatic updates.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>How Zone.js Triggers Change Detection</strong><br>When an asynchronous operation (like <code>setTimeout()</code> or an HTTP call) finishes, Zone.js intercepts it and calls Angular’s internal <code>ApplicationRef.tick()</code> method. This initiates the change detection cycle, ensuring that the UI stays consistent with the data model."
        },
        {
          "type": "text",
          "text": "<strong>Benefits of Using Zone.js</strong><br><ul><li>Automatically triggers change detection after async operations.</li><li>Eliminates the need for manual DOM updates.</li><li>Ensures the UI always reflects the latest application state.</li><li>Provides APIs to run code inside or outside Angular’s zone for performance tuning.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>When You Might Disable Zone.js</strong><br>Advanced developers sometimes disable Zone.js (using <code>zone-flags.ts</code>) to gain full control over change detection — often in highly optimized or reactive applications that use manual <code>ChangeDetectorRef</code> or frameworks like <code>RxAngular</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Zone.js as Angular’s 'watchdog' for async operations — it keeps an eye on everything happening in the background and tells Angular, “Hey, something changed, time to update the view!”"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Zone.js tracks asynchronous operations and notifies Angular when they complete.</li><li>Angular uses <code>NgZone</code> to wrap these operations.</li><li>This allows Angular to automatically trigger change detection and update the DOM.</li><li>You can use <code>runOutsideAngular()</code> for performance-critical code that shouldn’t trigger detection.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "zonejs",
      "change-detection",
      "performance",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 2,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "How Zone.js Triggers Angular Change Detection",
      "description": "Understand how Zone.js patches async APIs like events, timers, and promises so Angular knows when to run change detection and update the view."
    }
  },
  {
    "id": "angular-ngonchanges-vs-ngdocheck",
    "title": "What is the purpose of ngOnChanges() and how does it differ from ngDoCheck()?",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 1,
    "description": "ngOnChanges() and ngDoCheck() are Angular lifecycle hooks that detect and respond to changes in component data. ngOnChanges() automatically runs when @Input() values change, while ngDoCheck() allows developers to perform custom change detection logic beyond Angular’s default mechanism.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Angular provides lifecycle hooks that allow developers to tap into the change detection process and respond to data updates. Two important hooks for monitoring data changes are <code>ngOnChanges()</code> and <code>ngDoCheck()</code>. Both help in detecting changes to component state, but they serve different purposes and operate at different levels of precision."
        },
        {
          "type": "text",
          "text": "<strong>ngOnChanges()</strong><br>This hook is called automatically whenever the value of an <code>@Input()</code> property changes. It runs before <code>ngOnInit()</code> and receives a <code>SimpleChanges</code> object that contains the previous and current values of changed inputs."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `<p>{{ user.name }}</p>`\n})\nexport class UserCardComponent implements OnChanges {\n  @Input() user!: { name: string };\n\n  ngOnChanges(changes: SimpleChanges) {\n    console.log('Previous:', changes['user'].previousValue);\n    console.log('Current:', changes['user'].currentValue);\n  }\n}"
        },
        {
          "type": "text",
          "text": "In this example, <code>ngOnChanges()</code> automatically detects when the <code>user</code> input changes and logs the old and new values. It is especially useful when you want to react only to input-bound property changes."
        },
        {
          "type": "text",
          "text": "<strong>ngDoCheck()</strong><br>While <code>ngOnChanges()</code> only detects <code>@Input()</code> changes, <code>ngDoCheck()</code> is a more powerful hook that lets developers implement <em>custom change detection logic</em>. It runs during every change detection cycle, even if inputs haven’t changed."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, Input, DoCheck } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `<p>{{ user.name }}</p>`\n})\nexport class UserCardComponent implements DoCheck {\n  @Input() user!: { name: string };\n  private oldName = '';\n\n  ngDoCheck() {\n    if (this.user.name !== this.oldName) {\n      console.log('User name changed from', this.oldName, 'to', this.user.name);\n      this.oldName = this.user.name;\n    }\n  }\n}"
        },
        {
          "type": "text",
          "text": "In this example, <code>ngDoCheck()</code> manually checks for changes within the <code>user</code> object — something <code>ngOnChanges()</code> would not detect if only a property (not the object reference) changes."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "ngOnChanges()",
            "ngDoCheck()"
          ],
          "rows": [
            [
              "When Triggered",
              "When @Input() reference changes",
              "On every change detection cycle"
            ],
            [
              "Scope",
              "Tracks input-bound property changes",
              "Can detect deep or custom changes"
            ],
            [
              "Performance",
              "Lightweight",
              "Can be costly if overused"
            ],
            [
              "Use Case",
              "Reacting to @Input() updates",
              "Implementing custom change tracking logic"
            ]
          ],
          "caption": "Comparison between ngOnChanges() and ngDoCheck()"
        },
        {
          "type": "text",
          "text": "<strong>Performance Considerations</strong><br><ul><li><code>ngOnChanges()</code> is more efficient since it only runs when input references change.</li><li><code>ngDoCheck()</code> provides flexibility but should be used carefully, as it runs very frequently during change detection cycles.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>ngOnChanges()</code> as Angular’s built-in observer for input updates, while <code>ngDoCheck()</code> is a manual magnifying glass — you use it when Angular’s default detection isn’t enough."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li><code>ngOnChanges()</code> reacts to input-bound changes automatically.</li><li><code>ngDoCheck()</code> allows for custom logic to detect complex or deep changes.</li><li>Both help maintain UI consistency but differ in granularity and cost.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "lifecycle",
      "hooks",
      "change-detection",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 2,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "ngOnChanges vs ngDoCheck in Angular: Key Differences",
      "description": "Learn when ngOnChanges runs for @Input updates, when ngDoCheck is needed for custom checks, and how to avoid expensive manual detection logic."
    }
  },
  {
    "id": "angular-forroot-forchild",
    "title": "What are Angular modules’ forRoot() and forChild() methods used for?",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 1,
    "description": "forRoot() and forChild() are Angular module configuration methods that help manage singleton services and routing across root and feature modules. forRoot() configures global providers and routes for the root module, while forChild() configures additional routes for feature modules without duplicating providers.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In Angular, modules can include routing and services. The <code>forRoot()</code> and <code>forChild()</code> methods are conventions that help manage how routes and services are provided across different parts of an application — ensuring that global providers are instantiated only once, and feature modules get their own route configurations."
        },
        {
          "type": "text",
          "text": "<strong>The Problem They Solve</strong><br>When you import the same module (such as a routing or service module) into multiple feature modules, Angular might create multiple instances of services or conflicting route definitions. <code>forRoot()</code> and <code>forChild()</code> prevent this by clearly defining which module provides shared singletons (root-level) and which only extends configuration (child-level)."
        },
        {
          "type": "text",
          "text": "<strong>forRoot()</strong><br>The <code>forRoot()</code> method is used in the <strong>root module</strong> (usually <code>AppModule</code>). It configures and provides application-wide services, singletons, and routes that should be initialized once for the entire application."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: AppRoutingModule with forRoot()\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}"
        },
        {
          "type": "text",
          "text": "Here, <code>RouterModule.forRoot()</code> sets up the application's root router. It defines the initial navigation paths and ensures that only one router service instance exists across the app."
        },
        {
          "type": "text",
          "text": "<strong>forChild()</strong><br>The <code>forChild()</code> method is used in <strong>feature modules</strong>. It allows these modules to define their own route configurations without re-initializing the router or global providers. This supports modular architecture and lazy loading."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: ProductsRoutingModule with forChild()\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { ProductListComponent } from './product-list/product-list.component';\nimport { ProductDetailComponent } from './product-detail/product-detail.component';\n\nconst routes: Routes = [\n  { path: '', component: ProductListComponent },\n  { path: ':id', component: ProductDetailComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class ProductsRoutingModule {}"
        },
        {
          "type": "text",
          "text": "Here, <code>RouterModule.forChild()</code> defines routes specific to the <code>ProductsModule</code>. It does not create a new router instance but instead extends the main router configuration."
        },
        {
          "type": "text",
          "text": "<strong>forRoot() and forChild() in Shared Modules</strong><br>Custom shared modules (e.g., logging or analytics) may also use the <code>forRoot()</code>/<code>forChild()</code> pattern to manage singleton service instantiation."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: SharedModule using forRoot()\n@NgModule({\n  providers: []\n})\nexport class SharedModule {\n  static forRoot(): ModuleWithProviders<SharedModule> {\n    return {\n      ngModule: SharedModule,\n      providers: [LoggingService] // Singleton provider\n    };\n  }\n}"
        },
        {
          "type": "text",
          "text": "This ensures that the <code>LoggingService</code> is instantiated only once at the root level, even if <code>SharedModule</code> is imported in multiple places."
        },
        {
          "type": "list",
          "columns": [
            "Method",
            "Used In",
            "Purpose",
            "Example"
          ],
          "rows": [
            [
              "forRoot()",
              "Root module (AppModule)",
              "Configures global services and root routing",
              "RouterModule.forRoot(routes)"
            ],
            [
              "forChild()",
              "Feature module",
              "Defines module-specific routes without creating new instances",
              "RouterModule.forChild(routes)"
            ]
          ],
          "caption": "Differences Between forRoot() and forChild()"
        },
        {
          "type": "text",
          "text": "<strong>Best Practices</strong><ul><li>Use <code>forRoot()</code> only once — in the root module.</li><li>Use <code>forChild()</code> in feature or lazy-loaded modules.</li><li>Do not import <code>RouterModule.forRoot()</code> in feature modules, as it can cause multiple router instances and unpredictable behavior.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>forRoot()</code> as setting up the main roads of your app, while <code>forChild()</code> adds local streets within neighborhoods (feature modules) without rebuilding the entire map."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li><code>forRoot()</code> initializes global providers and routing — used in the root module.</li><li><code>forChild()</code> defines feature module routes without duplicating providers.</li><li>Together, they ensure scalable, modular, and efficient routing and service management in Angular applications.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "modules",
      "providers",
      "dependency-injection",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 2,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular forRoot vs forChild: Routing, Providers, and Singletons",
      "description": "Learn when to use forRoot and forChild, how they prevent duplicate providers, and how root vs feature module configuration impacts DI scope and routing."
    }
  },
  {
    "id": "angular-performance-optimization",
    "title": "How does Angular handle performance optimization for large applications?",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 1,
    "description": "Angular provides a variety of built-in tools and best practices for optimizing performance in large applications. These include efficient change detection strategies, lazy loading, Ahead-of-Time (AOT) compilation, tree-shaking, and other advanced techniques to minimize bundle size and rendering time.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>As Angular applications grow in size and complexity, performance optimization becomes essential to maintain fast loading times, smooth user interactions, and efficient change detection. Angular includes a robust set of features and optimization strategies designed to improve both runtime and build-time performance."
        },
        {
          "type": "text",
          "text": "<strong>1. Efficient Change Detection with OnPush</strong><br>By default, Angular checks all components in every change detection cycle. However, for large apps, this can be costly. Using <code>ChangeDetectionStrategy.OnPush</code> allows Angular to check components only when their input references change, significantly reducing unnecessary updates."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, ChangeDetectionStrategy, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-user-profile',\n  template: `<h3>{{ user.name }}</h3>`,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserProfileComponent {\n  @Input() user!: { name: string };\n}"
        },
        {
          "type": "text",
          "text": "This approach is especially effective when used with immutable data structures or RxJS streams that emit new values instead of mutating existing ones."
        },
        {
          "type": "text",
          "text": "<strong>2. Lazy Loading of Modules</strong><br>Angular supports <strong>lazy loading</strong>, which loads feature modules only when needed. This reduces the initial bundle size, improving startup performance for large-scale applications. Modules that are not immediately required by the user are loaded asynchronously upon navigation."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "{ path: 'admin', loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule) }"
        },
        {
          "type": "text",
          "text": "<strong>3. Ahead-of-Time (AOT) Compilation</strong><br>Angular’s AOT compiler converts TypeScript and HTML templates into optimized JavaScript during the build phase, rather than at runtime. This results in smaller, faster applications with fewer runtime errors."
        },
        {
          "type": "code",
          "language": "bash",
          "code": "ng build --prod --aot"
        },
        {
          "type": "text",
          "text": "AOT removes the need for the browser to compile templates, reducing the startup cost and improving performance, especially on low-powered devices."
        },
        {
          "type": "text",
          "text": "<strong>4. Tree Shaking and Bundle Optimization</strong><br>Tree shaking removes unused code from the final bundle. Angular’s build system (based on Webpack) automatically performs tree-shaking, minification, and dead-code elimination when building with production mode (<code>--configuration production</code>)."
        },
        {
          "type": "text",
          "text": "<strong>5. Using TrackBy with *ngFor</strong><br>When rendering lists with <code>*ngFor</code>, Angular re-renders all elements when data changes by default. By providing a <code>trackBy</code> function, you can optimize list rendering by updating only the modified elements."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<li *ngFor=\"let user of users; trackBy: trackById\">{{ user.name }}</li>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "trackById(index: number, user: any): number {\n  return user.id;\n}"
        },
        {
          "type": "text",
          "text": "<strong>6. Pure Pipes for Efficient Transformations</strong><br>Angular pipes are a great way to transform data in templates. Pure pipes execute only when input values change, unlike impure pipes, which run on every change detection cycle. Using pure pipes prevents redundant recalculations."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "@Pipe({ name: 'capitalize', pure: true })\nexport class CapitalizePipe implements PipeTransform {\n  transform(value: string): string {\n    return value.charAt(0).toUpperCase() + value.slice(1);\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>7. On-Demand Change Detection Control</strong><br>Developers can take control of change detection using <code>ChangeDetectorRef</code>. By detaching and reattaching detection manually, you can optimize performance in complex UIs with frequent updates."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "constructor(private cd: ChangeDetectorRef) {}\n\nngAfterViewInit() {\n  this.cd.detach(); // Stop automatic checking\n  setTimeout(() => {\n    this.cd.detectChanges(); // Manually trigger update\n  }, 1000);\n}"
        },
        {
          "type": "text",
          "text": "<strong>8. Using Web Workers for Heavy Computations</strong><br>Angular supports Web Workers to offload computationally expensive tasks (like image processing or data parsing) from the main UI thread. This keeps the interface responsive."
        },
        {
          "type": "code",
          "language": "bash",
          "code": "ng generate web-worker app"
        },
        {
          "type": "text",
          "text": "<strong>9. Async and OnPush with RxJS</strong><br>Using the <code>async</code> pipe along with <code>OnPush</code> components minimizes subscriptions and ensures Angular unsubscribes automatically. This prevents memory leaks and unnecessary re-renders."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<p *ngIf=\"user$ | async as user\">Welcome, {{ user.name }}!</p>"
        },
        {
          "type": "text",
          "text": "<strong>10. Preloading Strategies</strong><br>Angular’s Router offers preloading strategies that load lazy modules in the background after the main app is ready. This reduces navigation delays later on."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { PreloadAllModules, RouterModule } from '@angular/router';\n\nRouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules });"
        },
        {
          "type": "text",
          "text": "<strong>11. Using Pure Functions and Immutability</strong><br>Keeping your component logic pure (without side effects) and using immutable objects allows Angular to optimize rendering and makes debugging simpler. Immutable updates are especially effective when used with <code>OnPush</code>."
        },
        {
          "type": "text",
          "text": "<strong>12. Production Builds and Source Map Optimization</strong><br>Always use production builds in deployment. Angular’s production build mode enables AOT, tree shaking, minification, and optimizations by default, drastically improving runtime speed and reducing bundle size."
        },
        {
          "type": "code",
          "language": "bash",
          "code": "ng build --configuration production"
        },
        {
          "type": "text",
          "text": "<strong>13. Server-Side Rendering (SSR)</strong><br>Using Angular Universal for server-side rendering improves perceived performance and SEO. The initial HTML is rendered on the server, so the app appears faster to users before the client-side bundle fully loads."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Angular’s performance optimizations as tuning an orchestra — lazy loading reduces the number of players on stage, OnPush ensures only the right ones play, and AOT ensures every note is ready before the concert begins."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Angular optimizes large apps through OnPush detection, lazy loading, AOT, and tree shaking.</li><li>TrackBy, pure pipes, and RxJS streams prevent redundant rendering.</li><li>Web workers, preloading, and SSR further enhance responsiveness.</li><li>Combining these strategies ensures Angular apps remain fast, scalable, and efficient even at enterprise scale.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "performance",
      "change-detection",
      "optimization",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 2,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular Performance Optimization for Large Applications",
      "description": "Understand practical Angular performance levers: OnPush, lazy loading, trackBy, AOT, bundle trimming, and profiling to reduce detection and render cost."
    }
  },
  {
    "id": "angular-onpush-change-detection-debugging-real-bug",
    "title": "Explain OnPush Change Detection in Angular Like You’re Debugging a Real Production Bug",
    "technology": "angular",
    "difficulty": "advanced",
    "importance": 1,
    "description": "OnPush change detection tells Angular to skip checking a component unless one of a few specific triggers happens (Input reference change, event inside the component, async pipe emission, or manual markForCheck/detectChanges). It dramatically improves performance, but breaks the UI if you mutate objects or arrays instead of changing references.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>ChangeDetectionStrategy.OnPush</code> tells Angular: “Only check this component if something <em>meaningful</em> happened.” Meaningful = an <code>@Input</code> reference changed, an event happened in this component, an <code>async</code> pipe emitted, or you manually asked Angular to check."
        },
        {
          "type": "list",
          "columns": [
            "What happened?",
            "Will OnPush re-render?",
            "Why"
          ],
          "rows": [
            [
              "An @Input reference changed",
              "✅ Yes",
              "Angular compares references, not deep values."
            ],
            [
              "A click/event inside the component",
              "✅ Yes",
              "Events mark the component dirty."
            ],
            [
              "An async pipe emits a new value",
              "✅ Yes",
              "AsyncPipe internally calls markForCheck()."
            ],
            [
              "You mutated an object/array in place",
              "❌ No",
              "Reference did not change, Angular thinks nothing happened."
            ],
            [
              "You call markForCheck() manually",
              "✅ Yes",
              "You explicitly told Angular to re-check."
            ],
            [
              "You call detectChanges() manually",
              "✅ Yes (immediate)",
              "Forces synchronous change detection for this subtree."
            ]
          ],
          "caption": "What triggers change detection in OnPush components?"
        },
        {
          "type": "text",
          "text": "<strong>The classic real-world bug</strong><br><br>“My data changes but the UI doesn’t update.” This almost always means <strong>you mutated an object or array instead of creating a new reference</strong>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "@Component({\n  selector: 'app-user-list',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <div *ngFor=\"let user of users\">{{ user.name }}</div>\n  `\n})\nexport class UserListComponent {\n  @Input() users: { name: string }[] = [];\n\n  // ❌ BUG: UI will NOT update in OnPush\n  addUserWrong() {\n    this.users.push({ name: 'New User' }); // same array reference\n  }\n\n  // ✅ Correct: new reference => OnPush sees change\n  addUserCorrect() {\n    this.users = [...this.users, { name: 'New User' }];\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Why OnPush exists</strong><br><br>Default change detection checks <em>the whole component tree</em> on every async event (timers, HTTP, clicks, etc). OnPush lets Angular <strong>skip huge parts of the tree</strong> unless something relevant changed. This is critical for large apps and big lists."
        },
        {
          "type": "text",
          "text": "<strong>markForCheck() vs detectChanges()</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Method",
            "What it does",
            "When to use"
          ],
          "rows": [
            [
              "<code>markForCheck()</code>",
              "Marks this component and its parents as dirty for the next CD cycle.",
              "When data changes outside Angular's awareness (e.g., custom subscriptions, timers, non-async-pipe streams)."
            ],
            [
              "<code>detectChanges()</code>",
              "Immediately runs change detection on this component subtree.",
              "Rare cases: manual rendering, detached views, or very controlled performance scenarios."
            ]
          ],
          "caption": "Manual change detection tools"
        },
        {
          "type": "text",
          "text": "<strong>AsyncPipe is your best friend</strong><br><br>The <code>async</code> pipe automatically:<br>• Subscribes<br>• Unsubscribes<br>• Calls <code>markForCheck()</code> on emission<br><br>This is why OnPush + async pipe is the <strong>recommended default pattern</strong>."
        },
        {
          "type": "text",
          "text": "<strong>Common senior-level pitfalls</strong><br><br>• Mutating arrays/objects instead of replacing them<br>• Forgetting that OnPush uses <em>reference</em> checks, not deep checks<br>• Updating state inside subscriptions without async pipe or markForCheck<br>• Using OnPush everywhere without understanding its mental model"
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "What to do",
            "Why"
          ],
          "rows": [
            [
              "State comes from Observables",
              "Use <code>async</code> pipe",
              "Automatic CD + auto unsubscribe + best performance."
            ],
            [
              "State updated manually in code",
              "Use immutable updates (new reference)",
              "So OnPush can detect the change."
            ],
            [
              "State updated outside Angular or in manual subscriptions",
              "Call <code>markForCheck()</code>",
              "Otherwise Angular will not re-render."
            ]
          ],
          "caption": "Correct patterns with OnPush"
        },
        {
          "type": "text",
          "text": "<strong>Interview-level summary</strong><br><br><code>OnPush</code> makes Angular check a component only when inputs change by reference, an event happens, an async pipe emits, or you manually trigger detection. It gives big performance wins, but <strong>requires immutable state updates</strong>. Most “UI not updating” bugs in OnPush come from mutating objects instead of replacing them."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "change-detection",
      "onpush",
      "debugging",
      "performance"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 0,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular OnPush Change Detection: Real Bug Debugging Guide",
      "description": "See what triggers OnPush checks, why object mutation causes stale UI, and how markForCheck, immutable updates, and async pipe fix production bugs."
    }
  },
  {
    "id": "rxjs-switchmap-mergemap-exhaustmap-concatmap-angular-when-to-use",
    "title": "switchMap vs mergeMap vs exhaustMap vs concatMap: When Would You Use Each in Angular?",
    "technology": "angular",
    "difficulty": "advanced",
    "importance": 3,
    "description": "These RxJS flattening operators control how Angular handles overlapping async work (HTTP calls, saves, clicks, search). switchMap cancels previous, mergeMap runs in parallel, concatMap queues sequentially, and exhaustMap ignores new triggers while busy. Choosing the right one prevents race conditions, double submits, and UI glitches.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>All four operators take a stream of “triggers” (typing, clicks, route params) and map each trigger to an inner Observable (usually an HTTP call). The difference is what they do when a <em>new trigger arrives before the previous one finishes</em>:<br><br><code>switchMap</code> = cancel old, keep latest<br><code>mergeMap</code> = run all in parallel<br><code>concatMap</code> = queue one by one<br><code>exhaustMap</code> = ignore new until current completes"
        },
        {
          "type": "list",
          "columns": [
            "Operator",
            "What it does with overlap",
            "Best Angular use-cases",
            "Common bug it prevents (or causes)"
          ],
          "rows": [
            [
              "<code>switchMap</code>",
              "Cancels the previous inner Observable when a new value arrives (keeps only the latest).",
              "Search/autocomplete, typeahead filtering, route param changes where you only want the latest request.",
              "Prevents stale UI from older responses. (But can cancel work you actually needed.)"
            ],
            [
              "<code>mergeMap</code>",
              "Runs all inner Observables concurrently (no cancellation).",
              "Fire-and-forget analytics, loading independent resources in parallel, batch requests where order doesn’t matter.",
              "Can cause race conditions (older response overwrites newer state) if you update shared UI state."
            ],
            [
              "<code>concatMap</code>",
              "Queues triggers and runs inner Observables sequentially (preserves order).",
              "Save queue, uploading files in order, sequential steps where order matters and every action must run.",
              "Prevents out-of-order state. (But can feel “slow” under rapid triggers.)"
            ],
            [
              "<code>exhaustMap</code>",
              "Ignores new triggers while an inner Observable is active (first wins until completion).",
              "Login button, “Submit” button, “Pay now”, any action where double submit must be blocked.",
              "Prevents double submits. (But can drop user actions if they click again too soon.)"
            ]
          ],
          "caption": "Which RxJS mapping operator should you use in Angular?"
        },
        {
          "type": "text",
          "text": "<strong>Interview mental model</strong><br><br>Ask yourself: when triggers happen fast, do you want <strong>latest wins</strong>, <strong>all run</strong>, <strong>in order</strong>, or <strong>ignore spam</strong>?"
        },
        {
          "type": "list",
          "columns": [
            "You want…",
            "Pick",
            "Why"
          ],
          "rows": [
            [
              "Only the latest result (cancel previous)",
              "<code>switchMap</code>",
              "Typing fast should not show older results."
            ],
            [
              "All requests to run concurrently",
              "<code>mergeMap</code>",
              "Independent work can finish in any order."
            ],
            [
              "Every action to run, but strictly in order",
              "<code>concatMap</code>",
              "Queue saves/commands to avoid state corruption."
            ],
            [
              "Block spam clicks until completion",
              "<code>exhaustMap</code>",
              "Prevent double submit / duplicate payments."
            ]
          ],
          "caption": "Fast decision table"
        },
        {
          "type": "text",
          "text": "<strong>Real Angular examples</strong>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, ChangeDetectionStrategy, inject } from '@angular/core';\nimport { FormControl } from '@angular/forms';\nimport { debounceTime, distinctUntilChanged, switchMap, mergeMap, concatMap, exhaustMap, tap, filter } from 'rxjs/operators';\nimport { Observable, of, Subject } from 'rxjs';\n\nclass Api {\n  search(term: string): Observable<string[]> { return of([term]); }\n  save(payload: unknown): Observable<void> { return of(void 0); }\n  analytics(event: string): Observable<void> { return of(void 0); }\n}\n\n@Component({\n  selector: 'app-demo',\n  template: ``,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class DemoComponent {\n  private api = inject(Api);\n\n  // 1) Typeahead search: latest wins => switchMap\n  searchControl = new FormControl('');\n  searchResults$ = this.searchControl.valueChanges.pipe(\n    debounceTime(250),\n    distinctUntilChanged(),\n    switchMap(term => this.api.search(String(term ?? '')))\n  );\n\n  // 2) Submit button: block double submit => exhaustMap\n  private submitClicks$ = new Subject<void>();\n  submitting$ = this.submitClicks$.pipe(\n    exhaustMap(() => this.api.save({ /* form value */ }))\n  );\n\n  // 3) Sequential saves: preserve order => concatMap\n  private saveQueue$ = new Subject<unknown>();\n  saveInOrder$ = this.saveQueue$.pipe(\n    concatMap(payload => this.api.save(payload))\n  );\n\n  // 4) Parallel work: independent calls => mergeMap\n  private events$ = new Subject<string>();\n  trackEvents$ = this.events$.pipe(\n    mergeMap(name => this.api.analytics(name))\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Senior pitfall #1: race conditions with mergeMap</strong><br><br>If you use <code>mergeMap</code> for UI state that should reflect the latest request, you can get <em>out-of-order overwrites</em>: request A starts, then request B starts, B returns first (UI shows B), then A returns later and overwrites the UI with stale data. That’s why typeahead/search is almost always <code>switchMap</code>."
        },
        {
          "type": "text",
          "text": "<strong>Senior pitfall #2: thinking switchMap “cancels the server”</strong><br><br><code>switchMap</code> unsubscribes from the previous inner Observable. For Angular <code>HttpClient</code>, unsubscribing typically aborts the underlying request (via browser APIs). But if the server already processed it, cancellation won’t rewind time—it mainly prevents your app from handling stale results."
        },
        {
          "type": "text",
          "text": "<strong>Senior pitfall #3: exhaustMap dropping user intent</strong><br><br><code>exhaustMap</code> ignores new triggers while busy. Great for preventing double submits, but if you need “last click wins after current finishes”, use a different strategy (e.g., disable button in UI, or use <code>switchMap</code> with careful semantics)."
        },
        {
          "type": "list",
          "columns": [
            "Angular scenario",
            "Best operator",
            "Reason"
          ],
          "rows": [
            [
              "Search field / autocomplete",
              "<code>switchMap</code>",
              "Only latest input should win; old requests must be ignored."
            ],
            [
              "Submit / payment / login button",
              "<code>exhaustMap</code>",
              "Block duplicates until completion."
            ],
            [
              "Queueing writes (save draft events, ordered commands)",
              "<code>concatMap</code>",
              "Guarantees order and prevents overlapping state changes."
            ],
            [
              "Load independent resources (A, B, C in parallel)",
              "<code>mergeMap</code>",
              "Parallelism improves speed; ordering doesn’t matter."
            ]
          ],
          "caption": "Operator picks interviewers expect you to justify"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>switchMap</code> = latest wins (search, route changes). <code>mergeMap</code> = run all in parallel (independent work). <code>concatMap</code> = queue sequentially (ordered saves). <code>exhaustMap</code> = ignore spam until done (submit buttons). The “correct” choice is the one that matches how you want to handle overlapping triggers."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "rxjs",
      "operators",
      "async",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "switchMap vs mergeMap vs concatMap vs exhaustMap in Angular",
      "description": "Choose the right RxJS flattening operator for search, save, and submit flows by understanding cancellation, concurrency, queuing, and ignored triggers."
    }
  },
  {
    "id": "angular-prevent-memory-leaks-unsubscribe-patterns",
    "title": "How Do You Prevent Memory Leaks in Angular? All Real-World Unsubscribe Patterns Explained",
    "technology": "angular",
    "difficulty": "advanced",
    "importance": 1,
    "description": "Memory leaks in Angular almost always come from forgotten subscriptions, long-lived streams, or global listeners. The correct fixes include using the async pipe, takeUntilDestroyed/DestroyRef, takeUntil with a Subject, and understanding which streams complete automatically and which never do.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Angular itself does not magically clean up your RxJS subscriptions. If a stream does not complete by itself and you keep a subscription alive after the component is destroyed, you leak memory, CPU, and sometimes network activity. <strong>Most Angular memory leaks come from forgotten subscriptions or global listeners.</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Source type",
            "Does it auto-complete?",
            "Needs manual unsubscribe?",
            "Why"
          ],
          "rows": [
            [
              "<code>HttpClient</code> request",
              "✅ Yes",
              "❌ No",
              "HTTP observables complete after one response."
            ],
            [
              "<code>ActivatedRoute</code> params, <code>valueChanges</code>, Subjects",
              "❌ No",
              "✅ Yes",
              "They are long-lived streams tied to app lifetime."
            ],
            [
              "<code>interval</code>, <code>fromEvent</code>, WebSocket",
              "❌ No",
              "✅ Yes",
              "They never complete unless you stop them."
            ],
            [
              "<code>async</code> pipe",
              "—",
              "❌ No",
              "Angular unsubscribes automatically on destroy."
            ]
          ],
          "caption": "Which subscriptions leak if you forget to clean them up?"
        },
        {
          "type": "text",
          "text": "<strong>Pattern #1: Use the async pipe (best default)</strong><br><br>The <code>async</code> pipe automatically subscribes and unsubscribes when the component is destroyed. It also integrates perfectly with <code>OnPush</code> change detection."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "@Component({\n  selector: 'app-users',\n  template: `\n    <ul>\n      <li *ngFor=\"let u of users$ | async\">{{ u.name }}</li>\n    </ul>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UsersComponent {\n  users$ = this.api.loadUsers(); // no manual subscribe\n}"
        },
        {
          "type": "text",
          "text": "<strong>Pattern #2: takeUntilDestroyed (modern Angular, recommended)</strong><br><br>This is the cleanest way to auto-unsubscribe in code in Angular 16+ using <code>DestroyRef</code>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, DestroyRef, inject } from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\n\n@Component({ selector: 'app-demo', template: '' })\nexport class DemoComponent {\n  private destroyRef = inject(DestroyRef);\n\n  ngOnInit() {\n    this.someStream$\n      .pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe(value => {\n        // safe: auto-unsubscribed on destroy\n      });\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Pattern #3: Classic takeUntil + Subject (works in all Angular versions)</strong>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, OnDestroy } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n@Component({ selector: 'app-demo', template: '' })\nexport class DemoComponent implements OnDestroy {\n  private destroy$ = new Subject<void>();\n\n  ngOnInit() {\n    this.someStream$\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(value => {\n        // safe\n      });\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Pattern #4: Manual Subscription aggregation (old-school)</strong><br><br>Works, but easy to forget to add new subscriptions. Not recommended for large components."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, OnDestroy } from '@angular/core';\nimport { Subscription } from 'rxjs';\n\n@Component({ selector: 'app-demo', template: '' })\nexport class DemoComponent implements OnDestroy {\n  private sub = new Subscription();\n\n  ngOnInit() {\n    this.sub.add(this.someStream$.subscribe());\n    this.sub.add(this.otherStream$.subscribe());\n  }\n\n  ngOnDestroy() {\n    this.sub.unsubscribe();\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Non-RxJS leaks: event listeners & timers</strong><br><br>Leaks don’t only come from Observables. <code>addEventListener</code>, <code>setInterval</code>, and 3rd-party libraries must also be cleaned up in <code>ngOnDestroy</code>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "ngOnInit() {\n  window.addEventListener('resize', this.onResize);\n  this.timer = setInterval(() => {}, 1000);\n}\n\nngOnDestroy() {\n  window.removeEventListener('resize', this.onResize);\n  clearInterval(this.timer);\n}"
        },
        {
          "type": "list",
          "columns": [
            "Pattern",
            "When to use",
            "Why"
          ],
          "rows": [
            [
              "<code>async</code> pipe",
              "Template-driven streams",
              "Safest, zero-leak, integrates with OnPush."
            ],
            [
              "<code>takeUntilDestroyed</code>",
              "Subscriptions in component code (Angular 16+)",
              "Modern, concise, no boilerplate."
            ],
            [
              "<code>takeUntil + Subject</code>",
              "Older Angular or shared base classes",
              "Battle-tested and explicit."
            ],
            [
              "Manual Subscription",
              "Very small/simple components",
              "Easy to forget and cause leaks."
            ]
          ],
          "caption": "Which unsubscribe strategy should you pick?"
        },
        {
          "type": "text",
          "text": "<strong>Senior pitfalls</strong><br><br>• Assuming Angular auto-unsubscribes everything (it doesn’t)<br>• Forgetting that <code>ActivatedRoute</code>, <code>valueChanges</code>, Subjects never complete<br>• Subscribing in services that live forever (root scope)<br>• Leaking intervals, event listeners, and WebSocket connections"
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br>To prevent memory leaks in Angular: prefer the <code>async</code> pipe in templates, use <code>takeUntilDestroyed</code> (or <code>takeUntil</code> + Subject) in code, know which Observables complete automatically (HTTP) and which don’t, and always clean up timers and event listeners in <code>ngOnDestroy</code>."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "rxjs",
      "subscriptions",
      "performance",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular memory leaks: unsubscribe patterns",
      "description": "Prevent memory leaks in Angular with practical unsubscribe patterns for Observables, including takeUntil, AsyncPipe, ngOnDestroy cleanup, and key pitfalls."
    }
  },
  {
    "id": "angular-controlvalueaccessor-vs-custom-two-way-binding",
    "title": "What Is ControlValueAccessor in Angular and Why Is It Better Than Custom Two-Way Binding?",
    "technology": "angular",
    "difficulty": "advanced",
    "importance": 1,
    "description": "ControlValueAccessor (CVA) is Angular’s official bridge between custom components and Angular Forms. It lets your component behave like a real form control (ngModel, formControl, formControlName) with validation, touched/dirty state, and disabled handling—unlike custom two-way binding which only syncs values and breaks form integration.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>ControlValueAccessor</code> (CVA) is the interface that tells Angular Forms how to <strong>write a value into your component</strong> and how your component <strong>reports changes back</strong>. If you want a custom input component to work with <code>ngModel</code>, <code>formControl</code>, or <code>formControlName</code>, you must implement CVA."
        },
        {
          "type": "text",
          "text": "<strong>Why not just use custom two-way binding?</strong><br><br>Two-way binding like <code>[(value)]</code> only synchronizes a value. It does <strong>not</strong> integrate with Angular Forms, so you lose validation, touched/dirty states, disabled state, and form-level APIs. CVA plugs your component into the <em>entire forms ecosystem</em>."
        },
        {
          "type": "list",
          "columns": [
            "Capability",
            "Custom [(value)] binding",
            "ControlValueAccessor"
          ],
          "rows": [
            [
              "Works with Reactive Forms / ngModel",
              "❌ No",
              "✅ Yes"
            ],
            [
              "Supports validators",
              "❌ No",
              "✅ Yes"
            ],
            [
              "Tracks touched / dirty / pristine",
              "❌ No",
              "✅ Yes"
            ],
            [
              "Supports disabled state",
              "❌ Manual hacks",
              "✅ Built-in via setDisabledState"
            ],
            [
              "Integrates with FormGroup / FormControl",
              "❌ No",
              "✅ Yes"
            ]
          ],
          "caption": "Two-way binding vs ControlValueAccessor"
        },
        {
          "type": "text",
          "text": "<strong>Minimal CVA implementation</strong><br><br>A CVA has four responsibilities:<br>• <code>writeValue</code>: Angular → component<br>• <code>registerOnChange</code>: component → Angular<br>• <code>registerOnTouched</code>: mark as touched<br>• <code>setDisabledState</code>: handle disabled"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, forwardRef } from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\n\n@Component({\n  selector: 'app-rating',\n  template: `\n    <button *ngFor=\"let n of [1,2,3,4,5]\" (click)=\"set(n)\" [disabled]=\"disabled\">\n      {{ n }}\n    </button>\n  `,\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => RatingComponent),\n      multi: true\n    }\n  ]\n})\nexport class RatingComponent implements ControlValueAccessor {\n  value = 0;\n  disabled = false;\n\n  private onChange = (v: number) => {};\n  private onTouched = () => {};\n\n  writeValue(v: number): void {\n    this.value = v ?? 0;\n  }\n\n  registerOnChange(fn: (v: number) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  set(v: number) {\n    if (this.disabled) return;\n    this.value = v;\n    this.onChange(v);   // notify Angular Forms\n    this.onTouched();   // mark as touched\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Using it like a real form control</strong>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<form [formGroup]=\"form\">\n  <app-rating formControlName=\"rating\"></app-rating>\n</form>"
        },
        {
          "type": "text",
          "text": "<strong>Why this is strictly better than custom two-way binding</strong><br><br>With CVA, your component becomes a <strong>first-class Angular form control</strong>. It participates in validation, form submission, reset, disabled state propagation, and form-level state tracking. Two-way binding only moves a value around—it does not integrate into the forms system."
        },
        {
          "type": "list",
          "columns": [
            "Real-world requirement",
            "Without CVA",
            "With CVA"
          ],
          "rows": [
            [
              "Disable the whole form",
              "❌ You must wire every input manually",
              "✅ setDisabledState is called automatically"
            ],
            [
              "Mark control as touched",
              "❌ Manual hacks",
              "✅ Angular handles it"
            ],
            [
              "Show validation errors",
              "❌ Not integrated",
              "✅ Works via FormControl"
            ],
            [
              "Reset the form",
              "❌ Manual reset logic",
              "✅ Angular resets automatically"
            ]
          ],
          "caption": "Why CVA scales in real apps"
        },
        {
          "type": "text",
          "text": "<strong>Senior-level pitfalls</strong><br><br>• Forgetting to call <code>onTouched()</code> (control never becomes touched)<br>• Not implementing <code>setDisabledState</code> (disabled forms don’t work)<br>• Mutating internal state without calling <code>onChange</code><br>• Using custom two-way binding for components that should be form controls"
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br><code>ControlValueAccessor</code> is Angular’s official way to make a custom component behave like a real form control. It integrates with Reactive Forms and ngModel, supports validation, touched/dirty state, disabled handling, and form APIs. Custom two-way binding only syncs a value and does not integrate with Angular Forms, which makes it unsuitable for serious form components."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "forms",
      "controlvalueaccessor",
      "two-way-binding",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "ControlValueAccessor in Angular vs Custom Two-Way Binding",
      "description": "Learn why CVA integrates with Angular Forms validation, touched/dirty state, and disabled handling, while custom two-way binding only syncs value changes."
    }
  },
  {
    "id": "angular-template-driven-vs-reactive-forms-which-scales",
    "title": "Template-Driven vs Reactive Forms in Angular: Which One Scales and Why?",
    "technology": "angular",
    "difficulty": "advanced",
    "importance": 1,
    "description": "Template-driven forms rely on directives in the template and implicit state, while reactive forms define the entire form model in TypeScript. Reactive forms scale better because they are explicit, testable, composable, and predictable for complex validation and dynamic form structures.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Both approaches create the same thing in the end (a <code>FormGroup</code> tree). The difference is <strong>where the form model lives</strong>:<br><br>• <strong>Template-driven</strong>: the form is inferred from the template.<br>• <strong>Reactive</strong>: the form is declared explicitly in TypeScript.<br><br>The more complex the form becomes, the more valuable the explicit model of reactive forms becomes."
        },
        {
          "type": "list",
          "columns": [
            "Dimension",
            "Template-Driven Forms",
            "Reactive Forms"
          ],
          "rows": [
            [
              "Where the model lives",
              "In the template (via directives like ngModel)",
              "In TypeScript (FormGroup/FormControl)"
            ],
            [
              "Data flow",
              "Mostly implicit, two-way binding",
              "Explicit, unidirectional data flow"
            ],
            [
              "Validation",
              "Template-based (attributes, directives)",
              "Function-based, composable, testable"
            ],
            [
              "Dynamic forms",
              "❌ Hard to do",
              "✅ First-class support (FormArray, dynamic controls)"
            ],
            [
              "Testability",
              "❌ Hard (need to render template)",
              "✅ Easy (pure TS objects)"
            ],
            [
              "Predictability",
              "⚠️ Lower (implicit state & timing)",
              "✅ High (explicit model)"
            ]
          ],
          "caption": "Template-driven vs Reactive forms"
        },
        {
          "type": "text",
          "text": "<strong>Template-driven example (simple, but limited)</strong>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<form #f=\"ngForm\">\n  <input name=\"email\" ngModel required email />\n  <button [disabled]=\"f.invalid\">Save</button>\n</form>"
        },
        {
          "type": "text",
          "text": "<strong>Reactive example (explicit and scalable)</strong>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "form = new FormGroup({\n  email: new FormControl('', [Validators.required, Validators.email])\n});"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<form [formGroup]=\"form\">\n  <input formControlName=\"email\" />\n  <button [disabled]=\"form.invalid\">Save</button>\n</form>"
        },
        {
          "type": "text",
          "text": "<strong>Why Reactive Forms scale better</strong><br><br>In real applications you eventually need:<br>• Dynamic fields (add/remove rows)<br>• Cross-field validation<br>• Conditional enable/disable logic<br>• Programmatic resets, patches, partial updates<br>• Testable validation logic<br><br>All of these are <strong>natural</strong> in reactive forms and <strong>awkward</strong> in template-driven forms."
        },
        {
          "type": "list",
          "columns": [
            "Real-world requirement",
            "Template-driven",
            "Reactive"
          ],
          "rows": [
            [
              "Dynamic rows (FormArray)",
              "❌ Very hard",
              "✅ Built-in support"
            ],
            [
              "Cross-field validation",
              "⚠️ Awkward",
              "✅ Clean validator functions"
            ],
            [
              "Conditional fields",
              "⚠️ Hacky",
              "✅ Simple enable/disable APIs"
            ],
            [
              "Unit testing",
              "❌ Requires TestBed + template",
              "✅ Pure TypeScript tests"
            ],
            [
              "Complex state transitions",
              "❌ Hard to reason about",
              "✅ Predictable and explicit"
            ]
          ],
          "caption": "Why reactive forms dominate in large apps"
        },
        {
          "type": "text",
          "text": "<strong>Performance and architecture considerations</strong><br><br>Reactive forms fit naturally with:<br>• <code>OnPush</code> change detection<br>• Immutable update patterns<br>• Observable-based workflows<br>• CVA-based custom controls<br><br>Template-driven forms rely heavily on directives and two-way binding, which becomes harder to control and reason about at scale."
        },
        {
          "type": "text",
          "text": "<strong>When template-driven forms are still OK</strong><br><br>• Very small forms (login, newsletter signup)<br>• Prototypes, admin panels, quick internal tools<br>• When you want minimal boilerplate and don’t need complex logic"
        },
        {
          "type": "text",
          "text": "<strong>Senior-level pitfalls</strong><br><br>• Mixing template-driven and reactive approaches in the same form<br>• Using template-driven forms for dynamic or complex workflows<br>• Putting business logic in templates instead of validators/services"
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br>Template-driven forms are fine for simple cases, but <strong>reactive forms scale better</strong> because the form model is explicit, testable, composable, and predictable. Any serious Angular application with dynamic fields, complex validation, or non-trivial workflows should default to reactive forms."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "forms",
      "reactive-forms",
      "template-driven",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Template-Driven vs Reactive Forms in Angular: Which Scales?",
      "description": "Compare template-driven and reactive forms by scalability, testability, dynamic validation, and maintainability to choose the right approach for each form."
    }
  },
  {
    "id": "rxjs-sharereplay-angular-how-it-breaks-your-app",
    "title": "What Is shareReplay in RxJS and How Can It Silently Break Your Angular App?",
    "technology": "angular",
    "difficulty": "advanced",
    "importance": 1,
    "description": "shareReplay is an RxJS operator that turns a cold observable into a shared hot one and caches the last emitted values. Used incorrectly, it can cause memory leaks, stale data bugs, and unexpected behavior—especially in Angular services and HTTP streams.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>shareReplay</code> does two things at once:<br>• It <strong>shares</strong> a single subscription among multiple subscribers.<br>• It <strong>replays</strong> the last N emitted values to new subscribers.<br><br>This is extremely useful for caching HTTP calls—but also extremely easy to misuse."
        },
        {
          "type": "text",
          "text": "<strong>The classic Angular use-case</strong><br><br>You want multiple components to consume the same HTTP data without triggering multiple requests."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "users$ = this.http.get<User[]>('/api/users').pipe(\n  shareReplay(1)\n);"
        },
        {
          "type": "text",
          "text": "<strong>What problem does this solve?</strong><br><br>Without <code>shareReplay</code>, every <code>subscribe()</code> or <code>async</code> pipe would trigger a <em>new HTTP request</em>. With <code>shareReplay(1)</code>, the first request is cached and reused."
        },
        {
          "type": "list",
          "columns": [
            "Behavior",
            "Without shareReplay",
            "With shareReplay(1)"
          ],
          "rows": [
            [
              "Second subscriber",
              "Triggers new HTTP request",
              "Gets cached value"
            ],
            [
              "Third subscriber",
              "Triggers new HTTP request",
              "Gets cached value"
            ],
            [
              "Network usage",
              "Many duplicate calls",
              "Single call"
            ]
          ],
          "caption": "Why people use shareReplay"
        },
        {
          "type": "text",
          "text": "<strong>How shareReplay can silently break your app</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Problem",
            "Why it happens",
            "Symptom in real apps"
          ],
          "rows": [
            [
              "Memory leaks",
              "By default, shareReplay keeps the source subscribed forever.",
              "Services never released, websockets/intervals never stop."
            ],
            [
              "Stale data",
              "Cached value is reused even when data should refresh.",
              "User navigates away/back and sees outdated data."
            ],
            [
              "Error caching",
              "If the source errors, the error is also replayed.",
              "Stream is permanently broken until reload."
            ],
            [
              "Unexpected global state",
              "shareReplay turns cold streams into hot singletons.",
              "Components influence each other indirectly."
            ]
          ],
          "caption": "The hidden dangers"
        },
        {
          "type": "text",
          "text": "<strong>The most important option: refCount</strong><br><br>Modern RxJS lets you write:"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "users$ = this.http.get<User[]>('/api/users').pipe(\n  shareReplay({ bufferSize: 1, refCount: true })\n);"
        },
        {
          "type": "text",
          "text": "<strong>What does <code>refCount: true</code> do?</strong><br><br>It tells RxJS: “When there are no subscribers left, <strong>unsubscribe from the source</strong> and free resources.” Without this, the source stays alive forever."
        },
        {
          "type": "list",
          "columns": [
            "Configuration",
            "When last subscriber unsubscribes",
            "Memory behavior"
          ],
          "rows": [
            [
              "shareReplay(1)",
              "Source stays subscribed",
              "❌ Potential leak"
            ],
            [
              "shareReplay({ bufferSize: 1, refCount: true })",
              "Source unsubscribes",
              "✅ Safe cleanup"
            ]
          ],
          "caption": "Why refCount matters"
        },
        {
          "type": "text",
          "text": "<strong>Another subtle trap: error caching</strong><br><br>If the HTTP call errors once, <code>shareReplay</code> will replay that error forever. All future subscribers instantly get the error, and the stream never retries unless you rebuild it or add <code>retry</code> logic."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "users$ = this.http.get<User[]>('/api/users').pipe(\n  retry(1),\n  shareReplay({ bufferSize: 1, refCount: true })\n);"
        },
        {
          "type": "text",
          "text": "<strong>Senior rule of thumb</strong><br><br>• Use <code>shareReplay</code> for caching expensive or shared streams.<br>• Prefer <code>{ bufferSize: 1, refCount: true }</code> unless you intentionally want a forever-alive cache.<br>• Be explicit about refresh/invalidation semantics.<br>• Never blindly slap <code>shareReplay(1)</code> everywhere."
        },
        {
          "type": "list",
          "columns": [
            "Angular scenario",
            "Should you use shareReplay?",
            "How"
          ],
          "rows": [
            [
              "Config loaded once at app startup",
              "✅ Yes",
              "shareReplay(1) without refCount may be OK"
            ],
            [
              "User-specific API data",
              "⚠️ Be careful",
              "Use refCount or explicit refresh trigger"
            ],
            [
              "WebSocket / interval stream",
              "❌ Usually dangerous",
              "You probably want manual lifecycle control"
            ],
            [
              "HTTP list used by many components",
              "✅ Yes",
              "shareReplay({ bufferSize: 1, refCount: true })"
            ]
          ],
          "caption": "When to use shareReplay in Angular"
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br><code>shareReplay</code> shares a single subscription and caches the last values. It is great for avoiding duplicate HTTP calls, but can cause memory leaks, stale data, and permanent error states if used carelessly. In Angular, the safe default is <code>shareReplay({ bufferSize: 1, refCount: true })</code> and a clear cache invalidation strategy."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "rxjs",
      "sharereplay",
      "performance",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "RxJS shareReplay in Angular: Caching Benefits and Hidden Bugs",
      "description": "Learn how shareReplay shares and replays streams, when it helps HTTP caching, and how wrong refCount or buffer settings cause stale data and memory leaks."
    }
  },
  {
    "id": "angular-http-what-actually-cancels-request",
    "title": "What Actually Cancels an HTTP Request in Angular?",
    "technology": "angular",
    "difficulty": "advanced",
    "importance": 1,
    "description": "In Angular, HTTP requests are canceled by unsubscribing from the Observable, usually via switchMap, takeUntil, async pipe, or manual unsubscribe. This triggers the browser AbortController/XHR abort under the hood. But not all operators or patterns truly cancel the network request—some only ignore the result.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>An Angular <code>HttpClient</code> request is just an Observable wrapper around a browser request. <strong>The only thing that can actually cancel it is unsubscribing from that Observable</strong>. When you unsubscribe, Angular tells the browser to abort the underlying request (via <code>AbortController</code> or XHR abort)."
        },
        {
          "type": "list",
          "columns": [
            "Action",
            "Does it cancel the network request?",
            "What really happens"
          ],
          "rows": [
            [
              "Unsubscribe from HttpClient Observable",
              "✅ Yes",
              "Browser request is aborted."
            ],
            [
              "switchMap to a new request",
              "✅ Yes",
              "Previous inner subscription is unsubscribed."
            ],
            [
              "takeUntil emits",
              "✅ Yes",
              "Subscription is torn down → request aborted."
            ],
            [
              "Component destroyed (async pipe)",
              "✅ Yes",
              "AsyncPipe unsubscribes automatically."
            ],
            [
              "Using mergeMap",
              "❌ No",
              "Old requests keep running in parallel."
            ],
            [
              "Ignoring the result in code",
              "❌ No",
              "Network still continues; you just drop the response."
            ]
          ],
          "caption": "What truly cancels HTTP in Angular?"
        },
        {
          "type": "text",
          "text": "<strong>The classic search example</strong><br><br>When users type quickly, you want to cancel old requests and only keep the latest one."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "this.results$ = this.searchControl.valueChanges.pipe(\n  debounceTime(300),\n  distinctUntilChanged(),\n  switchMap(term => this.http.get(`/api/search?q=${term}`))\n);"
        },
        {
          "type": "text",
          "text": "<strong>Why this cancels old requests</strong><br><br><code>switchMap</code> unsubscribes from the previous inner Observable when a new value arrives. Since <code>HttpClient</code> cancels requests on unsubscribe, the browser request is aborted."
        },
        {
          "type": "text",
          "text": "<strong>takeUntil pattern (component lifecycle)</strong>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "this.http.get('/api/data').pipe(\n  takeUntil(this.destroy$)\n).subscribe();\n\nngOnDestroy() {\n  this.destroy$.next();\n  this.destroy$.complete();\n}"
        },
        {
          "type": "text",
          "text": "<strong>What does NOT cancel the request</strong><br><br>Many devs think these cancel HTTP, but they don’t:"
        },
        {
          "type": "list",
          "columns": [
            "Myth",
            "Reality"
          ],
          "rows": [
            [
              "“I used mergeMap, so old requests are gone”",
              "❌ mergeMap runs everything in parallel. Nothing is canceled."
            ],
            [
              "“I navigated away from the page”",
              "❌ Unless you unsubscribed (async pipe or takeUntil), request keeps running."
            ],
            [
              "“I ignored the result in subscribe”",
              "❌ The network request still completes."
            ],
            [
              "“The server will stop anyway”",
              "❌ The server may continue processing even if client aborts."
            ]
          ],
          "caption": "Common misconceptions"
        },
        {
          "type": "text",
          "text": "<strong>Important nuance: canceling the browser request vs canceling server work</strong><br><br>When Angular aborts the request, the <em>browser connection</em> is closed. The server may or may not stop processing—this depends entirely on server implementation. From the frontend point of view, however, the request is gone."
        },
        {
          "type": "list",
          "columns": [
            "Angular pattern",
            "Does it cancel HTTP?",
            "Why"
          ],
          "rows": [
            [
              "AsyncPipe in template",
              "✅ Yes",
              "Auto-unsubscribes when component is destroyed."
            ],
            [
              "switchMap",
              "✅ Yes",
              "Unsubscribes previous inner Observable."
            ],
            [
              "takeUntil / takeUntilDestroyed",
              "✅ Yes",
              "Unsubscribe is triggered by notifier or lifecycle."
            ],
            [
              "mergeMap",
              "❌ No",
              "No cancellation semantics."
            ],
            [
              "shareReplay",
              "⚠️ Depends",
              "May keep the request alive if refCount is false."
            ]
          ],
          "caption": "Cancellation behavior by pattern"
        },
        {
          "type": "text",
          "text": "<strong>Senior-level pitfall</strong><br><br>Using <code>shareReplay</code> without <code>refCount</code> can keep an HTTP request (or its subscription) alive forever, making it impossible to cancel later even if components unsubscribe."
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br>In Angular, <strong>only unsubscribing</strong> cancels an HTTP request. Operators like <code>switchMap</code>, <code>takeUntil</code>, and the <code>async</code> pipe cancel requests because they unsubscribe. Operators like <code>mergeMap</code> do not cancel anything—they just ignore or parallelize results. Real cancellation = unsubscribe."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "http",
      "rxjs",
      "cancellation",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Angular HTTP Cancellation: What Really Aborts Requests?",
      "description": "Understand which patterns actually cancel HttpClient calls (unsubscribe, switchMap, takeUntil, async pipe) and which patterns only ignore late responses."
    }
  },
  {
    "id": "angular-hierarchical-dependency-injection-real-bug",
    "title": "Explain Hierarchical Dependency Injection in Angular With a Real Bug Example",
    "technology": "angular",
    "difficulty": "advanced",
    "importance": 1,
    "description": "Angular’s dependency injection is hierarchical: every injector can create its own instance of a service. If you provide the same service in different places (root, module, component, route), you can accidentally get multiple instances and break shared state, caching, or coordination logic.",
    "seo": {
      "title": "Angular Hierarchical DI Bug Patterns",
      "description": "Understand Angular’s injector hierarchy, why duplicate providers create multiple service instances, and how to diagnose shared-state bugs quickly."
    },
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Angular does not have a single global injector. It has a <strong>tree of injectors</strong>. When Angular resolves a dependency, it starts from the current component’s injector and walks <em>up the tree</em> until it finds a provider. This means <strong>where you provide a service changes how many instances exist</strong>."
        },
        {
          "type": "text",
          "text": "<strong>The real-world bug</strong><br><br>“Why does my shared state reset when I navigate?” or “Why does my cache disappear in some components but not others?” The usual answer: <strong>you accidentally created multiple instances of the same service</strong>."
        },
        {
          "type": "list",
          "columns": [
            "Where you provide the service",
            "How many instances exist",
            "Typical use"
          ],
          "rows": [
            [
              "<code>providedIn: 'root'</code>",
              "1 for the whole app",
              "Global singleton (auth, config, global cache)"
            ],
            [
              "In a lazy-loaded route or module",
              "1 per lazy-loaded subtree",
              "Feature-scoped state"
            ],
            [
              "In a component’s <code>providers</code>",
              "1 per component instance",
              "Local, isolated state"
            ]
          ],
          "caption": "Where you provide a service determines its lifetime and scope"
        },
        {
          "type": "text",
          "text": "<strong>The bug in code</strong><br><br>You think you have one cache service, but you accidentally created many."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "@Injectable({ providedIn: 'root' })\nexport class UserCacheService {\n  users: string[] = [];\n}\n\n@Component({\n  selector: 'app-user-list',\n  template: `...`,\n  // ❌ BUG: this creates a NEW instance just for this component\n  providers: [UserCacheService]\n})\nexport class UserListComponent {\n  constructor(public cache: UserCacheService) {}\n}"
        },
        {
          "type": "text",
          "text": "<strong>What goes wrong</strong><br><br>Other parts of the app inject the <em>root</em> instance of <code>UserCacheService</code>, but <code>UserListComponent</code> gets its <em>own private copy</em>. Now state, caches, and flags are silently out of sync."
        },
        {
          "type": "text",
          "text": "<strong>How Angular resolves the dependency</strong><br><br>1) Check the component’s injector<br>2) If not found, check parent component injectors<br>3) Then module/route injectors<br>4) Finally root injector<br><br>The <strong>first match wins</strong>."
        },
        {
          "type": "list",
          "columns": [
            "Injection site",
            "Which instance you get",
            "Why"
          ],
          "rows": [
            [
              "Component with its own providers",
              "Component-scoped instance",
              "Local provider shadows parent/root"
            ],
            [
              "Child of that component",
              "Same component-scoped instance",
              "Injector tree inheritance"
            ],
            [
              "Some other component elsewhere",
              "Root instance",
              "Different injector branch"
            ]
          ],
          "caption": "How the injector tree affects instance sharing"
        },
        {
          "type": "text",
          "text": "<strong>Another common real bug: lazy-loaded modules</strong><br><br>If you provide a service in a lazy-loaded route/module, you get a <strong>separate instance</strong> from the rest of the app. This often breaks auth state, caches, or WebSocket connections."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "export const routes: Routes = [\n  {\n    path: 'admin',\n    loadComponent: () => import('./admin.component'),\n    providers: [AdminStateService] // feature-scoped instance\n  }\n];"
        },
        {
          "type": "text",
          "text": "<strong>When component-level providers are actually correct</strong><br><br>• Reusable UI widgets with isolated state<br>• Temporary, per-instance state machines<br>• Editable rows, dialogs, or dynamic components that must not share state"
        },
        {
          "type": "list",
          "columns": [
            "Goal",
            "Where to provide",
            "Why"
          ],
          "rows": [
            [
              "Global shared state (auth, config, cache)",
              "<code>providedIn: 'root'</code>",
              "Single instance for entire app"
            ],
            [
              "Feature-isolated state",
              "Route/module providers",
              "Scoped lifetime"
            ],
            [
              "Per-component isolated state",
              "Component <code>providers</code>",
              "New instance per component"
            ]
          ],
          "caption": "Correct scoping strategy"
        },
        {
          "type": "text",
          "text": "<strong>Senior-level pitfalls</strong><br><br>• Accidentally re-providing a root service in a component<br>• Breaking caches or auth state via lazy-loaded module providers<br>• Assuming “service = singleton” without checking injector scope<br>• Debugging “state randomly resets” for hours"
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br>Angular DI is hierarchical: services are resolved by walking up the injector tree. Where you provide a service determines how many instances exist. Many real-world bugs come from accidentally creating multiple instances by providing a service in a component or lazy-loaded route when you expected a singleton."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "dependency-injection",
      "hierarchy",
      "debugging",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "rxjs-subject-vs-behaviorsubject-vs-replaysubject-vs-asyncsubject",
    "title": "Subject vs BehaviorSubject vs ReplaySubject vs AsyncSubject in Angular: when do you use which?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "All four are RxJS Subject variants, but they differ in what late subscribers receive and when values are emitted. Interviewers expect you to choose the right one based on initial value needs, replay history, completion behavior, and memory tradeoffs.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>These are all multicasting primitives, but they answer different product questions:<br>• Do I need an initial value right now?<br>• Should late subscribers see old values?<br>• Do I only care about the final value after completion?<br><br>Pick the wrong one and your UI will either miss state, replay too much history, or never emit when you expect."
        },
        {
          "type": "list",
          "columns": [
            "Type",
            "Initial value required?",
            "What a late subscriber gets",
            "Best fit"
          ],
          "rows": [
            [
              "<code>Subject</code>",
              "No",
              "Only future emissions",
              "Fire-and-forget events (click intents, toast triggers)"
            ],
            [
              "<code>BehaviorSubject</code>",
              "Yes",
              "Latest value immediately",
              "Current UI state (selected tab, auth status, filter value)"
            ],
            [
              "<code>ReplaySubject(n)</code>",
              "No",
              "Last <code>n</code> values",
              "History/buffer use-cases (chat stream, recent actions)"
            ],
            [
              "<code>AsyncSubject</code>",
              "No",
              "Final value only, and only after completion",
              "One-shot workflows where only the final result matters"
            ]
          ],
          "caption": "The interview-grade difference in one table"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Subject, BehaviorSubject, ReplaySubject, AsyncSubject } from 'rxjs';\n\n// 1) Subject: event bus for \"do something now\" signals\nconst refreshClick$ = new Subject<void>();\n\n// 2) BehaviorSubject: always has a current state value\nconst selectedTheme$ = new BehaviorSubject<'light' | 'dark'>('light');\n\n// 3) ReplaySubject: keep last N values for late subscribers\nconst recentSearches$ = new ReplaySubject<string>(3);\n\n// 4) AsyncSubject: emit only final value when complete() is called\nconst finalReport$ = new AsyncSubject<string>();\nfinalReport$.next('draft');\nfinalReport$.next('final');\nfinalReport$.complete(); // subscribers receive only 'final'"
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "Pick",
            "Why"
          ],
          "rows": [
            [
              "Button click intent stream",
              "<code>Subject</code>",
              "No initial or replayed value needed"
            ],
            [
              "Store current search/filter state",
              "<code>BehaviorSubject</code>",
              "New subscribers need immediate current value"
            ],
            [
              "Keep a short in-memory event history",
              "<code>ReplaySubject(2-5)</code>",
              "Late subscribers need recent context"
            ],
            [
              "Only publish final batch/job result",
              "<code>AsyncSubject</code>",
              "Intermediate values are noise"
            ]
          ],
          "caption": "Fast decision guide for real Angular code"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Injectable } from '@angular/core';\nimport { BehaviorSubject, Subject } from 'rxjs';\n\n@Injectable({ providedIn: 'root' })\nexport class SearchUiStore {\n  private readonly querySubject = new BehaviorSubject<string>('');\n  readonly query$ = this.querySubject.asObservable();\n\n  private readonly refreshSubject = new Subject<void>();\n  readonly refresh$ = this.refreshSubject.asObservable();\n\n  setQuery(value: string): void {\n    this.querySubject.next(value);\n  }\n\n  refresh(): void {\n    this.refreshSubject.next();\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "Common pitfall",
            "Why it hurts",
            "Fix"
          ],
          "rows": [
            [
              "Using <code>BehaviorSubject</code> with a fake default like <code>null</code>",
              "Consumers must handle meaningless initial states everywhere",
              "Use <code>ReplaySubject(1)</code> if no true initial value exists"
            ],
            [
              "Using large <code>ReplaySubject</code> buffers in long-lived services",
              "Memory grows and old state lingers too long",
              "Keep buffer small and intentional"
            ],
            [
              "Choosing <code>AsyncSubject</code> for never-ending streams",
              "No value is emitted because completion never happens",
              "Use <code>BehaviorSubject</code>/<code>ReplaySubject</code> for ongoing streams"
            ],
            [
              "Exposing the Subject itself publicly",
              "Any consumer can call <code>next()</code> and break state discipline",
              "Keep Subject private and expose only <code>asObservable()</code>"
            ]
          ],
          "caption": "Mistakes that show up in production code reviews"
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br><code>Subject</code> = live events only. <code>BehaviorSubject</code> = current value + future updates. <code>ReplaySubject</code> = recent history + future updates. <code>AsyncSubject</code> = only final value on completion. In Angular, default to BehaviorSubject for local UI state, Subject for intent events, and ReplaySubject only when you truly need history."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "rxjs",
      "observables",
      "state",
      "basics"
    ],
    "updatedAt": "2026-02-26",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Subject vs BehaviorSubject vs ReplaySubject vs AsyncSubject in Angular (RxJS)",
      "description": "Understand when to use Subject, BehaviorSubject, ReplaySubject, and AsyncSubject in Angular with practical examples, tradeoffs, and common interview pitfalls."
    }
  },
  {
    "id": "rxjs-tap-vs-map-angular-when-to-use",
    "title": "RxJS tap vs map in Angular: side effects vs transformation (with real examples)",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "tap and map are frequently confused in Angular RxJS pipelines. map transforms emitted values; tap runs side effects without changing emissions. Interviewers use this to test stream thinking, operator intent, and your ability to avoid subtle production bugs.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>If you’re unsure which one to use, ask one question: <strong>“Should the next operator receive a different value?”</strong><br><br>If yes, use <code>map</code>. If no, and you only need a side effect (logging, loading flags, analytics), use <code>tap</code>."
        },
        {
          "type": "list",
          "columns": [
            "Rule",
            "map",
            "tap"
          ],
          "rows": [
            [
              "Changes emitted value?",
              "✅ Yes",
              "❌ No (passes through original value)"
            ],
            [
              "Primary purpose",
              "Transform data",
              "Run side effects (log, metrics, local state flags)"
            ],
            [
              "Purity expectation",
              "Prefer pure deterministic functions",
              "Can be impure (side effects), but keep intent explicit"
            ],
            [
              "Typical Angular usage",
              "DTO -> view model mapping",
              "Set loading flags, debug, analytics pings"
            ]
          ],
          "caption": "The practical difference interviewers care about"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { catchError, debounceTime, distinctUntilChanged, finalize, map, of, switchMap, tap } from 'rxjs';\n\ntype UserDto = { id: string; full_name: string };\ntype UserVm = { id: string; name: string };\n\nthis.results$ = this.searchControl.valueChanges.pipe(\n  debounceTime(250),\n  distinctUntilChanged(),\n\n  // side effect (does not change stream value)\n  tap(() => this.isLoading = true),\n\n  switchMap(query =>\n    this.http.get<UserDto[]>(`/api/users?q=${encodeURIComponent(query)}`).pipe(\n      // transformation (changes value type/shape)\n      map(dtos => dtos.map(d => ({ id: d.id, name: d.full_name }) as UserVm)),\n      catchError(() => of([] as UserVm[])),\n      finalize(() => this.isLoading = false)\n    )\n  )\n);"
        },
        {
          "type": "text",
          "text": "<strong>Common trap #1</strong><br><br><code>tap</code> does not transform values. Returning a value inside <code>tap</code> is ignored:"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "of(2).pipe(\n  tap(v => v * 10) // ignored\n).subscribe(console.log); // prints 2, not 20"
        },
        {
          "type": "text",
          "text": "Use <code>map</code> when the emitted value must change:"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "of(2).pipe(\n  map(v => v * 10)\n).subscribe(console.log); // prints 20"
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "Choose",
            "Why"
          ],
          "rows": [
            [
              "Convert API response shape",
              "<code>map</code>",
              "You need a new emitted value"
            ],
            [
              "Log values during debugging",
              "<code>tap</code>",
              "Observation without altering data"
            ],
            [
              "Set <code>isLoading</code>, emit telemetry, debug stream values",
              "<code>tap</code> (+ <code>finalize</code>)",
              "Imperative side effects belong outside transformations"
            ],
            [
              "Compute derived fields",
              "<code>map</code>",
              "Pure data shaping keeps pipeline predictable"
            ]
          ],
          "caption": "Fast decision guide for day-to-day Angular code"
        },
        {
          "type": "list",
          "columns": [
            "Common mistake",
            "Why it hurts",
            "Fix"
          ],
          "rows": [
            [
              "Encoding/normalizing data inside <code>tap</code>",
              "Other developers assume <code>tap</code> is non-transforming; pipeline intent becomes misleading",
              "Move data shaping to <code>map</code>"
            ],
            [
              "Mutating objects in <code>tap</code>",
              "Hidden shared-state bugs and OnPush surprises",
              "Create new objects in <code>map</code> (immutable style)"
            ],
            [
              "Forgetting to return in <code>map</code>",
              "Emits <code>undefined</code> unexpectedly",
              "Always return transformed value from <code>map</code>"
            ],
            [
              "Using <code>tap</code> for critical logic while assuming it always runs",
              "No subscription means pipeline never executes",
              "Ensure stream is consumed (<code>async</code> pipe or explicit subscribe)"
            ]
          ],
          "caption": "Production footguns to avoid"
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br><code>map</code> is for transformation; <code>tap</code> is for side effects. A clean stream keeps data-shaping logic in <code>map</code> and keeps <code>tap</code> for observability/imperative work. That boundary is what makes RxJS code readable, testable, and safer in real Angular apps."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "rxjs",
      "operators",
      "transformations",
      "basics"
    ],
    "updatedAt": "2026-02-26",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "RxJS tap vs map in Angular: Difference, Use Cases, and Best Practices",
      "description": "Learn tap vs map in RxJS for Angular with practical examples. Understand side effects vs transformation, where to place each operator, and common mistakes asked in interviews."
    }
  },
  {
    "id": "ngrx-data-flow-end-to-end-angular",
    "title": "NgRx data flow end-to-end in Angular: actions, reducers, effects, selectors",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "NgRx data flow in Angular follows a predictable loop: component dispatches actions, reducers create the next immutable state, selectors read and derive view data, and effects handle async side effects before dispatching success/failure actions. This is the core actions-reducers-effects-selectors flow interviewers expect.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core mental model</strong><br><br>Think of NgRx as a one-way loop:<br><br><code>Component event -> dispatch(action) -> reducer computes new state -> selector derives VM -> template renders</code><br><br>Effects run <em>beside</em> this loop for async work (HTTP, analytics, router side effects), then dispatch follow-up actions like success/failure."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "Who does it",
            "What happens",
            "Why it matters"
          ],
          "rows": [
            [
              "1. UI intent",
              "Component",
              "User clicks/searches; component dispatches an action",
              "Events become explicit and traceable"
            ],
            [
              "2. State transition",
              "Reducer",
              "Pure function returns next immutable state",
              "Predictable updates and easy debugging"
            ],
            [
              "3. Async side effect",
              "Effect",
              "Listens to action, calls API, dispatches success/failure",
              "Keeps reducers pure and components thin"
            ],
            [
              "4. Read model",
              "Selector",
              "Memoized selection/derivation from store state",
              "Performance + reusable view logic"
            ],
            [
              "5. Render",
              "Template + async pipe",
              "Subscribes to selector output and updates UI",
              "Reactive view with minimal manual subscriptions"
            ]
          ],
          "caption": "NgRx data flow diagram (end-to-end loop)"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// books.actions.ts\nimport { createAction, props } from '@ngrx/store';\n\nexport const loadBooks = createAction('[Books Page] Load Books');\nexport const loadBooksSuccess = createAction(\n  '[Books API] Load Books Success',\n  props<{ books: Book[] }>()\n);\nexport const loadBooksFailure = createAction(\n  '[Books API] Load Books Failure',\n  props<{ error: string }>()\n);\n\n// books.reducer.ts\nimport { createReducer, on } from '@ngrx/store';\n\nexport interface BooksState {\n  books: Book[];\n  loading: boolean;\n  error: string | null;\n}\n\nexport const initialState: BooksState = {\n  books: [],\n  loading: false,\n  error: null\n};\n\nexport const booksReducer = createReducer(\n  initialState,\n  on(loadBooks, state => ({ ...state, loading: true, error: null })),\n  on(loadBooksSuccess, (state, { books }) => ({ ...state, books, loading: false })),\n  on(loadBooksFailure, (state, { error }) => ({ ...state, error, loading: false }))\n);\n\n// books.effects.ts\nimport { Injectable, inject } from '@angular/core';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { catchError, map, of, switchMap } from 'rxjs';\n\n@Injectable()\nexport class BooksEffects {\n  private actions$ = inject(Actions);\n  private api = inject(BooksApiService);\n\n  loadBooks$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(loadBooks),\n      switchMap(() =>\n        this.api.getBooks().pipe(\n          map(books => loadBooksSuccess({ books })),\n          catchError(err => of(loadBooksFailure({ error: String(err) })))\n        )\n      )\n    )\n  );\n}\n\n// books.selectors.ts\nimport { createFeatureSelector, createSelector } from '@ngrx/store';\n\nexport const selectBooksState = createFeatureSelector<BooksState>('books');\nexport const selectBooks = createSelector(selectBooksState, s => s.books);\nexport const selectLoading = createSelector(selectBooksState, s => s.loading);\nexport const selectError = createSelector(selectBooksState, s => s.error);\nexport const selectVm = createSelector(\n  selectBooks,\n  selectLoading,\n  selectError,\n  (books, loading, error) => ({ books, loading, error, total: books.length })\n);\n\n// books-page.component.ts\nimport { ChangeDetectionStrategy, Component, inject } from '@angular/core';\nimport { Store } from '@ngrx/store';\n\n@Component({\n  selector: 'app-books-page',\n  template: `\n    <button (click)=\"reload()\">Reload</button>\n\n    <ng-container *ngIf=\"vm$ | async as vm\">\n      <p *ngIf=\"vm.loading\">Loading...</p>\n      <p *ngIf=\"vm.error\">Error: {{ vm.error }}</p>\n      <p>Total: {{ vm.total }}</p>\n      <li *ngFor=\"let b of vm.books\">{{ b.title }}</li>\n    </ng-container>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class BooksPageComponent {\n  private store = inject(Store);\n  readonly vm$ = this.store.select(selectVm);\n\n  ngOnInit(): void {\n    this.store.dispatch(loadBooks());\n  }\n\n  reload(): void {\n    this.store.dispatch(loadBooks());\n  }\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Common mistake",
            "Why it breaks",
            "Fix"
          ],
          "rows": [
            [
              "Putting HTTP in reducers",
              "Reducers must be synchronous and pure",
              "Move async work to effects"
            ],
            [
              "Doing heavy mapping in components",
              "Duplicates logic and hurts performance",
              "Use memoized selectors for derived view models"
            ],
            [
              "Subscribing manually everywhere",
              "Leak risk and boilerplate",
              "Use <code>store.select(...)</code> + <code>async</code> pipe"
            ],
            [
              "Dispatching vague action names",
              "Hard to trace intent in DevTools",
              "Use event-style action naming (<code>[Source] Event</code>)"
            ]
          ],
          "caption": "What interviewers flag quickly"
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br>In Angular state management with NgRx, components dispatch actions for user intent, reducers compute next immutable state, selectors expose memoized read models, and templates render selector output. Effects handle async side effects and dispatch success/failure actions back into the same loop. If you can explain that loop clearly, you understand NgRx data flow."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "store",
      "selectors",
      "effects",
      "state-management"
    ],
    "updatedAt": "2026-02-26",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "NgRx Data Flow in Angular: Actions, Reducers, Effects, Selectors",
      "description": "Learn the end-to-end NgRx data flow in Angular: component dispatch, reducer state updates, effect side effects, selector memoization, and view rendering with success/failure action loops."
    }
  },
  {
    "id": "ngrx-store-vs-component-state-angular-when-to-use",
    "title": "NgRx Store vs local component state in Angular: global vs local, and when to use NgRx",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "One of the most practical Angular state management decisions is choosing NgRx Store vs local component state. Use local state for short-lived UI details and use Store for shared, long-lived, globally relevant state. Interviewers expect clear rules for global vs local state in Angular and when NgRx is worth it.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Don’t ask “Is NgRx good or bad?” Ask: <strong>“Who needs this state, how long should it live, and does it need traceable transitions?”</strong><br><br>If state is screen-local and short-lived, keep it in the component. If it is shared, persistent, or business-critical across features, move it to Store."
        },
        {
          "type": "list",
          "columns": [
            "State example",
            "Best home",
            "Why"
          ],
          "rows": [
            [
              "Modal open/close",
              "Component local state",
              "Purely visual, page-specific, short lifetime"
            ],
            [
              "Form draft on one screen",
              "Component local state (or form state service)",
              "Usually local workflow; avoid global complexity too early"
            ],
            [
              "Authenticated user/session",
              "NgRx Store",
              "Needed across app (header, guards, permissions, API flows)"
            ],
            [
              "Shared filters used by multiple pages/widgets",
              "NgRx Store (or URL + Store facade)",
              "Multiple consumers need consistent synchronized state"
            ],
            [
              "Server-backed entity cache (users/orders/products)",
              "NgRx Store",
              "Shared read model, dedupe/loading/error handling, normalized updates"
            ]
          ],
          "caption": "Decision matrix: global vs local state in Angular"
        },
        {
          "type": "list",
          "columns": [
            "Put it in Store if...",
            "Why this is a good signal"
          ],
          "rows": [
            [
              "More than one feature/component tree needs it",
              "Store gives a single source of truth"
            ],
            [
              "You need time-travel/debuggable action history",
              "Actions + reducers make transitions explicit"
            ],
            [
              "You need robust loading/error/retry flows for shared data",
              "Effects + selectors centralize async behavior and read models"
            ],
            [
              "You need derived state reused across screens",
              "Memoized selectors prevent duplicated transformation logic"
            ],
            [
              "State must survive route changes or be rehydrated",
              "Global state lifetime matches app-level concerns"
            ]
          ],
          "caption": "Practical rule set for when to use NgRx"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example split: local UI state + global business state\n@Component({\n  selector: 'app-products-page',\n  template: `...`\n})\nexport class ProductsPageComponent {\n  // local UI state (ephemeral)\n  isFilterPanelOpen = false;\n\n  // global shared state (Store)\n  readonly vm$ = this.store.select(selectProductsVm);\n\n  constructor(private store: Store) {}\n\n  ngOnInit(): void {\n    this.store.dispatch(loadProducts());\n  }\n\n  onFilterChanged(filter: ProductFilter): void {\n    this.store.dispatch(setSharedProductFilter({ filter }));\n  }\n\n  togglePanel(): void {\n    this.isFilterPanelOpen = !this.isFilterPanelOpen;\n  }\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Anti-pattern",
            "Why it hurts",
            "Better approach"
          ],
          "rows": [
            [
              "Putting every tiny UI flag in Store",
              "Action/reducer noise, slower iteration, harder readability",
              "Keep ephemeral view state in component"
            ],
            [
              "Keeping cross-feature business state in random components",
              "Duplicate logic, drift, race conditions between screens",
              "Promote to Store with selectors/effects"
            ],
            [
              "Using Store as a dump of raw API payloads only",
              "Components become transformation-heavy and inconsistent",
              "Create memoized selectors for derived view models"
            ],
            [
              "Mixing local and global ownership without boundaries",
              "Unclear source of truth and hard-to-debug updates",
              "Document state ownership per feature"
            ]
          ],
          "caption": "What senior reviewers usually call out"
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br>Use local component state for UI-ephemeral, screen-specific concerns. Use NgRx Store for shared, durable, business-relevant state that multiple parts of the app depend on. The best architecture is mixed: local for view mechanics, Store for app-level truth."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "store",
      "state-management",
      "architecture",
      "basics"
    ],
    "updatedAt": "2026-02-26",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "NgRx Store vs Component State in Angular: Global vs Local State",
      "description": "Learn when to use NgRx Store vs local component state in Angular with a practical decision matrix: modal state, form drafts, auth user, shared filters, and server cache."
    }
  },
  {
    "id": "ngrx-reducer-pure-function-immutability-side-effects",
    "title": "NgRx reducer pure function in practice: immutability, side effects, and common mistakes",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "A reducer in NgRx must be a pure function: same input state + action must always produce the same next state, with no side effects. Interviewers test reducer immutability and whether you can spot forbidden reducer side effects like mutation, Math.random(), HTTP, router navigation, and service calls.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>An NgRx reducer is a synchronous, deterministic state transition function. It should only compute the next immutable state from <code>(state, action)</code>. If it reaches outside (network, router, random values, services), it is no longer a pure reducer."
        },
        {
          "type": "list",
          "columns": [
            "Forbidden in reducers",
            "Why it is wrong",
            "Where it belongs"
          ],
          "rows": [
            [
              "State mutation (<code>push</code>, direct assignment, in-place edits)",
              "Breaks immutability and memoization assumptions",
              "Return new objects/arrays in reducer"
            ],
            [
              "<code>Math.random()</code> / time-dependent values",
              "Same input may produce different output",
              "Generate IDs/timestamps before dispatch or in effects"
            ],
            [
              "HTTP calls",
              "Async side effect inside supposedly pure function",
              "Effects"
            ],
            [
              "Router navigation",
              "External side effect not a state calculation",
              "Effects or component/facade orchestration"
            ],
            [
              "Service calls (analytics, storage, logging APIs)",
              "Leaks imperative side effects into reducer",
              "Effects or dedicated services triggered elsewhere"
            ]
          ],
          "caption": "Reducer purity guardrails"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// ❌ Bad reducer: impure + mutating\nexport const ordersReducer = createReducer(\n  initialState,\n  on(placeOrder, (state, { item, router, api, audit }) => {\n    state.orders.push(item); // mutation\n\n    const id = Math.random().toString(36).slice(2); // non-deterministic\n\n    api.postOrder(item).subscribe(); // HTTP side effect\n    router.navigate(['/orders', id]); // navigation side effect\n    audit.track('order_placed', item); // service side effect\n\n    return state; // same reference returned\n  })\n);"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// ✅ Good reducer: pure + immutable\nexport interface OrdersState {\n  orders: Array<{ id: string; name: string }>;\n  loading: boolean;\n  error: string | null;\n}\n\nexport const initialState: OrdersState = {\n  orders: [],\n  loading: false,\n  error: null\n};\n\nexport const ordersReducer = createReducer(\n  initialState,\n  on(placeOrder, state => ({ ...state, loading: true, error: null })),\n  on(placeOrderSuccess, (state, { order }) => ({\n    ...state,\n    orders: [...state.orders, order],\n    loading: false\n  })),\n  on(placeOrderFailure, (state, { error }) => ({ ...state, error, loading: false }))\n);"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// ✅ Side effects move to effects\n@Injectable()\nexport class OrdersEffects {\n  placeOrder$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(placeOrder),\n      switchMap(({ draft }) =>\n        this.api.postOrder(draft).pipe(\n          map(order => placeOrderSuccess({ order })),\n          catchError(err => of(placeOrderFailure({ error: String(err) })))\n        )\n      )\n    )\n  );\n\n  navigateOnSuccess$ = createEffect(\n    () =>\n      this.actions$.pipe(\n        ofType(placeOrderSuccess),\n        tap(({ order }) => this.router.navigate(['/orders', order.id]))\n      ),\n    { dispatch: false }\n  );\n\n  constructor(\n    private actions$: Actions,\n    private api: OrdersApiService,\n    private router: Router\n  ) {}\n}"
        },
        {
          "type": "list",
          "columns": [
            "Reducer purity checklist",
            "Pass condition"
          ],
          "rows": [
            [
              "Deterministic output",
              "Same state + action always yields same next state"
            ],
            [
              "No mutation",
              "Original state untouched; new references returned"
            ],
            [
              "No async work",
              "No HTTP/subscription/promise in reducer"
            ],
            [
              "No framework side effects",
              "No router navigation, no service invocations"
            ],
            [
              "Synchronous and small",
              "Just state transition logic, nothing else"
            ]
          ],
          "caption": "Quick review rubric before merge"
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br>An NgRx reducer pure function does one thing: compute next immutable state. It must avoid mutation and all side effects, including <code>Math.random()</code>, HTTP, router calls, and service usage. Put side effects in effects, keep reducers deterministic, and selector memoization and debugging stay reliable."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "store",
      "state-management",
      "effects",
      "basics"
    ],
    "updatedAt": "2026-02-26",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "NgRx Reducer Pure Function: Immutability and Side Effects Explained",
      "description": "Learn NgRx reducer purity in practice: reducer immutability rules, forbidden reducer side effects, and bad vs good reducer examples with a production checklist."
    }
  },
  {
    "id": "ngrx-selectors-memoization-derived-state-performance",
    "title": "NgRx selectors beyond getting state: memoization, derived state, and Angular performance",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "NgRx selectors are not just state getters. They create memoized, composable read models that power derived state in Angular apps. Interviewers expect you to explain selector composition, NgRx selector memoization behavior, and why this improves performance.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Selectors are your app’s <em>read layer</em>. Instead of pushing filtering/sorting/mapping logic into components, you compose selectors once and expose a memoized view model. This keeps components thin and avoids repeated recalculation."
        },
        {
          "type": "list",
          "columns": [
            "Selector level",
            "Example",
            "Responsibility"
          ],
          "rows": [
            [
              "Feature selector",
              "<code>selectProductsFeature</code>",
              "Grab one feature slice from root state"
            ],
            [
              "Entity/base selectors",
              "<code>selectEntities</code>, <code>selectIds</code>",
              "Read normalized raw state"
            ],
            [
              "Derived selectors",
              "<code>selectAllProducts</code>, <code>selectFilteredProducts</code>",
              "Transform/filter/sort domain data"
            ],
            [
              "VM selector",
              "<code>selectProductsVm</code>",
              "Return final UI-ready shape for component/template"
            ]
          ],
          "caption": "Composed selector flow: feature -> entities -> filtered/sorted VM"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { createFeatureSelector, createSelector } from '@ngrx/store';\n\ntype Product = { id: string; name: string; price: number };\ntype SortKey = 'name-asc' | 'price-desc';\n\ninterface ProductsState {\n  entities: Record<string, Product>;\n  ids: string[];\n  query: string;\n  sort: SortKey;\n  loading: boolean;\n  error: string | null;\n}\n\nconst selectProductsFeature = createFeatureSelector<ProductsState>('products');\n\nconst selectEntities = createSelector(selectProductsFeature, s => s.entities);\nconst selectIds = createSelector(selectProductsFeature, s => s.ids);\nconst selectQuery = createSelector(selectProductsFeature, s => s.query);\nconst selectSort = createSelector(selectProductsFeature, s => s.sort);\nconst selectLoading = createSelector(selectProductsFeature, s => s.loading);\nconst selectError = createSelector(selectProductsFeature, s => s.error);\n\nconst selectAllProducts = createSelector(selectIds, selectEntities, (ids, entities) =>\n  ids.map(id => entities[id])\n);\n\nconst selectFilteredProducts = createSelector(selectAllProducts, selectQuery, (products, query) => {\n  const q = query.trim().toLowerCase();\n  if (!q) return products;\n  return products.filter(p => p.name.toLowerCase().includes(q));\n});\n\nconst selectSortedProducts = createSelector(selectFilteredProducts, selectSort, (products, sort) => {\n  const copy = [...products];\n  if (sort === 'name-asc') return copy.sort((a, b) => a.name.localeCompare(b.name));\n  return copy.sort((a, b) => b.price - a.price);\n});\n\nexport const selectProductsVm = createSelector(\n  selectSortedProducts,\n  selectLoading,\n  selectError,\n  (items, loading, error) => ({ items, loading, error, total: items.length })\n);"
        },
        {
          "type": "list",
          "columns": [
            "Memoization behavior",
            "What happens",
            "Practical impact"
          ],
          "rows": [
            [
              "First evaluation",
              "Projector runs and result is cached",
              "Expected initial compute cost"
            ],
            [
              "Same input selector references",
              "Cached result returned, projector does not re-run",
              "Avoids unnecessary CPU and re-renders"
            ],
            [
              "Any input reference changes",
              "Projector re-runs once and cache is updated",
              "Recompute only when data actually changed"
            ],
            [
              "Inputs recreated every time",
              "Memoization is defeated",
              "Performance degrades and UI churn increases"
            ]
          ],
          "caption": "How NgRx selector memoization actually works"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// ❌ Pitfall: selecting whole state and rebuilding arrays/objects in component\n@Component({ selector: 'app-products', template: `...` })\nexport class ProductsComponent {\n  // broad selection + local mapping each emission\n  readonly vm$ = this.store.select(state => state).pipe(\n    map(state => {\n      const items = Object.values(state.products.entities)\n        .filter(p => p.name.includes(state.products.query))\n        .sort((a, b) => a.name.localeCompare(b.name));\n\n      return {\n        items: [...items], // new object/array every time\n        total: items.length,\n        loading: state.products.loading\n      };\n    })\n  );\n}\n\n// ✅ Better: keep composition in selectors, component only selects VM\n@Component({ selector: 'app-products', template: `...` })\nexport class ProductsComponent {\n  readonly vm$ = this.store.select(selectProductsVm);\n}"
        },
        {
          "type": "list",
          "columns": [
            "Common pitfall",
            "Why it hurts",
            "Fix"
          ],
          "rows": [
            [
              "Selecting the whole root state in components",
              "Any unrelated state change can trigger unnecessary recalculation",
              "Select the narrowest feature/VM selector"
            ],
            [
              "Doing filter/sort/map in components repeatedly",
              "Logic duplication + unstable references + harder tests",
              "Move derivation into composed selectors"
            ],
            [
              "Returning brand-new objects everywhere without need",
              "Memoization cannot help if inputs are constantly rebuilt",
              "Preserve stable references where possible and compose selectors"
            ],
            [
              "Keeping selectors too shallow (no VM selector)",
              "Components become bloated orchestration layers",
              "Create a single UI-focused VM selector"
            ]
          ],
          "caption": "Selector performance pitfalls senior reviewers spot"
        },
        {
          "type": "text",
          "text": "<strong>Interview summary</strong><br><br>NgRx selectors are a memoized read-model layer, not just property accessors. Compose selectors from feature state to entities to derived filtered/sorted data, then expose a final view model selector to components. This improves Angular selector performance, reduces component complexity, and keeps state logic reusable."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "angular",
      "store",
      "selectors",
      "memoization",
      "performance"
    ],
    "updatedAt": "2026-02-26",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "NgRx Selectors Memoization: Derived State and Angular Performance",
      "description": "Learn NgRx selectors beyond state access: composed selectors, derived state in NgRx, memoization behavior, and Angular selector performance pitfalls to avoid."
    }
  }
]
