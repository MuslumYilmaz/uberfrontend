[
  {
    "id": "angular-lifecycle-constructor-oninit-afterviewinit-dom",
    "title": "What’s the difference between constructor, ngOnInit, and ngAfterViewInit, and which one is correct for DOM/ViewChild access?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "constructor is for DI + trivial class setup, ngOnInit is for initialization that depends on inputs/bindings, and ngAfterViewInit is for work that needs the component view (DOM, ViewChild). For DOM/ViewChild access, ngAfterViewInit is usually correct—except @ViewChild({ static: true }) cases which are available earlier.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>These run at different moments in the component lifecycle. The right hook depends on what you need: DI only (constructor), inputs/bindings (ngOnInit), or the rendered view / ViewChild / DOM (ngAfterViewInit)."
        },
        {
          "type": "list",
          "columns": [
            "Hook",
            "When it runs",
            "What it’s for",
            "DOM / ViewChild availability"
          ],
          "rows": [
            [
              "<code>constructor</code>",
              "When the class instance is created (before Angular initializes bindings).",
              "Dependency injection + minimal field initialization (no Angular-dependent logic).",
              "❌ Not safe for DOM. View is not created. ViewChild not resolved."
            ],
            [
              "<code>ngOnInit()</code>",
              "Once, after Angular sets data-bound inputs (after first <code>ngOnChanges</code>).",
              "Initialization that depends on inputs, services, starting streams, fetching data.",
              "⚠️ Usually not for DOM. ViewChild only if <code>@ViewChild({ static: true })</code>."
            ],
            [
              "<code>ngAfterViewInit()</code>",
              "Once, after Angular finishes creating the component’s view + child views.",
              "Work that needs the rendered view: <code>@ViewChild</code>, DOM measurements, focus, 3rd-party widgets init.",
              "✅ Safe for DOM/ViewChild (default <code>static: false</code>)."
            ]
          ],
          "caption": "Constructor vs ngOnInit vs ngAfterViewInit"
        },
        {
          "type": "text",
          "text": "<strong>Which one is correct for DOM / ViewChild?</strong><br><br><strong>Use <code>ngAfterViewInit()</code> for DOM/ViewChild access in most cases.</strong> That’s when Angular guarantees the view exists and view queries (default <code>static: false</code>) are resolved."
        },
        {
          "type": "text",
          "text": "<strong>Important nuance: <code>@ViewChild</code> static option</strong><br><br><code>@ViewChild(..., { static: true })</code> resolves earlier (before/at init), so it can be used in <code>ngOnInit()</code> <em>if</em> the element is always present (not inside <code>*ngIf</code>/<code>*ngFor</code>). Default is <code>static: false</code>, which is available in <code>ngAfterViewInit()</code>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { AfterViewInit, Component, ElementRef, OnInit, ViewChild } from '@angular/core';\n\n@Component({\n  selector: 'app-demo',\n  template: `\n    <input #nameInput />\n    <!-- If this input were under *ngIf, static:true would be wrong -->\n  `\n})\nexport class DemoComponent implements OnInit, AfterViewInit {\n  // Case A (common): default static:false => available in ngAfterViewInit\n  @ViewChild('nameInput') nameInput?: ElementRef<HTMLInputElement>;\n\n  // Case B: static:true => available in ngOnInit (ONLY if always present)\n  // @ViewChild('nameInput', { static: true }) nameInput!: ElementRef<HTMLInputElement>;\n\n  constructor(/* inject services here */) {\n    // DI only. No DOM.\n  }\n\n  ngOnInit(): void {\n    // Good: init that depends on @Input() or services.\n    // If using static:true, you *can* access nameInput here.\n  }\n\n  ngAfterViewInit(): void {\n    // Safe place for DOM/ViewChild\n    this.nameInput?.nativeElement.focus();\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "Correct hook",
            "Why"
          ],
          "rows": [
            [
              "Read <code>@Input()</code> values, set up streams, start API calls",
              "<code>ngOnInit</code>",
              "Inputs are set; component is initialized."
            ],
            [
              "Access <code>@ViewChild</code> / measure DOM / focus element",
              "<code>ngAfterViewInit</code>",
              "View is created; queries are resolved."
            ],
            [
              "ViewChild element is always present (not under *ngIf/*ngFor) and you need it early",
              "<code>ngOnInit</code> + <code>@ViewChild({ static: true })</code>",
              "Static query resolves before init."
            ],
            [
              "Access projected content via <code>@ContentChild</code>",
              "<code>ngAfterContentInit</code>",
              "Projected content is initialized (different from the view)."
            ]
          ],
          "caption": "Picking the right lifecycle hook"
        },
        {
          "type": "text",
          "text": "<strong>Common pitfall</strong><br><br>If you change a bound value inside <code>ngAfterViewInit</code>, you can trigger <code>ExpressionChangedAfterItHasBeenCheckedError</code> in dev mode. Fix by avoiding sync bound mutations there, or scheduling them (microtask) / triggering a follow-up change detection deliberately (advanced)."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>constructor</code> = DI + minimal setup. <code>ngOnInit</code> = initialization that depends on inputs/bindings. <code>ngAfterViewInit</code> = anything that needs the rendered view (DOM, <code>ViewChild</code>). For DOM/ViewChild access, <strong>ngAfterViewInit is the default correct choice</strong>, with the exception of <code>@ViewChild({ static: true })</code> when the element is guaranteed to exist."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-vs-angularjs",
    "title": "What is the difference between Angular and AngularJS?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Angular (also known as Angular 2+) is a complete rewrite of AngularJS (Angular 1.x). While AngularJS is based on JavaScript and the Model-View-Controller (MVC) pattern, Angular is built using TypeScript and follows a component-based architecture with enhanced performance, modularity, and maintainability.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Angular and AngularJS are both frameworks developed by Google, but they are fundamentally different technologies. AngularJS (released in 2010) was designed for simpler web applications using JavaScript and the MVC model. Angular (released in 2016) is a complete reimagining of the framework, using TypeScript, a modern component architecture, and advanced features like RxJS and Ahead-of-Time (AOT) compilation."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "AngularJS (1.x)",
            "Angular (2+)"
          ],
          "rows": [
            [
              "Language",
              "Written in JavaScript (ES5).",
              "Written in TypeScript, a superset of JavaScript offering static typing."
            ],
            [
              "Architecture",
              "Follows MVC or MVVM design patterns.",
              "Uses a component-based architecture for modular and reusable code."
            ],
            [
              "Mobile Support",
              "Limited; not designed for mobile apps.",
              "Built with mobile-first performance optimization."
            ],
            [
              "Performance",
              "Two-way data binding for all elements, which can slow large apps.",
              "Improved with unidirectional data flow and a more efficient change detection mechanism."
            ],
            [
              "Dependency Injection",
              "Basic and less flexible.",
              "Robust dependency injection system for scalable applications."
            ],
            [
              "Routing",
              "Uses third-party libraries for routing.",
              "Includes a built-in and powerful Angular Router."
            ],
            [
              "Templating",
              "Uses strings with expressions inside HTML.",
              "Uses powerful, declarative templates with structural directives like *ngIf and *ngFor."
            ],
            [
              "Tooling",
              "No CLI; manual setup required.",
              "Includes Angular CLI for project scaffolding, builds, and testing."
            ],
            [
              "Versioning",
              "Single major version (1.x).",
              "Actively maintained with continuous updates (Angular 2+)."
            ],
            [
              "Learning Curve",
              "Easier for small apps but limited for large-scale development.",
              "More complex initially, but better suited for enterprise applications."
            ]
          ],
          "caption": "Major differences between AngularJS and Angular"
        },
        {
          "type": "text",
          "text": "<strong>Why Angular Replaced AngularJS</strong><br>AngularJS’s digest cycle and two-way binding mechanism caused performance bottlenecks in large-scale apps. Angular was rebuilt from scratch to overcome these limitations, adopting a modular approach with better dependency management, improved performance, and compatibility with modern browsers and tools."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- AngularJS syntax -->\n<div ng-app=\"app\" ng-controller=\"MainCtrl\">\n  <h1>{{ message }}</h1>\n</div>\n\n<!-- Angular syntax -->\n<app-root></app-root>\n\n// Angular components are defined in TypeScript rather than JavaScript controllers."
        },
        {
          "type": "text",
          "text": "<strong>Key Improvements in Angular</strong><br><ul><li>Component-based structure improves reusability and maintainability.</li><li>Enhanced tooling with Angular CLI for faster development.</li><li>Reactive programming support through RxJS for handling asynchronous data.</li><li>Faster rendering and improved performance with Ahead-of-Time compilation.</li><li>Stronger typing and IntelliSense support with TypeScript integration.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> In short: AngularJS introduced the idea of declarative web apps, while Angular made it scalable, maintainable, and ready for modern web development."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>AngularJS is JavaScript-based and uses controllers and scopes.</li><li>Angular is TypeScript-based and uses components and modules.</li><li>Angular offers better performance, scalability, and developer tooling.</li><li>They are not backward-compatible — migrating requires rewriting major parts of the application.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-component-vs-service-responsibilities",
    "title": "What responsibilities belong inside an Angular component vs a service?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Angular components should focus on UI/presentation and user interactions, while services should hold reusable logic, business rules, and side effects (HTTP, caching, state). Clean separation keeps components thin, improves testability, and avoids duplicated logic across the app.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Use <strong>components</strong> for rendering + wiring UI events to actions. Use <strong>services</strong> for reusable logic and side effects (HTTP, caching, state, orchestration). A good component reads like a “view model composer”, not a mini back-end."
        },
        {
          "type": "list",
          "columns": [
            "Area",
            "Component (belongs here)",
            "Service (belongs here)"
          ],
          "rows": [
            [
              "UI rendering",
              "Template bindings, UI composition, structural directives, view-only formatting",
              "No DOM/template concerns"
            ],
            [
              "User interaction",
              "Click handlers, form submit handlers, mapping UI events → intent/actions",
              "Input validation rules that are reusable across screens"
            ],
            [
              "State",
              "Ephemeral UI state (open/closed, selected tab, local filters, loading flags for UI)",
              "Shared/stateful app logic (cache, session data, cross-component state), facades"
            ],
            [
              "Business rules",
              "Minimal (only what’s needed to connect UI to rules)",
              "Core rules (pricing logic, permission checks, normalization, mapping DTO→domain)"
            ],
            [
              "Data access",
              "Never call low-level APIs directly (avoid HttpClient usage in components)",
              "HTTP calls, retries, error mapping, caching, request dedupe"
            ],
            [
              "Reusability",
              "Rare (components can be reusable, but should avoid app-specific business logic)",
              "High (same service can be used by multiple components)"
            ],
            [
              "Testing",
              "Shallow: assert template bindings + event wiring + observable usage",
              "Deep: unit test rules/side effects without rendering"
            ]
          ],
          "caption": "Component vs Service responsibilities"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>If the code depends on <strong>how something is shown</strong> (DOM, template state, view events) → component. If it depends on <strong>what something means</strong> (rules, data fetching, caching, orchestration) → service."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// user.service.ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, shareReplay } from 'rxjs';\n\nexport interface UserDto { id: string; name: string; }\nexport interface User { id: string; displayName: string; }\n\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private users$?: Observable<User[]>;\n\n  constructor(private http: HttpClient) {}\n\n  getUsers(): Observable<User[]> {\n    // Cache + dedupe requests for this session\n    this.users$ ??= this.http.get<UserDto[]>('/api/users').pipe(\n      // Business mapping belongs here (or a dedicated mapper)\n      // so multiple components get consistent data.\n      // Keep mapping pure.\n      // DTO -> domain model:\n      // (If mapping grows, extract to a pure function.)\n      shareReplay({ bufferSize: 1, refCount: true })\n    ) as unknown as Observable<User[]>;\n\n    return this.users$;\n  }\n}"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// user-list.component.ts\nimport { Component, ChangeDetectionStrategy } from '@angular/core';\nimport { Observable, map, startWith } from 'rxjs';\nimport { UserService, User } from './user.service';\n\n@Component({\n  selector: 'app-user-list',\n  templateUrl: './user-list.component.html',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserListComponent {\n  // UI state belongs here\n  readonly search = '';\n\n  // Data stream comes from a service\n  readonly users$: Observable<User[]> = this.userService.getUsers();\n\n  // UI-only derived state can be computed in the component\n  // (keep it cheap; heavy transforms should be in a service/facade)\n  readonly viewModel$ = this.users$.pipe(\n    map(users => ({\n      users,\n      total: users.length\n    })),\n    startWith({ users: [], total: 0 })\n  );\n\n  constructor(private userService: UserService) {}\n\n  onRefreshClick(): void {\n    // UI intent: trigger refresh.\n    // If refresh needs side-effects (invalidate cache), expose that from the service.\n    // e.g. this.userService.invalidateUsersCache();\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "Common mistake",
            "Why it hurts",
            "Fix"
          ],
          "rows": [
            [
              "HttpClient calls inside components",
              "Duplicates logic, makes components hard to test and reuse",
              "Move data access to a service/facade"
            ],
            [
              "Business rules in templates (complex expressions)",
              "Hard to read, hard to test, runs every CD cycle",
              "Compute in TS (component for UI-only, service for reusable rules)"
            ],
            [
              "Services manipulating the DOM",
              "Breaks separation, complicates SSR/testing",
              "Keep DOM work in components/directives; services stay UI-agnostic"
            ],
            [
              "“God component” that owns everything",
              "Becomes unmaintainable; PRs become risky",
              "Extract services + presentational components; keep the container thin"
            ]
          ],
          "caption": "Typical boundary violations"
        },
        {
          "type": "text",
          "text": "<strong>Extra nuance: service scope</strong><br><br>Most services are singletons (<code>providedIn: 'root'</code>). If you need per-component instance state (e.g., a wizard session), provide the service at the component level via <code>providers: [WizardStateService]</code> so each component instance gets its own copy."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Keep components focused on UI + event wiring + lightweight view-model shaping. Put reusable logic, side effects, data access, and business rules into services (or facades). This separation improves testability, reuse, and long-term maintainability."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-component-metadata",
    "title": "What metadata does @Component provide, and why does Angular need it?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "The @Component decorator attaches metadata to a TypeScript class so Angular can treat it as a component. This metadata tells Angular how to render the view (template + styles), how to match it in HTML (selector), what dependencies it can use (imports/providers), and how to run it (change detection, encapsulation, host bindings). Angular needs this because a plain class doesn’t contain enough information to compile and instantiate a UI component.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>@Component({...})</code> is configuration for Angular’s compiler/runtime. It turns a plain class into something Angular can: (1) match in templates, (2) compile into render instructions, and (3) instantiate with the right DI scope and runtime behavior."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, ChangeDetectionStrategy, ViewEncapsulation } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  standalone: true,\n  imports: [],\n  template: `\n    <article class=\"card\">\n      <h3>{{ name }}</h3>\n    </article>\n  `,\n  styles: [`.card { padding: 12px; }`],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.Emulated,\n  providers: [],\n  host: { '[class.highlight]': 'highlight' }\n})\nexport class UserCardComponent {\n  name = 'Ada';\n  highlight = false;\n}"
        },
        {
          "type": "list",
          "columns": [
            "Metadata field",
            "What it tells Angular",
            "Why it matters"
          ],
          "rows": [
            [
              "<code>selector</code>",
              "How this component is referenced in templates (e.g. <code>&lt;app-user-card&gt;</code>).",
              "Without it, Angular can’t match your class to an element in the DOM/template."
            ],
            [
              "<code>template</code> / <code>templateUrl</code>",
              "The view structure to compile and render.",
              "Angular compiles it into efficient render instructions; the class alone has no view."
            ],
            [
              "<code>styles</code> / <code>styleUrls</code>",
              "The component’s CSS.",
              "Angular can scope/apply styles according to encapsulation settings."
            ],
            [
              "<code>standalone</code> + <code>imports</code>",
              "Which directives/pipes/components are available in this template (standalone world).",
              "Defines template dependency scope; missing imports means compile/runtime errors."
            ],
            [
              "<code>providers</code>",
              "DI providers scoped to this component subtree.",
              "Controls service lifetime/scope (component-level instances vs root singletons)."
            ],
            [
              "<code>changeDetection</code>",
              "How Angular runs change detection for this component.",
              "Affects performance + update semantics (e.g., <code>OnPush</code> vs default)."
            ],
            [
              "<code>encapsulation</code>",
              "How styles are scoped (Emulated/None/ShadowDom).",
              "Prevents style bleeding (or intentionally allows it)."
            ],
            [
              "<code>host</code> / <code>hostDirectives</code>",
              "Host bindings/listeners and composition on the host element.",
              "Lets Angular wire DOM behavior without manual imperative DOM code."
            ],
            [
              "<code>animations</code>",
              "Animation triggers available for this component.",
              "Angular needs to register triggers so the runtime can execute them."
            ]
          ],
          "caption": "Common @Component metadata and what each part configures"
        },
        {
          "type": "text",
          "text": "<strong>Why Angular needs this metadata</strong><br><br>A component is not “just a class” in Angular. Angular must know: (1) what DOM tag/selector maps to this class, (2) what template to compile, (3) what dependencies are allowed in that template, (4) what DI scope to use, and (5) how to run runtime behaviors like change detection and style scoping. None of that is inferable reliably from TypeScript code alone."
        },
        {
          "type": "list",
          "columns": [
            "Angular uses metadata to...",
            "Concrete outcome"
          ],
          "rows": [
            [
              "Compile templates (AOT/JIT) into render instructions",
              "Fast runtime rendering; template errors are caught early in AOT builds."
            ],
            [
              "Create an internal component definition (Ivy)",
              "Angular generates internal definitions (e.g., the compiled component factory/definition) that drive creation + updates."
            ],
            [
              "Resolve template dependency scope",
              "Standalone <code>imports</code> (or NgModule declarations/imports) decide what directives/pipes are legal in the template."
            ],
            [
              "Build the DI boundary",
              "Component-level <code>providers</code> create a scoped injector for the component subtree."
            ],
            [
              "Apply runtime policies",
              "<code>OnPush</code>, encapsulation, host bindings, animations all change runtime behavior."
            ]
          ],
          "caption": "What Angular actually does with @Component metadata"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>@Component</code> metadata is the contract between your class and Angular’s compiler/runtime: how to find it (<code>selector</code>), how to render it (<code>template</code>/<code>styles</code>), what it can use (<code>imports</code>/<code>providers</code>), and how it behaves (<code>changeDetection</code>/<code>encapsulation</code>/<code>host</code>). Angular needs it because the framework must compile and instantiate UI components deterministically."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-ngmodules-vs-standalone",
    "title": "What problems do NgModules solve that standalone components don’t?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Standalone components remove the need for NgModules for most app composition, routing, and DI setup. NgModules still solve a few practical problems: packaging legacy (non-standalone) declarations, consuming module-based third-party libraries (forRoot/forChild), and providing a single import/export “bundle” boundary that some teams and libraries still rely on.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Standalone components shift Angular’s \"template dependency scope\" from <code>@NgModule</code> to the component itself (<code>imports</code> on the component). For modern apps, that removes most reasons to create feature/shared modules.<br><br>NgModules still matter mainly as a <strong>packaging + compatibility layer</strong> for legacy declarables and module-based libraries/config APIs."
        },
        {
          "type": "list",
          "columns": [
            "Problem / need",
            "NgModule solves it by...",
            "Standalone status"
          ],
          "rows": [
            [
              "Using non-standalone directives/pipes/components (legacy code or older libs)",
              "Declaring them once and exporting them via a module",
              "Standalone cannot directly import non-standalone declarables; you import the NgModule that exports them."
            ],
            [
              "Module-style library configuration (forRoot/forChild patterns)",
              "Returning <code>ModuleWithProviders</code> and wiring providers through module imports",
              "Standalone supports this mostly via <code>importProvidersFrom(SomeModule.forRoot(...))</code>, but the library still forces the NgModule shape."
            ],
            [
              "Single “bundle import” for a large set of template dependencies",
              "One <code>SharedModule</code> re-exports many imports/exports so feature code imports one thing",
              "Standalone can mimic with a shared array/const, but there’s no first-class “export scope” container like NgModule exports."
            ],
            [
              "Gradual migration in an existing NgModule app",
              "You can convert leaf components to standalone while keeping module boundaries intact",
              "Standalone is great for incremental migration, but NgModules remain the glue during the transition."
            ],
            [
              "Team convention: explicit public API surface (exports) for a domain",
              "Exports define what the rest of the app can use from that domain",
              "Standalone relies on regular TS exports + per-component imports; you lose the explicit “exports list” mechanism."
            ]
          ],
          "caption": "Where NgModules still provide value in a standalone-first Angular world"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// legacy-shared.module.ts\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { LegacyHighlightDirective } from './legacy-highlight.directive';\nimport { LegacyDatePipe } from './legacy-date.pipe';\n\n@NgModule({\n  declarations: [LegacyHighlightDirective, LegacyDatePipe],\n  imports: [CommonModule],\n  exports: [CommonModule, LegacyHighlightDirective, LegacyDatePipe]\n})\nexport class LegacySharedModule {}\n"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// standalone component consuming legacy declarations via NgModule\nimport { Component } from '@angular/core';\nimport { LegacySharedModule } from './legacy-shared.module';\n\n@Component({\n  standalone: true,\n  selector: 'app-user-card',\n  imports: [LegacySharedModule],\n  template: `\n    <div legacyHighlight>\n      {{ today | legacyDate }}\n    </div>\n  `\n})\nexport class UserCardComponent {\n  today = new Date();\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "If you’re fully standalone, do this instead",
            "Why it’s the equivalent"
          ],
          "rows": [
            [
              "Create reusable import bundles as constants (not modules)",
              "Gives you “one name” to import across many standalone components without an NgModule exports list."
            ],
            [
              "Prefer provider functions (<code>provideRouter</code>, <code>provideHttpClient</code>, etc.)",
              "Moves app configuration to bootstrap/route providers and reduces NgModule-only configuration patterns."
            ]
          ],
          "caption": "Standalone alternatives to common “SharedModule” patterns"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// shared-imports.ts (standalone-friendly)\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\n\nexport const SHARED_IMPORTS = [CommonModule, RouterModule] as const;\n\n// any.component.ts\nimport { Component } from '@angular/core';\nimport { SHARED_IMPORTS } from './shared-imports';\n\n@Component({\n  standalone: true,\n  imports: [...SHARED_IMPORTS],\n  template: `...`\n})\nexport class AnyComponent {}\n"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Module-based library config still shows up a lot\nimport { bootstrapApplication, importProvidersFrom } from '@angular/core';\nimport { AppComponent } from './app.component';\nimport { TranslateModule } from 'some-translate-lib';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    importProvidersFrom(TranslateModule.forRoot({ defaultLang: 'en' }))\n  ]\n});\n"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Standalone components cover most of what NgModules were used for (composition, routing, DI setup). NgModules still “win” mainly for <strong>legacy/non-standalone declarations</strong> and <strong>module-shaped third-party APIs</strong> (especially <code>forRoot</code>/<code>forChild</code>). In a greenfield app with modern libs, you usually don’t need to write new NgModules."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-appmodule-standalone-changes",
    "title": "What changed about AppModule with standalone components?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Standalone components moved most of what AppModule used to do (declaring components, importing template dependencies, and app-wide setup) into components + bootstrap configuration. In many apps, AppModule disappears entirely and the app boots with bootstrapApplication(AppComponent, { providers: [...] }).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Before standalone, Angular assembled the app through <code>AppModule</code>: you declared components/pipes/directives there, imported modules, and bootstrapped <code>AppComponent</code> via <code>bootstrap: [AppComponent]</code>.<br><br>With standalone, Angular can assemble the app without <code>AppModule</code>. Each standalone component declares its own template dependency scope using <code>imports</code>, and app-wide configuration moves to the bootstrap call (<code>providers</code>) or an <code>ApplicationConfig</code>."
        },
        {
          "type": "list",
          "columns": [
            "Area",
            "NgModule-era (AppModule)",
            "Standalone-era (no AppModule)"
          ],
          "rows": [
            [
              "Bootstrapping",
              "<code>platformBrowserDynamic().bootstrapModule(AppModule)</code>",
              "<code>bootstrapApplication(AppComponent, { providers: [...] })</code>"
            ],
            [
              "Template dependencies (CommonModule, Router, Material, etc.)",
              "Pulled in via <code>imports</code> on NgModules; components rely on module scope",
              "Declared per component via <code>imports: [...]</code> (or via route-level providers)"
            ],
            [
              "Declaring components/pipes/directives",
              "<code>declarations: [...]</code> on NgModules",
              "No declarations; standalone declarables are imported directly where used"
            ],
            [
              "Global providers (HTTP, router, interceptors, etc.)",
              "Mostly via NgModule imports (<code>HttpClientModule</code>, <code>RouterModule.forRoot</code>) and <code>providers</code>",
              "Mostly via provider functions (<code>provideHttpClient</code>, <code>provideRouter</code>) + <code>providers</code> array"
            ],
            [
              "Feature modules",
              "Common pattern for grouping + routing",
              "Often replaced by standalone routes + lazy-loaded standalone components"
            ]
          ],
          "caption": "AppModule stops being the central assembly point; component imports + bootstrap providers take over."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// NgModule-era\n// main.ts\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app/app.module';\n\nplatformBrowserDynamic()\n  .bootstrapModule(AppModule)\n  .catch(console.error);\n\n// app.module.ts\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\nimport { RouterModule } from '@angular/router';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    RouterModule.forRoot([])\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Standalone-era\n// main.ts\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideRouter } from '@angular/router';\nimport { provideHttpClient, withInterceptors } from '@angular/common/http';\nimport { importProvidersFrom } from '@angular/core';\nimport { AppComponent } from './app/app.component';\nimport { routes } from './app/app.routes';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideRouter(routes),\n    provideHttpClient(\n      withInterceptors([\n        // (req, next) => next(req)\n      ])\n    ),\n\n    // Compatibility: module-shaped libraries can still be used\n    // importProvidersFrom(SomeLibModule.forRoot(...))\n    // importProvidersFrom(BrowserAnimationsModule)\n  ]\n}).catch(console.error);"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// app.component.ts (standalone)\nimport { Component } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [RouterOutlet],\n  template: `<router-outlet />`\n})\nexport class AppComponent {}"
        },
        {
          "type": "list",
          "columns": [
            "So... do you still need AppModule?",
            "Answer"
          ],
          "rows": [
            [
              "Greenfield standalone app",
              "Usually no. AppModule can be removed entirely."
            ],
            [
              "Migrating an existing NgModule app",
              "Often yes (temporarily). You can convert leaf components/routes to standalone while keeping AppModule during the transition."
            ],
            [
              "Using a library that only exposes NgModules / forRoot APIs",
              "You might not need AppModule, but you’ll still consume NgModules via <code>importProvidersFrom(...)</code> (or keep AppModule if that’s simpler)."
            ],
            [
              "Legacy non-standalone declarables (directives/pipes/components)",
              "You can’t import them directly into a standalone component; you import the NgModule that declares/exports them."
            ]
          ],
          "caption": "AppModule becomes optional, but NgModules still exist as a compatibility/container mechanism."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Standalone shifts the “assembly” responsibility away from <code>AppModule</code>:<br>• Template scope moves to <code>imports</code> on components.<br>• App-wide setup moves to <code>bootstrapApplication(...)</code> providers (or <code>ApplicationConfig</code>).<br>• AppModule often disappears, but NgModules may remain for legacy code and module-shaped libraries."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-template-compilation-and-binding",
    "title": "How does Angular compile templates and bind them to component state?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Angular turns your component template into generated render/update instructions (AOT or JIT). At runtime, change detection re-runs the update phase so bindings (text, properties, attributes, events) stay in sync with the component instance (state).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Angular does <strong>two big jobs</strong>:<br>1) <strong>Compile</strong> the template into efficient instructions (Ivy) + type-check it.<br>2) <strong>Run change detection</strong> to execute the template’s <em>update</em> instructions, keeping the DOM synced with the component instance."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "What happens",
            "Why it matters"
          ],
          "rows": [
            [
              "Template parse",
              "HTML + Angular syntax become an internal AST (elements, bindings, directives, pipes).",
              "Angular understands what must be created vs updated."
            ],
            [
              "Template scope resolution",
              "Figure out which directives/pipes/components are legal (standalone <code>imports</code> or NgModule scope).",
              "Missing imports become compile errors."
            ],
            [
              "Template type-checking",
              "Angular generates TS type-check blocks so your bindings are checked by TypeScript.",
              "Catches <code>user.nmae</code> / wrong input types at build time (AOT)."
            ],
            [
              "Code generation (Ivy)",
              "Compiler emits a template function with <em>create</em> and <em>update</em> phases (instructions).",
              "Runtime is fast: no string templates, no regex, minimal DOM work."
            ],
            [
              "Bundling (AOT) or runtime compile (JIT)",
              "AOT ships generated JS; JIT compiles in the browser (dev-style).",
              "AOT = smaller/faster startup + earlier errors."
            ]
          ],
          "caption": "What “compiling an Angular template” actually means"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, signal } from '@angular/core';\n\n@Component({\n  selector: 'app-counter',\n  standalone: true,\n  template: `\n    <h3>Hello, {{ name }}</h3>\n    <button [disabled]=\"count() >= 3\" (click)=\"inc()\">\n      Count: {{ count() }}\n    </button>\n  `\n})\nexport class CounterComponent {\n  name = 'Ada';\n  count = signal(0);\n\n  inc() {\n    this.count.update(v => v + 1);\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>What the compiler roughly generates (simplified)</strong><br><br>Angular creates a <code>template(rf, ctx)</code> function. <code>rf</code> is a flag: create vs update. <code>ctx</code> is the component instance."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "function CounterComponent_Template(rf: number, ctx: CounterComponent) {\n  if (rf & 1) {\n    // CREATE phase: create DOM nodes + wire listeners once\n    // ɵɵelementStart(0, 'h3');\n    // ɵɵtext(1);\n    // ɵɵelementEnd();\n    // ɵɵelementStart(2, 'button');\n    // ɵɵlistener('click', () => ctx.inc());\n    // ɵɵtext(3);\n    // ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    // UPDATE phase: re-evaluate bindings and patch DOM as needed\n    // ɵɵtextInterpolate1('Hello, ', ctx.name, '');\n    // ɵɵproperty('disabled', ctx.count() >= 3);\n    // ɵɵtextInterpolate1('Count: ', ctx.count(), '');\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "Binding in template",
            "Compiled into",
            "When it runs"
          ],
          "rows": [
            [
              "Interpolation <code>{{ x }}</code>",
              "Text update instruction (set text node value).",
              "Every change detection update pass."
            ],
            [
              "Property binding <code>[disabled]=\"expr\"</code>",
              "Property update instruction (set DOM property).",
              "Every update pass; only patches if value changed."
            ],
            [
              "Attribute/class/style bindings",
              "Dedicated attribute/class/style instructions.",
              "Every update pass; optimized diffs."
            ],
            [
              "Event binding <code>(click)=\"fn()\"</code>",
              "Listener instruction storing a callback referencing <code>ctx</code>.",
              "Listener is created once; runs on events."
            ],
            [
              "Directive/component inputs",
              "Input set instructions calling directive/component input setters.",
              "Every update pass when values change."
            ]
          ],
          "caption": "How template syntax becomes runtime work"
        },
        {
          "type": "text",
          "text": "<strong>How the template “binds to component state”</strong><br><br>Bindings read from the component instance (<code>ctx</code>). When state changes, Angular runs change detection and re-executes the template’s <em>update</em> phase, re-reading <code>ctx</code> and patching the DOM."
        },
        {
          "type": "list",
          "columns": [
            "What triggers an update pass",
            "Typical examples"
          ],
          "rows": [
            [
              "User events",
              "click/input/submit handlers run, state changes, Angular checks affected views."
            ],
            [
              "Async completion",
              "timers, HTTP responses, observable emissions, promise resolution (via zone or explicit scheduling)."
            ],
            [
              "Manual signals / APIs",
              "signals update, <code>markForCheck()</code>, <code>detectChanges()</code> (advanced cases)."
            ],
            [
              "Input changes from parent",
              "Parent updates child input binding; child updates in the next pass."
            ]
          ],
          "caption": "Change detection is the bridge between state changes and DOM updates"
        },
        {
          "type": "list",
          "columns": [
            "AOT vs JIT",
            "AOT (build-time)",
            "JIT (runtime)"
          ],
          "rows": [
            [
              "When compiled",
              "During build; ships compiled instructions.",
              "In the browser; compiles templates at runtime."
            ],
            [
              "Startup performance",
              "Better (no runtime compilation cost).",
              "Worse (extra work at runtime)."
            ],
            [
              "Error timing",
              "More errors caught earlier (type-check + template checks).",
              "Some errors appear later (at runtime)."
            ],
            [
              "Typical usage",
              "Production builds.",
              "Dev workflows / special cases."
            ]
          ],
          "caption": "Both end up with the same Ivy-style instructions; the main difference is when they’re produced"
        },
        {
          "type": "list",
          "columns": [
            "Practical implications (interview-relevant)",
            "What to say"
          ],
          "rows": [
            [
              "Templates are not “magic strings”",
              "They compile to create/update instructions; update phase re-runs on CD."
            ],
            [
              "Keep templates cheap",
              "Avoid heavy computations in bindings; move to component and cache/derive."
            ],
            [
              "OnPush changes behavior",
              "OnPush reduces checks; updates happen on input reference change, events, async, or explicit marking."
            ],
            [
              "Structural directives change the tree",
              "<code>*ngIf</code>/<code>*ngFor</code> compile into embedded views; creation/destruction is real DOM work."
            ]
          ],
          "caption": "What this means for performance and architecture"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Angular compiles templates into Ivy render instructions with a <em>create</em> and <em>update</em> phase. The <em>update</em> phase re-reads values from the component instance and patches the DOM during change detection, which is how bindings stay synced with component state."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-data-binding",
    "title": "What is data binding in Angular?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Data binding in Angular is a powerful mechanism that connects a component’s TypeScript logic with its HTML template, allowing dynamic synchronization of data between the model and the view. It ensures that changes in the data automatically reflect in the UI and vice versa, depending on the binding type used.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Data binding is one of the core features of Angular. It allows seamless communication between the TypeScript class (component logic) and the HTML template (view). With data binding, you can dynamically display data, respond to user input, and modify application state without manually manipulating the DOM. This keeps the code cleaner, more maintainable, and aligned with Angular’s declarative approach."
        },
        {
          "type": "text",
          "text": "<strong>Why Data Binding Matters</strong><br>Without data binding, developers would have to manually update the DOM elements whenever data changes. Angular automates this process through its powerful change detection mechanism, ensuring that the user interface always reflects the latest state of the underlying model."
        },
        {
          "type": "list",
          "columns": [
            "Type of Binding",
            "Description",
            "Syntax Example"
          ],
          "rows": [
            [
              "Interpolation",
              "Displays component data in the HTML template.",
              "{{ propertyName }}"
            ],
            [
              "Property Binding",
              "Binds a component property to a DOM element’s attribute or property.",
              "[property]=\"expression\""
            ],
            [
              "Event Binding",
              "Listens for user actions like clicks, keystrokes, or mouse movements and triggers methods in the component.",
              "(event)=\"handlerFunction()\""
            ],
            [
              "Two-Way Binding",
              "Combines property and event binding to keep the component and the UI in sync.",
              "[(ngModel)]=\"propertyName\""
            ]
          ],
          "caption": "The four main types of data binding in Angular"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Example: All types of data binding -->\n<h2>{{ title }}</h2> <!-- Interpolation -->\n<img [src]=\"imageUrl\" /> <!-- Property Binding -->\n<button (click)=\"onClick()\">Click Me</button> <!-- Event Binding -->\n<input [(ngModel)]=\"username\" placeholder=\"Enter name\" /> <!-- Two-Way Binding -->"
        },
        {
          "type": "text",
          "text": "<strong>How It Works</strong><br>Angular’s change detection mechanism tracks variable updates inside the component. When data changes, the framework automatically updates the corresponding DOM elements in the template. Similarly, user interactions can modify component variables, creating a continuous feedback loop between the model and the view."
        },
        {
          "type": "text",
          "text": "<strong>Benefits of Data Binding</strong><br><ul><li>Eliminates the need for manual DOM manipulation.</li><li>Keeps the UI and business logic in sync automatically.</li><li>Improves code readability and maintainability.</li><li>Supports both one-way and two-way data flow depending on the requirement.</li><li>Facilitates modular, testable, and reactive application architecture.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of data binding as a two-way communication channel — it ensures that when your data changes, your UI updates, and when the user interacts with your UI, your data changes accordingly."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Data binding connects the component (logic) and template (view) in Angular.</li><li>It provides four main binding types: interpolation, property, event, and two-way binding.</li><li>It helps maintain dynamic and reactive UIs without direct DOM manipulation.</li><li>It forms the foundation for Angular’s declarative and reactive design pattern.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-interpolation-vs-property-binding",
    "title": "What is the difference between interpolation and property binding?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Both interpolation and property binding in Angular are used to display dynamic data in templates, but they differ in syntax and use cases. Interpolation binds data as text within HTML, while property binding binds data directly to DOM element properties or attributes.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Interpolation (<code>{{ }}</code>) and property binding (<code>[ ]</code>) are both one-way data binding techniques in Angular. They transfer data from the component class to the template, ensuring that the view displays up-to-date information. However, they differ in how they interact with the DOM and the types of values they can handle."
        },
        {
          "type": "text",
          "text": "<strong>Interpolation</strong><br>Interpolation is used to embed component data into the template as plain text. It evaluates an expression and converts the result into a string, which Angular inserts into the DOM at runtime. Interpolation can be used inside text nodes or attribute values (with limitations)."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Interpolation Example -->\n<h1>Welcome, {{ userName }}!</h1>\n<p>Your score: {{ score + 10 }}</p>"
        },
        {
          "type": "text",
          "text": "<strong>Property Binding</strong><br>Property binding binds component properties directly to DOM element properties or attributes. This allows dynamic updates to element values, states, and styles — not just text. Property binding is more versatile and supports non-string data types such as numbers, booleans, and objects."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Property Binding Example -->\n<img [src]=\"profileImageUrl\" [alt]=\"userName\" />\n<button [disabled]=\"isDisabled\">Submit</button>"
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Interpolation",
            "Property Binding"
          ],
          "rows": [
            [
              "Purpose",
              "Display data as text in HTML templates.",
              "Bind component properties to DOM element attributes or properties."
            ],
            [
              "Syntax",
              "{{ propertyName }}",
              "[property]=\"expression\""
            ],
            [
              "Data Type",
              "Always converts data to string.",
              "Can handle various data types like boolean, number, or object."
            ],
            [
              "Use Case",
              "When inserting values into text nodes or simple inline attributes.",
              "When binding values to HTML element properties (e.g., disabled, src, value)."
            ],
            [
              "Example",
              "<h2>{{ title }}</h2>",
              "<input [value]=\"title\" />"
            ]
          ],
          "caption": "Key differences between interpolation and property binding"
        },
        {
          "type": "text",
          "text": "<strong>Practical Usage</strong><br>While interpolation is convenient for displaying text or computed values, property binding should be used whenever you need to bind dynamic data to an element property — for example, enabling/disabling a button, setting image sources, or toggling classes dynamically."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Use interpolation when you just need to display text, and property binding when you want to dynamically manipulate HTML element properties."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Interpolation inserts text into templates using {{ }} syntax.</li><li>Property binding links component properties to DOM element attributes using [ ] syntax.</li><li>Property binding is more flexible and supports non-string values.</li><li>Both are one-way bindings that flow data from the component to the view.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-event-binding",
    "title": "What is event binding in Angular?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Event binding in Angular allows components to respond to user interactions such as clicks, keystrokes, or form submissions by executing methods defined in the component class. It establishes a one-way data flow from the view to the component.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Event binding in Angular provides a way to listen to user actions and trigger logic in the component class. It’s the bridge that connects UI events in the template to methods or expressions in the component. This keeps the application interactive and reactive to user input without requiring manual DOM event handling."
        },
        {
          "type": "text",
          "text": "<strong>How It Works</strong><br>Angular uses parentheses <code>( )</code> around an event name to bind it to a method. When the event occurs (like a button click or keypress), Angular executes the specified function in the component, passing along event data if necessary."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Event Binding Example -->\n<button (click)=\"onClick()\">Click Me</button>\n<input (input)=\"onInputChange($event)\" placeholder=\"Type something...\" />"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Component logic\nexport class EventExampleComponent {\n  onClick() {\n    alert('Button clicked!');\n  }\n\n  onInputChange(event: any) {\n    console.log('Input value:', event.target.value);\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Supported Events</strong><br>Angular supports most native DOM events like <code>click</code>, <code>input</code>, <code>keydown</code>, <code>mouseover</code>, <code>submit</code>, and custom events emitted by child components using <code>@Output()</code> and <code>EventEmitter</code>."
        },
        {
          "type": "text",
          "text": "<strong>Event Binding with Custom Events</strong><br>Components can communicate using custom events defined by the <code>@Output()</code> decorator. The parent component listens for these events just like any native DOM event."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// child.component.ts\nimport { Component, Output, EventEmitter } from '@angular/core';\n\n@Component({ selector: 'app-child', template: `<button (click)=\"notifyParent()\">Notify</button>` })\nexport class ChildComponent {\n  @Output() notify = new EventEmitter<string>();\n\n  notifyParent() {\n    this.notify.emit('Child says hello!');\n  }\n}\n\n// parent.component.html\n<app-child (notify)=\"onNotify($event)\"></app-child>"
        },
        {
          "type": "text",
          "text": "<strong>Benefits of Event Binding</strong><br><ul><li>Provides a declarative way to handle user interactions.</li><li>Reduces the need for direct DOM manipulation.</li><li>Improves separation of concerns between logic and presentation.</li><li>Works seamlessly with both native and custom events.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Event binding makes your application interactive — it’s how your UI listens and reacts to the user’s actions in real time."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Event binding listens for user interactions using the (event) syntax.</li><li>It calls a method in the component when the event occurs.</li><li>It supports both built-in DOM events and custom component events.</li><li>It maintains one-way communication from the view to the component.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-directives",
    "title": "What are directives in Angular?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Directives in Angular are special classes that add behavior, logic, or structure to elements in the DOM. They allow developers to manipulate the DOM efficiently by extending the functionality of HTML elements and attributes. Angular includes built-in directives like *ngIf, *ngFor, and [ngClass], and also allows developers to create custom directives.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In Angular, a directive is an instruction that tells the framework how to manipulate or interact with the DOM. Directives are used to change the appearance, structure, or behavior of elements in a template dynamically. They can modify existing elements or inject new ones based on logic defined in the directive class."
        },
        {
          "type": "text",
          "text": "<strong>Purpose of Directives</strong><br>Directives enable developers to build dynamic, reusable, and declarative UIs. They eliminate the need for low-level DOM manipulation by providing a higher-level abstraction that integrates smoothly with Angular’s templating and change detection system."
        },
        {
          "type": "list",
          "columns": [
            "Type",
            "Description",
            "Examples"
          ],
          "rows": [
            [
              "Component Directives",
              "Directives with a template. Every component in Angular is technically a directive with its own HTML, CSS, and logic.",
              "All Angular components"
            ],
            [
              "Structural Directives",
              "Change the structure of the DOM by adding or removing elements dynamically.",
              "*ngIf, *ngFor, *ngSwitch"
            ],
            [
              "Attribute Directives",
              "Change the appearance or behavior of an existing element without altering the DOM structure.",
              "[ngClass], [ngStyle], custom attribute directives"
            ]
          ],
          "caption": "Three main types of directives in Angular"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: Creating a custom attribute directive\nimport { Directive, ElementRef, Renderer2, HostListener } from '@angular/core';\n\n@Directive({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n  constructor(private el: ElementRef, private renderer: Renderer2) {}\n\n  @HostListener('mouseenter') onMouseEnter() {\n    this.renderer.setStyle(this.el.nativeElement, 'background-color', 'yellow');\n  }\n\n  @HostListener('mouseleave') onMouseLeave() {\n    this.renderer.removeStyle(this.el.nativeElement, 'background-color');\n  }\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Using the custom directive -->\n<p appHighlight>Hover over this text to see the directive in action!</p>"
        },
        {
          "type": "text",
          "text": "<strong>Built-in Directives</strong><br>Angular provides several built-in directives for common use cases:<ul><li><strong>*ngIf:</strong> Conditionally adds or removes elements based on a Boolean expression.</li><li><strong>*ngFor:</strong> Iterates over a list of items and renders one element per item.</li><li><strong>[ngClass]:</strong> Dynamically adds or removes CSS classes.</li><li><strong>[ngStyle]:</strong> Dynamically sets inline styles based on component data.</li><li><strong>*ngSwitch:</strong> Switches between multiple template sections based on a condition.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Why Directives Are Useful</strong><br><ul><li>They extend HTML with custom behavior.</li><li>Encourage reusability and modularity of UI logic.</li><li>Reduce code duplication and improve maintainability.</li><li>Enable clean, declarative manipulation of DOM elements.</li><li>Integrate seamlessly with Angular’s reactive data model.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Directives are like instructions for your HTML elements — they tell Angular what to do with them, whether it’s showing, hiding, styling, or transforming content dynamically."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Directives are classes that modify the DOM or element behavior in Angular.</li><li>They come in three types: component, structural, and attribute.</li><li>They enable developers to write declarative and reusable UI logic.</li><li>Angular provides many built-in directives, and developers can also create custom ones.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-structural-vs-attribute-directives",
    "title": "What is the difference between structural and attribute directives?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Structural directives modify the structure of the DOM by adding or removing elements dynamically, while attribute directives change the appearance or behavior of existing elements without altering the DOM structure.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In Angular, directives can be broadly classified into two functional types — structural and attribute directives. Both modify how elements behave, but they do so in different ways. Structural directives affect the DOM structure itself, while attribute directives modify existing elements by changing their style, behavior, or attributes."
        },
        {
          "type": "text",
          "text": "<strong>Structural Directives</strong><br>Structural directives are responsible for altering the layout of the DOM. They add, remove, or replace elements dynamically based on a condition or data source. These directives are easily recognizable because they are prefixed with an asterisk (<code>*</code>), which is shorthand for using Angular’s template syntax."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Example: Structural Directives -->\n<div *ngIf=\"isLoggedIn\">Welcome back, user!</div>\n<ul>\n  <li *ngFor=\"let item of items\">{{ item }}</li>\n</ul>"
        },
        {
          "type": "text",
          "text": "<strong>Common Structural Directives</strong><br><ul><li><strong>*ngIf:</strong> Conditionally includes or excludes an element based on a Boolean expression.</li><li><strong>*ngFor:</strong> Repeats an element for each item in an array or iterable.</li><li><strong>*ngSwitch:</strong> Dynamically displays one of several possible templates based on a given value.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Attribute Directives</strong><br>Attribute directives modify the appearance or behavior of existing DOM elements. Unlike structural directives, they do not change the layout of the DOM — they only apply visual or behavioral changes, such as dynamically setting classes, styles, or event listeners."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: Custom attribute directive\nimport { Directive, ElementRef, Renderer2 } from '@angular/core';\n\n@Directive({ selector: '[appTextColor]' })\nexport class TextColorDirective {\n  constructor(private el: ElementRef, private renderer: Renderer2) {\n    this.renderer.setStyle(this.el.nativeElement, 'color', 'blue');\n  }\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Using the custom attribute directive -->\n<p appTextColor>This text is styled using a custom attribute directive.</p>"
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Structural Directives",
            "Attribute Directives"
          ],
          "rows": [
            [
              "Purpose",
              "Modify the DOM structure by adding or removing elements.",
              "Modify element behavior or appearance without changing DOM structure."
            ],
            [
              "Prefix",
              "Prefixed with an asterisk (*) in the template.",
              "No prefix used."
            ],
            [
              "Examples",
              "*ngIf, *ngFor, *ngSwitch",
              "[ngClass], [ngStyle], custom attribute directives"
            ],
            [
              "Effect on DOM",
              "Creates or destroys elements.",
              "Applies styles, classes, or event listeners to existing elements."
            ],
            [
              "Use Case",
              "Controlling template structure dynamically.",
              "Changing element look or functionality dynamically."
            ]
          ],
          "caption": "Comparison between structural and attribute directives"
        },
        {
          "type": "text",
          "text": "<strong>Practical Example</strong><br>A structural directive like <code>*ngIf</code> can show or hide an element, while an attribute directive like <code>[ngStyle]</code> can change the color or font of an element without removing it from the DOM."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Structural vs Attribute Example -->\n<div *ngIf=\"isVisible\">This will appear only if isVisible is true.</div>\n<p [ngStyle]=\"{ color: 'red', fontWeight: 'bold' }\">This text will always exist but styled dynamically.</p>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of structural directives as construction tools that build or remove parts of the DOM, while attribute directives are decorators that enhance or modify existing elements."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Structural directives modify the DOM layout by adding, removing, or manipulating elements.</li><li>Attribute directives modify the appearance or behavior of elements without changing their structure.</li><li>Structural directives use the * prefix, while attribute directives do not.</li><li>Together, they provide powerful ways to create dynamic, interactive, and visually rich user interfaces in Angular.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-ngif-dom-lifecycle",
    "title": "How does *ngIf affect the DOM and component lifecycle?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "*ngIf is a structural directive that conditionally creates and destroys an embedded view. That means DOM nodes, component instances, directives, listeners, and template bindings inside the *ngIf block are actually created when the condition becomes true and destroyed when it becomes false.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>*ngIf</code> does not “hide” elements. It <strong>adds/removes</strong> a chunk of template by creating/destroying an <em>embedded view</em> (<code>EmbeddedViewRef</code>) in a <code>ViewContainerRef</code>. When the view is removed, Angular destroys everything inside it (components, directives, pipes, listeners) and runs <code>ngOnDestroy</code>."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Shorthand -->\n<app-child *ngIf=\"show\"></app-child>\n\n<!-- Roughly equivalent to -->\n<ng-template [ngIf]=\"show\">\n  <app-child></app-child>\n</ng-template>"
        },
        {
          "type": "list",
          "columns": [
            "When condition flips",
            "DOM result",
            "Instance result",
            "Lifecycle impact"
          ],
          "rows": [
            [
              "false → true",
              "Nodes are inserted into the DOM",
              "New component/directive instances are created",
              "constructor → (ngOnChanges) → ngOnInit → view/content hooks"
            ],
            [
              "true → false",
              "Nodes are removed from the DOM",
              "Instances are destroyed",
              "ngOnDestroy runs; subscriptions/cleanup should happen here"
            ],
            [
              "true → true (condition stays true)",
              "DOM stays",
              "Same instances stay",
              "Normal change detection updates bindings"
            ]
          ],
          "caption": "What *ngIf actually changes"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// child.component.ts\nimport { Component, OnDestroy, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-child',\n  template: `Child is alive`\n})\nexport class ChildComponent implements OnInit, OnDestroy {\n  constructor() {\n    console.log('child: constructor');\n  }\n\n  ngOnInit(): void {\n    console.log('child: ngOnInit');\n  }\n\n  ngOnDestroy(): void {\n    console.log('child: ngOnDestroy');\n  }\n}\n\n// parent template\n// <button (click)=\"show = !show\">toggle</button>\n// <app-child *ngIf=\"show\"></app-child>"
        },
        {
          "type": "list",
          "columns": [
            "Topic",
            "*ngIf behavior",
            "Practical consequence"
          ],
          "rows": [
            [
              "Component state",
              "Reset on every re-create",
              "Local fields, form state, and child component state are lost on hide/show"
            ],
            [
              "Subscriptions/listeners",
              "Destroyed view stops emitting into template",
              "If you subscribe manually, you must unsubscribe in ngOnDestroy (or use async pipe / takeUntilDestroyed)"
            ],
            [
              "DI scope",
              "Component-level providers are torn down with the view",
              "A service provided in the component gets a fresh instance on next show"
            ],
            [
              "View queries",
              "ViewChild/ContentChild inside the block disappear",
              "References become undefined when view is destroyed; guard access"
            ],
            [
              "Change detection cost",
              "Removed subtree is not checked",
              "Hiding heavy UI with *ngIf can reduce CD + DOM updates"
            ]
          ],
          "caption": "Key implications interviewers care about"
        },
        {
          "type": "list",
          "columns": [
            "Technique",
            "Does it remove from DOM?",
            "Does it destroy component instances?",
            "When to prefer"
          ],
          "rows": [
            [
              "*ngIf",
              "Yes",
              "Yes",
              "When you want real teardown (free resources, remove listeners, skip CD)"
            ],
            [
              "[hidden] / CSS (display:none)",
              "No",
              "No",
              "When you need to preserve state and avoid re-creation cost"
            ],
            [
              "ng-container + else template",
              "Same as *ngIf",
              "Same as *ngIf",
              "When you want clean conditional branching without extra wrapper DOM"
            ]
          ],
          "caption": "*ngIf vs hiding"
        },
        {
          "type": "list",
          "columns": [
            "Common gotcha",
            "What happens",
            "Fix"
          ],
          "rows": [
            [
              "Toggling a form with *ngIf",
              "User input resets on every hide/show",
              "Use [hidden] if you must preserve state, or persist the form model outside the child"
            ],
            [
              "Expensive init in ngOnInit",
              "Runs every time the view is recreated",
              "Cache in a service/facade, or keep component alive and just hide it"
            ],
            [
              "Memory leaks",
              "Manual subscriptions keep running if not cleaned up",
              "Use async pipe, takeUntilDestroyed(), or ngOnDestroy cleanup"
            ]
          ],
          "caption": "Practical pitfalls"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>*ngIf</code> creates/destroys an embedded view. True = build DOM + instantiate components/directives and run init hooks. False = remove DOM + destroy instances and run <code>ngOnDestroy</code>. Use it when you want real teardown and to skip change detection for that subtree; use hiding when you need to keep state alive."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-ngfor-trackby",
    "title": "Why is trackBy important in *ngFor, and what breaks without it?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "trackBy tells Angular how to uniquely identify items in an *ngFor list so it can reuse existing DOM nodes and component instances when the array changes. Without it (or with a bad trackBy), Angular may destroy and recreate rows unnecessarily, which hurts performance and can reset UI state like input values, focus, and child component state.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>*ngFor</code> maintains a list of embedded views (DOM + directives + child components). <code>trackBy</code> defines each item's identity so Angular can do efficient diffs: <strong>move/update</strong> existing views instead of <strong>destroy/recreate</strong> them."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<ul>\n  <li *ngFor=\"let user of users; trackBy: trackByUserId\">\n    <app-user-row [user]=\"user\"></app-user-row>\n  </li>\n</ul>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "type User = { id: string; name: string };\n\nexport class UsersComponent {\n  users: User[] = [\n    { id: 'u1', name: 'Ada' },\n    { id: 'u2', name: 'Linus' }\n  ];\n\n  trackByUserId(index: number, user: User): string {\n    return user.id;\n  }\n\n  // Common real-world cause of problems: new object references on refresh\n  refreshFromApiLike(): void {\n    // Same ids, but NEW objects => without trackBy, Angular treats them as new items\n    this.users = this.users.map(u => ({ ...u }));\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "What trackBy controls",
            "What Angular can do",
            "Why it matters"
          ],
          "rows": [
            [
              "Item identity",
              "Match old items to new items across changes",
              "Prevents treating “same logical item” as a brand-new row"
            ],
            [
              "DOM reuse",
              "Reuse existing DOM nodes and directives",
              "Avoids heavy DOM churn and layout/repaint work"
            ],
            [
              "Component instance reuse",
              "Keep child component instances for the same logical item",
              "Preserves child state and avoids repeated ngOnInit/ngOnDestroy"
            ],
            [
              "Row movement",
              "Move existing views when sorting/reordering",
              "Keeps UI stable instead of flickering or re-initializing"
            ]
          ],
          "caption": "trackBy lets Angular perform a stable, minimal update of the rendered list"
        },
        {
          "type": "list",
          "columns": [
            "Without trackBy (or with unstable identity)",
            "What breaks / degrades",
            "Typical symptom"
          ],
          "rows": [
            [
              "Array recreated with new object references",
              "Rows are destroyed + recreated even if ids are the same",
              "Inputs reset, focus/caret jumps, child state resets"
            ],
            [
              "Expensive child rows (components, heavy templates)",
              "More DOM work + more lifecycle work",
              "Scroll jank, CPU spikes, visible flicker on updates"
            ],
            [
              "UI state stored in the DOM (focus, selection, <input> value while typing)",
              "DOM state is lost on re-create",
              "User is typing and the caret jumps / typed text disappears"
            ],
            [
              "3rd-party widgets inside rows (charts, editors)",
              "Widgets get torn down and rebuilt",
              "Re-initialization costs + lost internal widget state"
            ],
            [
              "Bad trackBy (random, Date.now, returning a new object)",
              "Identity changes every check => Angular rebuilds everything",
              "Worst-case: every CD cycle behaves like a full rerender"
            ]
          ],
          "caption": "Most “trackBy bugs” show up when you refresh data or rebuild arrays (common with immutability patterns)"
        },
        {
          "type": "list",
          "columns": [
            "TrackBy choice",
            "When it's correct",
            "When it causes bugs"
          ],
          "rows": [
            [
              "Stable unique id (recommended)",
              "Items have a real unique key (id, uuid, slug)",
              "Rarely; only if the id is not actually unique/stable"
            ],
            [
              "Composite key (e.g., `${type}:${id}`)",
              "Multiple item types share the same id space",
              "If any part of the composite can change over time"
            ],
            [
              "Value itself (primitives)",
              "List is strings/numbers and values are unique/stable",
              "If values can repeat (duplicates) => identity collisions"
            ],
            [
              "Index (avoid unless list is static)",
              "List never reorders/inserts/removes, only updates values in-place",
              "On insert/reorder, state sticks to the wrong row (wrong input value on wrong item)"
            ]
          ],
          "caption": "Key rule: identity must represent the logical item, not its current position"
        },
        {
          "type": "text",
          "text": "<strong>Extra note</strong><br><br>Modern Angular also has <code>@for</code> with a <code>track</code> expression (same concept): <code>@for (user of users; track user.id) { ... }</code>. The principle is identical: stable identity => stable DOM + preserved state."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br><code>trackBy</code> is important because it gives Angular a stable key per item so it can reuse and move existing rows instead of recreating them. Without it (especially when data refresh creates new object references), you pay in performance and you lose UI state (inputs, focus, child component state). Use a stable unique id; avoid index unless the list is truly static."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-services",
    "title": "What are services in Angular and why are they used?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Services in Angular are classes that handle reusable logic, such as fetching data, managing state, or communicating with APIs. They are used to promote code reusability, maintainability, and separation of concerns by keeping business logic separate from components.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In Angular, a <strong>service</strong> is a class that provides reusable functionality or logic that can be shared across multiple components. Services help keep your application modular and organized by separating data management, business rules, and helper logic from the component’s view and UI logic."
        },
        {
          "type": "text",
          "text": "<strong>Purpose of Services</strong><br>Services are used to perform tasks such as:<ul><li>Fetching data from a backend API.</li><li>Handling user authentication or authorization.</li><li>Managing shared state or caching data.</li><li>Encapsulating business logic or calculations.</li><li>Logging or configuration handling.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Creating a Service</strong><br>You can create a service using the Angular CLI command:<br><code>ng generate service service-name</code><br>or shorthand:<br><code>ng g s service-name</code>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: user.service.ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable({ providedIn: 'root' })\nexport class UserService {\n  private apiUrl = 'https://api.example.com/users';\n\n  constructor(private http: HttpClient) {}\n\n  getUsers(): Observable<any[]> {\n    return this.http.get<any[]>(this.apiUrl);\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Using a Service in a Component</strong><br>Once a service is created, it can be injected into any component that needs it. Angular’s dependency injection system automatically creates an instance and provides it wherever required."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: Injecting and using a service in a component\nimport { Component, OnInit } from '@angular/core';\nimport { UserService } from './user.service';\n\n@Component({\n  selector: 'app-user-list',\n  templateUrl: './user-list.component.html'\n})\nexport class UserListComponent implements OnInit {\n  users: any[] = [];\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    this.userService.getUsers().subscribe(data => {\n      this.users = data;\n    });\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Advantages of Using Services</strong><br><ul><li>Encourages modular and maintainable architecture.</li><li>Enables reusability of logic across multiple components.</li><li>Improves testability by isolating business logic from components.</li><li>Supports dependency injection, making code loosely coupled.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Scope of a Service</strong><br>When a service is declared with <code>providedIn: 'root'</code>, it is available application-wide as a singleton instance. You can also provide services at the module or component level for more granular control."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of a service as the 'brain' that handles logic, while components are the 'face' that interacts with users — keeping them separate makes your app cleaner and easier to manage."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Services are classes that handle reusable and shared logic in Angular.</li><li>They are used for tasks like data fetching, business logic, or app configuration.</li><li>They can be injected into components, directives, or other services.</li><li>Services improve modularity, testability, and maintainability.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-dependency-injection",
    "title": "What is dependency injection in Angular?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Dependency Injection (DI) in Angular is a design pattern that provides components or services with their required dependencies rather than having them create those dependencies themselves. It makes code modular, testable, and easier to maintain.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Dependency Injection (DI) is a key feature of Angular’s architecture that simplifies how components and services acquire the resources they need. Instead of manually creating instances of classes, Angular’s DI system provides them automatically whenever required."
        },
        {
          "type": "text",
          "text": "<strong>Core Concept</strong><br>In traditional programming, you might instantiate dependencies directly using the <code>new</code> keyword. In Angular, DI removes this tight coupling by letting a centralized injector create and supply dependencies. This makes your code more flexible and easier to maintain."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Without Dependency Injection\nexport class UserListComponent {\n  userService = new UserService(); // tightly coupled to this class\n}\n\n// With Dependency Injection\nexport class UserListComponent {\n  constructor(private userService: UserService) {} // Angular injects the dependency\n}"
        },
        {
          "type": "text",
          "text": "<strong>How It Works</strong><br>Angular’s DI system uses three main concepts:<ul><li><strong>Provider:</strong> Defines how to create or deliver a dependency (e.g., via <code>@Injectable</code> or module providers).</li><li><strong>Injector:</strong> A container that maintains a map of dependencies and provides them when needed.</li><li><strong>Dependency Token:</strong> A unique key (often the class type) used by the injector to look up the dependency instance.</li></ul>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: A simple DI setup\n@Injectable({ providedIn: 'root' })\nexport class LoggerService {\n  log(message: string) {\n    console.log('Log:', message);\n  }\n}\n\n@Component({ selector: 'app-home', templateUrl: './home.component.html' })\nexport class HomeComponent {\n  constructor(private logger: LoggerService) {}\n\n  ngOnInit() {\n    this.logger.log('Home component initialized.');\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Hierarchical Injection</strong><br>Angular provides a hierarchical DI system. This means services can be scoped differently based on where they’re provided:<ul><li><code>providedIn: 'root'</code> — A single instance is shared across the entire app (singleton).</li><li>Provided in a specific <strong>module</strong> — Available only to components within that module.</li><li>Provided in a <strong>component</strong> — A new instance is created for that component and its children.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Benefits of Dependency Injection</strong><br><ul><li>Promotes loose coupling between classes and services.</li><li>Makes code easier to test (you can replace dependencies with mocks).</li><li>Improves maintainability and scalability in large applications.</li><li>Encourages modular and reusable design patterns.</li></ul>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Providing a service at the component level\n@Component({\n  selector: 'app-dashboard',\n  templateUrl: './dashboard.component.html',\n  providers: [LoggerService] // new instance for this component only\n})\nexport class DashboardComponent {\n  constructor(private logger: LoggerService) {\n    this.logger.log('Dashboard loaded');\n  }\n}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Dependency Injection as a delivery service for your classes — instead of creating what you need, Angular delivers it for you, ensuring consistency and efficiency."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Dependency Injection is a design pattern that provides required dependencies to a class rather than creating them manually.</li><li>Angular’s DI system uses injectors, providers, and tokens to manage dependencies.</li><li>It supports different levels of service scope: root, module, or component.</li><li>DI simplifies testing, improves modularity, and enhances maintainability.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-ngoninit-vs-constructor",
    "title": "What is the difference between ngOnInit() and the constructor in a component?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "The constructor in an Angular component is a TypeScript feature used to initialize class members and inject dependencies, while ngOnInit() is an Angular lifecycle hook that is called after the component is initialized. ngOnInit() is ideal for performing initialization logic that requires access to component inputs or Angular bindings.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In Angular, both the <code>constructor</code> and the <code>ngOnInit()</code> method play roles in component initialization, but they serve different purposes. The constructor is a TypeScript feature that runs when the class is instantiated, whereas <code>ngOnInit()</code> is part of Angular’s lifecycle hooks and runs once the component has been fully initialized."
        },
        {
          "type": "text",
          "text": "<strong>Constructor</strong><br>The <code>constructor</code> is called when a component class is created. It’s primarily used for dependency injection and basic setup that doesn’t depend on Angular bindings or lifecycle states. It should not contain any logic that relies on template bindings or external data sources."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "export class UserComponent {\n  constructor(private userService: UserService) {\n    console.log('Constructor called');\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>ngOnInit()</strong><br><code>ngOnInit()</code> is one of Angular’s lifecycle hooks defined in the <code>OnInit</code> interface. It is called by Angular after the component’s data-bound properties have been initialized. This is the right place to perform component setup that depends on bindings, inputs, or services."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-user',\n  templateUrl: './user.component.html'\n})\nexport class UserComponent implements OnInit {\n  users: any[] = [];\n\n  constructor(private userService: UserService) {\n    console.log('Constructor called');\n  }\n\n  ngOnInit() {\n    console.log('ngOnInit called');\n    this.userService.getUsers().subscribe(data => {\n      this.users = data;\n    });\n  }\n}"
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Constructor",
            "ngOnInit()"
          ],
          "rows": [
            [
              "Definition",
              "A TypeScript feature that initializes class members.",
              "An Angular lifecycle hook for initialization logic."
            ],
            [
              "Execution Time",
              "Called when the class is instantiated.",
              "Called after Angular initializes input properties."
            ],
            [
              "Purpose",
              "Used for dependency injection and basic setup.",
              "Used for initialization logic that requires Angular bindings."
            ],
            [
              "Access to Inputs",
              "Not available — @Input values are not yet set.",
              "Available — all @Input values are accessible."
            ],
            [
              "Best Practice",
              "Keep it lightweight — no heavy logic or async calls.",
              "Use it for initialization, API calls, or data setup."
            ]
          ],
          "caption": "Comparison between constructor and ngOnInit()"
        },
        {
          "type": "text",
          "text": "<strong>Key Takeaways</strong><br><ul><li>The constructor is part of TypeScript, not Angular’s lifecycle.</li><li><code>ngOnInit()</code> is triggered by Angular after input properties are resolved.</li><li>Dependency injection happens in the constructor, but complex logic belongs in <code>ngOnInit()</code>.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of the constructor as 'building the skeleton' of your component, and <strong>ngOnInit()</strong> as 'bringing it to life' once Angular has wired everything together."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li><code>constructor</code> is for dependency injection and simple setup.</li><li><code>ngOnInit()</code> is for initialization logic that requires bindings or external data.</li><li>Both are executed during component creation but at different stages of Angular’s lifecycle.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-pipes",
    "title": "What are Angular pipes and how are they used?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Angular pipes are features that transform data in templates. They are used to format data such as dates, numbers, currencies, and text. Pipes can be built-in or custom and are used with the pipe (|) operator in templates.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Pipes in Angular are powerful tools that allow you to transform data directly within your templates. They are similar to filters in other frameworks. A pipe takes an input value, processes it, and returns a transformed output without altering the original data."
        },
        {
          "type": "text",
          "text": "<strong>How Pipes Work</strong><br>Pipes use the pipe (<code>|</code>) operator in templates. The data before the pipe is the input, and the transformation defined by the pipe is applied to produce formatted output. Multiple pipes can be chained together for more complex transformations."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Basic Pipe Examples -->\n<p>{{ today | date }}</p>\n<p>{{ user.name | uppercase }}</p>\n<p>{{ price | currency:'USD' }}</p>"
        },
        {
          "type": "text",
          "text": "<strong>Common Built-in Pipes</strong><br>Angular comes with several built-in pipes for common formatting tasks:<ul><li><strong>date</strong> – Formats date values (e.g., <code>{{ today | date:'fullDate' }}</code>).</li><li><strong>uppercase</strong> / <strong>lowercase</strong> – Converts text to uppercase or lowercase.</li><li><strong>currency</strong> – Formats numbers as currency.</li><li><strong>percent</strong> – Displays numbers as percentages.</li><li><strong>json</strong> – Converts an object into a JSON-formatted string.</li><li><strong>async</strong> – Automatically subscribes to an Observable or Promise and returns the latest value.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Custom Pipes</strong><br>You can also create your own pipes for application-specific formatting. Use the Angular CLI command:<br><code>ng generate pipe pipe-name</code> or <code>ng g p pipe-name</code>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: Creating a custom pipe\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({ name: 'capitalize' })\nexport class CapitalizePipe implements PipeTransform {\n  transform(value: string): string {\n    if (!value) return '';\n    return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();\n  }\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Using the custom pipe in a template -->\n<p>{{ 'angular' | capitalize }}</p>\n<!-- Output: Angular -->"
        },
        {
          "type": "text",
          "text": "<strong>Chaining Pipes</strong><br>Multiple pipes can be chained together for compound transformations. For example, to display a user’s name in uppercase and formatted as currency:"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<p>{{ amount | currency:'EUR' | uppercase }}</p>"
        },
        {
          "type": "text",
          "text": "<strong>Pure vs Impure Pipes</strong><br><ul><li><strong>Pure Pipes:</strong> Execute only when the input data changes by reference. These are optimized for performance.</li><li><strong>Impure Pipes:</strong> Recalculate on every change detection cycle, which can be useful for real-time transformations but may affect performance.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Advantages of Using Pipes</strong><br><ul><li>They make templates cleaner and easier to read.</li><li>Encapsulate transformation logic in reusable, testable units.</li><li>Provide a declarative way to format or modify data in the view.</li><li>Allow seamless chaining for multiple transformations.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of a pipe as a 'formatter' — it takes raw data and turns it into something user-friendly right inside your template, without touching the actual data model."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Pipes transform data in Angular templates without mutating it.</li><li>They can be built-in (e.g., date, currency, uppercase) or custom.</li><li>Pipes are declared using the <code>@Pipe</code> decorator and implement <code>PipeTransform</code>.</li><li>They improve readability and maintainability of template logic.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-custom-two-way-binding",
    "title": "How would you implement two-way binding for a custom component (Input/Output naming convention), and what can go wrong?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Angular supports two-way binding on custom components via [(...)] when the component exposes a matching @Input/@Output pair: <prop> and <prop>Change. It’s syntactic sugar for [prop] plus (propChange).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>[(x)]</code> works only if Angular can find:<br>• <code>@Input() x</code><br>• <code>@Output() xChange</code><br><br>Then this:<br><code>&lt;app-cmp [(x)]=&quot;state&quot;&gt;&lt;/app-cmp&gt;</code><br>is equivalent to:<br><code>&lt;app-cmp [x]=&quot;state&quot; (xChange)=&quot;state = $event&quot;&gt;&lt;/app-cmp&gt;</code>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, EventEmitter, Input, Output, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-text-input',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `\n    <label>\n      <span class=\"sr-only\">Name</span>\n      <input\n        [value]=\"value\"\n        (input)=\"onInput(($event.target as HTMLInputElement).value)\"\n      />\n    </label>\n  `\n})\nexport class TextInputComponent {\n  @Input() value = '';\n  @Output() valueChange = new EventEmitter<string>();\n\n  onInput(next: string): void {\n    // Do NOT rely on mutating @Input() to update parent.\n    // Always emit the change.\n    this.valueChange.emit(next);\n  }\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- parent.component.html -->\n<app-text-input [(value)]=\"name\"></app-text-input>\n\n<p>Preview: {{ name }}</p>"
        },
        {
          "type": "text",
          "text": "<strong>Aliasing still works (but names must still match)</strong><br><br>If you alias the input name, the output alias must be <em>that alias</em> + <code>Change</code>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-toggle',\n  template: `\n    <button type=\"button\" (click)=\"toggle()\">\n      {{ checked ? 'ON' : 'OFF' }}\n    </button>\n  `\n})\nexport class ToggleComponent {\n  @Input('checked') checked = false;\n  @Output('checkedChange') checkedChange = new EventEmitter<boolean>();\n\n  toggle(): void {\n    this.checkedChange.emit(!this.checked);\n  }\n}\n\n// usage:\n// <app-toggle [(checked)]=\"isEnabled\"></app-toggle>"
        },
        {
          "type": "list",
          "columns": [
            "What can go wrong",
            "Symptom",
            "Fix"
          ],
          "rows": [
            [
              "Naming mismatch (e.g., @Output() valueChanged instead of valueChange)",
              "[(value)] fails to compile / template error",
              "Use exact convention: input <prop> + output <prop>Change (or matching aliases)"
            ],
            [
              "You mutate the @Input() and forget to emit",
              "Child UI updates, parent state does not",
              "Treat @Input as read-only; emit through the Output for parent updates"
            ],
            [
              "Emitting at the wrong time (during init hooks)",
              "ExpressionChangedAfterItHasBeenCheckedError / flicker",
              "Emit from user actions or schedule (e.g., queueMicrotask/setTimeout) if you must emit after init"
            ],
            [
              "Two sources of truth (internal state diverges from input)",
              "UI shows stale value or “snaps back”",
              "Render from the @Input; if you keep local state, sync it carefully in ngOnChanges"
            ],
            [
              "Using [(...)] with a non-assignable expression",
              "Template error: can't assign to expression",
              "Bind to a writable field: [(value)]=\"name\" (not \"getName()\" / pipes / literals)"
            ],
            [
              "Objects/arrays are mutated instead of replaced (especially with OnPush patterns)",
              "Hard-to-debug stale UI / shared state side effects",
              "Emit new references (immutable updates) or clearly own mutation boundaries"
            ],
            [
              "Using custom two-way binding for form controls when you really need Angular Forms integration",
              "ngModel / reactive forms don’t work properly (touched/dirty/validation)",
              "Implement ControlValueAccessor for true form controls"
            ]
          ],
          "caption": "Common pitfalls with custom two-way binding"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Custom two-way binding is just <code>[prop]</code> + <code>(propChange)</code>. Implement <code>@Input() prop</code> and <code>@Output() propChange</code>, emit on user interaction, avoid mutating inputs as your update mechanism, and use ControlValueAccessor when the component is a real form control."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-lifecycle-hooks",
    "title": "What are lifecycle hooks in Angular?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Lifecycle hooks in Angular are special methods that allow developers to tap into key moments of a component’s or directive’s lifecycle, such as creation, updates, and destruction. They help manage initialization, change detection, and cleanup processes.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Angular components and directives go through a well-defined lifecycle — from creation to destruction. Lifecycle hooks are special methods provided by Angular that allow developers to execute code at specific moments during this lifecycle, such as when the component is initialized, checked for changes, or removed from the DOM."
        },
        {
          "type": "text",
          "text": "<strong>Why Lifecycle Hooks Are Important</strong><br>Lifecycle hooks give you fine-grained control over component behavior, enabling you to:<ul><li>Initialize data or services when the component loads.</li><li>Respond to changes in data-bound properties.</li><li>Perform DOM manipulations safely after rendering.</li><li>Clean up resources or subscriptions before the component is destroyed.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Common Lifecycle Hooks</strong><br>Angular offers several lifecycle hooks, each serving a unique purpose in the component lifecycle."
        },
        {
          "type": "list",
          "columns": [
            "Hook",
            "Purpose"
          ],
          "rows": [
            [
              "<code>ngOnChanges()</code>",
              "Called before <code>ngOnInit()</code> whenever input properties change."
            ],
            [
              "<code>ngOnInit()</code>",
              "Invoked once after the first <code>ngOnChanges()</code>; ideal for initialization logic."
            ],
            [
              "<code>ngDoCheck()</code>",
              "Called during every change detection cycle; used for custom change tracking."
            ],
            [
              "<code>ngAfterContentInit()</code>",
              "Runs after projected content (<ng-content>) has been initialized."
            ],
            [
              "<code>ngAfterContentChecked()</code>",
              "Runs after every check of projected content."
            ],
            [
              "<code>ngAfterViewInit()</code>",
              "Runs after the component’s view (and child views) have been initialized."
            ],
            [
              "<code>ngAfterViewChecked()</code>",
              "Called after every check of the component’s view and child views."
            ],
            [
              "<code>ngOnDestroy()</code>",
              "Called just before Angular destroys the component; used for cleanup tasks."
            ]
          ],
          "caption": "List of key Angular lifecycle hooks"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, OnInit, OnDestroy } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `<p>Lifecycle demo</p>`\n})\nexport class ExampleComponent implements OnInit, OnDestroy {\n\n  constructor() {\n    console.log('Constructor: Component instance created');\n  }\n\n  ngOnInit() {\n    console.log('ngOnInit: Component initialized');\n  }\n\n  ngOnDestroy() {\n    console.log('ngOnDestroy: Cleaning up before destruction');\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Execution Order</strong><br>The hooks follow a specific sequence throughout the component’s lifecycle:<br><br><code>constructor → ngOnChanges → ngOnInit → ngDoCheck → ngAfterContentInit → ngAfterContentChecked → ngAfterViewInit → ngAfterViewChecked → ngOnDestroy</code>"
        },
        {
          "type": "text",
          "text": "<strong>Real-World Example</strong><br>Imagine a component that subscribes to a data stream when it initializes and needs to unsubscribe before being destroyed to avoid memory leaks. You can handle this cleanly using <code>ngOnInit()</code> and <code>ngOnDestroy()</code>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "ngOnInit() {\n  this.subscription = this.dataService.getData().subscribe(data => {\n    this.data = data;\n  });\n}\n\nngOnDestroy() {\n  this.subscription.unsubscribe(); // Prevent memory leaks\n}"
        },
        {
          "type": "text",
          "text": "<strong>Benefits of Lifecycle Hooks</strong><br><ul><li>Enable precise control over initialization and cleanup.</li><li>Improve performance by managing when data and DOM operations occur.</li><li>Enhance maintainability by organizing logic across different lifecycle stages.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of lifecycle hooks as ‘checkpoints’ in a component’s life — you can insert logic at each checkpoint to control how your component behaves as it grows, updates, and disappears."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Lifecycle hooks are methods Angular calls during a component’s creation, change detection, and destruction.</li><li>Common hooks include <code>ngOnInit()</code>, <code>ngOnChanges()</code>, and <code>ngOnDestroy()</code>.</li><li>They are ideal for initialization, data fetching, and resource cleanup tasks.</li><li>They make components predictable, modular, and easier to debug.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-input-output",
    "title": "What is the purpose of the @Input() and @Output() decorators?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "@Input() and @Output() are Angular decorators used for communication between parent and child components. @Input() allows a parent component to pass data to a child component, while @Output() enables the child to emit events back to the parent using an EventEmitter.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Angular components often need to communicate with each other, especially in parent-child relationships. The <code>@Input()</code> and <code>@Output()</code> decorators are core mechanisms for this communication. They make data flow predictable and help maintain a unidirectional data architecture — parent ➜ child (via <code>@Input()</code>) and child ➜ parent (via <code>@Output()</code>)."
        },
        {
          "type": "text",
          "text": "<strong>@Input()</strong><br><code>@Input()</code> is used in a child component to receive data from its parent. It makes a property in the child component bindable from the parent’s template."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Child component: user-card.component.ts\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `<h3>{{ user.name }}</h3><p>{{ user.email }}</p>`\n})\nexport class UserCardComponent {\n  @Input() user!: { name: string; email: string };\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent component template -->\n<app-user-card [user]=\"selectedUser\"></app-user-card>"
        },
        {
          "type": "text",
          "text": "Here, the parent component passes the <code>selectedUser</code> object to the <code>user</code> property of the child using property binding."
        },
        {
          "type": "text",
          "text": "<strong>@Output()</strong><br><code>@Output()</code> allows the child component to send events or data back to the parent. It is typically paired with <code>EventEmitter</code> to emit custom events that the parent can listen to."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Child component: user-card.component.ts\nimport { Component, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `<button (click)=\"selectUser()\">Select</button>`\n})\nexport class UserCardComponent {\n  @Output() userSelected = new EventEmitter<string>();\n\n  selectUser() {\n    this.userSelected.emit('User selected successfully!');\n  }\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent component template -->\n<app-user-card (userSelected)=\"handleUserSelection($event)\"></app-user-card>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Parent component logic\nhandleUserSelection(message: string) {\n  console.log(message); // Output: 'User selected successfully!'\n}"
        },
        {
          "type": "list",
          "columns": [
            "Decorator",
            "Direction",
            "Purpose"
          ],
          "rows": [
            [
              "@Input()",
              "Parent ➜ Child",
              "Passes data into the child component."
            ],
            [
              "@Output()",
              "Child ➜ Parent",
              "Emits events or data from the child to the parent."
            ]
          ],
          "caption": "Data flow between components using @Input() and @Output()"
        },
        {
          "type": "text",
          "text": "<strong>Benefits of Using @Input() and @Output()</strong><ul><li>Encourages clean, predictable data flow.</li><li>Reduces tight coupling between components.</li><li>Supports reusability and modularity in complex UIs.</li><li>Enables event-driven architecture in component hierarchies.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>@Input()</code> as passing information ‘down the family tree’ and <code>@Output()</code> as sending signals ‘back up’ to the parent component."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li><code>@Input()</code> allows data binding from a parent component to a child.</li><li><code>@Output()</code> emits custom events from a child to a parent.</li><li>Together, they enable two-way communication between components in a structured and maintainable way.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-observables-rxjs",
    "title": "What are observables in Angular, and how do they relate to RxJS?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Observables are a core part of Angular’s reactive programming model, used to handle asynchronous data streams. They are provided by the RxJS library and allow developers to react to changes in data over time, such as user input, HTTP responses, or real-time updates.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Observables are data streams that emit values over time. They represent a powerful abstraction for handling asynchronous events, such as user interactions, HTTP requests, or WebSocket connections. Angular heavily relies on Observables for managing async operations through its integration with <strong>RxJS</strong> (Reactive Extensions for JavaScript)."
        },
        {
          "type": "text",
          "text": "<strong>Relationship Between Angular and RxJS</strong><br>RxJS is the underlying library that implements the Observable pattern in Angular. Many Angular features — like HTTPClient, Reactive Forms, and Router events — use RxJS Observables for reactive programming and event-driven workflows."
        },
        {
          "type": "text",
          "text": "<strong>Creating an Observable</strong><br>Observables can be created using the <code>Observable</code> class or RxJS creation operators like <code>of()</code>, <code>from()</code>, or <code>interval()</code>."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Observable, of, interval } from 'rxjs';\n\n// Example 1: Custom Observable\nconst customObservable = new Observable(observer => {\n  observer.next('First value');\n  observer.next('Second value');\n  setTimeout(() => observer.complete(), 1000);\n});\n\n// Example 2: Built-in RxJS operators\nconst numbers$ = of(1, 2, 3, 4, 5);\nconst timer$ = interval(1000);"
        },
        {
          "type": "text",
          "text": "<strong>Subscribing to an Observable</strong><br>To receive values from an Observable, you must <em>subscribe</em> to it. This triggers the Observable to start emitting values."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "numbers$.subscribe(value => console.log('Received:', value));\n\ncustomObservable.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('Completed!')\n});"
        },
        {
          "type": "text",
          "text": "<strong>Observables in Angular</strong><br>Angular uses Observables in many core features:<ul><li><strong>HTTP Requests</strong> — via <code>HttpClient</code> service.</li><li><strong>Reactive Forms</strong> — form controls emit value and status changes as Observables.</li><li><strong>Routing</strong> — router events (e.g., navigationStart) are emitted as Observables.</li><li><strong>Event Streams</strong> — you can use RxJS to handle streams like mouse movements or input changes.</li></ul>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: Using Observable with HttpClient\nimport { HttpClient } from '@angular/common/http';\nimport { Component, OnInit } from '@angular/core';\n\n@Component({ selector: 'app-user-list', templateUrl: './user-list.component.html' })\nexport class UserListComponent implements OnInit {\n  users$ = this.http.get<any[]>('https://jsonplaceholder.typicode.com/users');\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit() {\n    this.users$.subscribe(data => console.log(data));\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>RxJS Operators</strong><br>Operators transform or combine Observables to produce new ones. Commonly used operators include:<ul><li><code>map()</code> — transforms emitted values.</li><li><code>filter()</code> — filters out unwanted values.</li><li><code>switchMap()</code> — switches to a new Observable on emission.</li><li><code>debounceTime()</code> — delays emissions to handle rapid events (like typing).</li><li><code>catchError()</code> — handles errors gracefully.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Advantages of Observables</strong><br><ul><li>Provide powerful tools for handling asynchronous and event-based data.</li><li>Support cancellation — unsubscribing stops the stream.</li><li>Offer operators for complex data flow transformations.</li><li>Enable reactive programming patterns in Angular.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Observable vs Promise</strong><br><ul><li><strong>Observables</strong> can emit multiple values over time, while <strong>Promises</strong> resolve only once.</li><li>Observables are lazy (nothing happens until subscribed), whereas Promises are eager.</li><li>Observables can be canceled easily using <code>unsubscribe()</code>.</li></ul>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: Unsubscribing from an Observable\nconst subscription = timer$.subscribe(value => console.log(value));\n\n// Stop receiving values after 5 seconds\nsetTimeout(() => subscription.unsubscribe(), 5000);"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of an Observable as a live 'data stream' — it keeps flowing with new values until you stop listening (unsubscribe), while a Promise is like a one-time delivery package."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Observables represent data streams that emit values over time.</li><li>They are powered by RxJS, Angular’s reactive programming backbone.</li><li>Used extensively in Angular for HTTP, forms, and event handling.</li><li>Support operators for transforming, filtering, and combining asynchronous data.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-routing",
    "title": "What is Angular routing and how do you define routes?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Angular routing is a feature that allows navigation between different views or components in a single-page application (SPA). Routes are defined using the RouterModule and configured with path-component mappings in a routing module.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Angular’s routing system enables navigation between different views or components without reloading the page. It turns your Angular application into a single-page application (SPA) — meaning that instead of fetching new HTML pages from the server, it dynamically updates the view based on the URL."
        },
        {
          "type": "text",
          "text": "<strong>How Routing Works</strong><br>The Angular Router maps URL paths to specific components. When the browser’s address changes, Angular determines which component to display by matching the URL with a defined route configuration."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: app-routing.module.ts\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { AboutComponent } from './about/about.component';\nimport { ContactComponent } from './contact/contact.component';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent }, // default route\n  { path: 'about', component: AboutComponent },\n  { path: 'contact', component: ContactComponent },\n  { path: '**', redirectTo: '' } // wildcard route for 404s\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}"
        },
        {
          "type": "text",
          "text": "<strong>Defining Routes</strong><br>Each route is defined as an object in the <code>Routes</code> array with at least a <code>path</code> and a <code>component</code> property:<ul><li><strong>path</strong> – the URL segment (e.g., 'about').</li><li><strong>component</strong> – the component to render when the path is matched.</li></ul>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- app.component.html -->\n<nav>\n  <a routerLink=\"/\">Home</a>\n  <a routerLink=\"/about\">About</a>\n  <a routerLink=\"/contact\">Contact</a>\n</nav>\n\n<!-- Placeholder for route content -->\n<router-outlet></router-outlet>"
        },
        {
          "type": "text",
          "text": "<strong>RouterModule Methods</strong><br><ul><li><code>RouterModule.forRoot(routes)</code> – used in the root module for application-wide routing.</li><li><code>RouterModule.forChild(routes)</code> – used in feature modules for modular routing setups.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Navigation Methods</strong><br>Angular provides two main ways to navigate:<ul><li>Declaratively with <code>routerLink</code> in templates.</li><li>Programmatically with <code>Router.navigate()</code> in TypeScript.</li></ul>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: programmatic navigation\nimport { Router } from '@angular/router';\n\nconstructor(private router: Router) {}\n\ngoToAbout() {\n  this.router.navigate(['/about']);\n}"
        },
        {
          "type": "text",
          "text": "<strong>Route Parameters</strong><br>Routes can also include dynamic parameters, allowing you to create routes that depend on variable data (e.g., user IDs)."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example with route parameters\n{ path: 'user/:id', component: UserDetailComponent }"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Accessing route parameter in component\nimport { ActivatedRoute } from '@angular/router';\n\nconstructor(private route: ActivatedRoute) {}\n\nngOnInit() {\n  const id = this.route.snapshot.paramMap.get('id');\n  console.log('User ID:', id);\n}"
        },
        {
          "type": "text",
          "text": "<strong>Benefits of Angular Routing</strong><br><ul><li>Enables smooth client-side navigation without page reloads.</li><li>Improves performance and user experience.</li><li>Supports route guards, parameters, and lazy loading for scalability.</li><li>Allows nested and child routes for modular app structures.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Angular routing as a GPS — it maps URLs to the right components so users can navigate your app fluidly without ever leaving the page."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Angular routing manages navigation between components in SPAs.</li><li>Routes are defined using <code>RouterModule</code> and configured in a routing module.</li><li><code>routerLink</code> and <code>Router.navigate()</code> are used for navigation.</li><li>Dynamic routes, guards, and lazy loading enhance flexibility.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-lazy-loading",
    "title": "What is lazy loading in Angular?",
    "technology": "angular",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Lazy loading in Angular is a technique that loads feature modules only when they are needed, rather than at application startup. It improves performance by reducing the initial bundle size and speeding up the first load.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Lazy loading in Angular is an optimization strategy that helps improve performance by loading specific parts of the application only when required. Instead of downloading all modules and components when the app starts, Angular fetches feature modules on demand — typically when the user navigates to a particular route."
        },
        {
          "type": "text",
          "text": "<strong>How It Works</strong><br>By default, Angular eagerly loads all modules at startup. With lazy loading, feature modules are split into separate chunks, and Angular loads them only when their routes are accessed. This reduces the initial load time and makes the application faster and more efficient."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: Setting up lazy loading in app-routing.module.ts\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\n\nconst routes: Routes = [\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\n  { path: 'home', loadChildren: () => import('./home/home.module').then(m => m.HomeModule) },\n  { path: 'products', loadChildren: () => import('./products/products.module').then(m => m.ProductsModule) }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}"
        },
        {
          "type": "text",
          "text": "In this example, the <code>home</code> and <code>products</code> feature modules are not loaded until the user navigates to their respective routes. Each module is fetched dynamically using the <code>loadChildren</code> property."
        },
        {
          "type": "text",
          "text": "<strong>Creating a Lazy-Loaded Module</strong><br>Use the Angular CLI to generate a module with routing configured for lazy loading:<br><code>ng generate module products --route products --module app.module</code>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: products-routing.module.ts\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { ProductListComponent } from './product-list/product-list.component';\n\nconst routes: Routes = [\n  { path: '', component: ProductListComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class ProductsRoutingModule {}"
        },
        {
          "type": "text",
          "text": "<strong>Benefits of Lazy Loading</strong><br><ul><li>Reduces initial bundle size for faster application startup.</li><li>Improves overall app performance by loading only necessary modules.</li><li>Enhances scalability — new modules can be added easily without affecting initial load time.</li><li>Better user experience on slower networks or large applications.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Eager Loading vs Lazy Loading</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Eager Loading",
            "Lazy Loading"
          ],
          "rows": [
            [
              "When Loaded",
              "All modules loaded at startup.",
              "Modules loaded on demand when needed."
            ],
            [
              "Performance",
              "Slower initial load, faster subsequent navigation.",
              "Faster initial load, modules loaded asynchronously."
            ],
            [
              "Use Case",
              "Small or simple applications.",
              "Large-scale or modular applications."
            ]
          ],
          "caption": "Comparison between Eager and Lazy Loading"
        },
        {
          "type": "text",
          "text": "<strong>Preloading Strategy</strong><br>Angular also provides a hybrid approach called <strong>preloading</strong>, where lazily loaded modules are fetched in the background after the app loads. You can enable it using the <code>PreloadAllModules</code> strategy:"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { PreloadAllModules, RouterModule } from '@angular/router';\n\nRouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules });"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of lazy loading as packing your app into ‘mini-bundles’ — instead of loading everything upfront, Angular loads each bundle only when the user needs it."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Lazy loading defers loading feature modules until needed.</li><li>Improves performance by reducing the initial bundle size.</li><li>Configured via <code>loadChildren</code> in the routing module.</li><li>Ideal for large, modular, and enterprise-level applications.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-change-detection-strategies",
    "title": "What are change detection strategies in Angular, and how do they work?",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 5,
    "description": "Change detection in Angular is the mechanism that keeps the view in sync with the component’s data. Angular provides two strategies — Default and OnPush — to determine when and how it checks for changes and updates the DOM.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Change detection in Angular is the process by which the framework synchronizes the application's data model (component properties) with the view (DOM). Whenever the data changes, Angular determines what parts of the view need to be updated and efficiently re-renders them. This is one of the most critical mechanisms in Angular’s performance model."
        },
        {
          "type": "text",
          "text": "<strong>How Change Detection Works</strong><br>Angular maintains a tree of components, each associated with a change detector. Whenever a change occurs (for example, a user event, async call, or timer), Angular traverses this tree and checks if the component’s data bindings have changed. If a change is detected, the DOM is updated accordingly."
        },
        {
          "type": "text",
          "text": "<strong>Change Detection Strategies</strong><br>Angular provides two strategies to control how and when the change detection mechanism runs:"
        },
        {
          "type": "list",
          "columns": [
            "Strategy",
            "Description"
          ],
          "rows": [
            [
              "<code>ChangeDetectionStrategy.Default</code>",
              "This is the default strategy. Angular checks every component in the component tree during every change detection cycle, whether or not its input data has changed. It’s simple but less efficient for large applications."
            ],
            [
              "<code>ChangeDetectionStrategy.OnPush</code>",
              "With this strategy, Angular only checks the component and its children when specific conditions occur — such as when an @Input() reference changes, an event originates from inside the component, or you manually trigger detection. This makes the app faster and more predictable."
            ]
          ],
          "caption": "Angular Change Detection Strategies"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `<p>{{ user.name }}</p>`,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserCardComponent {\n  user = { name: 'Alice' };\n}"
        },
        {
          "type": "text",
          "text": "In the example above, the component uses the <code>OnPush</code> strategy. Angular will only re-check this component when the <code>user</code> reference changes — not when you mutate its properties (e.g., <code>user.name = 'Bob'</code>)."
        },
        {
          "type": "text",
          "text": "<strong>When Does Angular Trigger Change Detection?</strong><br>Angular triggers change detection automatically in response to various async events, such as:<ul><li>User interactions (clicks, input changes, etc.)</li><li>Promises and Observables completing</li><li>setTimeout() and setInterval() callbacks</li><li>XHR or fetch responses</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Manually Controlling Change Detection</strong><br>For performance-sensitive applications, developers can control change detection manually using the <code>ChangeDetectorRef</code> API."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { ChangeDetectorRef, Component } from '@angular/core';\n\n@Component({ selector: 'app-demo', template: `{{ counter }}` })\nexport class DemoComponent {\n  counter = 0;\n  constructor(private cd: ChangeDetectorRef) {}\n\n  increment() {\n    this.counter++;\n    this.cd.detectChanges(); // manually trigger change detection\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>Performance Considerations</strong><br><ul><li><code>Default</code> is simpler and sufficient for smaller apps but can become costly for large component trees.</li><li><code>OnPush</code> is more performant and should be used when components depend on immutable data or pure inputs.</li><li>Manual detection control (using <code>ChangeDetectorRef</code>) is useful for advanced optimization scenarios.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Angular change detection as a 'smart mirror' — by default it checks everything for changes, but with <code>OnPush</code> you tell it to look only when you know something has changed."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Change detection keeps the UI in sync with data changes.</li><li>Two strategies exist — Default (checks all) and OnPush (checks only when inputs or events trigger).</li><li>OnPush provides better performance for immutable and reactive data flows.</li><li>Developers can use <code>ChangeDetectorRef</code> for fine-grained control.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-zonejs-change-detection",
    "title": "How does Angular’s Zone.js help in change detection?",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 5,
    "description": "Zone.js is a library used by Angular to automatically track and intercept asynchronous operations such as events, promises, and timers. It notifies Angular whenever an async event completes so the framework can trigger change detection automatically.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Zone.js is a powerful library that Angular uses under the hood to manage asynchronous operations and automatically trigger change detection. Without it, developers would have to manually inform Angular every time something asynchronous (like an event, timer, or HTTP call) modifies the application state."
        },
        {
          "type": "text",
          "text": "<strong>What Is a Zone?</strong><br>A 'zone' is like an execution context that keeps track of all asynchronous tasks (e.g., setTimeout, event listeners, Promises). Zone.js patches these APIs so it can detect when they start and finish. Once an async task completes, Zone.js notifies Angular, which then runs the change detection cycle to update the UI."
        },
        {
          "type": "text",
          "text": "<strong>How Angular Uses Zone.js</strong><br>Angular creates a special zone called the <code>NgZone</code>. It wraps all asynchronous operations inside this zone. When an async event completes, Zone.js calls Angular’s internal mechanism to check for data changes and refresh the view."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, NgZone } from '@angular/core';\n\n@Component({ selector: 'app-zone-demo', template: `<p>{{ counter }}</p>` })\nexport class ZoneDemoComponent {\n  counter = 0;\n  constructor(private zone: NgZone) {\n    this.zone.runOutsideAngular(() => {\n      setInterval(() => {\n        this.counter++;\n        // Update runs outside Angular zone, so UI won't update automatically\n      }, 1000);\n    });\n  }\n\n  startDetection() {\n    this.zone.run(() => {\n      console.log('Entering Angular Zone');\n    });\n  }\n}"
        },
        {
          "type": "text",
          "text": "In this example:<ul><li><code>runOutsideAngular()</code> executes code without triggering change detection.</li><li><code>run()</code> brings execution back into the Angular zone, enabling automatic updates.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>How Zone.js Triggers Change Detection</strong><br>When an asynchronous operation (like <code>setTimeout()</code> or an HTTP call) finishes, Zone.js intercepts it and calls Angular’s internal <code>ApplicationRef.tick()</code> method. This initiates the change detection cycle, ensuring that the UI stays consistent with the data model."
        },
        {
          "type": "text",
          "text": "<strong>Benefits of Using Zone.js</strong><br><ul><li>Automatically triggers change detection after async operations.</li><li>Eliminates the need for manual DOM updates.</li><li>Ensures the UI always reflects the latest application state.</li><li>Provides APIs to run code inside or outside Angular’s zone for performance tuning.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>When You Might Disable Zone.js</strong><br>Advanced developers sometimes disable Zone.js (using <code>zone-flags.ts</code>) to gain full control over change detection — often in highly optimized or reactive applications that use manual <code>ChangeDetectorRef</code> or frameworks like <code>RxAngular</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Zone.js as Angular’s 'watchdog' for async operations — it keeps an eye on everything happening in the background and tells Angular, “Hey, something changed, time to update the view!”"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Zone.js tracks asynchronous operations and notifies Angular when they complete.</li><li>Angular uses <code>NgZone</code> to wrap these operations.</li><li>This allows Angular to automatically trigger change detection and update the DOM.</li><li>You can use <code>runOutsideAngular()</code> for performance-critical code that shouldn’t trigger detection.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-ngonchanges-vs-ngdocheck",
    "title": "What is the purpose of ngOnChanges() and how does it differ from ngDoCheck()?",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 5,
    "description": "ngOnChanges() and ngDoCheck() are Angular lifecycle hooks that detect and respond to changes in component data. ngOnChanges() automatically runs when @Input() values change, while ngDoCheck() allows developers to perform custom change detection logic beyond Angular’s default mechanism.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Angular provides lifecycle hooks that allow developers to tap into the change detection process and respond to data updates. Two important hooks for monitoring data changes are <code>ngOnChanges()</code> and <code>ngDoCheck()</code>. Both help in detecting changes to component state, but they serve different purposes and operate at different levels of precision."
        },
        {
          "type": "text",
          "text": "<strong>ngOnChanges()</strong><br>This hook is called automatically whenever the value of an <code>@Input()</code> property changes. It runs before <code>ngOnInit()</code> and receives a <code>SimpleChanges</code> object that contains the previous and current values of changed inputs."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `<p>{{ user.name }}</p>`\n})\nexport class UserCardComponent implements OnChanges {\n  @Input() user!: { name: string };\n\n  ngOnChanges(changes: SimpleChanges) {\n    console.log('Previous:', changes['user'].previousValue);\n    console.log('Current:', changes['user'].currentValue);\n  }\n}"
        },
        {
          "type": "text",
          "text": "In this example, <code>ngOnChanges()</code> automatically detects when the <code>user</code> input changes and logs the old and new values. It is especially useful when you want to react only to input-bound property changes."
        },
        {
          "type": "text",
          "text": "<strong>ngDoCheck()</strong><br>While <code>ngOnChanges()</code> only detects <code>@Input()</code> changes, <code>ngDoCheck()</code> is a more powerful hook that lets developers implement <em>custom change detection logic</em>. It runs during every change detection cycle, even if inputs haven’t changed."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, Input, DoCheck } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `<p>{{ user.name }}</p>`\n})\nexport class UserCardComponent implements DoCheck {\n  @Input() user!: { name: string };\n  private oldName = '';\n\n  ngDoCheck() {\n    if (this.user.name !== this.oldName) {\n      console.log('User name changed from', this.oldName, 'to', this.user.name);\n      this.oldName = this.user.name;\n    }\n  }\n}"
        },
        {
          "type": "text",
          "text": "In this example, <code>ngDoCheck()</code> manually checks for changes within the <code>user</code> object — something <code>ngOnChanges()</code> would not detect if only a property (not the object reference) changes."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "ngOnChanges()",
            "ngDoCheck()"
          ],
          "rows": [
            [
              "When Triggered",
              "When @Input() reference changes",
              "On every change detection cycle"
            ],
            [
              "Scope",
              "Tracks input-bound property changes",
              "Can detect deep or custom changes"
            ],
            [
              "Performance",
              "Lightweight",
              "Can be costly if overused"
            ],
            [
              "Use Case",
              "Reacting to @Input() updates",
              "Implementing custom change tracking logic"
            ]
          ],
          "caption": "Comparison between ngOnChanges() and ngDoCheck()"
        },
        {
          "type": "text",
          "text": "<strong>Performance Considerations</strong><br><ul><li><code>ngOnChanges()</code> is more efficient since it only runs when input references change.</li><li><code>ngDoCheck()</code> provides flexibility but should be used carefully, as it runs very frequently during change detection cycles.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>ngOnChanges()</code> as Angular’s built-in observer for input updates, while <code>ngDoCheck()</code> is a manual magnifying glass — you use it when Angular’s default detection isn’t enough."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li><code>ngOnChanges()</code> reacts to input-bound changes automatically.</li><li><code>ngDoCheck()</code> allows for custom logic to detect complex or deep changes.</li><li>Both help maintain UI consistency but differ in granularity and cost.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-forroot-forchild",
    "title": "What are Angular modules’ forRoot() and forChild() methods used for?",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 5,
    "description": "forRoot() and forChild() are Angular module configuration methods that help manage singleton services and routing across root and feature modules. forRoot() configures global providers and routes for the root module, while forChild() configures additional routes for feature modules without duplicating providers.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In Angular, modules can include routing and services. The <code>forRoot()</code> and <code>forChild()</code> methods are conventions that help manage how routes and services are provided across different parts of an application — ensuring that global providers are instantiated only once, and feature modules get their own route configurations."
        },
        {
          "type": "text",
          "text": "<strong>The Problem They Solve</strong><br>When you import the same module (such as a routing or service module) into multiple feature modules, Angular might create multiple instances of services or conflicting route definitions. <code>forRoot()</code> and <code>forChild()</code> prevent this by clearly defining which module provides shared singletons (root-level) and which only extends configuration (child-level)."
        },
        {
          "type": "text",
          "text": "<strong>forRoot()</strong><br>The <code>forRoot()</code> method is used in the <strong>root module</strong> (usually <code>AppModule</code>). It configures and provides application-wide services, singletons, and routes that should be initialized once for the entire application."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: AppRoutingModule with forRoot()\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}"
        },
        {
          "type": "text",
          "text": "Here, <code>RouterModule.forRoot()</code> sets up the application's root router. It defines the initial navigation paths and ensures that only one router service instance exists across the app."
        },
        {
          "type": "text",
          "text": "<strong>forChild()</strong><br>The <code>forChild()</code> method is used in <strong>feature modules</strong>. It allows these modules to define their own route configurations without re-initializing the router or global providers. This supports modular architecture and lazy loading."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: ProductsRoutingModule with forChild()\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { ProductListComponent } from './product-list/product-list.component';\nimport { ProductDetailComponent } from './product-detail/product-detail.component';\n\nconst routes: Routes = [\n  { path: '', component: ProductListComponent },\n  { path: ':id', component: ProductDetailComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class ProductsRoutingModule {}"
        },
        {
          "type": "text",
          "text": "Here, <code>RouterModule.forChild()</code> defines routes specific to the <code>ProductsModule</code>. It does not create a new router instance but instead extends the main router configuration."
        },
        {
          "type": "text",
          "text": "<strong>forRoot() and forChild() in Shared Modules</strong><br>Custom shared modules (e.g., logging or analytics) may also use the <code>forRoot()</code>/<code>forChild()</code> pattern to manage singleton service instantiation."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: SharedModule using forRoot()\n@NgModule({\n  providers: []\n})\nexport class SharedModule {\n  static forRoot(): ModuleWithProviders<SharedModule> {\n    return {\n      ngModule: SharedModule,\n      providers: [LoggingService] // Singleton provider\n    };\n  }\n}"
        },
        {
          "type": "text",
          "text": "This ensures that the <code>LoggingService</code> is instantiated only once at the root level, even if <code>SharedModule</code> is imported in multiple places."
        },
        {
          "type": "list",
          "columns": [
            "Method",
            "Used In",
            "Purpose",
            "Example"
          ],
          "rows": [
            [
              "forRoot()",
              "Root module (AppModule)",
              "Configures global services and root routing",
              "RouterModule.forRoot(routes)"
            ],
            [
              "forChild()",
              "Feature module",
              "Defines module-specific routes without creating new instances",
              "RouterModule.forChild(routes)"
            ]
          ],
          "caption": "Differences Between forRoot() and forChild()"
        },
        {
          "type": "text",
          "text": "<strong>Best Practices</strong><ul><li>Use <code>forRoot()</code> only once — in the root module.</li><li>Use <code>forChild()</code> in feature or lazy-loaded modules.</li><li>Do not import <code>RouterModule.forRoot()</code> in feature modules, as it can cause multiple router instances and unpredictable behavior.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>forRoot()</code> as setting up the main roads of your app, while <code>forChild()</code> adds local streets within neighborhoods (feature modules) without rebuilding the entire map."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li><code>forRoot()</code> initializes global providers and routing — used in the root module.</li><li><code>forChild()</code> defines feature module routes without duplicating providers.</li><li>Together, they ensure scalable, modular, and efficient routing and service management in Angular applications.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "angular-performance-optimization",
    "title": "How does Angular handle performance optimization for large applications?",
    "technology": "angular",
    "difficulty": "hard",
    "importance": 5,
    "description": "Angular provides a variety of built-in tools and best practices for optimizing performance in large applications. These include efficient change detection strategies, lazy loading, Ahead-of-Time (AOT) compilation, tree-shaking, and other advanced techniques to minimize bundle size and rendering time.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>As Angular applications grow in size and complexity, performance optimization becomes essential to maintain fast loading times, smooth user interactions, and efficient change detection. Angular includes a robust set of features and optimization strategies designed to improve both runtime and build-time performance."
        },
        {
          "type": "text",
          "text": "<strong>1. Efficient Change Detection with OnPush</strong><br>By default, Angular checks all components in every change detection cycle. However, for large apps, this can be costly. Using <code>ChangeDetectionStrategy.OnPush</code> allows Angular to check components only when their input references change, significantly reducing unnecessary updates."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { Component, ChangeDetectionStrategy, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-user-profile',\n  template: `<h3>{{ user.name }}</h3>`,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserProfileComponent {\n  @Input() user!: { name: string };\n}"
        },
        {
          "type": "text",
          "text": "This approach is especially effective when used with immutable data structures or RxJS streams that emit new values instead of mutating existing ones."
        },
        {
          "type": "text",
          "text": "<strong>2. Lazy Loading of Modules</strong><br>Angular supports <strong>lazy loading</strong>, which loads feature modules only when needed. This reduces the initial bundle size, improving startup performance for large-scale applications. Modules that are not immediately required by the user are loaded asynchronously upon navigation."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "{ path: 'admin', loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule) }"
        },
        {
          "type": "text",
          "text": "<strong>3. Ahead-of-Time (AOT) Compilation</strong><br>Angular’s AOT compiler converts TypeScript and HTML templates into optimized JavaScript during the build phase, rather than at runtime. This results in smaller, faster applications with fewer runtime errors."
        },
        {
          "type": "code",
          "language": "bash",
          "code": "ng build --prod --aot"
        },
        {
          "type": "text",
          "text": "AOT removes the need for the browser to compile templates, reducing the startup cost and improving performance, especially on low-powered devices."
        },
        {
          "type": "text",
          "text": "<strong>4. Tree Shaking and Bundle Optimization</strong><br>Tree shaking removes unused code from the final bundle. Angular’s build system (based on Webpack) automatically performs tree-shaking, minification, and dead-code elimination when building with production mode (<code>--configuration production</code>)."
        },
        {
          "type": "text",
          "text": "<strong>5. Using TrackBy with *ngFor</strong><br>When rendering lists with <code>*ngFor</code>, Angular re-renders all elements when data changes by default. By providing a <code>trackBy</code> function, you can optimize list rendering by updating only the modified elements."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<li *ngFor=\"let user of users; trackBy: trackById\">{{ user.name }}</li>"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "trackById(index: number, user: any): number {\n  return user.id;\n}"
        },
        {
          "type": "text",
          "text": "<strong>6. Pure Pipes for Efficient Transformations</strong><br>Angular pipes are a great way to transform data in templates. Pure pipes execute only when input values change, unlike impure pipes, which run on every change detection cycle. Using pure pipes prevents redundant recalculations."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "@Pipe({ name: 'capitalize', pure: true })\nexport class CapitalizePipe implements PipeTransform {\n  transform(value: string): string {\n    return value.charAt(0).toUpperCase() + value.slice(1);\n  }\n}"
        },
        {
          "type": "text",
          "text": "<strong>7. On-Demand Change Detection Control</strong><br>Developers can take control of change detection using <code>ChangeDetectorRef</code>. By detaching and reattaching detection manually, you can optimize performance in complex UIs with frequent updates."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "constructor(private cd: ChangeDetectorRef) {}\n\nngAfterViewInit() {\n  this.cd.detach(); // Stop automatic checking\n  setTimeout(() => {\n    this.cd.detectChanges(); // Manually trigger update\n  }, 1000);\n}"
        },
        {
          "type": "text",
          "text": "<strong>8. Using Web Workers for Heavy Computations</strong><br>Angular supports Web Workers to offload computationally expensive tasks (like image processing or data parsing) from the main UI thread. This keeps the interface responsive."
        },
        {
          "type": "code",
          "language": "bash",
          "code": "ng generate web-worker app"
        },
        {
          "type": "text",
          "text": "<strong>9. Async and OnPush with RxJS</strong><br>Using the <code>async</code> pipe along with <code>OnPush</code> components minimizes subscriptions and ensures Angular unsubscribes automatically. This prevents memory leaks and unnecessary re-renders."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<p *ngIf=\"user$ | async as user\">Welcome, {{ user.name }}!</p>"
        },
        {
          "type": "text",
          "text": "<strong>10. Preloading Strategies</strong><br>Angular’s Router offers preloading strategies that load lazy modules in the background after the main app is ready. This reduces navigation delays later on."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "import { PreloadAllModules, RouterModule } from '@angular/router';\n\nRouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules });"
        },
        {
          "type": "text",
          "text": "<strong>11. Using Pure Functions and Immutability</strong><br>Keeping your component logic pure (without side effects) and using immutable objects allows Angular to optimize rendering and makes debugging simpler. Immutable updates are especially effective when used with <code>OnPush</code>."
        },
        {
          "type": "text",
          "text": "<strong>12. Production Builds and Source Map Optimization</strong><br>Always use production builds in deployment. Angular’s production build mode enables AOT, tree shaking, minification, and optimizations by default, drastically improving runtime speed and reducing bundle size."
        },
        {
          "type": "code",
          "language": "bash",
          "code": "ng build --configuration production"
        },
        {
          "type": "text",
          "text": "<strong>13. Server-Side Rendering (SSR)</strong><br>Using Angular Universal for server-side rendering improves perceived performance and SEO. The initial HTML is rendered on the server, so the app appears faster to users before the client-side bundle fully loads."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Angular’s performance optimizations as tuning an orchestra — lazy loading reduces the number of players on stage, OnPush ensures only the right ones play, and AOT ensures every note is ready before the concert begins."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Angular optimizes large apps through OnPush detection, lazy loading, AOT, and tree shaking.</li><li>TrackBy, pure pipes, and RxJS streams prevent redundant rendering.</li><li>Web workers, preloading, and SSR further enhance responsiveness.</li><li>Combining these strategies ensures Angular apps remain fast, scalable, and efficient even at enterprise scale.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  }
]