[
    {
        "id": "vue-counter",
        "title": "Counter (Component with Guarded Decrement)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "beginner",
        "importance": 3,
        "tags": [
            "vue",
            "components",
            "reactivity",
            "event-handlers",
            "basics"
        ],
        "description": {
            "summary": "Build a simple Vue 3 counter component that displays a value and has '+' and '−' buttons. The count must never go below 0.",
            "specs": {
                "requirements": [
                    "Render the counter UI as the main component.",
                    "Display the current count value.",
                    "Provide '+' and '−' buttons to increment and decrement.",
                    "Prevent the count from ever going below 0.",
                    "Include a 'Reset' button that sets the count back to 0."
                ],
                "expectedBehavior": [
                    "Initial count starts at 0.",
                    "Clicking '+' increases the count by 1.",
                    "Clicking '−' decreases the count by 1, but never below 0.",
                    "Clicking 'Reset' sets the count back to 0.",
                    "The '−' button is disabled when the count is 0."
                ],
                "implementationNotes": [
                    "Use Vue 3's Composition API with `ref` to store the count.",
                    "Use a `computed` property to determine when the count is zero and disable the decrement button.",
                    "Keep everything in a single `<App.vue>` component for this exercise."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`, `computed`)",
                    "Basic component structure",
                    "Click event handlers",
                    "Guarded state updates"
                ]
            }
        },
        "starterCodeHint": "Implement the counter logic inside `<script setup>`. Use `ref(0)` for the value and a `computed` property for the disabled state of the decrement button.",
        "solutionBlock": {
            "overview": "Use Vue 3's Composition API with `ref(0)` for the count and a `computed` property that returns `true` when the count is 0. The '+' button increments the ref, the '−' button decrements but is guarded so the value never becomes negative, and 'Reset' sets it back to 0.\n\n**Key ideas**\n- Store count in a single `ref`.\n- Derive disabled state from a `computed` value.\n- Guard the decrement so it never sets a negative value.",
            "approaches": [
                {
                    "title": "Single component with guarded decrement",
                    "prose": "Keep all logic inside `<script setup>` in `App.vue`. Use `const count = ref(0)` to create reactive state. Define a computed property `isZero` that checks `count.value === 0` and bind it to `:disabled` on the decrement button. Implement `inc`, `dec`, and `reset` as simple functions that mutate `count.value`, with `dec` checking that the value is greater than 0 before decrementing."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Updating `count` without guarding against negatives, allowing the value to go below 0.",
                    "Forgetting to use `.value` when reading or writing refs inside `<script setup>`.",
                    "Deriving `isZero` manually and forgetting to update it when count changes instead of using `computed`."
                ],
                "techniques": [
                    "Using `ref` for local reactive state in Vue 3.",
                    "Using `computed` to derive boolean UI state (disabled button).",
                    "Keeping state and handlers co-located with the component template."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-counter.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-counter"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-counter-solution.v1.json"
    },
    {
        "id": "vue-contact-form-starter",
        "title": "Contact Form (Single File Component + Fetch)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "forms",
            "http",
            "validation",
            "user-input"
        ],
        "description": {
            "summary": "Build a contact form in a Vue 3 single file component using the Composition API. You will only work inside <script setup> in App.vue. The template and styles are already provided for you. Validate the user's input and send the form data with a POST request to https://jsonplaceholder.typicode.com/posts, showing loading, success, and error states.",
            "specs": {
                "requirements": [
                    "Use Vue 3's Composition API in a single-file component (App.vue).",
                    "Use refs to track form fields: name, email, and message.",
                    "Make all fields required; validate email with a basic email pattern and require a minimum length for the message (e.g. at least 10 characters).",
                    "Disable the submit button while the form is invalid or while a request is in progress.",
                    "On submit, send a POST request with the form body to https://jsonplaceholder.typicode.com/posts.",
                    "Show a success message if the request succeeds and an error message if it fails."
                ],
                "expectedBehavior": [
                    "Initially, the submit button is disabled until all fields are valid.",
                    "If the user attempts to submit invalid data, validation error messages are shown for the affected fields once they have been touched.",
                    "On a valid submit, a POST request is sent and the button is disabled while the request is in flight.",
                    "On success, show the message: \"Your message has been sent. Thank you!\" and optionally reset the form.",
                    "On error, show the message: \"Something went wrong. Please try again.\" and allow the user to submit again."
                ],
                "implementationNotes": [
                    "Work only in <script setup> of App.vue. The template and CSS are already wired up.",
                    "Use refs for field values and for 'touched' flags to control when to show validation messages.",
                    "Derive booleans like nameIsValid, emailIsValid, messageIsValid, and formIsValid from the current values.",
                    "Use the fetch API to send a POST request to https://jsonplaceholder.typicode.com/posts with a JSON body.",
                    "Track an isSubmitting ref to control the disabled state and avoid double submissions.",
                    "Use successMessage and errorMessage refs for user feedback."
                ],
                "techFocus": [
                    "Vue 3 Composition API (refs and derived state)",
                    "Form validation and UX (touched state, inline errors, disabled submit)",
                    "Basic fetch usage and request lifecycle handling from a component",
                    "Single File Component structure with <template> and <script setup>"
                ]
            }
        },
        "starterCodeHint": "Focus exclusively on <script setup> inside App.vue. Use refs for name, email, and message, plus separate 'touched' flags. Derive a formIsValid boolean and implement an async handleSubmit that POSTs to https://jsonplaceholder.typicode.com/posts and updates successMessage / errorMessage.",
        "solutionBlock": {
            "overview": "This exercise combines a Vue 3 single file component, the Composition API, and an HTTP POST request. You will define refs for name, email, and message, along with 'touched' flags to control when to show validation errors. Derived booleans like nameIsValid, emailIsValid, messageIsValid, and formIsValid drive both inline error messages and the disabled state of the submit button.\n\nOn submit, you prevent the default form behavior, mark all fields as touched, clear previous messages, and guard against invalid input. If the form is valid, you set isSubmitting to true and use fetch to POST the JSON payload to https://jsonplaceholder.typicode.com/posts. Depending on the response, you either show \"Your message has been sent. Thank you!\" and reset the form or show \"Something went wrong. Please try again.\" and keep the current values for another attempt.\n\n**Test cases**\n- With all fields empty, the submit button is disabled.\n- Typing an invalid email keeps the form invalid and disabled.\n- Blurring out of empty fields marks them as touched and shows validation errors.\n- With valid inputs, clicking submit triggers a POST request and disables the button while the request is in flight.\n- On success, the success message appears and the fields are cleared.\n- On error, the error message appears and the user can try again.",
            "approaches": [
                {
                    "title": "Single file component with refs, derived validity, and fetch",
                    "prose": "Keep everything inside App.vue using <script setup>. Use refs for name, email, message, and for touched flags (touchedName, touchedEmail, touchedMessage). Derive nameIsValid, emailIsValid, and messageIsValid as booleans, and then combine them into formIsValid. In the template, bind fields with v-model, show error messages when a field is both touched and invalid, and disable the submit button when !formIsValid or isSubmitting is true.\n\nIn handleSubmit, call event.preventDefault(), mark all fields as touched, clear successMessage and errorMessage, and if the form is valid, set isSubmitting to true and send a fetch POST request to https://jsonplaceholder.typicode.com/posts with a JSON body. On a successful response, show the success message and reset the fields and touched flags. On failure, show the error message and leave the fields as-is.",
                    "codeTs": "<template>\n  <main class=\"main\">\n    <section class=\"section\">\n      <h1>Contact Us (Solution)</h1>\n\n      <form class=\"panel\" novalidate @submit=\"handleSubmit\">\n        <div class=\"field\">\n          <label for=\"name\">Name</label>\n          <input\n            id=\"name\"\n            type=\"text\"\n            v-model=\"name\"\n            @blur=\"touchedName = true\"\n          />\n          <p v-if=\"touchedName && !nameIsValid\" class=\"error\">Name is required.</p>\n        </div>\n\n        <div class=\"field\">\n          <label for=\"email\">Email</label>\n          <input\n            id=\"email\"\n            type=\"email\"\n            v-model=\"email\"\n            @blur=\"touchedEmail = true\"\n          />\n          <p v-if=\"touchedEmail && !email\" class=\"error\">Email is required.</p>\n          <p v-if=\"touchedEmail && email && !emailIsValid\" class=\"error\">Enter a valid email address.</p>\n        </div>\n\n        <div class=\"field\">\n          <label for=\"message\">Message</label>\n          <textarea\n            id=\"message\"\n            rows=\"4\"\n            v-model=\"message\"\n            @blur=\"touchedMessage = true\"\n          />\n          <p v-if=\"touchedMessage && !message\" class=\"error\">Message is required.</p>\n          <p\n            v-if=\"touchedMessage && message && !messageIsValid\"\n            class=\"error\"\n          >\n            Message should be at least 10 characters.\n          </p>\n        </div>\n\n        <button\n          type=\"submit\"\n          class=\"primary\"\n          :disabled=\"!formIsValid || isSubmitting\"\n        >\n          {{ isSubmitting ? 'Sending…' : 'Send message' }}\n        </button>\n\n        <p v-if=\"successMessage\" class=\"success\">{{ successMessage }}</p>\n        <p v-if=\"errorMessage\" class=\"error\">{{ errorMessage }}</p>\n      </form>\n    </section>\n  </main>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed } from 'vue';\n\nconst name = ref('');\nconst email = ref('');\nconst message = ref('');\n\nconst touchedName = ref(false);\nconst touchedEmail = ref(false);\nconst touchedMessage = ref(false);\n\nconst isSubmitting = ref(false);\nconst successMessage = ref('');\nconst errorMessage = ref('');\n\nconst nameIsValid = computed(() => name.value.trim().length > 0);\nconst emailIsValid = computed(() => /\\S+@\\S+\\.\\S+/.test(email.value));\nconst messageIsValid = computed(() => message.value.trim().length >= 10);\n\nconst formIsValid = computed(\n  () => nameIsValid.value && emailIsValid.value && messageIsValid.value\n);\n\nconst handleSubmit = async (event: any) => {\n  event.preventDefault();\n\n  touchedName.value = true;\n  touchedEmail.value = true;\n  touchedMessage.value = true;\n\n  successMessage.value = '';\n  errorMessage.value = '';\n\n  if (!formIsValid.value) {\n    return;\n  }\n\n  isSubmitting.value = true;\n\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/posts', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        name: name.value,\n        email: email.value,\n        message: message.value\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error('Request failed');\n    }\n\n    successMessage.value = 'Your message has been sent. Thank you!';\n\n    name.value = '';\n    email.value = '';\n    message.value = '';\n    touchedName.value = false;\n    touchedEmail.value = false;\n    touchedMessage.value = false;\n  } catch (error) {\n    errorMessage.value = 'Something went wrong. Please try again.';\n  } finally {\n    isSubmitting.value = false;\n  }\n};\n</script>\n"
                }
            ],
            "notes": {
                "pitfalls": [
                    "Forgetting to call event.preventDefault() in handleSubmit, which causes a full page reload.",
                    "Not using separate 'touched' refs, which makes it hard to control when validation messages appear.",
                    "Allowing the user to submit while the form is invalid or while a request is still in flight.",
                    "Not handling failed responses from fetch, leaving the user without feedback on errors."
                ],
                "techniques": [
                    "Using refs for field values and for UX flags like 'touched' and 'isSubmitting'.",
                    "Deriving all validity booleans (nameIsValid, emailIsValid, messageIsValid, formIsValid) with computed.",
                    "Using fetch for a simple JSON POST request from a component.",
                    "Driving button disabled state and inline messages directly from derived state."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-contact-form.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-contact-form-starter"
        },
        "companies": [
            "google",
            "meta",
            "airbnb"
        ],
        "solutionAsset": "assets/sb/vue/solution/vue-contact-form-solution.v1.json"
    },
    {
        "id": "vue-todo-list",
        "title": "Todo List (Refs + List Rendering)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "lists",
            "state-management",
            "event-handlers",
            "forms"
        ],
        "description": {
            "summary": "Build a small Todo List in Vue 3 using the Composition API and <script setup>. Users should be able to add tasks, mark them as completed, remove individual tasks, and clear all completed tasks.",
            "specs": {
                "requirements": [
                    "Render a Todo List as the main UI in App.vue.",
                    "Use a text input and 'Add' button to create new todos.",
                    "Display todos in a list using v-for.",
                    "Each todo should have a checkbox to toggle completion and a 'Remove' button.",
                    "Provide a 'Clear completed' button that removes all completed todos when clicked."
                ],
                "expectedBehavior": [
                    "Clicking 'Add' with non-empty trimmed text adds a new todo to the list and clears the input.",
                    "Checking a todo's checkbox toggles its completed state and visually marks it (line-through).",
                    "Clicking 'Remove' deletes that specific todo.",
                    "Clicking 'Clear completed' removes all todos where done === true.",
                    "An empty state message is shown when there are no todos."
                ],
                "implementationNotes": [
                    "Use `ref('')` for the controlled input value (newTask).",
                    "Store the list of todos in a `ref<Todo[]>([])` where each todo has `id`, `text`, and `done`.",
                    "Use `computed` for simple derived state like `hasTodos`.",
                    "Implement helpers `addTask`, `toggleTask`, `removeTask`, and `clearCompleted` inside `<script setup>`.",
                    "Keep everything in a single App.vue component."
                ],
                "techFocus": [
                    "Vue 3 Composition API with refs and computed",
                    "List rendering with v-for and keys",
                    "Immutable style array updates (map/filter) for clarity",
                    "Basic component-level state management"
                ]
            }
        },
        "starterCodeHint": "Work only inside `<script setup>` in App.vue. Use `const newTask = ref('')` and `const todos = ref([] as Todo[])`. Implement `addTask`, `toggleTask(id)`, `removeTask(id)`, and `clearCompleted()` and wire them to the template via @click / @change.",
        "solutionBlock": {
            "overview": "Use a single Vue 3 SFC with `<script setup>` to manage the todo list. Track the input value in `newTask` and store todos in a `ref` array with `{ id, text, done }`. A `computed` property `hasTodos` drives the empty state and footer visibility. Actions (`addTask`, `toggleTask`, `removeTask`, `clearCompleted`) update the `todos` array, and the template uses `v-for` to render items plus a checkbox and Remove button.\n\n**Key ideas**\n- Keep all state in refs inside `<script setup>`.\n- Use `v-for` + `:key` for list rendering.\n- Use immutable updates (`map` / `filter`) for clear toggling and removal.\n- Drive simple UI states (empty vs list, footer visibility) from computed values.",
            "approaches": [
                {
                    "title": "Single component with ref-backed list and immutable updates",
                    "prose": "Define `type Todo = { id: number; text: string; done: boolean }` and create `const newTask = ref('')` plus `const todos = ref([] as Todo[])`. `addTask` trims `newTask.value`, bails on empty, and appends a new todo with a unique `id` (e.g. `Date.now()`). `toggleTask(id)` replaces the array with `todos.value.map(todo => todo.id === id ? { ...todo, done: !todo.done } : todo)`. `removeTask(id)` and `clearCompleted()` use `filter` to drop items. A `hasTodos` computed returns `todos.value.length > 0` and controls whether you show the empty message or the list."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Mutating todos in place without updating the ref value in a way that keeps the code clear.",
                    "Adding empty or whitespace-only tasks by forgetting to trim the input.",
                    "Forgetting to use `:key` in `v-for`, which can lead to odd checkbox behaviour.",
                    "Toggling completion without visually reflecting it (missing the `done` class binding)."
                ],
                "techniques": [
                    "Using refs for both scalar and array state.",
                    "Using computed for derived flags such as `hasTodos`.",
                    "Updating arrays immutably to keep logic simple and predictable.",
                    "Binding classes dynamically with `:class` for completed todos."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-todo-list.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-todo-list"
        },
        "companies": [
            "google",
            "meta",
            "airbnb"
        ],
        "solutionAsset": "assets/sb/vue/solution/vue-todo-list-solution.v1.json"
    },
    {
        "id": "vue-image-slider",
        "title": "Image Slider (Basic Navigation)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "beginner",
        "importance": 3,
        "tags": [
            "vue",
            "components",
            "reactivity",
            "arrays",
            "event-handlers"
        ],
        "description": {
            "summary": "Build a simple Vue 3 image slider that shows one image at a time and lets the user move between slides with Previous/Next buttons and small dot indicators.",
            "specs": {
                "requirements": [
                    "Render the image slider UI as the main component.",
                    "Display exactly one slide at a time with an image and a caption.",
                    "Show the current position as 'Slide X of Y'.",
                    "Provide 'Previous' and 'Next' buttons to move between slides.",
                    "Disable 'Previous' on the first slide and 'Next' on the last slide.",
                    "Render dot indicators for each slide and allow clicking a dot to jump directly to that slide."
                ],
                "expectedBehavior": [
                    "Initial slide is the first one in the list.",
                    "Clicking 'Next' moves forward by one slide until the last slide.",
                    "Clicking 'Previous' moves backward by one slide until the first slide.",
                    "The 'Previous' button is disabled on the first slide.",
                    "The 'Next' button is disabled on the last slide.",
                    "Clicking a dot jumps to the corresponding slide and updates the active dot state."
                ],
                "implementationNotes": [
                    "Use Vue 3's Composition API with `ref` to store the current index.",
                    "Keep the slides in a constant array of objects with `id`, `title`, and `imageUrl`.",
                    "Use `computed` properties for `totalSlides`, `currentSlide`, `canGoPrev`, and `canGoNext`.",
                    "Implement small helper functions: `goTo(index)`, `prev()`, and `next()`.",
                    "Make sure navigation is guarded (do not go before the first slide or after the last slide)."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`, `computed`)",
                    "Derived state for UI (current slide, canGoPrev/canGoNext)",
                    "Event handlers for navigation",
                    "Working with arrays of data in a component"
                ]
            }
        },
        "starterCodeHint": "Define a `slides` array in `<script setup>` and track the current slide index in a `ref(0)`. Use `computed` values for the current slide, total slide count, and whether previous/next are allowed. Implement `goTo`, `prev`, and `next` to update the index safely.",
        "solutionBlock": {
            "overview": "Model the image slider as an array of slide objects and a single reactive index stored in a `ref`. Use `computed` properties to derive the current slide, total slide count, and whether the user can go to the previous or next slide. Expose three handlers: `goTo(index)` for jumping to a specific slide (guarded by bounds), `prev()` for moving one step left when possible, and `next()` for moving one step right when possible.\n\n**Key ideas**\n- Store only the current index as reactive state; everything else is derived.\n- Use `computed` for `currentSlide`, `canGoPrev`, and `canGoNext` so the template stays simple.\n- Guard navigation so the index never goes out of range.",
            "approaches": [
                {
                    "title": "Single component slider with derived navigation state",
                    "prose": "Keep all slider logic inside `<script setup>` in `App.vue`. Use a constant `slides` array and a `ref(0)` for `currentIndex`. Derive `totalSlides`, `currentSlide`, `canGoPrev`, and `canGoNext` with `computed` so the template can be mostly declarative. Implement `goTo(index)` with a simple bounds check, and use it from the dot buttons. Implement `prev()` and `next()` to decrement/increment the index only when the corresponding `canGoPrev`/`canGoNext` flags are true. This keeps the component predictable and easy to test."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Letting the index go below 0 or above the last slide index.",
                    "Accessing `slides[currentIndex]` without guarding, which can return `undefined` if the index is wrong.",
                    "Duplicating logic in multiple places instead of using `computed` for derived values."
                ],
                "techniques": [
                    "Using `ref` for reactive state in Vue 3.",
                    "Using `computed` to derive booleans and current-entity data from primitive state.",
                    "Driving both the main view and the small dot indicators from the same single source of truth."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-image-slider.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-image-slider"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-image-slider-solution.v1.json"
    },
    {
        "id": "vue-tabs-switcher",
        "title": "Tabs / Multi-View Switcher",
        "type": "coding",
        "technology": "vue",
        "difficulty": "beginner",
        "importance": 3,
        "tags": [
            "vue",
            "components",
            "reactivity",
            "conditional-rendering",
            "basics"
        ],
        "description": {
            "summary": "Build a simple Vue 3 tabbed interface with three tabs (\"Overview\", \"Details\", \"Settings\") that controls which content is visible.",
            "specs": {
                "requirements": [
                    "Render a tabbed UI with three tabs labeled \"Overview\", \"Details\", and \"Settings\".",
                    "Track which tab is currently active and visually highlight it.",
                    "Render only the active tab's content at a time."
                ],
                "expectedBehavior": [
                    "The initial active tab should be \"Overview\".",
                    "Clicking a tab makes it the active tab.",
                    "Only the active tab's panel is visible at any time.",
                    "The active tab button has a distinct visual style (e.g., filled pill) compared to inactive ones."
                ],
                "implementationNotes": [
                    "Use Vue 3's Composition API with `ref` to store the currently active tab.",
                    "Model the tab id as a string union (e.g., `'overview' | 'details' | 'settings'`).",
                    "Use a helper function like `isActive(tab)` to drive both active styles and conditional rendering.",
                    "Keep everything in a single `<App.vue>` component for this exercise."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`)",
                    "Basic component structure",
                    "Click event handlers",
                    "Conditional rendering based on reactive state"
                ]
            }
        },
        "starterCodeHint": "Implement the tab state and handlers inside `<script setup>`. Use `ref('overview')` for the active tab and a small helper like `isActive(tab)` to decide which tab is highlighted and which panel is shown.",
        "solutionBlock": {
            "overview": "Use Vue 3's Composition API with a single `ref` holding the active tab id. The tab buttons update that ref when clicked, and a helper like `isActive(tab)` is used in the template for both styling and conditional rendering.\n\n**Key ideas**\n- Store the active tab id in a single `ref`.\n- Drive the active pill style and visible panel from the same source of truth.\n- Keep all logic colocated with the component template using `<script setup>`.",
            "approaches": [
                {
                    "title": "Single component with `activeTab` ref and helper function",
                    "prose": "Keep all logic inside `<script setup>` in `App.vue`. Use `const activeTab = ref('overview')` to define the initial tab. Define a helper `const isActive = (tab: TabId) => activeTab.value === tab` and use it both for button classes and for `v-if` panels. Implement `selectTab(tab)` so it sets `activeTab.value = tab` when a tab button is clicked."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Using multiple booleans (`isOverview`, `isDetails`, `isSettings`) instead of a single tab id.",
                    "Forgetting to visually differentiate the active tab from inactive ones.",
                    "Rendering all panels at once instead of conditionally rendering only the active one."
                ],
                "techniques": [
                    "Using `ref` for local reactive state in Vue 3.",
                    "Using helper functions to keep the template clean.",
                    "Driving both styles and rendering from one reactive value."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-tabs.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-tabs-switcher"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-tabs-solution.v1.json"
    },
    {
        "id": "vue-filterable-user-list",
        "title": "Filterable / Searchable User List",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "components",
            "reactivity",
            "lists",
            "forms",
            "filtering"
        ],
        "description": {
            "summary": "Build a Vue 3 component that renders a user list with a search box, role filter, and \"only active\" checkbox.",
            "specs": {
                "requirements": [
                    "Render a filter UI and a list of users as the main component.",
                    "Use a fixed in-memory list of users (name, role, active flag).",
                    "Provide a text input that filters by name (case-insensitive).",
                    "Provide a role dropdown (All, Admin, Editor, Viewer) that filters by role.",
                    "Provide a checkbox that, when checked, shows only active users.",
                    "Render the filtered list below the controls."
                ],
                "expectedBehavior": [
                    "Initially, all users are shown.",
                    "Typing in the search box filters users whose name includes the search text (case-insensitive).",
                    "Changing the role dropdown filters by that role (or shows all roles when \"All\" is selected).",
                    "Checking the \"Only active users\" checkbox hides inactive users.",
                    "When no users match the filters, an empty state message is shown instead of an empty list."
                ],
                "implementationNotes": [
                    "Keep the user data in a fixed array inside the component (no fetch or API).",
                    "Use Vue 3's Composition API (`ref`, `computed`) in `<script setup>` to store filter state and derive the filtered list.",
                    "Treat the inputs as controlled with `v-model` bound to the reactive state.",
                    "Derive a `filteredUsers` computed from the base list + current filters.",
                    "You can mention memoization or performance considerations in discussion, but the plain computed is enough for this exercise."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`, `computed`)",
                    "Controlled inputs with `v-model`",
                    "Derived state for filtered lists",
                    "Rendering lists with `v-for` and keys"
                ]
            }
        },
        "starterCodeHint": "Define a constant USERS array with name, role, and active. Use `ref` for `searchTerm`, `selectedRole`, and `showOnlyActive`, and derive `filteredUsers` in a `computed` that applies all three filters.",
        "solutionBlock": {
            "overview": "The core of this exercise is combining three filters (search text, role selection, and an \"only active\" toggle) into a single derived list without mutating the original user data.\n\n**Key ideas**\n- Keep the base `USERS` list as a plain constant.\n- Use `ref` for `searchTerm`, `selectedRole`, and `showOnlyActive`.\n- Use a `computed` `filteredUsers` that applies all filters in sequence.\n- Render `filteredUsers` with `v-for`, and show an empty state when it is empty.\n\n**Test cases**\n- Default render shows all users.\n- Typing a partial name filters to matching users.\n- Changing the role filter to `Admin` shows only admins, `All` restores all roles.\n- Ticking \"Only active users\" hides inactive users.\n- When filters exclude all users, a \"no users\" message is rendered.",
            "approaches": [
                {
                    "title": "Single `<App.vue>` with `ref` state and computed `filteredUsers`",
                    "prose": "Keep everything in `App.vue` using `<script setup>`. Declare a constant `USERS` array for the data. Use `ref('')` for the search term, `ref<'all' | 'admin' | 'editor' | 'viewer'>('all')` for the role filter, and `ref(false)` for the active-only toggle. Derive `filteredUsers` with a `computed` that normalizes the search term to lower-case, optionally filters on role when not `\"all\"`, and optionally filters out inactive users when `showOnlyActive` is true.\n\nUse `v-model` on the text input, select, and checkbox so the UI is fully controlled. In the template, `v-for` over `filteredUsers`, render name, a small badge for the role, and a status pill for active vs inactive. If `filteredUsers.length === 0`, render an `li` with an empty state message.",
                    "proseCode": "The full solution is shown in the SDK solution JSON: it wires `ref` state with `v-model`, computes `filteredUsers`, and renders the list with matching styling."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Mutating the original `USERS` array instead of deriving a filtered list.",
                    "Forgetting to normalize search term and name to the same case.",
                    "Applying only one filter and ignoring role or `showOnlyActive`.",
                    "Trying to update reactive refs without using `.value` inside `<script setup>`."
                ],
                "techniques": [
                    "Using `ref` for local component state in Vue 3.",
                    "Using `computed` for derived lists.",
                    "`v-model` on text, select, and checkbox inputs.",
                    "Using `v-for` with `:key` for stable list rendering."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-filterable-user-list.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-filterable-user-list"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-filterable-user-list-solution.v1.json"
    }
]