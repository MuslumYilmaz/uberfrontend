[
    {
        "id": "vue-counter",
        "title": "Counter (Component with Guarded Decrement)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "beginner",
        "importance": 3,
        "tags": [
            "vue",
            "components",
            "reactivity",
            "event-handlers",
            "basics"
        ],
        "description": {
            "summary": "Build a simple Vue 3 counter component that displays a value and has '+' and '−' buttons. The count must never go below 0.",
            "specs": {
                "requirements": [
                    "Render the counter UI as the main component.",
                    "Display the current count value.",
                    "Provide '+' and '−' buttons to increment and decrement.",
                    "Prevent the count from ever going below 0.",
                    "Include a 'Reset' button that sets the count back to 0."
                ],
                "expectedBehavior": [
                    "Initial count starts at 0.",
                    "Clicking '+' increases the count by 1.",
                    "Clicking '−' decreases the count by 1, but never below 0.",
                    "Clicking 'Reset' sets the count back to 0.",
                    "The '−' button is disabled when the count is 0."
                ],
                "implementationNotes": [
                    "Use Vue 3's Composition API with `ref` to store the count.",
                    "Use a `computed` property to determine when the count is zero and disable the decrement button.",
                    "Keep everything in a single `<App.vue>` component for this exercise."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`, `computed`)",
                    "Basic component structure",
                    "Click event handlers",
                    "Guarded state updates"
                ]
            }
        },
        "starterCodeHint": "Implement the counter logic inside `<script setup>`. Use `ref(0)` for the value and a `computed` property for the disabled state of the decrement button.",
        "solutionBlock": {
            "overview": "Use Vue 3's Composition API with `ref(0)` for the count and a `computed` property that returns `true` when the count is 0. The '+' button increments the ref, the '−' button decrements but is guarded so the value never becomes negative, and 'Reset' sets it back to 0.\n\n**Key ideas**\n- Store count in a single `ref`.\n- Derive disabled state from a `computed` value.\n- Guard the decrement so it never sets a negative value.",
            "approaches": [
                {
                    "title": "Single component with guarded decrement",
                    "prose": "Keep all logic inside `<script setup>` in `App.vue`. Use `const count = ref(0)` to create reactive state. Define a computed property `isZero` that checks `count.value === 0` and bind it to `:disabled` on the decrement button. Implement `inc`, `dec`, and `reset` as simple functions that mutate `count.value`, with `dec` checking that the value is greater than 0 before decrementing."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Updating `count` without guarding against negatives, allowing the value to go below 0.",
                    "Forgetting to use `.value` when reading or writing refs inside `<script setup>`.",
                    "Deriving `isZero` manually and forgetting to update it when count changes instead of using `computed`."
                ],
                "techniques": [
                    "Using `ref` for local reactive state in Vue 3.",
                    "Using `computed` to derive boolean UI state (disabled button).",
                    "Keeping state and handlers co-located with the component template."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-counter.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-counter"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-counter-solution.v1.json"
    },
    {
        "id": "vue-contact-form-starter",
        "title": "Contact Form (Single File Component + Fetch)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "forms",
            "http",
            "validation",
            "user-input"
        ],
        "description": {
            "summary": "Build a contact form in a Vue 3 single file component using the Composition API. You will only work inside <script setup> in App.vue. The template and styles are already provided for you. Validate the user's input and send the form data with a POST request to https://jsonplaceholder.typicode.com/posts, showing loading, success, and error states.",
            "specs": {
                "requirements": [
                    "Use Vue 3's Composition API in a single-file component (App.vue).",
                    "Use refs to track form fields: name, email, and message.",
                    "Make all fields required; validate email with a basic email pattern and require a minimum length for the message (e.g. at least 10 characters).",
                    "Disable the submit button while the form is invalid or while a request is in progress.",
                    "On submit, send a POST request with the form body to https://jsonplaceholder.typicode.com/posts.",
                    "Show a success message if the request succeeds and an error message if it fails."
                ],
                "expectedBehavior": [
                    "Initially, the submit button is disabled until all fields are valid.",
                    "If the user attempts to submit invalid data, validation error messages are shown for the affected fields once they have been touched.",
                    "On a valid submit, a POST request is sent and the button is disabled while the request is in flight.",
                    "On success, show the message: \"Your message has been sent. Thank you!\" and optionally reset the form.",
                    "On error, show the message: \"Something went wrong. Please try again.\" and allow the user to submit again."
                ],
                "implementationNotes": [
                    "Work only in <script setup> of App.vue. The template and CSS are already wired up.",
                    "Use refs for field values and for 'touched' flags to control when to show validation messages.",
                    "Derive booleans like nameIsValid, emailIsValid, messageIsValid, and formIsValid from the current values.",
                    "Use the fetch API to send a POST request to https://jsonplaceholder.typicode.com/posts with a JSON body.",
                    "Track an isSubmitting ref to control the disabled state and avoid double submissions.",
                    "Use successMessage and errorMessage refs for user feedback."
                ],
                "techFocus": [
                    "Vue 3 Composition API (refs and derived state)",
                    "Form validation and UX (touched state, inline errors, disabled submit)",
                    "Basic fetch usage and request lifecycle handling from a component",
                    "Single File Component structure with <template> and <script setup>"
                ]
            }
        },
        "starterCodeHint": "Focus exclusively on <script setup> inside App.vue. Use refs for name, email, and message, plus separate 'touched' flags. Derive a formIsValid boolean and implement an async handleSubmit that POSTs to https://jsonplaceholder.typicode.com/posts and updates successMessage / errorMessage.",
        "solutionBlock": {
            "overview": "This exercise combines a Vue 3 single file component, the Composition API, and an HTTP POST request. You will define refs for name, email, and message, along with 'touched' flags to control when to show validation errors. Derived booleans like nameIsValid, emailIsValid, messageIsValid, and formIsValid drive both inline error messages and the disabled state of the submit button.\n\nOn submit, you prevent the default form behavior, mark all fields as touched, clear previous messages, and guard against invalid input. If the form is valid, you set isSubmitting to true and use fetch to POST the JSON payload to https://jsonplaceholder.typicode.com/posts. Depending on the response, you either show \"Your message has been sent. Thank you!\" and reset the form or show \"Something went wrong. Please try again.\" and keep the current values for another attempt.\n\n**Test cases**\n- With all fields empty, the submit button is disabled.\n- Typing an invalid email keeps the form invalid and disabled.\n- Blurring out of empty fields marks them as touched and shows validation errors.\n- With valid inputs, clicking submit triggers a POST request and disables the button while the request is in flight.\n- On success, the success message appears and the fields are cleared.\n- On error, the error message appears and the user can try again.",
            "approaches": [
                {
                    "title": "Single file component with refs, derived validity, and fetch",
                    "prose": "Keep everything inside App.vue using <script setup>. Use refs for name, email, message, and for touched flags (touchedName, touchedEmail, touchedMessage). Derive nameIsValid, emailIsValid, and messageIsValid as booleans, and then combine them into formIsValid. In the template, bind fields with v-model, show error messages when a field is both touched and invalid, and disable the submit button when !formIsValid or isSubmitting is true.\n\nIn handleSubmit, call event.preventDefault(), mark all fields as touched, clear successMessage and errorMessage, and if the form is valid, set isSubmitting to true and send a fetch POST request to https://jsonplaceholder.typicode.com/posts with a JSON body. On a successful response, show the success message and reset the fields and touched flags. On failure, show the error message and leave the fields as-is.",
                    "codeTs": "<template>\n  <main class=\"main\">\n    <section class=\"section\">\n      <h1>Contact Us (Solution)</h1>\n\n      <form class=\"panel\" novalidate @submit=\"handleSubmit\">\n        <div class=\"field\">\n          <label for=\"name\">Name</label>\n          <input\n            id=\"name\"\n            type=\"text\"\n            v-model=\"name\"\n            @blur=\"touchedName = true\"\n          />\n          <p v-if=\"touchedName && !nameIsValid\" class=\"error\">Name is required.</p>\n        </div>\n\n        <div class=\"field\">\n          <label for=\"email\">Email</label>\n          <input\n            id=\"email\"\n            type=\"email\"\n            v-model=\"email\"\n            @blur=\"touchedEmail = true\"\n          />\n          <p v-if=\"touchedEmail && !email\" class=\"error\">Email is required.</p>\n          <p v-if=\"touchedEmail && email && !emailIsValid\" class=\"error\">Enter a valid email address.</p>\n        </div>\n\n        <div class=\"field\">\n          <label for=\"message\">Message</label>\n          <textarea\n            id=\"message\"\n            rows=\"4\"\n            v-model=\"message\"\n            @blur=\"touchedMessage = true\"\n          />\n          <p v-if=\"touchedMessage && !message\" class=\"error\">Message is required.</p>\n          <p\n            v-if=\"touchedMessage && message && !messageIsValid\"\n            class=\"error\"\n          >\n            Message should be at least 10 characters.\n          </p>\n        </div>\n\n        <button\n          type=\"submit\"\n          class=\"primary\"\n          :disabled=\"!formIsValid || isSubmitting\"\n        >\n          {{ isSubmitting ? 'Sending…' : 'Send message' }}\n        </button>\n\n        <p v-if=\"successMessage\" class=\"success\">{{ successMessage }}</p>\n        <p v-if=\"errorMessage\" class=\"error\">{{ errorMessage }}</p>\n      </form>\n    </section>\n  </main>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed } from 'vue';\n\nconst name = ref('');\nconst email = ref('');\nconst message = ref('');\n\nconst touchedName = ref(false);\nconst touchedEmail = ref(false);\nconst touchedMessage = ref(false);\n\nconst isSubmitting = ref(false);\nconst successMessage = ref('');\nconst errorMessage = ref('');\n\nconst nameIsValid = computed(() => name.value.trim().length > 0);\nconst emailIsValid = computed(() => /\\S+@\\S+\\.\\S+/.test(email.value));\nconst messageIsValid = computed(() => message.value.trim().length >= 10);\n\nconst formIsValid = computed(\n  () => nameIsValid.value && emailIsValid.value && messageIsValid.value\n);\n\nconst handleSubmit = async (event: any) => {\n  event.preventDefault();\n\n  touchedName.value = true;\n  touchedEmail.value = true;\n  touchedMessage.value = true;\n\n  successMessage.value = '';\n  errorMessage.value = '';\n\n  if (!formIsValid.value) {\n    return;\n  }\n\n  isSubmitting.value = true;\n\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/posts', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        name: name.value,\n        email: email.value,\n        message: message.value\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error('Request failed');\n    }\n\n    successMessage.value = 'Your message has been sent. Thank you!';\n\n    name.value = '';\n    email.value = '';\n    message.value = '';\n    touchedName.value = false;\n    touchedEmail.value = false;\n    touchedMessage.value = false;\n  } catch (error) {\n    errorMessage.value = 'Something went wrong. Please try again.';\n  } finally {\n    isSubmitting.value = false;\n  }\n};\n</script>\n"
                }
            ],
            "notes": {
                "pitfalls": [
                    "Forgetting to call event.preventDefault() in handleSubmit, which causes a full page reload.",
                    "Not using separate 'touched' refs, which makes it hard to control when validation messages appear.",
                    "Allowing the user to submit while the form is invalid or while a request is still in flight.",
                    "Not handling failed responses from fetch, leaving the user without feedback on errors."
                ],
                "techniques": [
                    "Using refs for field values and for UX flags like 'touched' and 'isSubmitting'.",
                    "Deriving all validity booleans (nameIsValid, emailIsValid, messageIsValid, formIsValid) with computed.",
                    "Using fetch for a simple JSON POST request from a component.",
                    "Driving button disabled state and inline messages directly from derived state."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-contact-form.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-contact-form-starter"
        },
        "companies": [
            "google",
            "meta",
            "airbnb"
        ],
        "solutionAsset": "assets/sb/vue/solution/vue-contact-form-solution.v1.json"
    },
    {
        "id": "vue-todo-list",
        "title": "Todo List (Refs + List Rendering)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "lists",
            "state-management",
            "event-handlers",
            "forms"
        ],
        "description": {
            "summary": "Build a small Todo List in Vue 3 using the Composition API and <script setup>. Users should be able to add tasks, mark them as completed, remove individual tasks, and clear all completed tasks.",
            "specs": {
                "requirements": [
                    "Render a Todo List as the main UI in App.vue.",
                    "Use a text input and 'Add' button to create new todos.",
                    "Display todos in a list using v-for.",
                    "Each todo should have a checkbox to toggle completion and a 'Remove' button.",
                    "Provide a 'Clear completed' button that removes all completed todos when clicked."
                ],
                "expectedBehavior": [
                    "Clicking 'Add' with non-empty trimmed text adds a new todo to the list and clears the input.",
                    "Checking a todo's checkbox toggles its completed state and visually marks it (line-through).",
                    "Clicking 'Remove' deletes that specific todo.",
                    "Clicking 'Clear completed' removes all todos where done === true.",
                    "An empty state message is shown when there are no todos."
                ],
                "implementationNotes": [
                    "Use `ref('')` for the controlled input value (newTask).",
                    "Store the list of todos in a `ref<Todo[]>([])` where each todo has `id`, `text`, and `done`.",
                    "Use `computed` for simple derived state like `hasTodos`.",
                    "Implement helpers `addTask`, `toggleTask`, `removeTask`, and `clearCompleted` inside `<script setup>`.",
                    "Keep everything in a single App.vue component."
                ],
                "techFocus": [
                    "Vue 3 Composition API with refs and computed",
                    "List rendering with v-for and keys",
                    "Immutable style array updates (map/filter) for clarity",
                    "Basic component-level state management"
                ]
            }
        },
        "starterCodeHint": "Work only inside `<script setup>` in App.vue. Use `const newTask = ref('')` and `const todos = ref([] as Todo[])`. Implement `addTask`, `toggleTask(id)`, `removeTask(id)`, and `clearCompleted()` and wire them to the template via @click / @change.",
        "solutionBlock": {
            "overview": "Use a single Vue 3 SFC with `<script setup>` to manage the todo list. Track the input value in `newTask` and store todos in a `ref` array with `{ id, text, done }`. A `computed` property `hasTodos` drives the empty state and footer visibility. Actions (`addTask`, `toggleTask`, `removeTask`, `clearCompleted`) update the `todos` array, and the template uses `v-for` to render items plus a checkbox and Remove button.\n\n**Key ideas**\n- Keep all state in refs inside `<script setup>`.\n- Use `v-for` + `:key` for list rendering.\n- Use immutable updates (`map` / `filter`) for clear toggling and removal.\n- Drive simple UI states (empty vs list, footer visibility) from computed values.",
            "approaches": [
                {
                    "title": "Single component with ref-backed list and immutable updates",
                    "prose": "Define `type Todo = { id: number; text: string; done: boolean }` and create `const newTask = ref('')` plus `const todos = ref([] as Todo[])`. `addTask` trims `newTask.value`, bails on empty, and appends a new todo with a unique `id` (e.g. `Date.now()`). `toggleTask(id)` replaces the array with `todos.value.map(todo => todo.id === id ? { ...todo, done: !todo.done } : todo)`. `removeTask(id)` and `clearCompleted()` use `filter` to drop items. A `hasTodos` computed returns `todos.value.length > 0` and controls whether you show the empty message or the list."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Mutating todos in place without updating the ref value in a way that keeps the code clear.",
                    "Adding empty or whitespace-only tasks by forgetting to trim the input.",
                    "Forgetting to use `:key` in `v-for`, which can lead to odd checkbox behaviour.",
                    "Toggling completion without visually reflecting it (missing the `done` class binding)."
                ],
                "techniques": [
                    "Using refs for both scalar and array state.",
                    "Using computed for derived flags such as `hasTodos`.",
                    "Updating arrays immutably to keep logic simple and predictable.",
                    "Binding classes dynamically with `:class` for completed todos."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-todo-list.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-todo-list"
        },
        "companies": [
            "google",
            "meta",
            "airbnb"
        ],
        "solutionAsset": "assets/sb/vue/solution/vue-todo-list-solution.v1.json"
    }
]