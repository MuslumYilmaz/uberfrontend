[
    {
        "id": "vue-counter",
        "title": "Counter (Component with Guarded Decrement)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "beginner",
        "importance": 3,
        "tags": [
            "vue",
            "components",
            "reactivity",
            "event-handlers",
            "basics"
        ],
        "description": {
            "summary": "Build a simple Vue 3 counter component that displays a value and has '+' and '−' buttons. The count must never go below 0.",
            "specs": {
                "requirements": [
                    "Render the counter UI as the main component.",
                    "Display the current count value.",
                    "Provide '+' and '−' buttons to increment and decrement.",
                    "Prevent the count from ever going below 0.",
                    "Include a 'Reset' button that sets the count back to 0."
                ],
                "expectedBehavior": [
                    "Initial count starts at 0.",
                    "Clicking '+' increases the count by 1.",
                    "Clicking '−' decreases the count by 1, but never below 0.",
                    "Clicking 'Reset' sets the count back to 0.",
                    "The '−' button is disabled when the count is 0."
                ],
                "implementationNotes": [
                    "Use Vue 3's Composition API with `ref` to store the count.",
                    "Use a `computed` property to determine when the count is zero and disable the decrement button.",
                    "Keep everything in a single `<App.vue>` component for this exercise."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`, `computed`)",
                    "Basic component structure",
                    "Click event handlers",
                    "Guarded state updates"
                ]
            }
        },
        "starterCodeHint": "Implement the counter logic inside `<script setup>`. Use `ref(0)` for the value and a `computed` property for the disabled state of the decrement button.",
        "solutionBlock": {
            "overview": "Use Vue 3's Composition API with `ref(0)` for the count and a `computed` property that returns `true` when the count is 0. The '+' button increments the ref, the '−' button decrements but is guarded so the value never becomes negative, and 'Reset' sets it back to 0.\n\n**Key ideas**\n- Store count in a single `ref`.\n- Derive disabled state from a `computed` value.\n- Guard the decrement so it never sets a negative value.",
            "approaches": [
                {
                    "title": "Single component with guarded decrement",
                    "prose": "Keep all logic inside `<script setup>` in `App.vue`. Use `const count = ref(0)` to create reactive state. Define a computed property `isZero` that checks `count.value === 0` and bind it to `:disabled` on the decrement button. Implement `inc`, `dec`, and `reset` as simple functions that mutate `count.value`, with `dec` checking that the value is greater than 0 before decrementing."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Updating `count` without guarding against negatives, allowing the value to go below 0.",
                    "Forgetting to use `.value` when reading or writing refs inside `<script setup>`.",
                    "Deriving `isZero` manually and forgetting to update it when count changes instead of using `computed`."
                ],
                "techniques": [
                    "Using `ref` for local reactive state in Vue 3.",
                    "Using `computed` to derive boolean UI state (disabled button).",
                    "Keeping state and handlers co-located with the component template."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-counter.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-counter"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-counter-solution.v1.json"
    },
    {
        "id": "vue-contact-form-starter",
        "title": "Contact Form (Single File Component + Fetch)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "forms",
            "http",
            "validation",
            "user-input"
        ],
        "description": {
            "summary": "Build a contact form in a Vue 3 single file component using the Composition API. You will only work inside <script setup> in App.vue. The template and styles are already provided for you. Validate the user's input and send the form data with a POST request to https://jsonplaceholder.typicode.com/posts, showing loading, success, and error states.",
            "specs": {
                "requirements": [
                    "Use Vue 3's Composition API in a single-file component (App.vue).",
                    "Use refs to track form fields: name, email, and message.",
                    "Make all fields required; validate email with a basic email pattern and require a minimum length for the message (e.g. at least 10 characters).",
                    "Disable the submit button while the form is invalid or while a request is in progress.",
                    "On submit, send a POST request with the form body to https://jsonplaceholder.typicode.com/posts.",
                    "Show a success message if the request succeeds and an error message if it fails."
                ],
                "expectedBehavior": [
                    "Initially, the submit button is disabled until all fields are valid.",
                    "If the user attempts to submit invalid data, validation error messages are shown for the affected fields once they have been touched.",
                    "On a valid submit, a POST request is sent and the button is disabled while the request is in flight.",
                    "On success, show the message: \"Your message has been sent. Thank you!\" and optionally reset the form.",
                    "On error, show the message: \"Something went wrong. Please try again.\" and allow the user to submit again."
                ],
                "implementationNotes": [
                    "Work only in <script setup> of App.vue. The template and CSS are already wired up.",
                    "Use refs for field values and for 'touched' flags to control when to show validation messages.",
                    "Derive booleans like nameIsValid, emailIsValid, messageIsValid, and formIsValid from the current values.",
                    "Use the fetch API to send a POST request to https://jsonplaceholder.typicode.com/posts with a JSON body.",
                    "Track an isSubmitting ref to control the disabled state and avoid double submissions.",
                    "Use successMessage and errorMessage refs for user feedback."
                ],
                "techFocus": [
                    "Vue 3 Composition API (refs and derived state)",
                    "Form validation and UX (touched state, inline errors, disabled submit)",
                    "Basic fetch usage and request lifecycle handling from a component",
                    "Single File Component structure with <template> and <script setup>"
                ]
            }
        },
        "starterCodeHint": "Focus exclusively on <script setup> inside App.vue. Use refs for name, email, and message, plus separate 'touched' flags. Derive a formIsValid boolean and implement an async handleSubmit that POSTs to https://jsonplaceholder.typicode.com/posts and updates successMessage / errorMessage.",
        "solutionBlock": {
            "overview": "This exercise combines a Vue 3 single file component, the Composition API, and an HTTP POST request. You will define refs for name, email, and message, along with 'touched' flags to control when to show validation errors. Derived booleans like nameIsValid, emailIsValid, messageIsValid, and formIsValid drive both inline error messages and the disabled state of the submit button.\n\nOn submit, you prevent the default form behavior, mark all fields as touched, clear previous messages, and guard against invalid input. If the form is valid, you set isSubmitting to true and use fetch to POST the JSON payload to https://jsonplaceholder.typicode.com/posts. Depending on the response, you either show \"Your message has been sent. Thank you!\" and reset the form or show \"Something went wrong. Please try again.\" and keep the current values for another attempt.\n\n**Test cases**\n- With all fields empty, the submit button is disabled.\n- Typing an invalid email keeps the form invalid and disabled.\n- Blurring out of empty fields marks them as touched and shows validation errors.\n- With valid inputs, clicking submit triggers a POST request and disables the button while the request is in flight.\n- On success, the success message appears and the fields are cleared.\n- On error, the error message appears and the user can try again.",
            "approaches": [
                {
                    "title": "Single file component with refs, derived validity, and fetch",
                    "prose": "Keep everything inside App.vue using <script setup>. Use refs for name, email, message, and for touched flags (touchedName, touchedEmail, touchedMessage). Derive nameIsValid, emailIsValid, and messageIsValid as booleans, and then combine them into formIsValid. In the template, bind fields with v-model, show error messages when a field is both touched and invalid, and disable the submit button when !formIsValid or isSubmitting is true.\n\nIn handleSubmit, call event.preventDefault(), mark all fields as touched, clear successMessage and errorMessage, and if the form is valid, set isSubmitting to true and send a fetch POST request to https://jsonplaceholder.typicode.com/posts with a JSON body. On a successful response, show the success message and reset the fields and touched flags. On failure, show the error message and leave the fields as-is.",
                    "codeTs": "<template>\n  <main class=\"main\">\n    <section class=\"section\">\n      <h1>Contact Us (Solution)</h1>\n\n      <form class=\"panel\" novalidate @submit=\"handleSubmit\">\n        <div class=\"field\">\n          <label for=\"name\">Name</label>\n          <input\n            id=\"name\"\n            type=\"text\"\n            v-model=\"name\"\n            @blur=\"touchedName = true\"\n          />\n          <p v-if=\"touchedName && !nameIsValid\" class=\"error\">Name is required.</p>\n        </div>\n\n        <div class=\"field\">\n          <label for=\"email\">Email</label>\n          <input\n            id=\"email\"\n            type=\"email\"\n            v-model=\"email\"\n            @blur=\"touchedEmail = true\"\n          />\n          <p v-if=\"touchedEmail && !email\" class=\"error\">Email is required.</p>\n          <p v-if=\"touchedEmail && email && !emailIsValid\" class=\"error\">Enter a valid email address.</p>\n        </div>\n\n        <div class=\"field\">\n          <label for=\"message\">Message</label>\n          <textarea\n            id=\"message\"\n            rows=\"4\"\n            v-model=\"message\"\n            @blur=\"touchedMessage = true\"\n          />\n          <p v-if=\"touchedMessage && !message\" class=\"error\">Message is required.</p>\n          <p\n            v-if=\"touchedMessage && message && !messageIsValid\"\n            class=\"error\"\n          >\n            Message should be at least 10 characters.\n          </p>\n        </div>\n\n        <button\n          type=\"submit\"\n          class=\"primary\"\n          :disabled=\"!formIsValid || isSubmitting\"\n        >\n          {{ isSubmitting ? 'Sending…' : 'Send message' }}\n        </button>\n\n        <p v-if=\"successMessage\" class=\"success\">{{ successMessage }}</p>\n        <p v-if=\"errorMessage\" class=\"error\">{{ errorMessage }}</p>\n      </form>\n    </section>\n  </main>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed } from 'vue';\n\nconst name = ref('');\nconst email = ref('');\nconst message = ref('');\n\nconst touchedName = ref(false);\nconst touchedEmail = ref(false);\nconst touchedMessage = ref(false);\n\nconst isSubmitting = ref(false);\nconst successMessage = ref('');\nconst errorMessage = ref('');\n\nconst nameIsValid = computed(() => name.value.trim().length > 0);\nconst emailIsValid = computed(() => /\\S+@\\S+\\.\\S+/.test(email.value));\nconst messageIsValid = computed(() => message.value.trim().length >= 10);\n\nconst formIsValid = computed(\n  () => nameIsValid.value && emailIsValid.value && messageIsValid.value\n);\n\nconst handleSubmit = async (event: any) => {\n  event.preventDefault();\n\n  touchedName.value = true;\n  touchedEmail.value = true;\n  touchedMessage.value = true;\n\n  successMessage.value = '';\n  errorMessage.value = '';\n\n  if (!formIsValid.value) {\n    return;\n  }\n\n  isSubmitting.value = true;\n\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/posts', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        name: name.value,\n        email: email.value,\n        message: message.value\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error('Request failed');\n    }\n\n    successMessage.value = 'Your message has been sent. Thank you!';\n\n    name.value = '';\n    email.value = '';\n    message.value = '';\n    touchedName.value = false;\n    touchedEmail.value = false;\n    touchedMessage.value = false;\n  } catch (error) {\n    errorMessage.value = 'Something went wrong. Please try again.';\n  } finally {\n    isSubmitting.value = false;\n  }\n};\n</script>\n"
                }
            ],
            "notes": {
                "pitfalls": [
                    "Forgetting to call event.preventDefault() in handleSubmit, which causes a full page reload.",
                    "Not using separate 'touched' refs, which makes it hard to control when validation messages appear.",
                    "Allowing the user to submit while the form is invalid or while a request is still in flight.",
                    "Not handling failed responses from fetch, leaving the user without feedback on errors."
                ],
                "techniques": [
                    "Using refs for field values and for UX flags like 'touched' and 'isSubmitting'.",
                    "Deriving all validity booleans (nameIsValid, emailIsValid, messageIsValid, formIsValid) with computed.",
                    "Using fetch for a simple JSON POST request from a component.",
                    "Driving button disabled state and inline messages directly from derived state."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-contact-form.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-contact-form-starter"
        },
        "companies": [
            "google",
            "meta",
            "airbnb"
        ],
        "solutionAsset": "assets/sb/vue/solution/vue-contact-form-solution.v1.json"
    },
    {
        "id": "vue-todo-list",
        "title": "Todo List (Refs + List Rendering)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "lists",
            "state-management",
            "event-handlers",
            "forms"
        ],
        "description": {
            "summary": "Build a small Todo List in Vue 3 using the Composition API and <script setup>. Users should be able to add tasks, mark them as completed, remove individual tasks, and clear all completed tasks.",
            "specs": {
                "requirements": [
                    "Render a Todo List as the main UI in App.vue.",
                    "Use a text input and 'Add' button to create new todos.",
                    "Display todos in a list using v-for.",
                    "Each todo should have a checkbox to toggle completion and a 'Remove' button.",
                    "Provide a 'Clear completed' button that removes all completed todos when clicked."
                ],
                "expectedBehavior": [
                    "Clicking 'Add' with non-empty trimmed text adds a new todo to the list and clears the input.",
                    "Checking a todo's checkbox toggles its completed state and visually marks it (line-through).",
                    "Clicking 'Remove' deletes that specific todo.",
                    "Clicking 'Clear completed' removes all todos where done === true.",
                    "An empty state message is shown when there are no todos."
                ],
                "implementationNotes": [
                    "Use `ref('')` for the controlled input value (newTask).",
                    "Store the list of todos in a `ref<Todo[]>([])` where each todo has `id`, `text`, and `done`.",
                    "Use `computed` for simple derived state like `hasTodos`.",
                    "Implement helpers `addTask`, `toggleTask`, `removeTask`, and `clearCompleted` inside `<script setup>`.",
                    "Keep everything in a single App.vue component."
                ],
                "techFocus": [
                    "Vue 3 Composition API with refs and computed",
                    "List rendering with v-for and keys",
                    "Immutable style array updates (map/filter) for clarity",
                    "Basic component-level state management"
                ]
            }
        },
        "starterCodeHint": "Work only inside `<script setup>` in App.vue. Use `const newTask = ref('')` and `const todos = ref([] as Todo[])`. Implement `addTask`, `toggleTask(id)`, `removeTask(id)`, and `clearCompleted()` and wire them to the template via @click / @change.",
        "solutionBlock": {
            "overview": "Use a single Vue 3 SFC with `<script setup>` to manage the todo list. Track the input value in `newTask` and store todos in a `ref` array with `{ id, text, done }`. A `computed` property `hasTodos` drives the empty state and footer visibility. Actions (`addTask`, `toggleTask`, `removeTask`, `clearCompleted`) update the `todos` array, and the template uses `v-for` to render items plus a checkbox and Remove button.\n\n**Key ideas**\n- Keep all state in refs inside `<script setup>`.\n- Use `v-for` + `:key` for list rendering.\n- Use immutable updates (`map` / `filter`) for clear toggling and removal.\n- Drive simple UI states (empty vs list, footer visibility) from computed values.",
            "approaches": [
                {
                    "title": "Single component with ref-backed list and immutable updates",
                    "prose": "Define `type Todo = { id: number; text: string; done: boolean }` and create `const newTask = ref('')` plus `const todos = ref([] as Todo[])`. `addTask` trims `newTask.value`, bails on empty, and appends a new todo with a unique `id` (e.g. `Date.now()`). `toggleTask(id)` replaces the array with `todos.value.map(todo => todo.id === id ? { ...todo, done: !todo.done } : todo)`. `removeTask(id)` and `clearCompleted()` use `filter` to drop items. A `hasTodos` computed returns `todos.value.length > 0` and controls whether you show the empty message or the list."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Mutating todos in place without updating the ref value in a way that keeps the code clear.",
                    "Adding empty or whitespace-only tasks by forgetting to trim the input.",
                    "Forgetting to use `:key` in `v-for`, which can lead to odd checkbox behaviour.",
                    "Toggling completion without visually reflecting it (missing the `done` class binding)."
                ],
                "techniques": [
                    "Using refs for both scalar and array state.",
                    "Using computed for derived flags such as `hasTodos`.",
                    "Updating arrays immutably to keep logic simple and predictable.",
                    "Binding classes dynamically with `:class` for completed todos."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-todo-list.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-todo-list"
        },
        "companies": [
            "google",
            "meta",
            "airbnb"
        ],
        "solutionAsset": "assets/sb/vue/solution/vue-todo-list-solution.v1.json"
    },
    {
        "id": "vue-image-slider",
        "title": "Image Slider (Basic Navigation)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "beginner",
        "importance": 3,
        "tags": [
            "vue",
            "components",
            "reactivity",
            "arrays",
            "event-handlers"
        ],
        "description": {
            "summary": "Build a simple Vue 3 image slider that shows one image at a time and lets the user move between slides with Previous/Next buttons and small dot indicators.",
            "specs": {
                "requirements": [
                    "Render the image slider UI as the main component.",
                    "Display exactly one slide at a time with an image and a caption.",
                    "Show the current position as 'Slide X of Y'.",
                    "Provide 'Previous' and 'Next' buttons to move between slides.",
                    "Disable 'Previous' on the first slide and 'Next' on the last slide.",
                    "Render dot indicators for each slide and allow clicking a dot to jump directly to that slide."
                ],
                "expectedBehavior": [
                    "Initial slide is the first one in the list.",
                    "Clicking 'Next' moves forward by one slide until the last slide.",
                    "Clicking 'Previous' moves backward by one slide until the first slide.",
                    "The 'Previous' button is disabled on the first slide.",
                    "The 'Next' button is disabled on the last slide.",
                    "Clicking a dot jumps to the corresponding slide and updates the active dot state."
                ],
                "implementationNotes": [
                    "Use Vue 3's Composition API with `ref` to store the current index.",
                    "Keep the slides in a constant array of objects with `id`, `title`, and `imageUrl`.",
                    "Use `computed` properties for `totalSlides`, `currentSlide`, `canGoPrev`, and `canGoNext`.",
                    "Implement small helper functions: `goTo(index)`, `prev()`, and `next()`.",
                    "Make sure navigation is guarded (do not go before the first slide or after the last slide)."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`, `computed`)",
                    "Derived state for UI (current slide, canGoPrev/canGoNext)",
                    "Event handlers for navigation",
                    "Working with arrays of data in a component"
                ]
            }
        },
        "starterCodeHint": "Define a `slides` array in `<script setup>` and track the current slide index in a `ref(0)`. Use `computed` values for the current slide, total slide count, and whether previous/next are allowed. Implement `goTo`, `prev`, and `next` to update the index safely.",
        "solutionBlock": {
            "overview": "Model the image slider as an array of slide objects and a single reactive index stored in a `ref`. Use `computed` properties to derive the current slide, total slide count, and whether the user can go to the previous or next slide. Expose three handlers: `goTo(index)` for jumping to a specific slide (guarded by bounds), `prev()` for moving one step left when possible, and `next()` for moving one step right when possible.\n\n**Key ideas**\n- Store only the current index as reactive state; everything else is derived.\n- Use `computed` for `currentSlide`, `canGoPrev`, and `canGoNext` so the template stays simple.\n- Guard navigation so the index never goes out of range.",
            "approaches": [
                {
                    "title": "Single component slider with derived navigation state",
                    "prose": "Keep all slider logic inside `<script setup>` in `App.vue`. Use a constant `slides` array and a `ref(0)` for `currentIndex`. Derive `totalSlides`, `currentSlide`, `canGoPrev`, and `canGoNext` with `computed` so the template can be mostly declarative. Implement `goTo(index)` with a simple bounds check, and use it from the dot buttons. Implement `prev()` and `next()` to decrement/increment the index only when the corresponding `canGoPrev`/`canGoNext` flags are true. This keeps the component predictable and easy to test."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Letting the index go below 0 or above the last slide index.",
                    "Accessing `slides[currentIndex]` without guarding, which can return `undefined` if the index is wrong.",
                    "Duplicating logic in multiple places instead of using `computed` for derived values."
                ],
                "techniques": [
                    "Using `ref` for reactive state in Vue 3.",
                    "Using `computed` to derive booleans and current-entity data from primitive state.",
                    "Driving both the main view and the small dot indicators from the same single source of truth."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-image-slider.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-image-slider"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-image-slider-solution.v1.json"
    },
    {
        "id": "vue-tabs-switcher",
        "title": "Tabs / Multi-View Switcher",
        "type": "coding",
        "technology": "vue",
        "difficulty": "beginner",
        "importance": 3,
        "tags": [
            "vue",
            "components",
            "reactivity",
            "conditional-rendering",
            "basics"
        ],
        "description": {
            "summary": "Build a simple Vue 3 tabbed interface with three tabs (\"Overview\", \"Details\", \"Settings\") that controls which content is visible.",
            "specs": {
                "requirements": [
                    "Render a tabbed UI with three tabs labeled \"Overview\", \"Details\", and \"Settings\".",
                    "Track which tab is currently active and visually highlight it.",
                    "Render only the active tab's content at a time."
                ],
                "expectedBehavior": [
                    "The initial active tab should be \"Overview\".",
                    "Clicking a tab makes it the active tab.",
                    "Only the active tab's panel is visible at any time.",
                    "The active tab button has a distinct visual style (e.g., filled pill) compared to inactive ones."
                ],
                "implementationNotes": [
                    "Use Vue 3's Composition API with `ref` to store the currently active tab.",
                    "Model the tab id as a string union (e.g., `'overview' | 'details' | 'settings'`).",
                    "Use a helper function like `isActive(tab)` to drive both active styles and conditional rendering.",
                    "Keep everything in a single `<App.vue>` component for this exercise."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`)",
                    "Basic component structure",
                    "Click event handlers",
                    "Conditional rendering based on reactive state"
                ]
            }
        },
        "starterCodeHint": "Implement the tab state and handlers inside `<script setup>`. Use `ref('overview')` for the active tab and a small helper like `isActive(tab)` to decide which tab is highlighted and which panel is shown.",
        "solutionBlock": {
            "overview": "Use Vue 3's Composition API with a single `ref` holding the active tab id. The tab buttons update that ref when clicked, and a helper like `isActive(tab)` is used in the template for both styling and conditional rendering.\n\n**Key ideas**\n- Store the active tab id in a single `ref`.\n- Drive the active pill style and visible panel from the same source of truth.\n- Keep all logic colocated with the component template using `<script setup>`.",
            "approaches": [
                {
                    "title": "Single component with `activeTab` ref and helper function",
                    "prose": "Keep all logic inside `<script setup>` in `App.vue`. Use `const activeTab = ref('overview')` to define the initial tab. Define a helper `const isActive = (tab: TabId) => activeTab.value === tab` and use it both for button classes and for `v-if` panels. Implement `selectTab(tab)` so it sets `activeTab.value = tab` when a tab button is clicked."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Using multiple booleans (`isOverview`, `isDetails`, `isSettings`) instead of a single tab id.",
                    "Forgetting to visually differentiate the active tab from inactive ones.",
                    "Rendering all panels at once instead of conditionally rendering only the active one."
                ],
                "techniques": [
                    "Using `ref` for local reactive state in Vue 3.",
                    "Using helper functions to keep the template clean.",
                    "Driving both styles and rendering from one reactive value."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-tabs.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-tabs-switcher"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-tabs-solution.v1.json"
    },
    {
        "id": "vue-filterable-user-list",
        "title": "Filterable / Searchable User List",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "components",
            "reactivity",
            "lists",
            "forms",
            "filtering"
        ],
        "description": {
            "summary": "Build a Vue 3 component that renders a user list with a search box, role filter, and \"only active\" checkbox.",
            "specs": {
                "requirements": [
                    "Render a filter UI and a list of users as the main component.",
                    "Use a fixed in-memory list of users (name, role, active flag).",
                    "Provide a text input that filters by name (case-insensitive).",
                    "Provide a role dropdown (All, Admin, Editor, Viewer) that filters by role.",
                    "Provide a checkbox that, when checked, shows only active users.",
                    "Render the filtered list below the controls."
                ],
                "expectedBehavior": [
                    "Initially, all users are shown.",
                    "Typing in the search box filters users whose name includes the search text (case-insensitive).",
                    "Changing the role dropdown filters by that role (or shows all roles when \"All\" is selected).",
                    "Checking the \"Only active users\" checkbox hides inactive users.",
                    "When no users match the filters, an empty state message is shown instead of an empty list."
                ],
                "implementationNotes": [
                    "Keep the user data in a fixed array inside the component (no fetch or API).",
                    "Use Vue 3's Composition API (`ref`, `computed`) in `<script setup>` to store filter state and derive the filtered list.",
                    "Treat the inputs as controlled with `v-model` bound to the reactive state.",
                    "Derive a `filteredUsers` computed from the base list + current filters.",
                    "You can mention memoization or performance considerations in discussion, but the plain computed is enough for this exercise."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`, `computed`)",
                    "Controlled inputs with `v-model`",
                    "Derived state for filtered lists",
                    "Rendering lists with `v-for` and keys"
                ]
            }
        },
        "starterCodeHint": "Define a constant USERS array with name, role, and active. Use `ref` for `searchTerm`, `selectedRole`, and `showOnlyActive`, and derive `filteredUsers` in a `computed` that applies all three filters.",
        "solutionBlock": {
            "overview": "The core of this exercise is combining three filters (search text, role selection, and an \"only active\" toggle) into a single derived list without mutating the original user data.\n\n**Key ideas**\n- Keep the base `USERS` list as a plain constant.\n- Use `ref` for `searchTerm`, `selectedRole`, and `showOnlyActive`.\n- Use a `computed` `filteredUsers` that applies all filters in sequence.\n- Render `filteredUsers` with `v-for`, and show an empty state when it is empty.\n\n**Test cases**\n- Default render shows all users.\n- Typing a partial name filters to matching users.\n- Changing the role filter to `Admin` shows only admins, `All` restores all roles.\n- Ticking \"Only active users\" hides inactive users.\n- When filters exclude all users, a \"no users\" message is rendered.",
            "approaches": [
                {
                    "title": "Single `<App.vue>` with `ref` state and computed `filteredUsers`",
                    "prose": "Keep everything in `App.vue` using `<script setup>`. Declare a constant `USERS` array for the data. Use `ref('')` for the search term, `ref<'all' | 'admin' | 'editor' | 'viewer'>('all')` for the role filter, and `ref(false)` for the active-only toggle. Derive `filteredUsers` with a `computed` that normalizes the search term to lower-case, optionally filters on role when not `\"all\"`, and optionally filters out inactive users when `showOnlyActive` is true.\n\nUse `v-model` on the text input, select, and checkbox so the UI is fully controlled. In the template, `v-for` over `filteredUsers`, render name, a small badge for the role, and a status pill for active vs inactive. If `filteredUsers.length === 0`, render an `li` with an empty state message.",
                    "proseCode": "The full solution is shown in the SDK solution JSON: it wires `ref` state with `v-model`, computes `filteredUsers`, and renders the list with matching styling."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Mutating the original `USERS` array instead of deriving a filtered list.",
                    "Forgetting to normalize search term and name to the same case.",
                    "Applying only one filter and ignoring role or `showOnlyActive`.",
                    "Trying to update reactive refs without using `.value` inside `<script setup>`."
                ],
                "techniques": [
                    "Using `ref` for local component state in Vue 3.",
                    "Using `computed` for derived lists.",
                    "`v-model` on text, select, and checkbox inputs.",
                    "Using `v-for` with `:key` for stable list rendering."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-filterable-user-list.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-filterable-user-list"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-filterable-user-list-solution.v1.json"
    },
    {
        "id": "vue-accordion-faq",
        "title": "Accordion / FAQ Component",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "components",
            "composition-api",
            "props",
            "state-management"
        ],
        "description": {
            "summary": "Build a simple FAQ (accordion) UI in Vue 3 that renders 3–4 questions. Clicking a question should toggle its answer. By default, only one item can be open at a time, but the user can enable a mode where multiple items can stay open.",
            "specs": {
                "requirements": [
                    "Use Vue 3 with a single <App.vue> root component as the main entry.",
                    "Render a FAQ card with 3–4 FAQ items (question + answer).",
                    "Clicking a question toggles its answer open/closed.",
                    "In the default mode, only one FAQ item can be open at a time.",
                    "Add a control (e.g. a checkbox) to switch to 'allow multiple open' mode.",
                    "In 'allow multiple open' mode, more than one FAQ item can be open at the same time.",
                    "Use a child <FaqItem> component for a single FAQ row."
                ],
                "expectedBehavior": [
                    "Initially all FAQ items are closed.",
                    "Clicking a closed question opens its answer.",
                    "In single-open mode: opening one item closes any other open item.",
                    "Switching to multi-open mode keeps currently open items and allows opening more.",
                    "Clicking an open question closes it in both modes."
                ],
                "implementationNotes": [
                    "Keep the FAQ data (question + answer) in the parent component using a simple array.",
                    "Use Vue 3's `<script setup>` syntax and Composition API.",
                    "Track open items in the parent via a `ref<number[]>` that stores open indexes.",
                    "Create a child `<FaqItem>` component that takes `question`, `answer`, and `isOpen` as props and emits a `toggle` event when clicked.",
                    "Use `v-for` to render the list of FAQ items."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`, `computed`)",
                    "Lifting state up to the parent",
                    "Child communication via props and emits",
                    "Single vs multi selection using an array of open indexes"
                ]
            }
        },
        "starterCodeHint": "Keep FAQ data in the parent and use a `ref<number[]>` to store open item indexes. Implement `isItemOpen(index)`, `onItemToggle(index)`, and `onToggleAllowMultiple()` inside `<script setup>` and pass `isOpen` / `@toggle` to a child `<FaqItem>` component.",
        "solutionBlock": {
            "overview": "The key to this exercise is to have the parent component fully control which FAQ items are open. The parent stores the FAQ data (question + answer) and an array of open indexes in a `ref<number[]>`. Each child `<FaqItem>` is stateless and only receives `isOpen` plus an `@toggle` callback.\n\nIn single-open mode, the `openIndexes` ref behaves like a radio group: it is either empty or contains a single index. In multi-open mode, it behaves like a set of indexes. Toggling between modes requires normalizing the `openIndexes` array when going back to single-open mode.\n\n**Key ideas**\n- Keep all UI state (which items are open, whether multiple are allowed) in the parent.\n- Represent open items as an array of indexes (`ref<number[]>`).\n- Use a child component that simply renders UI and emits `toggle` when clicked.\n- Derive `isItemOpen(index)` from the `openIndexes` array.",
            "approaches": [
                {
                    "title": "Parent-controlled openIndexes with a child <FaqItem> component",
                    "prose": "In `<App.vue>`, define:\n\n- A simple `faqItems` array of `{ question, answer }` objects.\n- `const allowMultiple = ref(false)` to track mode.\n- `const openIndexes = ref<number[]>([])` to store which items are open.\n\nImplement helpers:\n- `const isItemOpen = (index: number) => openIndexes.value.includes(index);`\n- `const onItemToggle = (index: number) => { ... }` that toggles the index depending on `allowMultiple.value`.\n\nIn multi-open mode, treat `openIndexes.value` as a set: remove the index if present, otherwise add it. In single-open mode, either set it to `[index]` or `[]`. Pass these down to `<FaqItem>` via props and `@toggle` to keep the child simple and reusable.\n\n`<FaqItem>` itself uses `defineProps` for `question`, `answer`, and `isOpen`, and `defineEmits` to emit a `toggle` event when its header button is clicked."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Letting each `<FaqItem>` manage its own open state, which makes it hard to enforce the 'only one open' rule.",
                    "Using a single `ref<number | null>` for `openIndex` and then trying to hack multi-open behavior into it.",
                    "Mutating the `openIndexes.value` array in place instead of assigning a new array (harder to reason about)."
                ],
                "techniques": [
                    "Using `ref<number[]>` to represent a collection of selected items in Vue 3.",
                    "Using `defineProps` / `defineEmits` in `<script setup>` for clean parent–child communication.",
                    "Deriving `isItemOpen` from an index array to support both single and multi selection with the same state shape."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-accordion-faq.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-accordion-faq"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-accordion-faq-solution.v1.json"
    },
    {
        "id": "vue-pagination-table",
        "title": "Paginated Data Table",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "components",
            "reactivity",
            "pagination",
            "arrays"
        ],
        "description": {
            "summary": "Build a simple paginated data table in Vue 3 that shows a static list of users. Display 5 rows per page, with Previous / Next controls and a \"Page X of Y\" indicator. Disable the navigation buttons appropriately on the first and last pages.",
            "specs": {
                "requirements": [
                    "Render the table UI as the main <App.vue> component.",
                    "Use a static list (around 20 users) with id, name, email, and role.",
                    "Show 5 rows per page.",
                    "Add \"Previous\" and \"Next\" buttons to change the current page.",
                    "Display the current page and total pages (for example \"Page 2 of 4\").",
                    "Disable \"Previous\" on the first page and \"Next\" on the last page."
                ],
                "expectedBehavior": [
                    "Initial render shows the first 5 users (page 1).",
                    "Clicking \"Next\" advances by 5 users until the last page.",
                    "Clicking \"Previous\" moves back by 5 users until the first page.",
                    "On the first page, \"Previous\" is disabled and does nothing when clicked.",
                    "On the last page, \"Next\" is disabled and does nothing when clicked.",
                    "The label \"Page X of Y\" always matches the current page."
                ],
                "implementationNotes": [
                    "Use Vue 3's Composition API with `ref` and `computed` in `<script setup>`.",
                    "Store the current page index in a `ref` (0-based).",
                    "Keep a constant `PAGE_SIZE = 5` and derive start/end indices from the current page.",
                    "Use a `computed` for the current slice of users and for the \"first/last page\" flags."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`, `computed`)",
                    "Derived state from minimal source of truth",
                    "Array slicing with `slice(start, end)`",
                    "Handling UI edge cases for first/last pages"
                ]
            }
        },
        "starterCodeHint": "Keep all logic inside `<script setup lang=\"ts\">`. Use `const currentPage = ref(0)` for page state, a constant `PAGE_SIZE = 5`, and `computed` properties to derive the current page slice, total pages, and button disabled state.",
        "solutionBlock": {
            "overview": "This exercise is about managing a single piece of state: the current page. The full users array stays static in the component. From that, you derive the paged slice, total page count, and booleans indicating when you are on the first or last page.\n\n**Core ideas**\n- `currentPage` is a `ref(0)` and represents a 0-based index.\n- `PAGE_SIZE` is a constant (5 rows per page).\n- `totalPages` is a `computed` that uses `Math.ceil(USERS.length / PAGE_SIZE)`.\n- A `computed` for `pagedUsers` uses `slice(start, end)` where `start = currentPage.value * PAGE_SIZE`.\n- `isFirstPage` and `isLastPage` are `computed` booleans used to disable navigation buttons and guard the handlers.\n\n**Test cases**\n- Initial render → first 5 users, label shows `Page 1 of N`, Previous disabled.\n- Clicking Next repeatedly walks through the list and disables Next on the last page.\n- Clicking Previous repeatedly walks back and disables Previous on the first page.\n- The page label always matches the current page index.",
            "approaches": [
                {
                    "title": "Single component with derived pagination slice",
                    "prose": "Keep everything in `App.vue` using `<script setup lang=\"ts\">`. Define the users array and `PAGE_SIZE` as constants. Store `currentPage` in a `ref(0)`. Then create `computed` properties for `totalPages`, `pagedUsers`, `isFirstPage`, and `isLastPage`. The `goPrevious` and `goNext` handlers simply adjust `currentPage.value` within bounds. The template renders the table rows from `pagedUsers` and binds disabled state and click handlers on the Previous / Next buttons."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Treating `currentPage` as 1-based while doing `slice` calculations, causing off-by-one bugs.",
                    "Letting `currentPage` go below 0 or above `totalPages - 1` because handlers aren’t guarded.",
                    "Deriving the slice inline in the template instead of a named `computed`, which makes the code harder to read.",
                    "Forgetting to use `.value` when reading/writing `ref`s inside `<script setup>`."
                ],
                "techniques": [
                    "Using `ref` and `computed` to derive view state from minimal data.",
                    "Using array `slice(start, end)` for pagination.",
                    "Co-locating state and logic with the template in a single file component."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-pagination-table.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-pagination-table"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-pagination-table-solution.v1.json"
    },
    {
        "id": "vue-theme-toggle",
        "title": "Theme Toggle with Persisted Light/Dark Mode",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "composition-api",
            "state-management",
            "local-storage",
            "theming"
        ],
        "description": {
            "summary": "Add a global light/dark theme toggle in the top-right of the page using Vue 3. The selected theme should be stored in localStorage and restored when the page reloads.",
            "specs": {
                "requirements": [
                    "Render a main page layout with a simple content card and a theme toggle control in the top-right corner.",
                    "Support two themes: \"light\" and \"dark\".",
                    "Store the current theme in a single source of truth (e.g. a module-level ref / small theme composable).",
                    "Persist the selected theme in localStorage under a stable key.",
                    "On initial load, read the theme from localStorage and apply it before the user interacts.",
                    "Apply the theme at the document level by setting `data-theme` on `<html>`, so that the existing CSS can react to it.",
                    "You only need to edit `/src/App.vue` (the template and `<script setup>`). The CSS files are already wired to respond to `data-theme` and should be left as-is."
                ],
                "expectedBehavior": [
                    "By default, the app starts in light mode if there is no previous theme stored.",
                    "If the user toggles to dark mode, the page background, text, and card colors change.",
                    "Reloading the page keeps the user’s last theme selection (light or dark).",
                    "The toggle UI (label or icon) always reflects the actual current theme.",
                    "Switching themes is instant and does not require a full reload."
                ],
                "implementationNotes": [
                    "Use Vue 3’s Composition API with a `ref<'light' | 'dark'>` to hold the current theme.",
                    "Read from `window.localStorage` using a stable key (for example `uf-theme`) and validate the stored value.",
                    "Apply the theme to `document.documentElement` via `setAttribute('data-theme', theme)` so the CSS can use `:root[data-theme='dark']` / `html[data-theme='dark'] ...` selectors.",
                    "Encapsulate the side-effects (localStorage read/write + DOM attribute update) in a couple of helper functions instead of scattering them across the component.",
                    "Avoid duplicating theme logic in multiple places; treat the theme ref as the single source of truth and derive `isDark` from it via `computed`."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`, `computed`)",
                    "Simple global-ish state via a module-level ref or mini composable",
                    "Side-effects and initialization logic in `<script setup>`",
                    "Using localStorage safely in a browser environment",
                    "Simple theming by driving `data-theme` on `<html>` and letting existing CSS respond"
                ]
            }
        },
        "starterCodeHint": "Create a `Theme` type (`'light' | 'dark'`) and a `ref<Theme>('light')` that holds the current theme. On startup, read a stored value from `localStorage` (if running in the browser), validate it, and call a helper that sets `document.documentElement.dataset.theme`. Derive an `isDark` computed from the theme and wire the toggle button to a `toggleTheme()` function that flips between `'light'` and `'dark'` and persists the result.",
        "solutionBlock": {
            "overview": "This exercise is about lifting theme state into a small global-ish store in Vue (a module-level `ref` + helpers) and wiring it to both the UI and the DOM. You store the current theme (`'light'` or `'dark'`) in a reactive `ref`, read an initial value from `localStorage` when the module is evaluated, and apply that value to the `<html>` element via a `data-theme` attribute. The root `App.vue` template shows a toggle in the top-right corner and delegates all theme changes to `toggleTheme()`. The provided CSS (`styles.css` + `App.css`) already listens to `data-theme` using `:root[data-theme='dark']` and `html[data-theme='dark'] .app-shell` rules, so you don't need to touch any styles.\n\n**Test cases**\n- First visit with empty localStorage → app starts in light mode and shows the light theme.\n- Click the toggle once → app switches to dark mode, the page background becomes dark, and the toggle shows dark mode.\n- Reload the page after switching to dark mode → app initializes in dark mode.\n- Toggle back to light → theme changes immediately and localStorage is updated.\n- The toggle label/icon always matches the active theme.",
            "approaches": [
                {
                    "title": "Module-level theme store with `data-theme` on `<html>`",
                    "prose": "Use a tiny theme store built directly in `<script setup>`.\n\n1. Define a `Theme` type alias (`'light' | 'dark'`) and a stable localStorage key.\n2. Create `const theme = ref<Theme>('light')` as the single source of truth.\n3. Add `applyTheme(theme)` that sets `document.documentElement.setAttribute('data-theme', theme)`.\n4. Run an `initTheme()` function at module evaluation time: it reads from localStorage, validates `'light'` / `'dark'`, falls back to `'light'`, assigns to `theme.value`, and calls `applyTheme`.\n5. Implement `setTheme(theme)` to update the ref, write to localStorage, and call `applyTheme`.\n6. Implement `toggleTheme()` to flip between `'light'` and `'dark'` using `setTheme`.\n7. Expose `const isDark = computed(() => theme.value === 'dark')` and an `onToggleClick()` handler that calls `toggleTheme()`.\n\nThe template stays very simple: it just binds the button to `onToggleClick` and shows `🌙 / ☀️` and `Dark / Light` labels based on `isDark`. All the persistence and DOM side-effects live in a few small helpers, keeping the component easy to reason about."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Reading from localStorage too late (e.g. only in a `mounted` hook) and causing a visible flash from light to dark.",
                    "Forgetting to actually apply the theme to `<html>` and only updating a label in the UI.",
                    "Using multiple sources of truth for the theme (for example, having separate `isDark` and `theme` refs that can drift apart).",
                    "Not guarding access to `window` / `localStorage` when running in non-browser environments."
                ],
                "techniques": [
                    "Using a module-level `ref` as a simple global store in Vue 3.",
                    "Using `computed` to derive booleans (`isDark`) from core state.",
                    "Encapsulating all side-effects (DOM + localStorage) in small helpers called from state-changing functions.",
                    "Letting preconfigured CSS (`:root[data-theme='dark']` and `html[data-theme='dark'] .app-shell`) handle visual changes while the script only controls `data-theme`."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-theme-toggle.v2.json",
            "openFile": "/src/App.vue",
            "storageKey": "v2:ui:vue:vue-theme-toggle"
        },
        "companies": [
            "google",
            "meta",
            "uber"
        ],
        "solutionAsset": "assets/sb/vue/solution/vue-theme-toggle-solution.v2.json"
    },
    {
        "id": "vue-multi-step-form",
        "title": "Multi-step Signup Form (3-step Wizard)",
        "type": "coding",
        "technology": "vue",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "vue",
            "forms",
            "validation",
            "wizard",
            "state-management",
            "composition-api"
        ],
        "description": {
            "summary": "Build a 3-step signup flow in Vue 3 that collects basic info, address info, and shows a summary with a final submit action. Each step should be validated before the user can proceed.",
            "specs": {
                "requirements": [
                    "Render a 3-step signup form as a small wizard-style UI.",
                    "Step 1: Basic info (name, email).",
                    "Step 2: Address info (street, city, country, optional postal code).",
                    "Step 3: Summary + Submit (show all collected data and allow submission).",
                    "Provide a \"Next\" button to advance to the next step.",
                    "\"Next\" must only be enabled when the current step is valid.",
                    "Provide an optional \"Back\" button to navigate to the previous step (except on the first step).",
                    "On the summary step, show a read-only overview of all data entered so far.",
                    "On the last step, show a \"Submit\" button that submits the aggregated data."
                ],
                "expectedBehavior": [
                    "Initial render shows Step 1 (Basic info) with empty fields.",
                    "Typing in inputs updates the internal form state in real time.",
                    "If required fields on the current step are invalid or empty, the \"Next\" button is disabled (or clicking it shows validation errors and does not advance).",
                    "When the current step is valid, the \"Next\" button becomes enabled and moves to the next step when clicked.",
                    "The \"Back\" button moves to the previous step and preserves already-entered values.",
                    "The summary step reflects the latest values from the previous steps.",
                    "Clicking \"Submit\" on the summary step validates all data and then performs a final action (e.g. logs the payload to the console)."
                ],
                "implementationNotes": [
                    "Use Vue 3's Composition API in `<script setup>`.",
                    "Store the entire form data (basic + address) in a single `reactive` object or equivalent structure.",
                    "Use one `ref` for the current step index (e.g. `currentStep = ref(0)`).",
                    "Use `computed` properties to derive booleans like `isFirstStep`, `isLastStep`, `canGoNext`, and `canSubmit` based on current step and validation rules.",
                    "Implement simple per-step validation functions or computed objects (e.g. `basicErrors`, `addressErrors`) and drive both error messages and disabled states from them.",
                    "Use `v-model` bindings for input elements so the form state stays in sync with user input.",
                    "Use conditional rendering (`v-if` / `v-else-if` / `v-else`) to show the relevant step content based on `currentStep`."
                ],
                "techFocus": [
                    "Vue 3 Composition API (`ref`, `reactive`, `computed`)",
                    "Multi-step form / wizard patterns",
                    "Form validation + disabled states",
                    "Centralized form state management",
                    "Conditional rendering and navigation between steps"
                ]
            }
        },
        "starterCodeHint": "Use `<script setup>` with a `ref` for `currentStep` and a `reactive` object for the combined form state (basic + address). Derive `isFirstStep`, `isLastStep`, and `canGoNext` as `computed` properties based on simple validation rules. Drive `Next` button disabled state and error messages from these computed values.",
        "solutionBlock": {
            "overview": "Implement a 3-step signup wizard using Vue 3's Composition API. Keep all form state in a single `reactive` object with nested `basic` and `address` sections, and track the current step with a `ref`. Use `computed` properties to derive validation flags and control when the user can move forward or submit the form.\n\n**Key ideas**\n- Centralize all form fields inside one `reactive` object so you can easily show a summary view.\n- Track the current step with `currentStep = ref(0)` and use conditional rendering in the template to show the correct step content.\n- Implement per-step validation (e.g. `basicErrors`, `addressErrors`) as `computed` objects that inspect the reactive form fields.\n- Derive `canGoNext` and `canSubmit` from these validation results so buttons stay disabled until the current step is valid.\n- Preserve form values when navigating between steps, and have the summary step render directly from the same reactive data.",
            "approaches": [
                {
                    "title": "Single `<App.vue>` wizard with reactive form state and computed validation",
                    "prose": "Keep everything inside `App.vue` using `<script setup>`. Define a `reactive` `form` object to hold `basic` (name, email) and `address` (street, city, country, postalCode) data. Use a `ref` for `currentStep` and drive the view with `v-if`/`v-else-if` blocks for each step. For validation, create `computed` objects like `basicErrors` and `addressErrors` that return booleans based on whether fields are empty or invalid. Then derive `isBasicValid`, `isAddressValid`, `canGoNext`, and `canSubmit` as additional `computed` values. The `next()` handler should check `canGoNext` before incrementing `currentStep`, while `prev()` decrements it when possible. The summary step simply displays the same reactive `form` data, and the `submit()` handler validates everything one last time before logging or sending the payload."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Scattering form state across multiple refs instead of keeping it in a single structured `reactive` object, which makes the summary and submit step harder to implement.",
                    "Implementing validation only in the click handlers and not deriving it from `computed` properties, which can lead to duplicated logic and inconsistent UI states.",
                    "Allowing navigation to the next step even when required fields are empty, or forgetting to disable the \"Next\" button until the step is valid.",
                    "Resetting or recreating the form object when changing steps, which causes entered values to be lost."
                ],
                "techniques": [
                    "Using `reactive` for grouped form data (with nested objects) so all steps share the same source of truth.",
                    "Using `computed` properties to derive validation flags and navigation booleans (`canGoNext`, `canSubmit`, `isFirstStep`, `isLastStep`).",
                    "Driving button disabled states and inline error messages entirely from validation `computed`s.",
                    "Using `v-model` for input fields so changes automatically update the underlying reactive form object."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/vue/question/vue-multi-step-form.v1.json",
            "openFile": "/src/App.vue",
            "storageKey": "v1:ui:vue:vue-multi-step-form"
        },
        "solutionAsset": "assets/sb/vue/solution/vue-multi-step-form-solution.v1.json"
    }
]