[
  {
    "id": "vue-reactivity-vs-react-concepts",
    "title": "What problems does Vue’s reactivity system solve, and how does Vue differ from React conceptually?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Vue’s reactivity system tracks data dependencies and updates only the affected DOM bindings, reducing manual state wiring. Compared to React’s explicit state updates and reconciliation, Vue offers automatic dependency tracking with template-level reactivity.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>What Vue reactivity solves (the practical problems)</strong><br><br>In UI code you constantly fight the same issues: keeping DOM in sync with state, updating derived values efficiently, and avoiding “update everything” work. Vue’s reactivity system solves these by automatically tracking what your UI depends on and updating only what’s affected when state changes."
        },
        {
          "type": "list",
          "columns": [
            "Problem in UI apps",
            "Without reactivity you do...",
            "Vue reactivity gives you..."
          ],
          "rows": [
            [
              "State → DOM synchronization",
              "Manually set text/classes/attributes or write glue code everywhere",
              "Declarative templates; mutate state and the DOM updates automatically"
            ],
            [
              "Derived state (filters, totals, formatting)",
              "Recompute on every render or cache manually",
              "computed() is cached automatically and invalidated only when dependencies change"
            ],
            [
              "Avoiding unnecessary work",
              "Re-render or recompute too much, then add manual memoization",
              "Dependency tracking updates only the effects/components that actually touched the changed property"
            ],
            [
              "Batching multiple changes",
              "Accidentally trigger multiple paints/renders in a row",
              "Updates are queued/deduped and flushed (microtask) so many mutations typically produce one DOM patch"
            ],
            [
              "Side effects based on state changes",
              "Wire custom subscriptions and cleanup",
              "watch()/watchEffect() run when tracked dependencies change, with controlled timing (flush options)"
            ]
          ],
          "caption": "What problems Vue reactivity solves"
        },
        {
          "type": "text",
          "text": "<strong>What Vue is doing under the hood (high level)</strong><br><br>Vue 3 wraps state in Proxies. When code runs inside a reactive “effect” (component render, computed, watcher), any reactive <code>get</code> is tracked. When you later <code>set</code> a reactive property, Vue triggers only the effects that previously read that property. Those effects are scheduled and batched, then Vue patches the DOM."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Vue 3 (Composition API) - fine-grained dependency tracking -->\n<script setup>\nimport { ref, computed } from 'vue';\n\nconst price = ref(100);\nconst qty = ref(2);\n\n// Cached until price/qty changes\nconst total = computed(() => price.value * qty.value);\n\nfunction addOne() {\n  qty.value++;\n}\n</script>\n\n<template>\n  <p>Qty: {{ qty }}</p>\n  <p>Total: {{ total }}</p>\n  <button @click=\"addOne\">+1</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>How Vue differs from React conceptually</strong><br><br>The biggest difference is the update model:<br>• <strong>Vue:</strong> “push” model. Dependency graph decides what to update (<em>who depends on what</em>). Component updates happen because reactive reads were tracked.<br>• <strong>React:</strong> “render-as-a-function” model. State updates schedule a re-render of a component; during re-render React re-executes your component function to compute the next UI, then reconciles."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Vue (conceptual model)",
            "React (conceptual model)"
          ],
          "rows": [
            [
              "Update trigger",
              "Reactive property write triggers tracked dependents (effects/components)",
              "setState/useState setter schedules component re-render"
            ],
            [
              "Granularity",
              "Property-level dependency tracking; avoids updating unrelated dependents",
              "Component-level re-render by default; you add memoization/selectors to skip work"
            ],
            [
              "Authoring UI",
              "Templates (compiled) + directives; JS in script section (SFC)",
              "JSX/TSX (UI is JS); everything expressed as functions/components"
            ],
            [
              "Optimization story",
              "Compiler hints (patch flags/block tree) + reactive tracking reduce diffing work",
              "Reconciliation + memo/useMemo/useCallback + architecture patterns reduce re-render cost"
            ],
            [
              "Derived state",
              "computed() is first-class and cached by default",
              "Derived values computed during render; caching is manual (useMemo) or via external stores"
            ],
            [
              "Two-way binding",
              "Built-in pattern (<code>v-model</code>) for form bindings",
              "Explicit: value + onChange (controlled components) or uncontrolled refs"
            ],
            [
              "Mental model summary",
              "Mutate reactive state; Vue figures out what depends on it",
              "Update state; React re-runs render to recompute UI"
            ]
          ],
          "caption": "Vue vs React: conceptual differences"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// React - re-render computes next UI\nimport { useMemo, useState } from 'react';\n\nexport function Cart() {\n  const [price, setPrice] = useState(100);\n  const [qty, setQty] = useState(2);\n\n  // Optional caching (manual)\n  const total = useMemo(() => price * qty, [price, qty]);\n\n  return (\n    <>\n      <p>Qty: {qty}</p>\n      <p>Total: {total}</p>\n      <button onClick={() => setQty(q => q + 1)}>+1</button>\n    </>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br>Vue’s reactivity exists to remove manual DOM sync and to make updates precise via dependency tracking + batching. React’s core idea is re-running component functions to describe the next UI and reconciling the result. Vue leans on a reactive graph + compiler; React leans on a render cycle + reconciliation, with optimization patterns layered on top."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "reactivity",
      "react",
      "state-management",
      "virtual-dom",
      "frameworks"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-internal-rendering-pipeline",
    "title": "How does Vue track state changes and trigger re-renders internally?",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 2,
    "description": "Vue re-renders components by combining (1) reactive state (Proxy-based in Vue 3), (2) dependency tracking (track/trigger), and (3) a scheduler that batches component updates, then patches the DOM via virtual DOM diffing (optimized with compiler hints like patch flags).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Vue doesn’t “poll” your state. It records <em>who read what</em> during render, and when that state changes it re-runs only the affected render effects."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "What happens internally",
            "Why it matters"
          ],
          "rows": [
            [
              "1) Make state reactive",
              "Vue wraps objects with a Proxy (Vue 3) so it can intercept <code>get</code>/<code>set</code>.",
              "Lets Vue observe reads/writes without you calling setState."
            ],
            [
              "2) Render inside an effect",
              "Each component render runs inside a reactive “effect” (think: tracked function).",
              "Any reactive reads during render become dependencies."
            ],
            [
              "3) Track dependencies on reads",
              "On <code>get</code>, Vue calls <code>track(target, key)</code> to link (target,key) → activeEffect.",
              "Vue learns exactly which component depends on which property."
            ],
            [
              "4) Trigger on writes",
              "On <code>set</code>, Vue calls <code>trigger(target, key)</code> to find all effects depending on (target,key).",
              "Only affected components/computed/watchers are scheduled."
            ],
            [
              "5) Batch updates",
              "Component effects are queued (deduped) and flushed in a microtask (scheduler).",
              "Multiple synchronous mutations cause only one re-render per component."
            ],
            [
              "6) Re-render + patch DOM",
              "Re-run render → new VNode tree → <code>patch(oldVNode, newVNode)</code> updates DOM.",
              "Virtual DOM diff updates only what changed."
            ]
          ],
          "caption": "Vue’s internal reactivity → rendering pipeline"
        },
        {
          "type": "text",
          "text": "<strong>Dependency tracking (track/trigger) in simplified pseudo-code</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Highly simplified mental model (not Vue source)\nconst targetMap = new WeakMap();\nlet activeEffect = null;\n\nfunction track(target, key) {\n  if (!activeEffect) return;\n  let depsMap = targetMap.get(target);\n  if (!depsMap) targetMap.set(target, (depsMap = new Map()));\n  let dep = depsMap.get(key);\n  if (!dep) depsMap.set(key, (dep = new Set()));\n  dep.add(activeEffect);\n}\n\nfunction trigger(target, key) {\n  const depsMap = targetMap.get(target);\n  const dep = depsMap?.get(key);\n  if (!dep) return;\n  dep.forEach(effect => effect.scheduler ? effect.scheduler(effect) : effect.run());\n}\n\nfunction effect(fn, scheduler) {\n  const e = {\n    run() {\n      activeEffect = e;\n      try { return fn(); } finally { activeEffect = null; }\n    },\n    scheduler\n  };\n  e.run();\n  return e;\n}"
        },
        {
          "type": "text",
          "text": "<strong>How “re-render” is actually wired</strong><br><br>Each component has a render effect. When its dependencies trigger, Vue doesn’t immediately run it; it queues it."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Conceptually\nconst componentUpdateEffect = effect(\n  () => {\n    const nextVNodeTree = renderComponent();\n    patch(prevVNodeTree, nextVNodeTree);\n    prevVNodeTree = nextVNodeTree;\n  },\n  (job) => queueJob(job) // scheduler batching\n);"
        },
        {
          "type": "text",
          "text": "<strong>Scheduler / batching</strong><br><br>Vue queues component jobs and flushes them in a microtask. So if you do <code>state.a++</code> then <code>state.b++</code> synchronously, the component typically renders once. <code>nextTick()</code> resolves after the queued DOM patches are applied."
        },
        {
          "type": "text",
          "text": "<strong>Vue 3 render performance extra</strong><br><br>Vue 3’s compiler adds hints (patch flags + block tree) so the runtime can skip diffing stable parts of the template and focus on dynamic bindings. Reactivity decides <em>which components update</em>; patch flags help decide <em>how much work the DOM patch does</em> within that update."
        },
        {
          "type": "list",
          "columns": [
            "Reactive primitive",
            "Internal behavior",
            "Update timing"
          ],
          "rows": [
            [
              "computed()",
              "Runs as a lazy effect; caches value until a dependency triggers (marks it “dirty”).",
              "Recomputes on next access, not immediately on every change."
            ],
            [
              "watch()",
              "Creates an effect on a getter; on trigger runs a callback (side effects).",
              "Flush can be <code>pre</code>/<code>post</code>/<code>sync</code> (controls when callback runs relative to render)."
            ],
            [
              "ref()",
              "Wraps a value; reads/writes track/trigger via <code>.value</code>.",
              "Same scheduler rules when used by components."
            ]
          ],
          "caption": "Where computed/watch/ref fit in the same engine"
        },
        {
          "type": "text",
          "text": "<strong>Practical implications / common gotchas</strong><br><br>• If you destructure reactive objects (e.g., <code>const { x } = reactiveObj</code>), you may lose tracking because the render no longer reads through the Proxy.<br>• If you mutate many things in a row, expect one render (batched), and use <code>await nextTick()</code> when you need DOM to be updated.<br>• If something doesn’t update, it usually means the render didn’t read that reactive source (no dependency tracked)."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Vue tracks reactive reads during render (track), schedules dependent component effects on writes (trigger → queue), then re-renders and patches the DOM in a batched flush. That’s the whole “state change → re-render” loop."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "rendering",
      "reactivity",
      "virtual-dom",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Vue rendering pipeline: state to DOM",
      "description": "Follow Vue's rendering pipeline from reactive dependency tracking to scheduled effects and patching, so you can explain how state changes reach the DOM."
    }
  },
  {
    "id": "vue-data-must-be-function",
    "title": "Why must data be a function in Vue components, and what breaks if it isn’t?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "In Vue, component data must be a function so each instance gets its own state object. If it were a shared object, multiple instances would mutate the same reference and leak state between components. This avoids shared state bugs and makes components safer to reuse and test.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>data()</code> must be a function in reusable component definitions so Vue can create a <em>new state object per component instance</em>. If you use a plain object, every instance points to the <em>same object reference</em> (shared state)."
        },
        {
          "type": "list",
          "columns": [
            "data option",
            "What Vue needs",
            "What happens in practice"
          ],
          "rows": [
            [
              "<code>data() { return { ... } }</code>",
              "A factory that returns a new object per instance",
              "Each component instance has isolated state"
            ],
            [
              "<code>data: { ... }</code>",
              "A single object",
              "All instances share the same state (cross-instance leaks)"
            ]
          ],
          "caption": "Why Vue requires data() in components"
        },
        {
          "type": "text",
          "text": "<strong>What breaks if <code>data</code> is an object?</strong><br><br>Nothing “crashes” immediately—Vue can still make it reactive—but your component stops being instance-safe. The bugs show up as state leaking between instances."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- WRONG: shared state across instances -->\n<script>\nconst Counter = {\n  template: `\n    <button @click=\"count++\">Count: {{ count }}</button>\n  `,\n  data: { count: 0 } // ❌ shared reference\n};\n\nexport default {\n  components: { Counter }\n};\n</script>\n\n<template>\n  <Counter />\n  <Counter />\n</template>\n\n<!-- Click one button -> both counters update because they share the same 'count'. -->"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- CORRECT: per-instance state -->\n<script>\nconst Counter = {\n  template: `\n    <button @click=\"count++\">Count: {{ count }}</button>\n  `,\n  data() {\n    return { count: 0 }; // ✅ new object per instance\n  }\n};\n\nexport default {\n  components: { Counter }\n};\n</script>\n\n<template>\n  <Counter />\n  <Counter />\n</template>"
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "Symptom",
            "Why it happens"
          ],
          "rows": [
            [
              "Rendering the same component multiple times",
              "Changing state in one instance changes the others",
              "All instances reference the same object"
            ],
            [
              "Lists (<code>v-for</code>) of stateful components",
              "Items “share” state unexpectedly (especially with filtering/sorting)",
              "Instances are supposed to be isolated; shared data violates that"
            ],
            [
              "SSR (Nuxt / server rendering)",
              "Request-to-request state leakage between users",
              "Server process reuses the same module/object across requests"
            ]
          ],
          "caption": "Real-world breakages from shared component data"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>• If you want <em>instance state</em> (almost always): use <code>data()</code>.<br>• If you want <em>intentionally shared state</em>: don’t “accidentally” share via <code>data: {}</code>—use a store (Pinia) or a clearly named shared module/composable."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Vue requires <code>data()</code> in component definitions because components are instantiated multiple times. A function returns a fresh object per instance. If <code>data</code> is a plain object, state becomes shared, causing cross-instance bugs and (in SSR) even cross-user data leaks."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Rendering a list of card components, each needs isolated local state for toggles and counters.<br><br><strong>Common pitfalls</strong><br><ul><li>Using a shared object for data and leaking state between instances.</li><li>Mutating data outside the component and causing side effects.</li><li>Assuming reactivity works the same for shared references.</li></ul><strong>Trade-off or test tip</strong><br>Returning a function is slightly more boilerplate but safer. Test two instances to ensure state stays isolated.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "data",
      "components",
      "state",
      "instances",
      "best-practices"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-reactive-interpolation-into-dom",
    "title": "How does Vue interpolate reactive state into the DOM?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Explain what happens from a template expression like {{ count }} to a real DOM text node update: template compilation, dependency tracking during render, scheduling/batching, and DOM patching. Mention how Vue handles refs in templates and why interpolation escapes HTML by default.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>The core idea</strong><br><br>Vue doesn’t “re-run the whole DOM.” It compiles <code>{{ ... }}</code> into a render function that creates a Virtual DOM (VNode) tree. During render, Vue tracks which reactive properties were read. When one of those properties changes, Vue schedules the component update, re-runs the render function, diffs old vs new VNodes, and patches only the affected DOM nodes (e.g., a single text node)."
        },
        {
          "type": "list",
          "columns": [
            "Stage",
            "What Vue does",
            "Why it matters"
          ],
          "rows": [
            [
              "1) Compile template",
              "<code>{{ count }}</code> becomes code that produces a text VNode (via <code>toDisplayString(count)</code>).",
              "Interpolation is not “magic at runtime”; it’s mostly compiler output + runtime patching."
            ],
            [
              "2) Mount (first render)",
              "Runs render inside a reactive effect. Any reactive read (like <code>count</code>) is tracked.",
              "Vue learns exactly which component depends on which reactive keys."
            ],
            [
              "3) State change",
              "When you mutate reactive state, Vue <em>triggers</em> the dependent render effect(s).",
              "Only components that used that state are scheduled to update."
            ],
            [
              "4) Batch + schedule",
              "Updates are queued/deduped and flushed in a microtask.",
              "Multiple sync mutations typically lead to one DOM patch per component."
            ],
            [
              "5) Patch DOM",
              "Re-render → new VNodes → diff/patch updates only the dynamic parts (often a single text node).",
              "Efficient updates without manual DOM manipulation."
            ]
          ],
          "caption": "Template interpolation → reactive update → DOM patch"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { ref, nextTick } from 'vue';\n\nconst count = ref(0);\n\nasync function incTwice() {\n  count.value++;\n  count.value++;\n\n  // DOM is patched after the batched flush\n  await nextTick();\n  // Now the DOM reflects the final value\n}\n</script>\n\n<template>\n  <!-- Note: refs are auto-unwrapped in templates -->\n  <p>Count: {{ count }}</p>\n  <button @click=\"incTwice\">+2</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>What the compiler roughly generates</strong><br><br>Vue compiles templates to a render function that produces VNodes. For a dynamic text binding, the runtime can optimize patching using compiler hints (e.g., patch flags). Exact output varies, but the shape looks like this:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Pseudo-ish compiled shape (not exact Vue output)\nimport { openBlock, createElementBlock, toDisplayString } from 'vue';\n\nexport function render(_ctx) {\n  return (\n    openBlock(),\n    createElementBlock(\n      'p',\n      null,\n      'Count: ' + toDisplayString(_ctx.count),\n      /* patchFlag */ 1 // TEXT (runtime knows only text needs updating)\n    )\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Security: interpolation escapes HTML</strong><br><br><code>{{ value }}</code> renders text content (escaped). If you need to render HTML, Vue provides <code>v-html</code>, but you must treat it as XSS-sensitive and only use trusted/sanitized content."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <!-- Escaped: renders literally as \"<strong>Hi</strong>\" -->\n  <p>{{ raw }}</p>\n\n  <!-- Not escaped: injects HTML into the DOM (danger if untrusted) -->\n  <p v-html=\"raw\"></p>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nconst raw = ref('<strong>Hi</strong>');\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br>Interpolation in Vue is: template compile → render effect tracks reactive reads → state writes trigger scheduled re-render → VDOM diff + patch updates only the dynamic DOM nodes. Templates auto-unwrap refs, and interpolation is HTML-escaped by default."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "reactivity",
      "templates",
      "rendering",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-v-bind-reactive-attributes",
    "title": "How does v-bind connect reactive state to DOM attributes?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Explain how v-bind (:) turns reactive state into DOM attribute/prop updates: template compilation into a render function, dependency tracking during render, scheduled component updates, and how the runtime patches attributes vs DOM properties (including class/style and boolean attrs).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>v-bind</code> (shorthand <code>:</code>) is not a runtime “watcher on attributes”. Vue compiles your template into a render function. During render, Vue <em>reads</em> the reactive values used in bindings (so they get tracked). When those reactive values change, Vue re-runs the component render and then patches only the changed attributes/DOM props on the affected elements."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { ref, computed } from 'vue';\n\nconst img = ref('https://example.com/a.png');\nconst loading = ref(false);\nconst size = ref('sm');\n\nconst classes = computed(() => ({\n  'btn': true,\n  'btn--sm': size.value === 'sm',\n  'btn--lg': size.value === 'lg',\n  'is-loading': loading.value\n}));\n\nfunction toggle() {\n  loading.value = !loading.value;\n  size.value = size.value === 'sm' ? 'lg' : 'sm';\n}\n</script>\n\n<template>\n  <img :src=\"img\" :alt=\"loading ? 'Loading' : 'Ready'\" />\n\n  <!-- boolean + aria + class object -->\n  <button\n    :class=\"classes\"\n    :disabled=\"loading\"\n    :aria-busy=\"loading\"\n    @click=\"toggle\"\n  >\n    Toggle\n  </button>\n</template>"
        },
        {
          "type": "list",
          "columns": [
            "Stage",
            "What happens",
            "Why it matters"
          ],
          "rows": [
            [
              "1) Compile",
              "Template <code>:src=\"img\"</code> becomes a VNode prop binding in the render function.",
              "Bindings become plain JS expressions; no magic string parsing at runtime."
            ],
            [
              "2) Render in an effect",
              "Component render runs inside a reactive effect; reading <code>img.value</code>/<code>loading.value</code> is tracked.",
              "Vue learns exactly which component depends on which reactive keys."
            ],
            [
              "3) Reactive change",
              "A write like <code>loading.value = true</code> triggers the tracked render effect.",
              "Only components that used that reactive value are scheduled."
            ],
            [
              "4) Batch + flush",
              "Multiple synchronous writes are queued/deduped; update happens in a microtask.",
              "Avoids multiple DOM patches for back-to-back mutations."
            ],
            [
              "5) Patch",
              "Vue diffs old vs new VNodes and applies prop/attr changes to the real DOM node.",
              "Only changed attributes/properties are touched."
            ]
          ],
          "caption": "How a v-bind update flows from state → DOM"
        },
        {
          "type": "text",
          "text": "<strong>Attribute vs DOM property (the part interviewers probe)</strong><br><br>Vue’s patcher decides whether a binding should be applied as a DOM <em>property</em> (<code>el.value</code>, <code>el.checked</code>, <code>el.innerHTML</code> etc.) or as an HTML <em>attribute</em> (<code>setAttribute</code>). Most of the time Vue handles this for you, but knowing the difference explains edge cases (especially with form controls and boolean attributes)."
        },
        {
          "type": "list",
          "columns": [
            "Binding",
            "Vue patch behavior (typical)",
            "Notes / gotchas"
          ],
          "rows": [
            [
              "<code>:class</code>",
              "Special-cased: normalized + set as <code>className</code> efficiently.",
              "Object/array syntax is merged; avoids string concat in templates."
            ],
            [
              "<code>:style</code>",
              "Special-cased: patches individual style properties.",
              "Avoids rewriting the whole style string when only one value changes."
            ],
            [
              "Boolean attrs (e.g. <code>disabled</code>)",
              "Sets/removes based on truthiness (and often uses the DOM property).",
              "If false, Vue removes the attribute; DOM reflects enabled state."
            ],
            [
              "Form-related props (e.g. <code>value</code>, <code>checked</code>)",
              "Prefer DOM properties for correctness.",
              "Attributes don’t always reflect live state; properties do."
            ],
            [
              "SVG attrs",
              "Often must be attributes (SVG DOM differs from HTML).",
              "Vue handles element namespace differences for you."
            ]
          ],
          "caption": "What v-bind actually patches"
        },
        {
          "type": "text",
          "text": "<strong>What the compiler roughly generates</strong><br><br>The exact output varies, but conceptually <code>:src</code>/<code>:disabled</code>/<code>:class</code> become a props object on the VNode. The runtime uses patch flags / dynamic props so it can update only what’s dynamic."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Pseudo-ish shape (not exact Vue output)\nimport { openBlock, createElementBlock } from 'vue';\n\nexport function render(_ctx) {\n  return (\n    openBlock(),\n    createElementBlock('button', {\n      class: _ctx.classes,\n      disabled: _ctx.loading,\n      'aria-busy': _ctx.loading,\n      onClick: _ctx.toggle\n    }, 'Toggle', /* patchFlag */ 8 /* PROPS */, /* dynamicProps */ ['class','disabled','aria-busy'])\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Useful patterns</strong><br><br>1) Bind many attrs at once with an object (great for pass-through props / wrapper components).<br>2) Use dynamic argument when the attribute name itself is data-driven."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { computed, ref } from 'vue';\n\nconst attrs = computed(() => ({\n  id: 'cta',\n  title: 'Call to action',\n  'data-track': 'signup'\n}));\n\nconst attrName = ref('aria-label');\nconst label = ref('Sign up');\n</script>\n\n<template>\n  <a href=\"/signup\" v-bind=\"attrs\">Sign up</a>\n\n  <!-- dynamic attribute name -->\n  <button :[attrName]=\"label\">Hover me</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><code>v-bind</code> works because the template is compiled into a render function that <em>reads</em> reactive state during render (dependency tracking). State changes trigger a scheduled re-render, and Vue patches only the changed VNode props—mapping them to DOM properties or HTML attributes (with special handling for class/style/booleans)."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "directives",
      "v-bind",
      "reactivity",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-v-if-component-creation-destruction",
    "title": "How does v-if affect component creation and destruction?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what happens to a component instance when a v-if condition toggles: when it is created (mounted), when it is destroyed (unmounted), what lifecycle hooks run, and why local state resets. Contrast with v-show and mention when you should prefer one over the other.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>v-if</code> controls whether a template branch <em>exists</em>. For plain elements it means “insert/remove DOM”. For components it means “mount/unmount the component instance” — so the instance is created when the condition becomes true and destroyed when it becomes false."
        },
        {
          "type": "list",
          "columns": [
            "When condition...",
            "What Vue does",
            "What you observe"
          ],
          "rows": [
            [
              "becomes true (first time)",
              "Creates component instance and mounts it",
              "setup()/data() runs, DOM is created, mounted hooks fire"
            ],
            [
              "becomes false",
              "Unmounts component instance and removes DOM",
              "unmounted hooks fire, watchers/listeners cleaned up, DOM disappears"
            ],
            [
              "becomes true again",
              "Creates a new component instance (fresh)",
              "Local state resets (unless state lives outside the component)"
            ]
          ],
          "caption": "v-if toggling = mount/unmount (new instance each time)"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<script setup>\nimport { ref } from 'vue';\nimport Child from './Child.vue';\n\nconst show = ref(true);\n</script>\n\n<template>\n  <button @click=\"show = !show\">Toggle</button>\n  <Child v-if=\"show\" />\n</template>\n\n<!-- Child.vue -->\n<script setup>\nimport { onMounted, onBeforeUnmount, ref } from 'vue';\n\nconst clicks = ref(0);\nlet id;\n\nonMounted(() => {\n  console.log('mounted');\n  id = window.setInterval(() => console.log('tick'), 1000);\n});\n\nonBeforeUnmount(() => {\n  console.log('beforeUnmount (cleanup)');\n  window.clearInterval(id);\n});\n</script>\n\n<template>\n  <button @click=\"clicks++\">Clicks (resets after v-if): {{ clicks }}</button>\n</template>"
        },
        {
          "type": "list",
          "columns": [
            "Area",
            "What happens on v-if=false (unmount)",
            "Why it matters"
          ],
          "rows": [
            [
              "Local component state",
              "Discarded (next mount starts from initial state)",
              "You lose UI state like input values, counters, local caches"
            ],
            [
              "Watchers / effects",
              "Stopped automatically",
              "Avoids leaks, but also means side effects restart on next mount"
            ],
            [
              "DOM + focus",
              "Removed from DOM",
              "Focus is lost; selection/caret state is gone"
            ],
            [
              "Lifecycle hooks",
              "Vue 3: beforeUnmount/unmounted (Vue 2: beforeDestroy/destroyed)",
              "Interviewers often check that you know it’s actual destruction"
            ]
          ],
          "caption": "What “destroy” really implies with v-if"
        },
        {
          "type": "text",
          "text": "<strong>v-if vs v-show (performance + behavior)</strong><br><br><code>v-if</code> has higher toggle cost (create/destroy) but zero cost when false (nothing exists). <code>v-show</code> has higher initial cost (always renders once) but cheap toggles (CSS display only)."
        },
        {
          "type": "list",
          "columns": [
            "Use case",
            "Prefer",
            "Reason"
          ],
          "rows": [
            [
              "Toggles frequently (tabs, dropdown open/close)",
              "v-show",
              "Avoid repeated mount/unmount work; keeps state + DOM"
            ],
            [
              "Toggles rarely (auth gate, expensive panel, route-like branches)",
              "v-if",
              "Don’t pay initial render cost until needed; removes heavy DOM when off"
            ],
            [
              "Must preserve state across toggles but still avoid rendering when hidden",
              "Move state out / keep-alive (when applicable)",
              "State lives outside the destroyed instance, or instance is cached"
            ]
          ],
          "caption": "Choosing between v-if and v-show"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- v-show: component stays mounted, just hidden -->\n<template>\n  <Child v-show=\"show\" />\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Forcing recreation even when staying on-screen</strong><br><br>If you want to deliberately reset a component, you can change its <code>key</code>. A key change forces Vue to treat it as a different instance (destroy + create)."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <Child :key=\"resetVersion\" />\n  <button @click=\"resetVersion++\">Hard reset Child</button>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nimport Child from './Child.vue';\n\nconst resetVersion = ref(0);\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><code>v-if</code> is structural: it creates and destroys DOM and component instances. Toggling it re-runs setup/data and resets local state. Use <code>v-show</code> for frequent toggles, and keep state outside the component (or cache instances where appropriate) when you need persistence."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "directives",
      "v-if",
      "lifecycle",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "v-if creation and destruction in Vue",
      "description": "Understand how v-if mounts and unmounts Vue components, which lifecycle hooks run, why local state resets, and when v-show is the better choice."
    }
  },
  {
    "id": "vue-v-for-keys",
    "title": "Why are keys critical in v-for, and what breaks without them?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Explain why :key is required/recommended in v-for, what Vue uses it for during virtual DOM diffing, and give concrete examples of bugs you can get when keys are missing or unstable (including why using the index as key is usually wrong).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>:key</code> gives Vue a <em>stable identity</em> for each rendered item. During updates, Vue matches old VNodes to new VNodes primarily by <code>type + key</code>. With good keys, Vue can move/reuse the right DOM nodes and component instances. Without keys, Vue falls back to a mostly <em>index-based / in-place patch</em> strategy, which can reuse the wrong DOM/component for a different item."
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "With stable keys (e.g., item.id)",
            "Without keys / bad keys (e.g., index)"
          ],
          "rows": [
            [
              "Insert/remove in the middle",
              "Vue inserts/removes the correct node and keeps other items' DOM/state attached",
              "Vue reuses DOM nodes by position; DOM/state may “shift” to the wrong item"
            ],
            [
              "Sorting / reordering",
              "Vue moves existing nodes (minimal DOM work) and preserves per-item state",
              "Vue patches in place; items can display wrong state (inputs, toggles, child state)"
            ],
            [
              "Stateful child components in a list",
              "Each child instance stays with its data item",
              "Child instances can get reassigned to different data items (state leak/mismatch)"
            ],
            [
              "Transitions (<code>&lt;transition-group&gt;</code>)",
              "Correct enter/leave/move animations",
              "Animations glitch or don’t run correctly (Vue can’t track moves reliably)"
            ]
          ],
          "caption": "What keys enable vs what breaks without them"
        },
        {
          "type": "text",
          "text": "<strong>What “breaks” in practice</strong><br><br>Typical real bugs when keys are missing or unstable:<br>• <strong>Inputs show the wrong value</strong> after sorting/filtering because the DOM input element is reused for a different item.<br>• <strong>Focus/caret jumps</strong> (typing in an input, list updates, and the focused DOM node is reused/moved incorrectly).<br>• <strong>Checkboxes/toggles flip on the wrong row</strong> (DOM state vs data association breaks).<br>• <strong>Child component local state leaks</strong> (e.g., expanded/collapsed, internal caches, timers) to a different item after reordering.<br>• <strong>Transition-group move animations break</strong> because Vue can’t reliably compute “this node moved from A to B” without keys."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- BAD: no key (or :key=\"index\") can cause DOM/state to shift on reorder -->\n<script setup>\nimport { ref } from 'vue';\n\nconst items = ref([\n  { id: 1, name: 'Alpha' },\n  { id: 2, name: 'Bravo' },\n  { id: 3, name: 'Charlie' }\n]);\n\nfunction reverse() {\n  items.value = [...items.value].reverse();\n}\n</script>\n\n<template>\n  <button @click=\"reverse\">Reverse</button>\n\n  <ul>\n    <li v-for=\"(item, index) in items\">\n      <!-- Try typing in Alpha, then Reverse: the typed DOM input may appear under a different item -->\n      <label>\n        {{ item.name }}\n        <input placeholder=\"type here\" />\n      </label>\n    </li>\n  </ul>\n</template>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- GOOD: stable key preserves DOM association and component instances -->\n<script setup>\nimport { ref } from 'vue';\n\nconst items = ref([\n  { id: 1, name: 'Alpha' },\n  { id: 2, name: 'Bravo' },\n  { id: 3, name: 'Charlie' }\n]);\n\nfunction reverse() {\n  items.value = [...items.value].reverse();\n}\n</script>\n\n<template>\n  <button @click=\"reverse\">Reverse</button>\n\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">\n      <label>\n        {{ item.name }}\n        <input placeholder=\"type here\" />\n      </label>\n    </li>\n  </ul>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Index as key: when it’s wrong vs acceptable</strong><br><br><code>:key=\"index\"</code> is effectively “no stable identity” when the list can reorder, filter, insert, or delete. It tells Vue: “identity is position”, so Vue will keep DOM/state by index, not by data item. It’s only acceptable when the list is truly static (never changes order/length) or when each row has no meaningful state (rare in real apps)."
        },
        {
          "type": "list",
          "columns": [
            "Key rule",
            "Why",
            "Example"
          ],
          "rows": [
            [
              "Use a stable unique id",
              "Preserves identity across reorder/insert/delete",
              ":key=\"item.id\""
            ],
            [
              "Don’t use random/unstable keys",
              "Forces full destroy/recreate every render (kills performance/state)",
              ":key=\"Math.random()\" (bad)"
            ],
            [
              "Avoid index for dynamic lists",
              "Index changes when list changes, so identity shifts",
              ":key=\"index\" (usually bad)"
            ],
            [
              "Key must be primitive + stable",
              "Vue compares keys; stable primitives keep matching predictable",
              "number/string id"
            ],
            [
              "transition-group needs keys",
              "Move/enter/leave tracking depends on identity",
              "<transition-group> children must be keyed"
            ]
          ],
          "caption": "Best practices for :key in v-for"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br>Keys aren’t about “performance only”. They’re primarily about <em>correctness</em>: ensuring DOM nodes and component instances stay attached to the same logical data item across updates. Without stable keys (or with index keys), you risk state/DOM mismatches when the list changes."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "lists",
      "keys",
      "rendering",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Vue v-for keys: what breaks without them",
      "description": "Understand why stable keys are required in v-for, how Vue reuses nodes during diffing, and which UI bugs appear when indexes or unstable keys are used."
    }
  },
  {
    "id": "vue-v-model-syntax-sugar-expansion",
    "title": "Why is v-model syntax sugar, and what does it expand to?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Explain why v-model is considered syntax sugar in Vue: it’s compiled into a prop binding + an event listener. Show what it expands to for native form elements (text input, checkbox, select) and for custom components in Vue 3 (modelValue + update:modelValue). Include how v-model arguments (v-model:foo) and common modifiers (.trim, .number, .lazy) change the expansion.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>v-model</code> is <em>syntax sugar</em> because it doesn’t add a new runtime “two-way binding engine”. Vue’s template compiler rewrites it into:<br>1) a <strong>prop/attribute binding</strong> (state → DOM/component)<br>2) an <strong>event listener</strong> (DOM/component → state)<br><br>So it’s just a shorter way to write “bind value + update on event”."
        },
        {
          "type": "list",
          "columns": [
            "Usage",
            "Expands to (conceptually)",
            "Notes"
          ],
          "rows": [
            [
              "<code>&lt;input v-model=\"msg\" /&gt;</code>",
              "<code>:value=\"msg\"</code> + <code>@input=\"msg = $event.target.value\"</code>",
              "Text-like inputs use <code>input</code> event."
            ],
            [
              "<code>&lt;input type=\"checkbox\" v-model=\"ok\" /&gt;</code>",
              "<code>:checked=\"ok\"</code> + <code>@change=\"ok = $event.target.checked\"</code>",
              "Checkbox binds <code>checked</code>, not <code>value</code>."
            ],
            [
              "<code>&lt;select v-model=\"pick\"&gt;...</code>",
              "<code>:value=\"pick\"</code> + <code>@change=\"pick = $event.target.value\"</code>",
              "Select updates on <code>change</code>."
            ],
            [
              "<code>&lt;MyComp v-model=\"val\" /&gt;</code> (Vue 3)",
              "<code>:modelValue=\"val\"</code> + <code>@update:modelValue=\"val = $event\"</code>",
              "Custom components use <code>modelValue</code> + <code>update:modelValue</code> by default."
            ],
            [
              "<code>&lt;MyComp v-model:title=\"title\" /&gt;</code> (Vue 3)",
              "<code>:title=\"title\"</code> + <code>@update:title=\"title = $event\"</code>",
              "Argument changes prop/event name."
            ]
          ],
          "caption": "What v-model expands to (high level)"
        },
        {
          "type": "text",
          "text": "<strong>Native input example (the “long form”)</strong>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <!-- Sugar -->\n  <input v-model=\"msg\" />\n\n  <!-- Desugared -->\n  <input\n    :value=\"msg\"\n    @input=\"msg = $event.target.value\"\n  />\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nconst msg = ref('hello');\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Checkbox + select (different DOM properties/events)</strong><br><br>People call <code>v-model</code> “smart sugar” because it chooses the correct DOM property and event per form control."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <!-- Checkbox: checked + change -->\n  <input type=\"checkbox\" v-model=\"ok\" />\n  <input\n    type=\"checkbox\"\n    :checked=\"ok\"\n    @change=\"ok = $event.target.checked\"\n  />\n\n  <!-- Select: value + change -->\n  <select v-model=\"pick\">\n    <option value=\"a\">A</option>\n    <option value=\"b\">B</option>\n  </select>\n  <select\n    :value=\"pick\"\n    @change=\"pick = $event.target.value\"\n  >\n    <option value=\"a\">A</option>\n    <option value=\"b\">B</option>\n  </select>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nconst ok = ref(false);\nconst pick = ref('a');\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Custom components (Vue 3): modelValue + update:modelValue</strong><br><br>For components, <code>v-model</code> becomes a normal prop + a normal emitted event. The parent “listens” and assigns."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<template>\n  <!-- Sugar -->\n  <UserNameInput v-model=\"name\" />\n\n  <!-- Desugared -->\n  <UserNameInput\n    :modelValue=\"name\"\n    @update:modelValue=\"name = $event\"\n  />\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nimport UserNameInput from './UserNameInput.vue';\n\nconst name = ref('Müslüm');\n</script>\n\n<!-- UserNameInput.vue -->\n<template>\n  <input\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n\n<script setup>\ndefineProps({\n  modelValue: { type: String, required: true }\n});\n\ndefineEmits(['update:modelValue']);\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>v-model arguments (Vue 3): v-model:foo</strong><br><br>Arguments just swap the prop/event names. This enables multiple v-model bindings on one component."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<template>\n  <RangePicker v-model:start=\"start\" v-model:end=\"end\" />\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nimport RangePicker from './RangePicker.vue';\n\nconst start = ref('2025-01-01');\nconst end = ref('2025-12-31');\n</script>\n\n<!-- RangePicker.vue -->\n<template>\n  <input :value=\"start\" @input=\"$emit('update:start', $event.target.value)\" />\n  <input :value=\"end\" @input=\"$emit('update:end', $event.target.value)\" />\n</template>\n\n<script setup>\ndefineProps({\n  start: String,\n  end: String\n});\n\ndefineEmits(['update:start', 'update:end']);\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Modifiers (.trim, .number, .lazy) change the update expression</strong><br><br>Modifiers don’t change the “prop + event” structure, they change how the incoming value is read/coerced and when updates happen."
        },
        {
          "type": "list",
          "columns": [
            "Modifier",
            "Effect",
            "Desugared idea"
          ],
          "rows": [
            [
              "<code>.trim</code>",
              "Trims whitespace",
              "<code>msg = $event.target.value.trim()</code>"
            ],
            [
              "<code>.number</code>",
              "Coerces to number",
              "<code>age = Number($event.target.value)</code>"
            ],
            [
              "<code>.lazy</code>",
              "Updates on change/blur-like timing instead of input",
              "Uses <code>@change</code> instead of <code>@input</code> for text inputs"
            ]
          ],
          "caption": "How v-model modifiers affect the expansion"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><code>v-model</code> is compile-time sugar for “bind current value + listen and assign updates”. For native inputs it picks the correct DOM property/event. For components in Vue 3 it maps to <code>modelValue</code> + <code>update:modelValue</code> (or <code>v-model:arg</code> → <code>arg</code> + <code>update:arg</code>)."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "v-model",
      "directives",
      "forms",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-v-show-vs-v-if-dom-lifecycle",
    "title": "How do v-show and v-if differ in DOM behavior and lifecycle impact?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "v-if adds/removes elements from the DOM (mount/unmount lifecycle), while v-show toggles display via CSS and keeps elements in the DOM. Use v-if for expensive components; v-show for frequent toggles.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core difference</strong><br><br><code>v-if</code> is <em>structural</em>: the branch exists only when the condition is true (DOM nodes are created/inserted and later removed).<br><code>v-show</code> is <em>presentational</em>: the element/component is always rendered once, and Vue toggles visibility by setting <code>style.display</code> (typically <code>display: none</code>)."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "v-if",
            "v-show"
          ],
          "rows": [
            [
              "DOM when false",
              "Not in DOM (nodes removed / never created if initially false)",
              "Still in DOM, but hidden via CSS (display:none)"
            ],
            [
              "Component instance",
              "Destroyed when false; recreated when true again",
              "Stays mounted; same instance reused"
            ],
            [
              "Lifecycle hooks",
              "Mount/unmount hooks run on each toggle (Vue 3: mounted/beforeUnmount/unmounted; Vue 2: mounted/beforeDestroy/destroyed)",
              "Mount hooks run once; toggling does not unmount"
            ],
            [
              "Local state (inputs, refs, component data)",
              "Resets on re-mount (new instance)",
              "Preserved across toggles"
            ],
            [
              "Work when hidden",
              "Zero (no render, no DOM patching, no watchers inside because instance is gone)",
              "Still reactive; component can still update/compute even while hidden"
            ],
            [
              "Performance profile",
              "Higher toggle cost, lower steady-state cost when off",
              "Higher initial cost, very cheap toggles"
            ]
          ],
          "caption": "v-if vs v-show: DOM + lifecycle impact"
        },
        {
          "type": "text",
          "text": "<strong>DOM behavior (plain elements)</strong><br><br>• <code>v-if</code>: creates/removes the element. If it starts false, it is lazy (nothing is rendered until it becomes true).<br>• <code>v-show</code>: element exists, but Vue sets inline <code>display: none</code> when false (removed from layout and accessibility tree)."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <!-- v-if: element is created/removed -->\n  <div v-if=\"open\">Heavy DOM branch</div>\n\n  <!-- v-show: element always exists; only display toggles -->\n  <div v-show=\"open\">Same DOM node, just hidden</div>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nconst open = ref(false);\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Lifecycle impact (components)</strong><br><br>With <code>v-if</code>, toggling false unmounts the child component (cleanup runs, subscriptions stop, DOM removed). Toggling true creates a <em>fresh</em> instance, so local state resets.<br><br>With <code>v-show</code>, the child stays mounted the whole time; toggling only changes visibility. The instance, refs, and local state remain intact."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<script setup>\nimport { ref } from 'vue';\nimport Child from './Child.vue';\n\nconst show = ref(true);\n</script>\n\n<template>\n  <button @click=\"show = !show\">Toggle</button>\n\n  <!-- Swap between these to observe behavior -->\n  <Child v-if=\"show\" />\n  <!-- <Child v-show=\"show\" /> -->\n</template>\n\n<!-- Child.vue -->\n<script setup>\nimport { onMounted, onBeforeUnmount, ref } from 'vue';\n\nconst local = ref(0);\nlet timerId;\n\nonMounted(() => {\n  console.log('Child mounted');\n  timerId = window.setInterval(() => console.log('tick'), 1000);\n});\n\nonBeforeUnmount(() => {\n  console.log('Child beforeUnmount (cleanup)');\n  window.clearInterval(timerId);\n});\n</script>\n\n<template>\n  <button @click=\"local++\">Local state: {{ local }}</button>\n</template>\n\n<!-- v-if: local resets after hide/show; cleanup runs.\n     v-show: local keeps its value; cleanup does NOT run on hide/show. -->"
        },
        {
          "type": "list",
          "columns": [
            "Use case",
            "Prefer",
            "Reason"
          ],
          "rows": [
            [
              "Frequently toggled UI (tabs, dropdowns, accordions)",
              "v-show",
              "Cheap toggles; preserves state; avoids repeated mount/unmount"
            ],
            [
              "Rarely shown + heavy branch (expensive DOM, large list, complex child)",
              "v-if",
              "Avoid initial render cost; zero work while off"
            ],
            [
              "Need state preserved but also want to avoid background work while hidden",
              "v-if + state lifted (store/composable) or caching (keep-alive where applicable)",
              "Unmount stops work; externalized state prevents losing user input/state"
            ]
          ],
          "caption": "How to choose"
        },
        {
          "type": "text",
          "text": "<strong>Common gotchas interviewers like</strong><br><br>• <code>v-show</code> does not support <code>v-else</code>/<code>v-else-if</code> chains; <code>v-if</code> does.<br>• <code>v-show</code> hides via <code>display:none</code> (not just “invisible”); it won’t take space and won’t be reachable by screen readers while hidden.<br>• Hidden-with-<code>v-show</code> components can still run watchers/computed updates; <code>v-if</code> removes them entirely."
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><code>v-if</code> changes the DOM tree and component lifecycle (mount/unmount, state resets). <code>v-show</code> keeps the same DOM and instance, only toggling <code>display</code>. Use <code>v-show</code> for frequent toggles; use <code>v-if</code> when the branch is rarely needed or expensive and you want zero cost while it’s off."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "v-if",
      "v-show",
      "rendering",
      "performance",
      "lifecycle"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "v-show vs v-if in Vue: DOM and lifecycle",
      "description": "Compare v-show and v-if by real behavior: DOM insertion vs CSS toggling, lifecycle impact, state persistence, and the right performance trade-off."
    }
  },
  {
    "id": "vue-computed-properties",
    "title": "What are computed properties in Vue?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Computed properties are cached, reactive getters that recompute only when their dependencies change. Use them for derived state instead of methods to avoid unnecessary recalculation. Computed values improve performance by caching, so test dependency changes and edge cases.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Computed properties in Vue are a powerful way to define reactive logic that depends on existing data. They act like dynamic properties that automatically re-evaluate when the data they depend on changes — and they cache the result until dependencies are updated again."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <div>\n    <p>First Name: {{ firstName }}</p>\n    <p>Last Name: {{ lastName }}</p>\n    <p>Full Name (computed): {{ fullName }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      firstName: 'Mina',\n      lastName: 'Yilmaz'\n    };\n  },\n  computed: {\n    fullName() {\n      return this.firstName + ' ' + this.lastName;\n    }\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "In this example, <code>fullName</code> is a computed property that automatically re-calculates when <code>firstName</code> or <code>lastName</code> changes. Vue caches its value until one of these dependencies updates, avoiding unnecessary re-renders."
        },
        {
          "type": "text",
          "text": "<strong>How Computed Properties Work</strong><br>When Vue initializes a computed property, it tracks the reactive dependencies used inside the property. When any of those dependencies change, Vue marks the computed property as 'dirty' and re-evaluates it upon the next access."
        },
        {
          "type": "text",
          "text": "<strong>Computed vs Methods</strong><br>While both can return derived values, computed properties are cached and only re-run when dependencies change. In contrast, methods are executed every time they are called, regardless of data changes."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Computed",
            "Method"
          ],
          "rows": [
            [
              "Caching",
              "Yes (re-evaluates only when dependencies change)",
              "No (runs every time it’s called)"
            ],
            [
              "Use Case",
              "For derived or reactive data",
              "For event-driven or non-reactive actions"
            ],
            [
              "Performance",
              "Optimized for efficiency",
              "Less efficient for repeated calls"
            ]
          ],
          "caption": "Comparison Between Computed Properties and Methods"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "computed: {\n  reversedMessage() {\n    return this.message.split('').reverse().join('');\n  }\n}"
        },
        {
          "type": "text",
          "text": "Here, the computed property <code>reversedMessage</code> will only re-run when <code>message</code> changes, not on every render cycle."
        },
        {
          "type": "text",
          "text": "<strong>Computed Getters and Setters</strong><br>Computed properties can also include a setter to handle updates in both directions."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "computed: {\n  fullName: {\n    get() {\n      return this.firstName + ' ' + this.lastName;\n    },\n    set(value) {\n      const parts = value.split(' ');\n      this.firstName = parts[0];\n      this.lastName = parts[1];\n    }\n  }\n}"
        },
        {
          "type": "text",
          "text": "Now, assigning a value like <code>this.fullName = 'Jane Doe'</code> automatically updates <code>firstName</code> and <code>lastName</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of computed properties as smart variables that know when and how to update — they deliver dynamic results while minimizing unnecessary recalculations."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Computed properties calculate values based on reactive data.</li><li>They are cached until dependencies change.</li><li>Useful for derived state and transformations.</li><li>Support both getters and setters for two-way interaction.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>You compute a cart total from line items and want it to update only when inputs change.<br><br><strong>Common pitfalls</strong><br><ul><li>Using methods instead of computed, causing unnecessary recalculation.</li><li>Mutating state inside computed getters.</li><li>Forgetting computed must return a value.</li></ul><strong>Trade-off or test tip</strong><br>Computed values are cached but should remain pure. Test updates when dependencies change.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "computed",
      "reactivity",
      "derived-state",
      "performance"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-methods-in-templates",
    "title": "What happens when you call methods inside Vue templates?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Explain how template method calls are executed during render, why they run again on every component re-render, the performance/correctness pitfalls (expensive work, unstable references, side effects), and when to prefer computed properties or precomputed data.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Anything you reference in a Vue template is evaluated during the component’s <em>render</em>. A method call in the template is just a function call inside the compiled render function. That means:<br>• The method runs on the initial render.<br>• The method runs again on <em>every</em> subsequent re-render of that component.<br><br>Vue will track reactive reads that happen <em>inside</em> the method (because it runs during render), but the <em>result is not cached</em> like a computed property."
        },
        {
          "type": "list",
          "columns": [
            "Approach",
            "How often it runs",
            "Caching",
            "Best for"
          ],
          "rows": [
            [
              "Method call in template: {{ format() }}",
              "Every render of the component",
              "No",
              "Event-ish logic, cheap formatting, simple helpers"
            ],
            [
              "Computed: {{ formatted }}",
              "Only when its reactive deps change (then reused)",
              "Yes (until invalidated)",
              "Derived state, expensive transforms, stable references"
            ],
            [
              "Inline expression: {{ a + b }}",
              "Every render",
              "No",
              "Very small expressions only"
            ]
          ],
          "caption": "Method calls vs computed in templates"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { ref, computed } from 'vue';\n\nconst count = ref(0);\nconst theme = ref('light');\n\nfunction expensiveFormat(n) {\n  // pretend heavy work\n  let s = '';\n  for (let i = 0; i < 50000; i++) s = String(n);\n  return `Count: ${s}`;\n}\n\nconst formatted = computed(() => expensiveFormat(count.value));\n</script>\n\n<template>\n  <!-- Method: runs whenever this component re-renders (even if only theme changes) -->\n  <p>{{ expensiveFormat(count) }}</p>\n\n  <!-- Computed: recomputes only when count changes -->\n  <p>{{ formatted }}</p>\n\n  <button @click=\"count++\">inc</button>\n  <button @click=\"theme = theme === 'light' ? 'dark' : 'light'\">toggle theme</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Why this can hurt performance</strong><br><br>A component can re-render for many reasons (any reactive dependency used in render changes). If you call a method in the template, it’s executed again even when the method’s “inputs” didn’t change. In lists, it’s worse: a method used inside <code>v-for</code> can run <em>per item</em> per render."
        },
        {
          "type": "list",
          "columns": [
            "Pitfall",
            "What you’ll see",
            "Fix"
          ],
          "rows": [
            [
              "Expensive method in template",
              "UI jank / slow typing / slow toggles",
              "Move work into a computed, or precompute once (e.g., computed map / cached lookup)"
            ],
            [
              "Method allocates new objects/arrays each render",
              "Child components update unnecessarily (new prop reference each render)",
              "Return stable references via computed, or compute once and reuse"
            ],
            [
              "Method has side effects (mutates reactive state, logs, API calls)",
              "Infinite update loops, warnings, repeated API calls",
              "Keep template-called methods pure; do side effects in events/watchers"
            ],
            [
              "Method depends on params (e.g., format(item))",
              "You can’t just “convert to computed” 1:1",
              "Precompute a derived structure (Map/object) via computed; or memoize by key"
            ]
          ],
          "caption": "Common problems and fixes"
        },
        {
          "type": "text",
          "text": "<strong>When it’s OK to use a method in the template</strong><br><br>• It’s cheap (simple string/number formatting).<br>• It’s pure (no state writes, no I/O).<br>• It doesn’t allocate large new structures on every call.<br><br><strong>Rule of thumb</strong>: if you’d be annoyed seeing it run on every render in a profiler, make it a computed (or precomputed data) instead."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "templates",
      "methods",
      "performance",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-native-vs-component-events",
    "title": "What is the difference between native and component events in Vue?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain the difference between native DOM events (click/input/submit...) and component events emitted with $emit/emit in Vue. Cover what happens when you write @click on a real element vs on a component tag, how propagation differs (DOM bubbling vs parent-only emits), and the Vue 2 .native vs Vue 3 fallthrough/emits behavior. Explicit emits improve clarity; test propagation and accessibility of custom components.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><strong>Native events</strong> are browser DOM events fired by real elements (<code>&lt;button&gt;</code>, <code>&lt;input&gt;</code>, ...).<br><strong>Component events</strong> are custom events emitted by a Vue component (<code>emit('eventName', payload)</code>) and received by the parent."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Native (DOM) event",
            "Component event (emit)"
          ],
          "rows": [
            [
              "Where it originates",
              "Browser fires it on a real DOM node",
              "Component code emits it explicitly"
            ],
            [
              "How you listen",
              "On an element: <code>&lt;button @click=...&gt;</code>",
              "On a component tag: <code>&lt;MyComp @save=...&gt;</code>"
            ],
            [
              "Propagation",
              "Bubbles/captures through the DOM tree",
              "Goes to the direct parent only (no DOM bubbling)"
            ],
            [
              "Payload",
              "Usually a real <code>Event</code> object",
              "Whatever you emit (could be an Event, but often custom data)"
            ],
            [
              "Default behavior",
              "May have defaults (submit navigates, link navigates, etc.)",
              "No browser default; it’s app-level messaging"
            ]
          ],
          "caption": "Native DOM events vs component-emitted events"
        },
        {
          "type": "text",
          "text": "<strong>Example: native DOM event</strong>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<script setup>\nfunction onNativeClick(e) {\n  console.log('native click', e.type);\n}\n</script>\n\n<template>\n  <button type=\"button\" @click=\"onNativeClick\">Native click</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Example: component event (custom)</strong><br><br>The parent listens on the component tag, but it only fires if the child emits it."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- MyButton.vue -->\n<script setup>\nconst emit = defineEmits(['press']);\nfunction handleClick(e) {\n  emit('press', { originalEvent: e, ts: Date.now() });\n}\n</script>\n\n<template>\n  <button type=\"button\" @click=\"handleClick\">\n    <slot>Press</slot>\n  </button>\n</template>\n\n<!-- Parent.vue -->\n<script setup>\nfunction onPress(payload) {\n  console.log('component event press', payload.ts);\n}\n</script>\n\n<template>\n  <MyButton @press=\"onPress\">Component press</MyButton>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>The confusing part: @click on a component</strong><br><br>When you write <code>&lt;MyButton @click=... /&gt;</code>, it does <em>not</em> automatically mean “listen to the internal DOM click”. It depends on Vue version and how the component is authored."
        },
        {
          "type": "list",
          "columns": [
            "Case",
            "What @click means",
            "How to make it work intentionally"
          ],
          "rows": [
            [
              "Vue 2: <code>@click</code> on component",
              "Listens for a component-emitted <code>click</code> event (not DOM)",
              "Emit it from the child: <code>this.$emit('click', $event)</code>"
            ],
            [
              "Vue 2: <code>@click.native</code>",
              "Attach a native listener to the component’s root DOM element",
              "Use <code>.native</code> (Vue 2 only)"
            ],
            [
              "Vue 3: listener fallthrough (single-root component)",
              "If the event name is <em>not</em> declared in <code>emits</code>, Vue treats it as an attribute listener and can pass it to the root element",
              "Rely on fallthrough only when you really want “wrapper behaves like a DOM element”; otherwise use explicit custom events"
            ],
            [
              "Vue 3: declared in <code>emits</code>",
              "<code>@click</code> becomes a component event listener (must be emitted)",
              "Declare + emit: <code>defineEmits(['click'])</code> and <code>emit('click', $event)</code>"
            ]
          ],
          "caption": "Vue 2 vs Vue 3 behavior on component listeners"
        },
        {
          "type": "list",
          "columns": [
            "Gotcha",
            "Why it happens",
            "Rule of thumb"
          ],
          "rows": [
            [
              "Assuming DOM bubbling for component events",
              "Custom emits don’t bubble through DOM; only parent receives it",
              "If grandparents need it, re-emit upward or use a store"
            ],
            [
              "Using DOM event modifiers on custom events (.stop/.prevent)",
              "Those call <code>event.stopPropagation()</code>/<code>preventDefault()</code> — only meaningful if your payload is a real Event",
              "Use modifiers mainly for DOM events; for custom events, design payloads and logic explicitly"
            ],
            [
              "Naming a component event the same as a native event ('click')",
              "Can be valid but easily confuses “is this DOM or emitted?” (plus fallthrough rules in Vue 3)",
              "Prefer semantic names: <code>press</code>, <code>submit</code>, <code>close</code>, <code>update:modelValue</code>"
            ],
            [
              "Not declaring <code>emits</code> in Vue 3",
              "Vue can’t validate emitted events and listeners may fall through to DOM unintentionally",
              "Declare <code>emits</code> for your component API; it prevents accidental fallthrough for those event names"
            ]
          ],
          "caption": "Common interview-level pitfalls"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><strong>Native event</strong> = browser event on a real element (bubbles in DOM).<br><strong>Component event</strong> = explicit <code>emit</code> from child to parent (no DOM bubbling).<br>On a component tag, <code>@event</code> primarily means “listen for an emitted event”, except Vue 3 can also treat undeclared listeners as fallthrough attributes to the root element."
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A custom <code>BaseButton</code> should emit <code>click</code> to parent components while still handling native DOM events internally.<br><br><strong>Common pitfalls</strong><br><ul><li>Using native events on component tags without emitting.</li><li>Relying on Vue 2 <code>.native</code> behavior in Vue 3.</li><li>Not declaring <code>emits</code>, which hides event contracts.</li></ul><strong>Trade-off or test tip</strong><br>Explicit emits add clarity but more boilerplate. Test both DOM and emitted events with unit tests.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "events",
      "components",
      "emits",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-architecture-decisions-scalability",
    "title": "What architectural decisions are made when creating a Vue project, and how do they affect scalability?",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 2,
    "description": "When starting a Vue app, teams choose the build/runtime platform, state and routing strategy, code organization, and quality/performance tooling. These decisions directly affect maintainability, performance, testability, and how well multiple teams can work in parallel.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>“Scalability” in Vue isn’t just about performance — it’s mainly about keeping complexity manageable as features and teams grow. Early architectural choices determine whether your codebase stays modular, testable, and predictable."
        },
        {
          "type": "list",
          "columns": [
            "Decision",
            "Common Options",
            "Scalability Impact"
          ],
          "rows": [
            [
              "App platform",
              "SPA (Vite) vs SSR/SSG (Nuxt)",
              "SSR/SSG improves SEO/perf for content-heavy apps but adds complexity (server runtime, hydration, caching). SPA is simpler operationally."
            ],
            [
              "Language & typing",
              "JS vs TypeScript",
              "TS improves refactors, API contracts, and large-team collaboration; initial setup and discipline required."
            ],
            [
              "Component API style",
              "Composition API vs Options API",
              "Composition API scales better for logic reuse (composables) and complex components; easier to enforce patterns."
            ],
            [
              "Routing strategy",
              "Vue Router, nested routes, lazy-loaded route chunks",
              "Route-level code splitting + clear route boundaries prevents “one giant bundle” and encourages feature isolation."
            ],
            [
              "State management",
              "Local state, provide/inject, Pinia, server-state libs (e.g., TanStack Query)",
              "Over-globalizing state creates coupling. Use Pinia for shared cross-feature state; keep UI state local; use server-state caching for API data."
            ],
            [
              "Project structure",
              "By type (components/views/stores) vs by feature/domain",
              "Feature-based structure scales better: isolates dependencies, enables ownership per domain, reduces cross-import spaghetti."
            ],
            [
              "UI system",
              "Ad-hoc components vs design system (base components + tokens)",
              "A design system reduces duplication and UI drift; speeds up development and improves consistency."
            ],
            [
              "Data access layer",
              "Direct fetch in components vs services/repositories",
              "Central API layer improves testability, retries/caching, error handling, and consistent DTO↔domain mapping."
            ],
            [
              "Validation & forms",
              "Native handling vs schema-based validation (e.g., Zod/Yup) + form libs",
              "Schema-based validation scales better with complex forms and shared contracts."
            ],
            [
              "Testing strategy",
              "Unit (Vitest), component tests, E2E (Cypress/Playwright)",
              "Clear test pyramid prevents regressions as team grows; makes refactors safe."
            ],
            [
              "Code quality gates",
              "ESLint, Prettier, typecheck CI, commit hooks",
              "Automated consistency reduces review load and prevents style/typing drift across contributors."
            ],
            [
              "Performance strategy",
              "Code splitting, async components, virtual lists, memoization, image strategy",
              "Prevents performance debt. Without standards, large apps degrade from bundle bloat and unnecessary re-renders."
            ],
            [
              "Configuration & environments",
              "Env files + runtime config",
              "Clean env separation prevents “works on my machine” issues and supports multi-environment deployments safely."
            ]
          ],
          "caption": "Key Vue project architecture decisions and their scalability impact"
        },
        {
          "type": "text",
          "text": "<strong>Recommended baseline for a scalable Vue 3 app</strong><br><br>• Vite + Vue 3 + TypeScript<br>• Vue Router with lazy-loaded routes<br>• Pinia for true shared state only; keep UI state local<br>• Composition API + composables for shared logic<br>• Feature-based folder structure (domain modules)<br>• Central API layer (services) + consistent error handling<br>• Vitest for unit/component tests + Playwright/Cypress for E2E<br>• ESLint/Prettier + typecheck in CI"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: route-level code splitting (Vue Router)\nconst routes = [\n  {\n    path: '/admin',\n    component: () => import('./features/admin/AdminLayout.vue'),\n    children: [\n      {\n        path: 'users',\n        component: () => import('./features/admin/users/AdminUsersPage.vue')\n      }\n    ]\n  }\n];"
        },
        {
          "type": "code",
          "language": "text",
          "code": "# Example: feature-based structure\nsrc/\n  app/                 # app bootstrap, router, global plugins\n  features/\n    admin/\n      users/\n        components/\n        pages/\n        store/\n        api/\n        types/\n    booking/\n      ...\n  shared/\n    ui/                # base components\n    composables/\n    utils/\n    api/\n"
        },
        {
          "type": "text",
          "text": "<strong>Common scalability failures</strong><br><br>1) “Everything in the global store” → tight coupling + hard debugging.<br>2) No domain boundaries → circular imports + unclear ownership.<br>3) No API layer → duplicated fetch logic + inconsistent error handling.<br>4) No code splitting → slow initial load as app grows.<br>5) No enforced conventions → PR reviews turn into style/pattern debates."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Vue scales well when you enforce boundaries (features/domains), keep state usage intentional (local vs shared), reuse logic via composables, and standardize routing, API access, testing, and CI quality gates early. Most scalability problems are architecture + conventions, not Vue itself."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "architecture",
      "scalability",
      "state-management",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-computed-vs-watchers",
    "title": "Computed vs watch in Vue: derived state (cached) vs side effects (imperative)",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Computed properties and watchers both react to reactive changes, but they solve different problems: &lt;strong&gt;computed&lt;/strong&gt; is for &lt;strong&gt;derived state&lt;/strong&gt; (cached, declarative), while &lt;strong&gt;watch&lt;/strong&gt; is for &lt;strong&gt;side effects&lt;/strong&gt; (async/imperative work triggered by changes).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><strong>Computed</strong> = a derived value (like a formula). Vue tracks its dependencies and <strong>caches</strong> the result until one of them changes.<br><strong>Watch</strong> = run code when something changes. It’s meant for <strong>side effects</strong> (fetching, logging, syncing, timers), not for producing values for the template."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "computed",
            "watch / watchEffect"
          ],
          "rows": [
            [
              "Primary purpose",
              "Derived state (calculate a value from other reactive state)",
              "Side effects (do something when state changes)"
            ],
            [
              "Caching",
              "Yes (cached until deps change)",
              "No (runs when triggered)"
            ],
            [
              "Evaluation model",
              "Lazy: recomputes when accessed after being invalidated",
              "Eager: runs callback when source changes (timing configurable via flush)"
            ],
            [
              "Return value",
              "Yes (you read it like a value)",
              "No (callback-driven; produces effects, not a value)"
            ],
            [
              "Async work",
              "Avoid (keep it pure)",
              "Yes (common: API calls + cancellation)"
            ],
            [
              "Common mistake",
              "Putting side effects in computed",
              "Using watch to keep derived state in sync (duplicate state)"
            ]
          ],
          "caption": "Computed is for values; watch is for effects."
        },
        {
          "type": "text",
          "text": "<strong>Anti-pattern (common in interviews): using watch for derived state</strong><br><br>This duplicates state and can drift out of sync. Prefer <code>computed</code> unless you truly need an effect."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- BAD: derived state via watch (duplicate state) -->\n<script setup>\nimport { ref, watch, computed } from 'vue';\n\nconst first = ref('Mina');\nconst last = ref('Yilmaz');\n\nconst fullNameViaWatch = ref('');\nwatch([first, last], ([f, l]) => {\n  fullNameViaWatch.value = `${f} ${l}`;\n}, { immediate: true });\n\n// GOOD: derived state via computed (cached, always in sync)\nconst fullName = computed(() => `${first.value} ${last.value}`);\n</script>\n\n<template>\n  <p>watch-derived: {{ fullNameViaWatch }}</p>\n  <p>computed: {{ fullName }}</p>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Watchers (the right use): side effects + async + cancellation</strong><br><br>When a value changes and you need to <em>do</em> something (fetch, analytics, sync URL, write to storage), use <code>watch</code>. Use cleanup to avoid race conditions (old request finishing after a new one)."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { ref, watch } from 'vue';\n\nconst query = ref('');\nconst results = ref([]);\nconst error = ref(null);\n\nwatch(query, async (q, _prev, onCleanup) => {\n  if (!q.trim()) {\n    results.value = [];\n    error.value = null;\n    return;\n  }\n\n  const ctrl = new AbortController();\n  onCleanup(() => ctrl.abort());\n\n  try {\n    error.value = null;\n    const res = await fetch(`/api/search?q=${encodeURIComponent(q)}`, { signal: ctrl.signal });\n    results.value = await res.json();\n  } catch (e) {\n    // Ignore abort; handle real errors\n    if (e?.name !== 'AbortError') error.value = e;\n  }\n}, { flush: 'post' });\n</script>\n\n<template>\n  <input v-model=\"query\" placeholder=\"Search...\" />\n  <pre v-if=\"error\">{{ error }}</pre>\n  <ul>\n    <li v-for=\"r in results\" :key=\"r.id\">{{ r.title }}</li>\n  </ul>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Key options you should know (interview-level)</strong><ul>\n<li><code>immediate: true</code> runs the watcher once on setup (useful for initial fetch).</li>\n<li><code>deep: true</code> watches nested mutations (use sparingly; can be expensive). Prefer watching a specific getter like <code>() =&gt; obj.a.b</code>.</li>\n<li><code>flush</code>: <code>'pre'</code> (default), <code>'post'</code> (after DOM updates), <code>'sync'</code> (runs immediately; use carefully).</li>\n<li><code>watchEffect()</code>: tracks dependencies automatically (great for effects that depend on many reactive reads), but use it only for effects (same rule: not for derived display values).</li>\n</ul>"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>If the result is a <em>value you want to render</em> (filtering, formatting, totals) → <strong>computed</strong>.<br>If you need to <em>do something</em> when it changes (fetch, sync, log, imperative updates) → <strong>watch</strong>."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "computed",
      "watchers",
      "reactivity",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-lifecycle-hooks",
    "title": "What are lifecycle hooks in Vue and when are they used?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Lifecycle hooks in Vue are special methods that run at specific stages of a component’s lifecycle — from creation to destruction. They allow developers to perform logic like fetching data, manipulating the DOM, or cleaning up resources. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Every Vue component goes through a series of lifecycle stages — creation, mounting, updating, and unmounting. Vue provides lifecycle hooks, which are special functions you can define to run code automatically at these stages."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "export default {\n  data() {\n    return {\n      message: 'Hello Vue!'\n    };\n  },\n  created() {\n    console.log('Component is created!');\n  },\n  mounted() {\n    console.log('Component is mounted to the DOM!');\n  },\n  updated() {\n    console.log('Component has re-rendered!');\n  },\n  unmounted() {\n    console.log('Component has been removed from the DOM!');\n  }\n};"
        },
        {
          "type": "text",
          "text": "Each hook corresponds to a specific stage of the component lifecycle. For example, <code>created()</code> runs when the component is initialized, while <code>mounted()</code> runs when the component is added to the DOM."
        },
        {
          "type": "text",
          "text": "<strong>Commonly Used Lifecycle Hooks</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Hook",
            "When It Runs",
            "Typical Use Case"
          ],
          "rows": [
            [
              "beforeCreate",
              "Before data observation and events are set up",
              "Rarely used; low-level hook for advanced debugging"
            ],
            [
              "created",
              "After instance is created and reactive data is available",
              "Initialize data or fetch initial data"
            ],
            [
              "beforeMount",
              "Before component is mounted to the DOM",
              "Prepare final changes before mounting"
            ],
            [
              "mounted",
              "After the component is mounted to the DOM",
              "Access the DOM or third-party libraries"
            ],
            [
              "beforeUpdate",
              "Before reactive data causes re-rendering",
              "Perform checks before DOM updates"
            ],
            [
              "updated",
              "After DOM updates due to reactive data changes",
              "React to DOM changes or perform animations"
            ],
            [
              "beforeUnmount",
              "Before the component is destroyed",
              "Cleanup operations or cancel timers"
            ],
            [
              "unmounted",
              "After the component is destroyed and removed from DOM",
              "Release resources, event listeners, or observers"
            ]
          ],
          "caption": "Vue Lifecycle Hook Sequence"
        },
        {
          "type": "text",
          "text": "<strong>Lifecycle Hook Flow</strong><br>1️⃣ <code>beforeCreate</code> → 2️⃣ <code>created</code> → 3️⃣ <code>beforeMount</code> → 4️⃣ <code>mounted</code><br>Then for updates: 5️⃣ <code>beforeUpdate</code> → 6️⃣ <code>updated</code><br>And finally for teardown: 7️⃣ <code>beforeUnmount</code> → 8️⃣ <code>unmounted</code>."
        },
        {
          "type": "text",
          "text": "<strong>Use Case Example</strong><br>Fetching data when a component mounts is one of the most common lifecycle hook patterns:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "export default {\n  data() {\n    return { users: [] };\n  },\n  async mounted() {\n    const res = await fetch('https://api.example.com/users');\n    this.users = await res.json();\n  }\n};"
        },
        {
          "type": "text",
          "text": "In this example, the <code>mounted()</code> hook ensures the component is attached to the DOM before fetching and displaying data."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of lifecycle hooks as checkpoints — moments in a component’s journey where you can pause, inspect, or intervene to perform logic, cleanup, or side effects."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Lifecycle hooks run at specific stages of a component’s creation, update, and destruction.</li><li>Commonly used hooks include <code>created()</code>, <code>mounted()</code>, and <code>updated()</code>.</li><li>They’re essential for handling initialization, DOM access, and cleanup logic.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "lifecycle",
      "hooks",
      "components",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-directives",
    "title": "What are Vue directives and how do they work?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Vue directives are special attributes (v-if, v-for, v-model, v-bind, v-on) that apply reactive behavior to DOM elements. They control rendering, bind data, and handle events. Framework focus: Vue SFC patterns, ref/reactive state, computed/watch, and v-model bindings.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In Vue, directives are custom HTML attributes prefixed with <code>v-</code> that provide reactive behavior to DOM elements. They allow you to bind data, listen for events, show or hide elements, and apply dynamic logic directly in templates without writing manual JavaScript for DOM manipulation."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <div>\n    <p v-if=\"isVisible\">This paragraph is conditionally rendered.</p>\n    <p v-bind:title=\"message\">Hover to see the message.</p>\n    <button v-on:click=\"toggleVisibility\">Toggle Visibility</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      isVisible: true,\n      message: 'Hello from Vue!'\n    };\n  },\n  methods: {\n    toggleVisibility() {\n      this.isVisible = !this.isVisible;\n    }\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "In this example, three directives are used:<br>• <code>v-if</code> conditionally renders an element.<br>• <code>v-bind</code> dynamically binds a JavaScript value to an attribute.<br>• <code>v-on</code> listens for user events like clicks."
        },
        {
          "type": "text",
          "text": "<strong>How Directives Work</strong><br>When Vue compiles a template, it parses all directives and establishes reactivity links between the DOM and your component data. Whenever the underlying data changes, Vue automatically updates the DOM to reflect the new state — no manual DOM manipulation required."
        },
        {
          "type": "text",
          "text": "<strong>Common Built-in Directives</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Directive",
            "Description"
          ],
          "rows": [
            [
              "v-if / v-else / v-else-if",
              "Conditionally render elements based on a boolean expression."
            ],
            [
              "v-show",
              "Toggles visibility using the CSS display property."
            ],
            [
              "v-for",
              "Loops through arrays or objects to render lists."
            ],
            [
              "v-bind",
              "Binds dynamic attributes or props to elements and components."
            ],
            [
              "v-on",
              "Attaches event listeners to DOM elements."
            ],
            [
              "v-model",
              "Creates two-way data binding with form inputs."
            ],
            [
              "v-html",
              "Renders raw HTML content inside an element."
            ],
            [
              "v-text",
              "Updates an element’s text content directly."
            ]
          ],
          "caption": "Common Vue Directives and Their Usage"
        },
        {
          "type": "text",
          "text": "<strong>Custom Directives</strong><br>Vue also allows developers to define custom directives for specialized DOM behavior. Custom directives are registered using <code>app.directive()</code> in Vue 3."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "app.directive('focus', {\n  mounted(el) {\n    el.focus();\n  }\n});"
        },
        {
          "type": "text",
          "text": "Now, using <code>v-focus</code> in your template automatically focuses the element when mounted."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of directives as instructions for the DOM — they tell Vue what to do with elements when your data changes, keeping everything reactive and declarative."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Directives in Vue start with the prefix <code>v-</code> and enhance HTML behavior.</li><li>They dynamically bind data, handle events, and control the DOM.</li><li>Vue provides built-in directives like <code>v-if</code>, <code>v-for</code>, <code>v-bind</code>, and <code>v-on</code>.</li><li>You can create custom directives for advanced, reusable behavior.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "directives",
      "v-if",
      "v-for",
      "v-model",
      "templates"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 0,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-v-bind-v-on-fundamental-template-syntax",
    "title": "Why are v-bind and v-on fundamental to Vue’s template syntax?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Explain why Vue templates are basically HTML + data bindings + event bindings. Cover what v-bind and v-on compile to (VNode props + event listeners), how they connect reactivity to DOM updates, and why features like v-model build on them.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Vue templates are mostly static HTML. The two things that make templates <em>dynamic</em> are:<br>• <code>v-bind</code> (shorthand <code>:</code>) — state ➜ DOM (attributes/props/class/style)<br>• <code>v-on</code> (shorthand <code>@</code>) — DOM/component events ➜ code (which usually mutates state)<br><br>Those two directives are “fundamental” because they are the main bridges between your reactive state and the rendered output. Most higher-level conveniences (<code>v-model</code>, component prop/event APIs, many patterns) compile down to some combination of <code>v-bind</code> + <code>v-on</code>."
        },
        {
          "type": "list",
          "columns": [
            "Directive",
            "What you write in templates",
            "What it means (conceptually)"
          ],
          "rows": [
            [
              "v-bind (:)",
              "<code>:src=\"url\"</code>, <code>:class=\"cls\"</code>, <code>:disabled=\"loading\"</code>",
              "Evaluate expression during render; when reactive deps change, Vue patches only those bound props/attrs"
            ],
            [
              "v-on (@)",
              "<code>@click=\"inc\"</code>, <code>@input=\"onInput\"</code>, <code>@submit.prevent=\"save\"</code>",
              "Attach a listener; when event fires, run handler (often mutating reactive state)"
            ],
            [
              "Together",
              "UI updates flow: user event ➜ state change ➜ DOM patch",
              "This is the main “reactive loop” in Vue apps"
            ]
          ],
          "caption": "Why templates revolve around v-bind and v-on"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { computed, ref } from 'vue';\n\nconst count = ref(0);\nconst loading = ref(false);\n\nconst buttonClass = computed(() => ({\n  btn: true,\n  'is-loading': loading.value,\n  'is-positive': count.value > 0\n}));\n\nfunction inc() {\n  count.value++;\n}\n\nfunction toggleLoading() {\n  loading.value = !loading.value;\n}\n</script>\n\n<template>\n  <!-- v-bind: state -> DOM -->\n  <button\n    :class=\"buttonClass\"\n    :disabled=\"loading\"\n    :aria-busy=\"loading\"\n    @click=\"inc\"\n  >\n    Count: {{ count }}\n  </button>\n\n  <!-- v-on: event -> code -> state change -->\n  <button @click=\"toggleLoading\">\n    Toggle loading\n  </button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>What happens under the hood</strong><br><br>Vue compiles templates into a render function that produces VNodes. <code>v-bind</code> becomes VNode props (including special handling for <code>class</code>/<code>style</code> and boolean props). <code>v-on</code> becomes event listener props like <code>onClick</code>.<br><br>During render, reactive reads are tracked. When reactive state changes, Vue schedules a re-render and patches only changed VNode props/listeners onto the real DOM."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Pseudo-ish compiled shape (not exact Vue output)\nexport function render(_ctx) {\n  return h('button', {\n    class: _ctx.buttonClass,\n    disabled: _ctx.loading,\n    'aria-busy': _ctx.loading,\n    onClick: _ctx.inc\n  }, `Count: ${_ctx.count}`);\n}\n\n// Later, when count/loading changes:\n// Vue re-runs render -> diffs VNodes -> patches only changed props on the same DOM node."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "How it uses v-bind/v-on",
            "Why it matters"
          ],
          "rows": [
            [
              "Props on components",
              "<code>&lt;Child :value=\"x\" /&gt;</code>",
              "Same binding mechanism, but targets component props instead of DOM attrs"
            ],
            [
              "Component events",
              "<code>&lt;Child @save=\"onSave\" /&gt;</code>",
              "Same listener mechanism, but listens to emitted events (child ➜ parent)"
            ],
            [
              "v-model",
              "Compiles to a prop bind + an update listener",
              "Explains why v-model is “syntax sugar”"
            ],
            [
              "Object spread binding",
              "<code>v-bind=\"attrs\"</code>",
              "Pass-through attributes/props in a single place (wrapper components)"
            ],
            [
              "Event modifiers",
              "<code>@submit.prevent</code>, <code>@click.stop</code>, <code>@keyup.enter</code>",
              "Declarative control of default behavior and propagation"
            ],
            [
              "Dynamic arguments",
              "<code>:[name]=\"val\"</code>, <code>@[event]=\"handler\"</code>",
              "Attribute/event names can be data-driven (use carefully; readability)"
            ]
          ],
          "caption": "Most template features are variations of binding props and listening to events"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- v-model is just v-bind + v-on (Vue 3, custom component) -->\n<!-- Sugar -->\n<UserInput v-model=\"name\" />\n\n<!-- Desugared -->\n<UserInput\n  :modelValue=\"name\"\n  @update:modelValue=\"name = $event\"\n/>\n\n<!-- For native inputs (conceptually) -->\n<input :value=\"name\" @input=\"name = $event.target.value\" />"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><code>v-bind</code> and <code>v-on</code> are the core primitives because templates become dynamic only by (1) binding reactive values into VNode props and (2) wiring events back into your code. Everything else is either additional syntax around those primitives (like <code>v-model</code>) or structural directives that still rely on them to express dynamic attributes and interactivity."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "directives",
      "v-bind",
      "v-on",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-child-mutates-prop-directly",
    "title": "What breaks if a child mutates a prop directly?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "In Vue, props are meant to be read-only inputs from parent to child. Explain what breaks (correctness + debugging) when a child component directly mutates a prop, including the nested object/array case, and show the correct patterns (emit updates / v-model).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Props are the parent’s state flowing <em>down</em>. If the child mutates a prop, you lose the “single source of truth” and the update path becomes ambiguous (who changed it, when, and why). Vue will warn in dev, but the bigger issue is correctness + maintainability."
        },
        {
          "type": "list",
          "columns": [
            "What the child does",
            "What breaks",
            "Why it’s bad"
          ],
          "rows": [
            [
              "Assigns a prop directly (e.g. props.count++)",
              "Vue warns; update is rejected / overwritten on next parent render",
              "Child is trying to mutate parent-owned state without going through the parent"
            ],
            [
              "Mutates a nested field on an object/array prop (e.g. props.user.name = 'x')",
              "You silently mutate the parent’s object (shared reference) and create “action at a distance” bugs",
              "Objects/arrays are passed by reference; child mutation becomes parent mutation"
            ],
            [
              "Uses a prop as local state (editing it directly)",
              "UI can desync (parent re-renders and resets the child), race conditions with async updates",
              "Parent can re-send the prop anytime; child-local edits aren’t a stable source of truth"
            ],
            [
              "Triggers watchers/computed based on mutated prop",
              "Hard-to-trace update loops / unexpected re-renders",
              "You bypass the intended data flow and can create circular updates"
            ]
          ],
          "caption": "What actually breaks when a child mutates a prop"
        },
        {
          "type": "text",
          "text": "<strong>Bad example: child mutates a primitive prop</strong><br><br>In Vue 3, <code>defineProps()</code> is shallow readonly. Mutating it causes a dev warning and is considered an anti-pattern."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ChildCounter.vue (BAD) -->\n<script setup>\nconst props = defineProps({\n  count: { type: Number, required: true }\n});\n\nfunction inc() {\n  // ❌ anti-pattern: mutating a prop\n  // Vue warns in dev; parent can overwrite on next render.\n  props.count++;\n}\n</script>\n\n<template>\n  <button @click=\"inc\">Count: {{ count }}</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Correct pattern: emit an update (parent stays the source of truth)</strong><br><br>The child requests a change; the parent applies it."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ChildCounter.vue (GOOD) -->\n<script setup>\nconst props = defineProps({\n  count: { type: Number, required: true }\n});\n\nconst emit = defineEmits(['update:count']);\n\nfunction inc() {\n  emit('update:count', props.count + 1);\n}\n</script>\n\n<template>\n  <button @click=\"inc\">Count: {{ count }}</button>\n</template>\n\n<!-- Parent.vue -->\n<script setup>\nimport { ref } from 'vue';\nimport ChildCounter from './ChildCounter.vue';\n\nconst count = ref(0);\n</script>\n\n<template>\n  <!-- v-model:count = :count + @update:count -->\n  <ChildCounter v-model:count=\"count\" />\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>The tricky case: object/array props</strong><br><br>Even if Vue warns, mutating <code>props.user.name</code> is still mutating the same object the parent passed. This couples child behavior to parent state and makes bugs look “random” because the mutation didn’t go through an explicit parent update."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ChildUserEditor.vue (BAD) -->\n<script setup>\nconst props = defineProps({\n  user: { type: Object, required: true }\n});\n\nfunction rename() {\n  // ❌ Mutates parent-owned object via shared reference\n  props.user.name = 'New Name';\n}\n</script>\n\n<template>\n  <button @click=\"rename\">Rename</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>When you need “editable local state”</strong><br><br>Make a local copy for editing, and emit the final value (or emit on each change)."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ChildNameInput.vue (local draft -> emit) -->\n<script setup>\nimport { ref, watch } from 'vue';\n\nconst props = defineProps({\n  name: { type: String, required: true }\n});\nconst emit = defineEmits(['update:name']);\n\nconst draft = ref(props.name);\n\n// Keep draft in sync if parent changes the prop externally\nwatch(() => props.name, (v) => { draft.value = v; });\n\nfunction commit() {\n  emit('update:name', draft.value);\n}\n</script>\n\n<template>\n  <input v-model=\"draft\" />\n  <button @click=\"commit\">Save</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br>Mutating props breaks one-way data flow: the parent is no longer the single source of truth, updates become non-deterministic to trace, and nested object/array props can mutate parent state by reference. Correct approach: child <em>emits intent</em> (update events / v-model) and the parent owns the actual state mutation."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "props",
      "immutability",
      "components",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Vue child mutating props: what breaks",
      "description": "See why mutating a prop in a child causes one-way data flow issues, overwritten values, and warnings, then use emits or local copies for safe updates."
    }
  },
  {
    "id": "vue-composition-api-vs-mixins",
    "title": "Why does Vue recommend the Composition API over mixins today?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Vue recommends the Composition API over mixins because it avoids implicit merging and name collisions, improves code organization, and offers better TypeScript inference for reusable logic.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Vue recommends the Composition API over mixins because mixins scale poorly: they hide where logic/state comes from, can collide/override silently, and are hard to type and refactor. Composition API fixes that by making reuse <em>explicit</em> (import + call a composable), <em>composable</em> (combine multiple functions safely), and <em>TypeScript-friendly</em> (inference works through function signatures)."
        },
        {
          "type": "list",
          "columns": [
            "Problem with mixins",
            "What it looks like in code",
            "How Composition API fixes it"
          ],
          "rows": [
            [
              "Implicit sources (\"Where did this come from?\")",
              "Template/method uses <code>loading</code>/<code>save</code> but you can’t tell if it’s local or from a mixin",
              "You see it: <code>const { loading, save } = useSave()</code> (explicit import + call)"
            ],
            [
              "Name collisions / overrides",
              "Two mixins (or mixin + component) define the same <code>data</code>/<code>methods</code>/<code>computed</code> keys",
              "Return names you control (rename on destructure) and keep state scoped per composable call"
            ],
            [
              "Hard refactors",
              "Renaming a field in a mixin can break many components in non-obvious ways",
              "Refactor via normal TS/JS tooling: function exports, parameters, return types"
            ],
            [
              "Weak TypeScript inference",
              "Options API + mixins make it hard for TS to know what exists on <code>this</code>",
              "Composables are just functions: TS infers return types and narrows correctly"
            ],
            [
              "Hidden coupling and lifecycle side effects",
              "A mixin adds watchers/hooks that run in every component using it, often unexpectedly",
              "Composables make effects explicit and local; you call it only where needed"
            ],
            [
              "Testing friction",
              "Testing mixin behavior often requires mounting components or relying on <code>this</code>",
              "Test composables as plain functions (or with minimal Vue reactivity helpers)"
            ]
          ],
          "caption": "Why Composition API wins over mixins in large codebases"
        },
        {
          "type": "text",
          "text": "<strong>The big pain point: collisions and “action at a distance”</strong><br><br>Mixins merge into the component options. If multiple sources define the same key, you can get overrides or merged behavior (hooks). The result: you read a component and can’t confidently tell what runs, in what order, and which definition “wins”."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Example: mixin collisions are easy to introduce -->\n<script>\nconst SavingMixin = {\n  data() {\n    return { loading: false };\n  },\n  methods: {\n    save() {\n      // ...\n    }\n  }\n};\n\nconst AnalyticsMixin = {\n  data() {\n    return { loading: true }; // collision: same key name\n  },\n  methods: {\n    save() {\n      // collision: same method name (which one runs is non-obvious)\n    }\n  }\n};\n\nexport default {\n  name: 'UserForm',\n  mixins: [SavingMixin, AnalyticsMixin],\n  // component may also define loading/save again\n};\n</script>\n\n<template>\n  <button :disabled=\"loading\" @click=\"save\">Save</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Composition API approach: explicit, local, and composable</strong><br><br>With composables, logic reuse is just function composition: you import what you need, call it, and use returned refs/functions. Naming is explicit (and renameable), collisions are controlled, and types are predictable."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// useSave.ts\nimport { ref } from 'vue';\n\nexport function useSave() {\n  const loading = ref(false);\n\n  async function save(payload) {\n    loading.value = true;\n    try {\n      // ...api call\n    } finally {\n      loading.value = false;\n    }\n  }\n\n  return { loading, save };\n}\n\n// useAnalyticsSave.ts\nexport function useAnalyticsSave(baseSave) {\n  async function saveWithAnalytics(payload) {\n    // track(...)\n    return baseSave(payload);\n  }\n\n  return { saveWithAnalytics };\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- UserForm.vue (Composition API, explicit reuse) -->\n<script setup>\nimport { useSave } from './useSave';\nimport { useAnalyticsSave } from './useAnalyticsSave';\n\nconst { loading, save } = useSave();\nconst { saveWithAnalytics } = useAnalyticsSave(save);\n</script>\n\n<template>\n  <button :disabled=\"loading\" @click=\"saveWithAnalytics({ /* ... */ })\">\n    Save\n  </button>\n</template>"
        },
        {
          "type": "list",
          "columns": [
            "Interview-ready point",
            "What to say"
          ],
          "rows": [
            [
              "Why mixins are discouraged",
              "They create implicit APIs on the component, cause collisions/overrides, and make large codebases harder to reason about and type."
            ],
            [
              "Why Composition API is preferred",
              "Reusable logic becomes explicit (import + call), composable (combine functions safely), and TypeScript-friendly (good inference)."
            ],
            [
              "How reuse is done today",
              "Use composables (e.g., <code>useX()</code>) instead of mixins; keep component API clear and local."
            ],
            [
              "Are mixins forbidden?",
              "No—still supported, but composables are the recommended default for logic reuse in Vue 3-era apps."
            ]
          ],
          "caption": "What interviewers want you to highlight"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>You want to reuse form validation across multiple Vue components, choosing between a composable or a mixin.<br><br><strong>Common pitfalls</strong><br><ul><li>Mixin name collisions that silently override component methods.</li><li>Hidden dependencies in mixins that are hard to trace.</li><li>Overusing composables and making data flow harder to follow.</li></ul><strong>Trade-off or test tip</strong><br>Composition API is explicit but can be more verbose. Test by reusing the logic in two components and confirming reactivity works the same."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "composition-api",
      "mixins",
      "reuse",
      "maintainability",
      "typescript"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 0,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-sfc-vs-global-components",
    "title": "What is the difference between single-file components and global components?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Single-File Components (SFCs) and global components differ in scope and structure. SFCs define components in .vue files with encapsulated templates, scripts, and styles, while global components are registered once and accessible throughout the application.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vue components can be created as <strong>Single-File Components (SFCs)</strong> or <strong>Global Components</strong>. Both define reusable UI pieces, but they differ in organization, scope, and how they are registered within a Vue application."
        },
        {
          "type": "text",
          "text": "<strong>Single-File Components (SFCs)</strong><br>Single-File Components are stored in <code>.vue</code> files and include three main sections — &lt;template&gt;, &lt;script&gt;, and &lt;style&gt;. They provide a modular, maintainable way to build complex applications."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- UserCard.vue -->\n<template>\n  <div class=\"user-card\">\n    <h2>{{ name }}</h2>\n    <p>{{ email }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['name', 'email']\n};\n</script>\n\n<style scoped>\n.user-card { border: 1px solid #ddd; padding: 10px; }\n</style>"
        },
        {
          "type": "text",
          "text": "SFCs promote better organization by separating structure, logic, and styling within a single file while keeping them tightly coupled for easier maintenance. They are registered locally within the parent component or automatically via file-based routing tools like Vite or Nuxt."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// App.vue\n<template>\n  <UserCard name=\"Mina\" email=\"mina@example.com\" />\n</template>\n\n<script>\nimport UserCard from './UserCard.vue';\nexport default { components: { UserCard } };\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Global Components</strong><br>Global components, on the other hand, are registered once in your app’s entry point (usually <code>main.js</code>) and can be used anywhere without importing them explicitly."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nimport BaseButton from './components/BaseButton.vue';\n\nconst app = createApp(App);\napp.component('BaseButton', BaseButton);\napp.mount('#app');"
        },
        {
          "type": "text",
          "text": "Now the <code>BaseButton</code> component can be used in any template throughout the app without the need for imports."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- AnyComponent.vue -->\n<template>\n  <BaseButton>Click Me</BaseButton>\n</template>"
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Single-File Components (SFCs)",
            "Global Components"
          ],
          "rows": [
            [
              "Definition",
              "Components defined in .vue files with template, script, and style sections",
              "Components registered globally via app.component()"
            ],
            [
              "Scope",
              "Available only in components where imported",
              "Available everywhere in the app"
            ],
            [
              "Usage",
              "Locally registered and explicitly imported",
              "Globally available without import"
            ],
            [
              "Organization",
              "Encourages modularity and reusability",
              "Useful for shared UI elements like buttons or modals"
            ],
            [
              "Performance",
              "Scoped registration reduces memory overhead",
              "Can increase bundle size if overused"
            ]
          ],
          "caption": "Comparison Between Single-File and Global Components"
        },
        {
          "type": "text",
          "text": "<strong>When to Use Each</strong><ul><li>Use <strong>SFCs</strong> for application-specific, modular, and reusable components that benefit from encapsulation.</li><li>Use <strong>Global Components</strong> for shared UI elements like buttons, icons, or form fields that appear across multiple views.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of global components as public utilities — accessible everywhere but should be used sparingly, while SFCs are private blueprints — focused and modular for specific tasks."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>SFCs are defined in <code>.vue</code> files and locally registered for better modularity.</li><li>Global components are registered once and accessible throughout the app.</li><li>Use SFCs for maintainable large-scale apps, and global components for common UI building blocks.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "components",
      "sfc",
      "architecture",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-conditional-list-rendering",
    "title": "How does Vue handle conditional rendering and list rendering efficiently?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Vue handles conditional and list rendering efficiently through its virtual DOM diffing system. Directives like v-if, v-show, and v-for control what is rendered while Vue updates only the necessary parts of the DOM when data changes.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vue provides efficient and declarative ways to control rendering using directives like <code>v-if</code>, <code>v-show</code>, and <code>v-for</code>. These directives determine whether elements should appear in the DOM and how lists of elements are dynamically generated and updated. Vue’s virtual DOM efficiently detects what has changed and updates only the affected parts, rather than re-rendering the entire DOM."
        },
        {
          "type": "text",
          "text": "<strong>Conditional Rendering</strong><br>Conditional rendering in Vue is handled primarily with <code>v-if</code>, <code>v-else-if</code>, <code>v-else</code>, and <code>v-show</code>."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <div>\n    <p v-if=\"isLoggedIn\">Welcome back, {{ username }}!</p>\n    <p v-else>Please log in to continue.</p>\n\n    <button v-show=\"!isLoggedIn\">Login</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      isLoggedIn: false,\n      username: 'Mina'\n    };\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "Here’s how it works:<ul><li><code>v-if</code> adds or removes elements from the DOM completely based on the condition. It’s useful when the condition changes infrequently.</li><li><code>v-show</code> toggles the element’s CSS <code>display</code> property without adding or removing it from the DOM, which is more efficient for frequent toggling.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>List Rendering</strong><br>Vue’s <code>v-for</code> directive is used to render lists of items efficiently. Each list item is tracked using a <code>key</code>, allowing Vue to reuse and reorder DOM elements instead of re-creating them from scratch."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <ul>\n    <li v-for=\"user in users\" :key=\"user.id\">\n      {{ user.name }}\n    </li>\n  </ul>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      users: [\n        { id: 1, name: 'Alice' },\n        { id: 2, name: 'Bob' },\n        { id: 3, name: 'Charlie' }\n      ]\n    };\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "The <code>:key</code> attribute helps Vue track each item’s identity when updating the DOM. This makes updates more efficient, as Vue can determine what has changed, added, or removed using its virtual DOM diffing algorithm."
        },
        {
          "type": "list",
          "columns": [
            "Directive",
            "Purpose",
            "Efficiency Note"
          ],
          "rows": [
            [
              "v-if / v-else-if / v-else",
              "Conditionally add or remove elements from the DOM",
              "Slower if toggled frequently (creates/destroys elements)"
            ],
            [
              "v-show",
              "Toggle element visibility using CSS display",
              "Faster for frequent toggling"
            ],
            [
              "v-for",
              "Render a list of elements based on an array or object",
              "Highly optimized with key tracking and virtual DOM diffing"
            ]
          ],
          "caption": "Comparison of Conditional and List Rendering Techniques"
        },
        {
          "type": "text",
          "text": "<strong>Why It’s Efficient</strong><br>Vue uses a <em>virtual DOM</em> to compare the current and previous states of the UI. When changes occur, Vue only updates the parts that differ, instead of re-rendering the entire view. This ensures performance even in large lists or when toggling content rapidly."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>v-if</code> as removing or inserting items from a shelf and <code>v-show</code> as simply covering or uncovering them — both are efficient, but suited for different situations."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li><code>v-if</code> removes or inserts elements into the DOM.</li><li><code>v-show</code> toggles visibility via CSS.</li><li><code>v-for</code> efficiently renders dynamic lists using keys.</li><li>Vue’s virtual DOM minimizes unnecessary DOM updates for smooth performance.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "directives",
      "v-if",
      "v-for",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-router-navigation",
    "title": "What is the Vue Router and how is it used for navigation?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Vue Router enables client-side navigation with routes mapped to components. It supports dynamic params, nested routes, and navigation guards for auth and data loading. Routing impacts UX and data fetching; test guards, async navigation, and scroll restoration.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vue Router is an official library that enables navigation between different views or components in a Vue application. It transforms a Vue app into a Single-Page Application (SPA) by mapping URLs (routes) to specific components and handling transitions dynamically without reloading the page."
        },
        {
          "type": "text",
          "text": "<strong>Installing Vue Router</strong><br>To use Vue Router, install it with npm or yarn:"
        },
        {
          "type": "code",
          "language": "bash",
          "code": "npm install vue-router\n# or\nyarn add vue-router"
        },
        {
          "type": "text",
          "text": "<strong>Defining Routes</strong><br>Routes are defined as objects, where each route maps a URL path to a specific component."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// router.js\nimport { createRouter, createWebHistory } from 'vue-router';\nimport Home from './components/Home.vue';\nimport About from './components/About.vue';\n\nconst routes = [\n  { path: '/', component: Home },\n  { path: '/about', component: About }\n];\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes\n});\n\nexport default router;"
        },
        {
          "type": "text",
          "text": "<strong>Using the Router in Your App</strong><br>Once defined, the router must be registered in the main Vue application instance."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nimport router from './router';\n\nconst app = createApp(App);\napp.use(router);\napp.mount('#app');"
        },
        {
          "type": "text",
          "text": "Now your application can handle different pages without reloading. The <code>&lt;router-view&gt;</code> element acts as a placeholder that dynamically displays the active route’s component."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <div>\n    <nav>\n      <router-link to=\"/\">Home</router-link>\n      <router-link to=\"/about\">About</router-link>\n    </nav>\n\n    <router-view></router-view>\n  </div>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>How Navigation Works</strong><br>• <code>&lt;router-link&gt;</code> creates navigable links without refreshing the page.<br>• <code>&lt;router-view&gt;</code> displays the matched component for the current route.<br>• Vue Router automatically updates the browser’s history using the HTML5 History API."
        },
        {
          "type": "text",
          "text": "<strong>Dynamic and Nested Routes</strong><br>Vue Router supports dynamic routes (e.g., user profiles) and nested routes for hierarchical views."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "{ path: '/user/:id', component: UserProfile }"
        },
        {
          "type": "text",
          "text": "Access dynamic parameters in the component using <code>this.$route.params.id</code>."
        },
        {
          "type": "text",
          "text": "<strong>Programmatic Navigation</strong><br>You can also navigate using JavaScript instead of router-link components:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "this.$router.push('/about');\nthis.$router.replace('/');"
        },
        {
          "type": "text",
          "text": "<strong>Navigation Guards</strong><br>Vue Router includes navigation guards (e.g., <code>beforeEach</code>) to control access to routes, often used for authentication or logging."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "router.beforeEach((to, from, next) => {\n  if (to.path === '/admin' && !isLoggedIn()) {\n    next('/login');\n  } else {\n    next();\n  }\n});"
        },
        {
          "type": "text",
          "text": "<strong>Advantages of Vue Router</strong><ul><li>Enables navigation without page reloads.</li><li>Supports nested, dynamic, and lazy-loaded routes.</li><li>Integrates with browser history and back navigation.</li><li>Works seamlessly with Vue’s reactivity system.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Vue Router as the GPS of your application — it knows where you are, where you’re going, and updates the view without ever refreshing the page."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Vue Router maps URL paths to components for single-page navigation.</li><li>Use &lt;router-link&gt; for navigation and &lt;router-view&gt; to display views.</li><li>Supports dynamic, nested, and programmatic navigation.</li><li>Navigation guards help manage route access and user flow.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>Protect a dashboard route behind auth and redirect unauthenticated users to login.<br><br><strong>Common pitfalls</strong><br><ul><li>Forgetting to return/next in async guards.</li><li>Triggering infinite redirect loops.</li><li>Not handling scroll behavior on navigation.</li></ul><strong>Trade-off or test tip</strong><br>Guards improve security but add complexity. Test navigation timing and back-button behavior.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "router",
      "navigation",
      "spa",
      "routes",
      "guards"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 0,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-reactivity-system",
    "title": "What is the Vue reactivity system and how does it work internally?",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 5,
    "description": "The Vue reactivity system is the core mechanism that automatically updates the DOM whenever data changes. Internally, it uses proxies (in Vue 3) to track dependencies and trigger re-renders when reactive data is modified.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>The Vue reactivity system is what makes Vue applications dynamic and responsive. It allows your UI to automatically update when underlying data changes — without manually manipulating the DOM. In Vue 3, this system is powered by <strong>ES6 Proxies</strong>, which intercept and track operations on reactive objects."
        },
        {
          "type": "text",
          "text": "<strong>How Vue Reactivity Works</strong><br>Vue’s reactivity is built around three key concepts:<ul><li><strong>Reactive Data</strong>: Data that Vue tracks for changes.</li><li><strong>Dependency Tracking</strong>: Vue keeps track of which components or functions depend on which pieces of data.</li><li><strong>Reactivity Triggers</strong>: When data changes, Vue automatically re-runs or re-renders the parts of the app that depend on that data.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>1. Creating Reactive Data</strong><br>In Vue 3, the <code>reactive()</code> and <code>ref()</code> APIs from the Composition API are used to create reactive data sources."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive, ref } from 'vue';\n\nconst state = reactive({ count: 0 });\nconst message = ref('Hello Vue!');"
        },
        {
          "type": "text",
          "text": "Here, both <code>state</code> and <code>message</code> become reactive — Vue wraps them in a proxy that intercepts reads and writes to track changes."
        },
        {
          "type": "text",
          "text": "<strong>2. Tracking Dependencies</strong><br>When a component renders and accesses reactive properties, Vue records which reactive values were used. These dependencies are stored in an internal data structure called a <strong>Dependency Map</strong> (a WeakMap under the hood)."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Pseudo-code of dependency tracking\nfunction track(target, key) {\n  const effect = activeEffect; // current rendering effect\n  if (effect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) targetMap.set(target, (depsMap = new Map()));\n\n    let dep = depsMap.get(key);\n    if (!dep) depsMap.set(key, (dep = new Set()));\n\n    dep.add(effect);\n  }\n}"
        },
        {
          "type": "text",
          "text": "Every time a reactive property is accessed during rendering, Vue calls <code>track()</code> to register the current watcher or computed effect as a dependency."
        },
        {
          "type": "text",
          "text": "<strong>3. Triggering Updates</strong><br>When a reactive value changes, Vue triggers an update by looking up all the effects (like component re-renders or computed properties) that depend on that property, then re-executes them."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Pseudo-code of triggering updates\nfunction trigger(target, key) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) return;\n  const dep = depsMap.get(key);\n  if (dep) {\n    dep.forEach(effect => effect());\n  }\n}"
        },
        {
          "type": "text",
          "text": "This ensures that only the parts of the app that depend on the modified property are re-run, leading to efficient updates instead of full-page re-renders."
        },
        {
          "type": "text",
          "text": "<strong>4. Vue 2 vs Vue 3 Reactivity</strong><br>In Vue 2, reactivity was achieved with <code>Object.defineProperty()</code> — Vue defined getters and setters for each property. However, it couldn’t detect new properties or array index changes easily.<br><br>In Vue 3, the system uses <strong>Proxies</strong>, which can intercept all property operations (get, set, delete, etc.), enabling full reactivity without these limitations."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Vue 2 (Object.defineProperty)",
            "Vue 3 (Proxy)"
          ],
          "rows": [
            [
              "Detect new properties",
              "❌ Not supported",
              "✅ Supported"
            ],
            [
              "Detect array index changes",
              "❌ Limited",
              "✅ Fully supported"
            ],
            [
              "Performance",
              "Moderate",
              "Faster and more efficient"
            ],
            [
              "Memory usage",
              "Higher due to watchers",
              "Lower, centralized dependency tracking"
            ]
          ],
          "caption": "Comparison of Vue 2 and Vue 3 Reactivity Systems"
        },
        {
          "type": "text",
          "text": "<strong>5. Computed Properties and Watchers</strong><br>Computed properties in Vue use this same reactivity mechanism but cache results until their dependencies change. Watchers use reactive tracking to run custom logic when specific data updates."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive, computed, watch } from 'vue';\n\nconst state = reactive({ count: 0 });\nconst doubled = computed(() => state.count * 2);\n\nwatch(() => state.count, (newVal, oldVal) => {\n  console.log('Count changed:', oldVal, '→', newVal);\n});"
        },
        {
          "type": "text",
          "text": "Here, both <code>computed()</code> and <code>watch()</code> rely on Vue’s dependency tracking to know when <code>state.count</code> changes."
        },
        {
          "type": "text",
          "text": "<strong>6. Virtual DOM Integration</strong><br>When data changes, Vue marks affected components for re-rendering. During the next render cycle, Vue’s virtual DOM efficiently diffs the new and old virtual trees and updates only the changed elements in the real DOM."
        },
        {
          "type": "text",
          "text": "<strong>Why It’s Efficient</strong><br>Vue’s reactivity is fine-grained — it tracks dependencies at the property level. This means only the parts of your UI that depend on changed data are updated. Combined with virtual DOM diffing, this provides excellent runtime performance even for large applications."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of the Vue reactivity system as an intelligent observer — it watches over your data, remembers what depends on it, and instantly updates only what’s necessary when something changes."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Vue’s reactivity system tracks dependencies using Proxies and WeakMaps.</li><li>Reactive objects trigger updates only for the affected properties.</li><li>Vue 3’s Proxy-based reactivity is faster, more complete, and easier to maintain than Vue 2’s system.</li><li>Computed properties and watchers build upon the same reactive foundation.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "reactivity",
      "state",
      "core",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-composition-api",
    "title": "What are Vue Composition APIs (setup(), ref, reactive) and why were they introduced?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "The Vue Composition API provides a flexible and scalable way to organize component logic using functions like setup(), ref(), and reactive(). It was introduced in Vue 3 to improve reusability, maintainability, and TypeScript support compared to the Options API.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>The Composition API is a new way to write components in Vue 3. It provides greater flexibility and control over organizing logic inside components by using functions like <code>setup()</code>, <code>ref()</code>, and <code>reactive()</code>. This API was introduced to address the limitations of the traditional Options API, making complex component logic easier to read, reuse, and test."
        },
        {
          "type": "text",
          "text": "<strong>Why the Composition API Was Introduced</strong><br>In large applications, the Options API (using data, methods, computed, etc.) often leads to scattered logic — related code gets separated into different options, making it harder to maintain and reuse. The Composition API solves this by allowing developers to group related logic together using plain JavaScript functions."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example of Composition API\n<template>\n  <div>\n    <p>Count: {{ count }}</p>\n    <button @click=\"increment\">Increment</button>\n  </div>\n</template>\n\n<script>\nimport { ref } from 'vue';\n\nexport default {\n  setup() {\n    const count = ref(0);\n    const increment = () => count.value++;\n\n    return { count, increment };\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Key Concepts in the Composition API</strong>"
        },
        {
          "type": "text",
          "text": "<strong>1. setup() Function</strong><br>The <code>setup()</code> function is the entry point of the Composition API. It runs before the component is created and is used to declare reactive state, computed properties, watchers, and lifecycle hooks.<br><br>Anything returned from <code>setup()</code> becomes available in the component template."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "setup() {\n  const name = ref('Mina');\n  const greet = () => console.log(`Hello, ${name.value}!`);\n\n  return { name, greet };\n}"
        },
        {
          "type": "text",
          "text": "<strong>2. ref()</strong><br><code>ref()</code> creates a reactive reference to a primitive value (like numbers, strings, or booleans). When you update <code>ref.value</code>, Vue automatically tracks and re-renders any parts of the UI that depend on it."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const message = ref('Hello');\nmessage.value = 'Hi there!';"
        },
        {
          "type": "text",
          "text": "<strong>3. reactive()</strong><br><code>reactive()</code> creates a reactive object instead of a primitive. It’s ideal for tracking multiple properties within an object or array."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const user = reactive({ name: 'Alice', age: 25 });\nuser.age++; // Triggers reactivity automatically"
        },
        {
          "type": "text",
          "text": "<strong>4. Combining ref() and reactive()</strong><br>You can combine both approaches — use <code>ref()</code> for single values and <code>reactive()</code> for complex objects. They can also be mixed within the same component for flexibility."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const count = ref(0);\nconst user = reactive({ name: 'Mina', score: 10 });"
        },
        {
          "type": "text",
          "text": "<strong>Advantages of the Composition API</strong><ul><li>Better logic organization and reuse through composable functions.</li><li>Improved TypeScript support and static analysis.</li><li>Cleaner separation of concerns for large components.</li><li>Fully compatible with existing Options API — both can coexist in the same project.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of the Composition API as building blocks: instead of being restricted to predefined sections (data, methods, computed), you freely compose logic like LEGO pieces — reusable, organized, and scalable."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li><code>setup()</code> is the core entry point for the Composition API.</li><li><code>ref()</code> makes primitive values reactive.</li><li><code>reactive()</code> makes entire objects reactive.</li><li>Introduced to improve reusability, readability, and TypeScript compatibility.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "composition-api",
      "hooks",
      "reactivity",
      "basics"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vuex-state-management",
    "title": "What is the purpose of Vuex, and how does it help manage state in large applications?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Vuex is a centralized state management pattern for large Vue apps. It provides a single store, predictable mutations, and devtools time-travel debugging. Centralized state helps predictability and debugging, but it adds boilerplate and affects test setup and performance.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vuex is Vue’s official <strong>state management pattern and library</strong>. It serves as a centralized store that manages shared data and ensures all components access and modify it in a consistent, predictable way. This is crucial in large-scale applications where multiple components depend on or modify the same state."
        },
        {
          "type": "text",
          "text": "<strong>Why Vuex Is Needed</strong><br>In small apps, passing data via <code>props</code> and emitting events (<code>$emit</code>) works fine. However, in large applications with deeply nested components, data flow becomes hard to manage. Vuex solves this by providing a single source of truth — the <strong>store</strong> — from which all components can read or update data in a controlled manner."
        },
        {
          "type": "text",
          "text": "<strong>Core Concepts of Vuex</strong><br>Vuex is built around four key elements: <strong>State</strong>, <strong>Getters</strong>, <strong>Mutations</strong>, and <strong>Actions</strong>."
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Purpose",
            "Example"
          ],
          "rows": [
            [
              "State",
              "Holds the centralized data",
              "user.name, cartItems, authToken"
            ],
            [
              "Getters",
              "Computed properties for the store",
              "getters.cartTotal"
            ],
            [
              "Mutations",
              "Synchronous functions to modify state",
              "commit('addToCart', item)"
            ],
            [
              "Actions",
              "Asynchronous operations that commit mutations",
              "dispatch('fetchProducts')"
            ]
          ],
          "caption": "Core Elements of Vuex Store"
        },
        {
          "type": "text",
          "text": "<strong>Vuex Store Example</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// store.js\nimport { createStore } from 'vuex';\n\nconst store = createStore({\n  state() {\n    return {\n      count: 0,\n      user: { name: 'Mina' }\n    };\n  },\n  getters: {\n    upperName: (state) => state.user.name.toUpperCase()\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    }\n  },\n  actions: {\n    asyncIncrement({ commit }) {\n      setTimeout(() => commit('increment'), 500);\n    }\n  }\n});\n\nexport default store;"
        },
        {
          "type": "text",
          "text": "<strong>Using the Store in Components</strong><br>Once created, the store is registered globally and accessed via the <code>useStore()</code> function in components."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "<template>\n  <div>\n    <p>Count: {{ store.state.count }}</p>\n    <button @click=\"store.commit('increment')\">Increment</button>\n  </div>\n</template>\n\n<script>\nimport { useStore } from 'vuex';\n\nexport default {\n  setup() {\n    const store = useStore();\n    return { store };\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "Here, the component accesses the store’s <code>state</code> and triggers updates using <code>commit()</code> and <code>dispatch()</code>."
        },
        {
          "type": "text",
          "text": "<strong>Data Flow in Vuex</strong><br>Vuex enforces a one-way data flow:<br><br><ul><li><strong>State</strong>: The single source of truth.</li><li><strong>View</strong>: Displays state and triggers actions.</li><li><strong>Actions</strong>: Commit mutations asynchronously (e.g., API calls).</li><li><strong>Mutations</strong>: Synchronously change state.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Advantages of Vuex</strong><ul><li>Centralized state management — a single source of truth.</li><li>Predictable state transitions through mutations.</li><li>Improved debugging and time-travel debugging via DevTools.</li><li>Easy synchronization between components sharing data.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Vuex vs. Pinia</strong><br>Pinia, introduced later, is the official replacement for Vuex in Vue 3. It simplifies syntax, supports the Composition API natively, and reduces boilerplate while maintaining similar concepts like <code>state</code>, <code>getters</code>, and <code>actions</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Vuex as a shared control center: instead of each component managing its own data independently, they all communicate with the same centralized store — ensuring consistency and predictability."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Vuex provides a centralized, predictable state management system.</li><li>Components share data through a single source of truth — the store.</li><li>Mutations update state synchronously; actions handle async operations.</li><li>Ideal for large-scale apps where multiple components depend on shared state.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A large app shares auth state, preferences, and cached API results across many pages, so you centralize them in Vuex.<br><br><strong>Common pitfalls</strong><br><ul><li>Storing UI-local state globally, bloating the store.</li><li>Overusing mutations/actions for trivial changes.</li><li>Hard-to-test modules due to side effects.</li></ul><strong>Trade-off or test tip</strong><br>Global state improves consistency but adds complexity. Test modules in isolation and watch performance on large updates.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "vuex",
      "state-management",
      "store",
      "mutations",
      "architecture"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-virtual-dom-diffing",
    "title": "How does Vue’s virtual DOM and diffing algorithm optimize updates?",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 1,
    "description": "Vue uses a virtual DOM to compute minimal DOM updates. The diffing algorithm compares old and new virtual trees and patches only changed nodes, improving performance. Diffing optimizes updates, but keys and stable identity matter for performance and correctness.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vue’s virtual DOM is a lightweight JavaScript representation of the real DOM. Instead of directly manipulating the browser’s DOM — which is slow — Vue updates a virtual copy in memory and then compares it to the previous version using a process called <strong>diffing</strong>. After detecting the differences, Vue efficiently updates only the parts of the real DOM that have changed, resulting in faster rendering performance."
        },
        {
          "type": "text",
          "text": "<strong>1. The Problem with Direct DOM Manipulation</strong><br>Manipulating the real DOM frequently can be slow because each update triggers <em>recalculations of layout</em> and <em>repaints</em>. This becomes especially costly when multiple updates happen in quick succession, such as when reacting to user input or large data changes."
        },
        {
          "type": "text",
          "text": "To solve this, Vue uses a <strong>virtual DOM</strong> (a memory-based representation of the DOM structure). This allows Vue to compute the minimal set of changes needed before touching the real DOM."
        },
        {
          "type": "text",
          "text": "<strong>2. What Is the Virtual DOM?</strong><br>The virtual DOM (vDOM) is a tree of JavaScript objects that mirrors the structure of your UI. Each element in the UI is represented as a <strong>VNode</strong> (Virtual Node), containing information like the tag name, attributes, children, and event listeners."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example virtual DOM node representation\n{\n  tag: 'div',\n  props: { id: 'app' },\n  children: [\n    { tag: 'h1', children: ['Hello Vue!'] },\n    { tag: 'button', props: { onClick: handleClick }, children: ['Click me'] }\n  ]\n}"
        },
        {
          "type": "text",
          "text": "Instead of touching the actual DOM immediately, Vue constructs and updates this virtual representation during rendering."
        },
        {
          "type": "text",
          "text": "<strong>3. The Diffing Algorithm</strong><br>When reactive data changes, Vue re-renders the component and creates a <strong>new virtual DOM tree</strong>. It then compares this new tree to the previous one (a process known as <em>diffing</em>), determines what has changed, and applies only the minimal set of updates to the real DOM."
        },
        {
          "type": "text",
          "text": "Vue’s diffing algorithm works efficiently using several strategies:<ul><li><strong>Same Type Check:</strong> If two nodes have different tags, Vue replaces the old one entirely.</li><li><strong>Props Diffing:</strong> If two nodes have the same tag, Vue compares their attributes and updates only the changed ones.</li><li><strong>Children Comparison:</strong> For lists or nested elements, Vue compares keys and reuses existing DOM nodes whenever possible.</li></ul>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example of diffing behavior\nconst oldVNode = h('div', { class: 'red' }, 'Hello');\nconst newVNode = h('div', { class: 'blue' }, 'Hello World');\n\n// Vue detects:\n// - class changed from 'red' → 'blue'\n// - text changed from 'Hello' → 'Hello World'\n// Only these updates are applied to the real DOM."
        },
        {
          "type": "text",
          "text": "<strong>4. Keyed Updates for Lists</strong><br>When rendering lists (using v-for), Vue uses <code>key</code> attributes to efficiently track items. This prevents unnecessary re-renders when items are reordered or updated."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<ul>\n  <li v-for=\"user in users\" :key=\"user.id\">{{ user.name }}</li>\n</ul>"
        },
        {
          "type": "text",
          "text": "Without a proper <code>key</code>, Vue may re-render entire lists unnecessarily because it cannot tell which item corresponds to which DOM element. With keys, Vue can reorder elements instead of recreating them, which saves performance."
        },
        {
          "type": "text",
          "text": "<strong>5. Batch and Async Updates</strong><br>Vue batches DOM updates asynchronously. When multiple reactive changes occur in the same tick, Vue queues them and performs all updates together in the next event loop cycle using its <strong>nextTick()</strong> mechanism. This prevents unnecessary re-renders and ensures smooth UI updates."
        },
        {
          "type": "text",
          "text": "<strong>6. Virtual DOM vs Real DOM Performance</strong><br>Direct DOM manipulation triggers expensive layout recalculations, whereas virtual DOM updates are computed in memory. Only the minimal, necessary DOM operations are performed, drastically reducing CPU and memory overhead."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Real DOM",
            "Virtual DOM"
          ],
          "rows": [
            [
              "Update Speed",
              "Slow (direct manipulation)",
              "Fast (in-memory comparison)"
            ],
            [
              "Re-rendering",
              "Whole tree may refresh",
              "Only changed parts updated"
            ],
            [
              "Memory Usage",
              "Lower",
              "Slightly higher (virtual tree stored in memory)"
            ],
            [
              "Performance",
              "Costly on frequent updates",
              "Optimized via batching and diffing"
            ]
          ],
          "caption": "Comparison between Real DOM and Virtual DOM"
        },
        {
          "type": "text",
          "text": "<strong>7. Internal Optimization Techniques</strong><ul><li><strong>Static Tree Hoisting:</strong> Static parts of the template are skipped during updates.</li><li><strong>Patch Flags:</strong> Vue marks which parts of the template are dynamic, so it updates only those parts.</li><li><strong>Block Tree Optimization:</strong> Groups dynamic nodes together for faster diffing.</li></ul>These compiler-level optimizations further minimize the amount of DOM work during updates."
        },
        {
          "type": "text",
          "text": "<strong>8. Real-World Example</strong><br>When you update a single value in a large list, Vue doesn’t re-render the whole list. Instead, the virtual DOM detects exactly which element changed and only patches that DOM node — often just one line of text."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Vue’s virtual DOM like a smart editor — it reviews the changes before applying them to the final document, ensuring only the necessary parts are rewritten instead of retyping the entire page."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>The virtual DOM is a lightweight JS representation of the UI.</li><li>Vue’s diffing algorithm compares new and old virtual trees to detect changes.</li><li>Only the changed parts of the DOM are updated (patching).</li><li>Batching and compiler optimizations ensure smooth and efficient rendering.</li><li>This system enables Vue to maintain high performance even with complex UIs.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Practical scenario</strong><br>A list reorders frequently; diffing decides which DOM nodes to reuse to keep scrolling smooth.<br><br><strong>Common pitfalls</strong><br><ul><li>Missing or unstable keys, causing DOM reuse bugs.</li><li>Assuming diffing always minimizes DOM work.</li><li>Mutating arrays in place and confusing diffing heuristics.</li></ul><strong>Trade-off or test tip</strong><br>Stable keys improve correctness but require unique ids. Test list reorders and focus retention.</strong>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "virtual-dom",
      "diffing",
      "performance",
      "rendering"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 0,
      "detailPenalty": 2,
      "crossCompany": 0,
      "frequencyBonus": 0
    },
    "seo": {
      "title": "Vue virtual DOM diffing: optimize updates",
      "description": "See how Vue builds virtual nodes, diffs old and new trees, and patches only changed parts so updates stay fast without unnecessary DOM work."
    }
  },
  {
    "id": "vue-slots-default-named-scoped-slot-props",
    "title": "Explain Slots in Vue: default vs named vs scoped slots — and how slot props enable child-to-parent data flow",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain how Vue slots work (default, named, and scoped slots), what problem they solve, and how slot props allow a child component to pass data back to the parent’s template while still keeping one-way data flow.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Slots are Vue’s way of letting a <strong>parent inject template content into a child</strong> — while the child controls <em>where</em> and <em>how</em> that content is rendered. With <strong>scoped slots (slot props)</strong>, the child can also <strong>expose data to the parent’s slot template</strong>, enabling a powerful, explicit, and safe form of child → parent data flow."
        },
        {
          "type": "list",
          "columns": [
            "Slot type",
            "What it does",
            "When you use it"
          ],
          "rows": [
            [
              "Default slot",
              "Injects unnamed content into a child component",
              "Simple wrapper components (Card, Modal, Layout, etc.)"
            ],
            [
              "Named slot",
              "Lets you target multiple insertion points",
              "Complex layouts (header/body/footer, actions, sidebars)"
            ],
            [
              "Scoped slot (slot props)",
              "Child exposes data to the parent’s slot template",
              "Reusable logic components (List, Table, Fetcher, Virtualizer)"
            ]
          ],
          "caption": "The three kinds of slots in Vue"
        },
        {
          "type": "text",
          "text": "<strong>Default slot</strong><br><br>The simplest case: the parent passes some markup, and the child decides where to render it."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Card.vue -->\n<template>\n  <div class=\"card\">\n    <slot />\n  </div>\n</template>\n\n<!-- Parent.vue -->\n<Card>\n  <h2>Hello</h2>\n  <p>This goes into the default slot</p>\n</Card>"
        },
        {
          "type": "text",
          "text": "<strong>Named slots</strong><br><br>When a component has multiple insertion points, you name them."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Modal.vue -->\n<template>\n  <div class=\"modal\">\n    <header><slot name=\"header\" /></header>\n    <main><slot /></main>\n    <footer><slot name=\"footer\" /></footer>\n  </div>\n</template>\n\n<!-- Parent.vue -->\n<Modal>\n  <template #header>\n    <h2>Confirm</h2>\n  </template>\n\n  Are you sure?\n\n  <template #footer>\n    <button>OK</button>\n  </template>\n</Modal>"
        },
        {
          "type": "text",
          "text": "<strong>The real power: scoped slots (slot props)</strong><br><br>Normally, slot content is compiled in the <em>parent’s scope</em>. But sometimes the <strong>child has the data</strong> (e.g., a list, fetched results, virtualized rows). Scoped slots let the <strong>child expose data to the parent’s slot template</strong> explicitly."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ListRenderer.vue -->\n<template>\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">\n      <slot :item=\"item\" :index=\"item.id\" />\n    </li>\n  </ul>\n</template>\n\n<script setup>\nconst props = defineProps({\n  items: { type: Array, required: true }\n});\n</script>"
        },
        {
          "type": "text",
          "text": "Now the parent can <strong>decide how each item is rendered</strong>, using data provided by the child:"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<ListRenderer :items=\"users\">\n  <template #default=\"{ item }\">\n    <strong>{{ item.name }}</strong> ({{ item.email }})\n  </template>\n</ListRenderer>"
        },
        {
          "type": "text",
          "text": "<strong>Why this is not “breaking” one-way data flow</strong><br><br>The child is <em>not mutating parent state</em>. It is only <strong>exposing data</strong>. The parent still decides what to render and what to do with that data. This is <em>inversion of control</em>, not two-way binding."
        },
        {
          "type": "list",
          "columns": [
            "Without scoped slots",
            "With scoped slots"
          ],
          "rows": [
            [
              "Child controls both logic and rendering",
              "Child controls logic, parent controls rendering"
            ],
            [
              "Low flexibility",
              "Highly reusable and customizable components"
            ],
            [
              "Hard to generalize components",
              "Enables headless / renderless components"
            ]
          ],
          "caption": "Why scoped slots are a big deal"
        },
        {
          "type": "text",
          "text": "<strong>Common real-world use cases</strong><br><br>- Table components (you provide column templates)\n- List / virtual scroller components\n- Data fetcher components\n- Form builders\n- Headless UI components"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br>Default slots inject content, named slots target multiple regions, and scoped slots let the <em>child pass data into the parent’s slot template</em>. This enables highly reusable components where the child owns the logic, the parent owns the rendering — without breaking one-way data flow."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "components",
      "template-syntax",
      "props",
      "inputs-outputs",
      "slots"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-provide-inject-vs-prop-drilling-tradeoffs",
    "title": "Provide / Inject in Vue: when should you use it instead of prop drilling, and what are the hidden trade-offs?",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 2,
    "description": "Explain how provide/inject works in Vue, what problem it solves (prop drilling), when it is appropriate to use, and the architectural trade-offs and pitfalls compared to explicit props and state management.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>provide</code> / <code>inject</code> lets an ancestor component <strong>make values available to all descendants</strong> without passing them through every intermediate component as props. It solves <em>prop drilling</em>, but it also introduces <strong>implicit dependencies</strong> that can make your component tree harder to understand, refactor, and test."
        },
        {
          "type": "text",
          "text": "<strong>1. The Problem: Prop Drilling</strong><br><br>Sometimes data is needed deep in the component tree, but intermediate components do not care about it. With props, you end up passing the same value through many layers just to reach the real consumer."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- App.vue -->\n<Layout :theme=\"theme\" />\n\n<!-- Layout.vue -->\n<Sidebar :theme=\"theme\" />\n\n<!-- Sidebar.vue -->\n<SidebarItem :theme=\"theme\" />\n\n<!-- SidebarItem.vue -->\n<div :class=\"theme\">Item</div>"
        },
        {
          "type": "text",
          "text": "This is called <strong>prop drilling</strong>: noisy, repetitive, and fragile to refactors."
        },
        {
          "type": "text",
          "text": "<strong>2. How provide / inject Works</strong><br><br>An ancestor <code>provides</code> a value, and any descendant (no matter how deep) can <code>inject</code> it — without intermediate components knowing anything about it."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- App.vue -->\n<script setup>\nimport { provide, ref } from 'vue';\n\nconst theme = ref('dark');\nprovide('theme', theme);\n</script>\n\n<template>\n  <Layout />\n</template>\n\n<!-- SidebarItem.vue -->\n<script setup>\nimport { inject } from 'vue';\n\nconst theme = inject('theme');\n</script>\n\n<template>\n  <div :class=\"theme\">Item</div>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>3. When provide / inject is a Good Fit</strong><br><br>It is best for <strong>cross-cutting, infrastructural concerns</strong> that are not really part of your app’s business data flow:"
        },
        {
          "type": "list",
          "columns": [
            "Good use case",
            "Why it fits"
          ],
          "rows": [
            [
              "Design system / UI library internals",
              "Deep component trees need shared config (theme, size, density, locale)"
            ],
            [
              "Form / field registration systems",
              "Inputs register themselves to a parent form"
            ],
            [
              "Plugins and framework-like features",
              "Router, i18n, feature flags, permissions"
            ],
            [
              "Headless / compound components",
              "Parent provides behavior, children consume it implicitly"
            ]
          ],
          "caption": "Legitimate use cases for provide / inject"
        },
        {
          "type": "text",
          "text": "<strong>4. The Hidden Trade-Off: Implicit Coupling</strong><br><br>With props, a component’s dependencies are <strong>explicit</strong> in its API. With <code>inject</code>, dependencies become <strong>invisible</strong>: you can no longer tell what a component needs just by looking at its props."
        },
        {
          "type": "list",
          "columns": [
            "What you gain",
            "What you lose"
          ],
          "rows": [
            [
              "No prop drilling",
              "Hidden dependencies"
            ],
            [
              "Cleaner intermediate components",
              "Harder to reuse components in isolation"
            ],
            [
              "Flexible deep access",
              "Harder to refactor and trace data flow"
            ],
            [
              "Less boilerplate",
              "Harder to test (you must mock providers)"
            ]
          ],
          "caption": "The real cost of provide / inject"
        },
        {
          "type": "text",
          "text": "<strong>5. Another Subtle Issue: It Bypasses Your State Architecture</strong><br><br>If you start using provide/inject for <em>business state</em>, you effectively create a <strong>hidden global-ish state system</strong> that is harder to reason about than props, emits, or a proper store (Pinia/Vuex)."
        },
        {
          "type": "text",
          "text": "<strong>6. Reactivity Gotcha</strong><br><br><code>provide</code> / <code>inject</code> does <strong>not automatically make things reactive</strong>. You must provide a <code>ref</code>, <code>reactive</code> object, or computed value if you want updates to propagate."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// GOOD\nconst theme = ref('dark');\nprovide('theme', theme);\n\n// BAD (not reactive)\nprovide('theme', 'dark');"
        },
        {
          "type": "text",
          "text": "<strong>7. Decision Rule (Practical Heuristic)</strong><br><br>- If this is <strong>business data</strong> → use props / emits or a store.\n- If this is <strong>app infrastructure or component-internal wiring</strong> → provide/inject is OK.\n- If you feel tempted to use provide/inject to \"avoid wiring\" → that’s a code smell."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-triangle-exclamation'></i> A good mental model: <strong>provide/inject is dependency injection, not state management.</strong>"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready summary</strong><br><br>Provide/inject solves prop drilling by letting ancestors expose dependencies to deep children. It’s ideal for framework-like, cross-cutting concerns (themes, forms, plugins, compound components). But it introduces implicit coupling, hides dependencies, complicates testing and refactoring, and should <strong>not</strong> be used as a general replacement for props or stores."
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "dependency-injection",
      "context",
      "state-management",
      "architecture"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-why-declare-emits-type-safety-maintenance",
    "title": "Why should you declare emits in Vue? What breaks if you don’t, and how does it affect type safety and maintenance?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Explain why Vue encourages declaring emitted events (emits option / defineEmits), what can go wrong when events are not declared (silent typos, confusing APIs, missing validation), and how emits declarations improve type safety, refactoring, and long-term maintainability—especially in Vue 3 + TypeScript.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Declaring <code>emits</code> makes a component’s event API <strong>explicit</strong>. It prevents accidental event typos, enables runtime validation (optional), improves tooling/autocomplete, and gives you strong TypeScript inference for event names + payloads. If you don’t declare emits, you’re basically saying: “this component might emit anything, anytime,” which is a maintenance trap."
        },
        {
          "type": "text",
          "text": "<strong>1. What “declaring emits” means</strong><br><br>In Vue 3 you typically declare events with <code>defineEmits()</code> in <code>&lt;script setup&gt;</code> (or with the <code>emits</code> option in Options API). This defines the event names and (optionally) validates payloads."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ChildButton.vue (script setup) -->\n<script setup lang=\"ts\">\nconst emit = defineEmits<{ \n  (e: 'save'): void;\n  (e: 'update:count', value: number): void;\n}>();\n\nfunction onSave() {\n  emit('save');\n}\n\nfunction inc(current: number) {\n  emit('update:count', current + 1);\n}\n</script>\n\n<template>\n  <button @click=\"onSave\">Save</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>2. What breaks if you don’t declare emits?</strong><br><br>Sometimes nothing “crashes” immediately — and that’s the problem. The bugs are subtle: wrong event names, wrong payload shapes, and broken refactors that only show up in QA (or in production 😬)."
        },
        {
          "type": "list",
          "columns": [
            "If emits is NOT declared…",
            "What breaks",
            "Why it hurts"
          ],
          "rows": [
            [
              "You typo an event name (emit('udpate:modelValue'))",
              "Parent listener never runs",
              "Silent failure: everything looks wired, but nothing happens"
            ],
            [
              "Payload type/shape changes",
              "Parent code breaks at runtime (or behaves incorrectly)",
              "No compile-time signal; you discover it late"
            ],
            [
              "You refactor event names",
              "You miss call sites",
              "Events aren’t part of an explicit contract, so refactoring is risky"
            ],
            [
              "You ship reusable components",
              "Consumers don’t know the public event API",
              "Poor discoverability: people read the source or guess"
            ]
          ],
          "caption": "Common failure modes when emits isn’t declared"
        },
        {
          "type": "text",
          "text": "<strong>3. The biggest win: Type safety (Vue 3 + TypeScript)</strong><br><br>With declared emits, TypeScript can enforce both the <strong>event name</strong> and the <strong>payload type</strong>. Without it, <code>emit</code> is effectively untyped, so mistakes sneak through."
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// ✅ With declared emits\nconst emit = defineEmits<{ (e: 'submit', payload: { id: string }): void }>();\nemit('submit', { id: '123' });\n\n// ❌ These become compile errors:\n// emit('subimt', { id: '123' });          // typo\n// emit('submit', { id: 123 });            // wrong type\n// emit('submit');                         // missing payload\n\n// 🚫 Without declared emits, these can slip through as 'any'."
        },
        {
          "type": "text",
          "text": "<strong>4. Maintenance: emits = component contract</strong><br><br>Think of <code>emits</code> like documenting a component’s public API. Props define what comes <em>in</em>; emits define what goes <em>out</em>. When both are explicit, the component becomes easier to reuse, test, and refactor."
        },
        {
          "type": "text",
          "text": "<strong>5. Runtime validation (optional but helpful)</strong><br><br>Vue lets you validate emitted payloads at runtime if you use the <code>emits</code> option style (or declare validators). This is especially useful when TypeScript isn’t present everywhere (or for library components)."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Options API style (runtime validation)\nexport default {\n  emits: {\n    submit(payload) {\n      return payload && typeof payload.id === 'string';\n    }\n  },\n  methods: {\n    onSubmit() {\n      this.$emit('submit', { id: '123' });\n    }\n  }\n};"
        },
        {
          "type": "text",
          "text": "<strong>6. Security-ish / correctness-ish: listener fallthrough control</strong><br><br>In Vue 3, declaring <code>emits</code> helps Vue distinguish between component events and native DOM listeners passed to the root element. This reduces confusing edge cases where you think you’re listening to a component event but you’re actually attaching a DOM listener (or vice versa)."
        },
        {
          "type": "text",
          "text": "<strong>7. Practical heuristics (when to be strict)</strong><br><br>- For app code: always declare emits for components that are reused or shared across features.<br>- For UI library components: be extra strict; emits is part of your public API.<br>- For tiny one-off components: still worth it in Vue 3 + TS because it costs almost nothing and saves refactor pain later."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Quick mental model: <strong>props are inputs, emits are outputs</strong>. If you wouldn’t ship a function without typing its parameters, don’t ship a component without declaring its emitted events."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Declaring <code>emits</code> makes event APIs explicit and discoverable.</li><li>Without it, typos and payload mismatches can fail silently and are harder to refactor.</li><li>With Vue 3 + TypeScript, declared emits gives strong typing for event names and payloads.</li><li>Optional runtime validation can catch incorrect payloads even without TS.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "event-binding",
      "outputs",
      "components",
      "best-practices"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-ref-vs-reactive-difference-traps",
    "title": "ref vs reactive in Vue: what’s the real difference, when should you use each, and what are the common reactivity traps?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Explain the real difference between ref() and reactive() in Vue 3’s Composition API, when each is the better choice (primitives vs objects, replacement vs mutation, destructuring, template unwrapping), and the most common traps that lead to “why isn’t this updating?” bugs.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>ref()</code> wraps a value in an object with a <code>.value</code> property, while <code>reactive()</code> returns a Proxy of an object. The practical difference is: <strong>use ref for single values (especially primitives) and for values you’ll replace</strong>; <strong>use reactive for “state objects” you mostly mutate</strong>. Most bugs come from <em>destructuring</em>, <em>replacing reactive objects</em>, and <em>losing reactivity by pulling values out of proxies</em>."
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "ref()",
            "reactive()"
          ],
          "rows": [
            [
              "Works with primitives",
              "✅ Yes (recommended)",
              "🚫 No (expects object)"
            ],
            [
              "Return value",
              "{ value: ... } wrapper",
              "Proxy of the object"
            ],
            [
              "Update style",
              "Replace via <code>.value = ...</code> or mutate nested objects",
              "Mutate properties (e.g. <code>state.count++</code>)"
            ],
            [
              "Replacement",
              "✅ Easy (just set <code>.value</code>)",
              "⚠️ Reassigning loses reactivity if you overwrite the variable"
            ],
            [
              "Template usage",
              "Auto-unwraps <code>.value</code> in templates",
              "Used directly"
            ]
          ],
          "caption": "High-level differences between ref() and reactive()"
        },
        {
          "type": "text",
          "text": "<strong>1. ref(): best for primitives and replaceable values</strong><br><br>If the thing is a single value (number, string, boolean) or something you regularly replace (API result object, selected item, current tab), <code>ref</code> keeps it predictable."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { ref } from 'vue';\n\nconst count = ref(0);\ncount.value++;\n\nconst user = ref(null);\nuser.value = { id: 1, name: 'Ada' }; // easy replacement"
        },
        {
          "type": "text",
          "text": "<strong>2. reactive(): best for state objects you mutate</strong><br><br>If you naturally think in “state object with fields” and you mostly mutate properties, <code>reactive</code> is ergonomic."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive } from 'vue';\n\nconst state = reactive({\n  count: 0,\n  filters: { q: '', sort: 'asc' }\n});\n\nstate.count++;\nstate.filters.q = 'vue';"
        },
        {
          "type": "text",
          "text": "<strong>3. Trap #1: destructuring reactive breaks reactivity</strong><br><br>This is the #1 “why isn’t my UI updating?” moment. When you destructure from a reactive object, you pull out plain values and lose tracking."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive } from 'vue';\n\nconst state = reactive({ count: 0 });\n\n// ❌ Trap: loses reactivity\nconst { count } = state;\n\nstate.count++; // state changes\nconsole.log(count); // still 0 (stale)\n"
        },
        {
          "type": "text",
          "text": "<strong>Fix:</strong> use <code>toRefs()</code> (or <code>toRef()</code>) so destructured fields stay reactive."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive, toRefs } from 'vue';\n\nconst state = reactive({ count: 0 });\nconst { count } = toRefs(state);\n\ncount.value++;     // updates state.count\nstate.count++;     // updates count.value\n"
        },
        {
          "type": "text",
          "text": "<strong>4. Trap #2: replacing a reactive object breaks consumers</strong><br><br>With <code>reactive</code>, the Proxy identity matters. If you reassign the variable, anything holding the old proxy won’t see the new object."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive } from 'vue';\n\nlet state = reactive({ items: [] });\n\n// ❌ Trap: you replaced the proxy reference\nstate = reactive({ items: [1, 2, 3] });\n\n// Anything that captured the old 'state' won't update as you expect."
        },
        {
          "type": "text",
          "text": "<strong>Fix options:</strong><br>• Prefer <code>ref</code> if you need to replace wholesale.<br>• Or mutate the existing reactive object instead of replacing it."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Option A: use ref for replaceable objects\nimport { ref } from 'vue';\nconst state = ref({ items: [] });\nstate.value = { items: [1, 2, 3] };\n\n// Option B: mutate reactive object in place\nimport { reactive } from 'vue';\nconst s = reactive({ items: [] });\ns.items.splice(0, s.items.length, 1, 2, 3);"
        },
        {
          "type": "text",
          "text": "<strong>5. Trap #3: forgetting .value in script (but not in templates)</strong><br><br>Templates auto-unwrap refs, but JavaScript does not. People mix the two mental models and end up comparing or assigning the wrapper object."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { ref } from 'vue';\nconst count = ref(0);\n\n// ❌ Trap\n// if (count > 0) {}\n\n// ✅ Correct\nif (count.value > 0) {}\n</script>\n\n<template>\n  <!-- ✅ Auto-unwrap in templates -->\n  <p>{{ count }}</p>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>6. Trap #4: reactive + arrays, maps, and sets (mutation is fine, identity matters)</strong><br><br>Vue tracks mutations like <code>push</code>, <code>splice</code>, and property sets. The trap is when you expect reactivity after pulling values out and working with raw copies."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive } from 'vue';\n\nconst state = reactive({ items: [1, 2] });\nstate.items.push(3); // ✅ reactive\n\nconst itemsCopy = state.items.slice();\nitemsCopy.push(4);   // 🚫 not reactive (it's a copy)\n"
        },
        {
          "type": "text",
          "text": "<strong>7. Practical decision rules</strong><br><br><ul><li><strong>Use ref</strong> for primitives, DOM refs, and anything you replace (API results, selected entity, current step).</li><li><strong>Use reactive</strong> for cohesive state objects you mutate (form state, filter state).</li><li>If you want to destructure properties, use <code>toRefs()</code>.</li><li>If you keep wanting to replace the whole state object, you probably want <code>ref</code>, not <code>reactive</code>.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of it like this: <strong>ref is a box</strong> (you replace what’s inside), <strong>reactive is a smart object</strong> (you mutate fields). Most reactivity traps are basically “I took the value out and expected the magic to follow me.”"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li><code>ref()</code> wraps a value and updates via <code>.value</code> (best for primitives + replacements).</li><li><code>reactive()</code> returns a Proxy and updates via property mutation (best for state objects).</li><li>Common traps: destructuring reactive, reassigning reactive objects, forgetting <code>.value</code> in script, and mutating copies instead of the reactive source.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "composition-api",
      "reactivity",
      "state",
      "primitives",
      "objects"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-destructuring-breaks-reactivity-toRefs-toRef",
    "title": "Why does destructuring break reactivity in Vue? Explain toRefs, toRef, and how to safely extract reactive state",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 5,
    "description": "Explain why destructuring a reactive object in Vue breaks reactivity, how Vue’s Proxy-based tracking works, and how to use toRefs() and toRef() to safely extract reactive properties without losing updates.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In Vue 3, <code>reactive()</code> returns a <strong>Proxy</strong> that tracks property access and mutation. When you destructure properties from that object, you <strong>pull plain values out of the Proxy</strong>, so Vue can no longer track reads or writes. The fix is to use <code>toRefs()</code> or <code>toRef()</code>, which keep each extracted property <em>linked</em> to the original reactive source."
        },
        {
          "type": "text",
          "text": "<strong>1. The core problem: how Vue tracks reactivity</strong><br><br>Vue tracks reactivity by intercepting <em>property access</em> and <em>property mutation</em> on a Proxy. If you stop reading or writing through the Proxy, Vue can’t see what you’re doing anymore."
        },
        {
          "type": "text",
          "text": "<strong>2. The classic bug: destructuring a reactive object</strong><br><br>This looks innocent, but it breaks the reactive connection:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive } from 'vue';\n\nconst state = reactive({ count: 0 });\n\n// ❌ Trap: destructuring pulls out a plain number\nconst { count } = state;\n\nstate.count++;      // state updates\nconsole.log(count); // still 0 (stale)\n"
        },
        {
          "type": "text",
          "text": "Why? Because <code>count</code> is now just a <strong>number</strong>, not a reactive reference. Vue is no longer involved."
        },
        {
          "type": "text",
          "text": "<strong>3. The mental model</strong><br><br>- <code>reactive()</code> = a <strong>smart object (Proxy)</strong> that Vue watches.<br>- Destructuring = <strong>copying values out</strong> of that object.<br>- Copies are not reactive, so Vue loses the connection."
        },
        {
          "type": "text",
          "text": "<strong>4. The solution: toRefs()</strong><br><br><code>toRefs()</code> converts each property of a reactive object into a <strong>ref</strong> that stays connected to the original object."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive, toRefs } from 'vue';\n\nconst state = reactive({ count: 0, name: 'Ada' });\n\n// ✅ Safe: each field is now a ref linked to state\nconst { count, name } = toRefs(state);\n\ncount.value++;       // updates state.count\nstate.count++;       // updates count.value\n"
        },
        {
          "type": "text",
          "text": "<strong>5. toRef(): when you only need one property</strong><br><br>If you only want to extract a single property, use <code>toRef()</code> instead of converting everything."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive, toRef } from 'vue';\n\nconst state = reactive({ count: 0, name: 'Ada' });\n\n// ✅ Create a single reactive ref linked to state.count\nconst count = toRef(state, 'count');\n\ncount.value++;    // updates state.count\nstate.count++;    // updates count.value\n"
        },
        {
          "type": "text",
          "text": "<strong>6. Common place this bites people: composables</strong><br><br>If a composable returns a <code>reactive</code> object and you destructure it in the consumer, you silently lose reactivity."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// useCounter.js\nimport { reactive } from 'vue';\nexport function useCounter() {\n  const state = reactive({ count: 0 });\n  return state;\n}\n\n// ❌ In component\nconst { count } = useCounter(); // loses reactivity\n"
        },
        {
          "type": "text",
          "text": "<strong>Fix:</strong> either return <code>toRefs(state)</code> from the composable, or wrap the result with <code>toRefs()</code> at the call site."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// useCounter.js (better)\nimport { reactive, toRefs } from 'vue';\nexport function useCounter() {\n  const state = reactive({ count: 0 });\n  return toRefs(state);\n}\n\n// In component\nconst { count } = useCounter(); // ✅ stays reactive"
        },
        {
          "type": "text",
          "text": "<strong>7. How this relates to ref()</strong><br><br><code>ref</code>s are <em>already safe to destructure</em> because the reactivity lives in <code>.value</code>, not in a Proxy identity."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { ref } from 'vue';\n\nconst count = ref(0);\nconst { value } = count; // just a number copy\n\n// But normally you pass around the ref itself, not destructure .value"
        },
        {
          "type": "text",
          "text": "<strong>8. Practical rules of thumb</strong><br><br><ul><li>Never destructure a <code>reactive()</code> object directly.</li><li>If you want to extract fields: use <code>toRefs()</code> or <code>toRef()</code>.</li><li>If you want to freely destructure and pass values around, consider using <code>ref</code>s instead of a single reactive object.</li><li>Composables should usually return <code>toRefs(state)</code>, not the raw reactive object.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Intuition: <strong>reactivity lives in the Proxy, not in the values</strong>. Destructuring takes the values and leaves the magic behind."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Destructuring breaks reactivity because it extracts plain values from Vue’s Proxy.</li><li><code>toRefs()</code> converts each property into a ref that stays linked to the source object.</li><li><code>toRef()</code> creates a single linked ref for one property.</li><li>Use these helpers whenever you need to extract or return pieces of reactive state safely.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "composition-api",
      "reactivity",
      "objects",
      "state",
      "best-practices"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 2,
      "passCritical": 2,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-watch-vs-watcheffect-differences-infinite-loops",
    "title": "watch vs watchEffect in Vue: what’s the difference, when does each run, and how can you accidentally create infinite loops?",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 1,
    "description": "Explain the difference between watch() and watchEffect() in Vue 3, when each one runs, how dependency tracking works (explicit vs automatic), and the common patterns that accidentally cause infinite update loops.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>watch()</code> and <code>watchEffect()</code> both run side effects in response to reactive changes, but they work very differently: <strong>watch is explicit and lazy</strong> (you choose what to watch), while <strong>watchEffect is automatic and eager</strong> (Vue tracks everything you touch inside). Most bugs come from not realizing <em>what is being tracked</em> and from <em>mutating the same state you’re watching</em>."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "watch()",
            "watchEffect()"
          ],
          "rows": [
            [
              "Dependency tracking",
              "Explicit (you pass the source)",
              "Automatic (tracks what you read inside)"
            ],
            [
              "When it runs first time",
              "Only on change (unless immediate: true)",
              "Runs immediately once"
            ],
            [
              "Access to old/new value",
              "✅ Yes (newVal, oldVal)",
              "❌ No (no diff info)"
            ],
            [
              "Typical use",
              "React to a specific piece of state",
              "Run an effect that depends on many things"
            ],
            [
              "Predictability",
              "High",
              "Lower (depends on what gets accessed)"
            ]
          ],
          "caption": "watch() vs watchEffect() at a glance"
        },
        {
          "type": "text",
          "text": "<strong>1. watch(): explicit, targeted, predictable</strong><br><br>You tell Vue exactly what to watch. It runs only when that source changes."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { ref, watch } from 'vue';\n\nconst query = ref('');\n\nwatch(query, (newVal, oldVal) => {\n  console.log('query changed from', oldVal, 'to', newVal);\n  // e.g. fetchData(newVal)\n});"
        },
        {
          "type": "text",
          "text": "By default, this does <strong>not</strong> run on mount. You can opt in:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "watch(query, () => { /* ... */ }, { immediate: true });"
        },
        {
          "type": "text",
          "text": "<strong>2. watchEffect(): automatic, eager, convenient</strong><br><br>Vue runs the function immediately, tracks every reactive value you <em>touch</em>, and re-runs it when any of them changes."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { ref, watchEffect } from 'vue';\n\nconst query = ref('');\nconst page = ref(1);\n\nwatchEffect(() => {\n  // Vue automatically tracks: query.value and page.value\n  fetchData(query.value, page.value);\n});"
        },
        {
          "type": "text",
          "text": "<strong>3. When should you use which?</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Situation",
            "Prefer"
          ],
          "rows": [
            [
              "React to one specific value changing",
              "watch()"
            ],
            [
              "Need old vs new value",
              "watch()"
            ],
            [
              "Effect depends on many reactive values",
              "watchEffect()"
            ],
            [
              "You want it to run immediately",
              "watchEffect() (or watch + immediate)"
            ],
            [
              "You want maximum predictability",
              "watch()"
            ]
          ],
          "caption": "Practical decision table"
        },
        {
          "type": "text",
          "text": "<strong>4. The #1 footgun: creating an infinite loop</strong><br><br>If your watcher <strong>mutates the same reactive state that it depends on</strong>, you can easily create a self-triggering loop."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { ref, watchEffect } from 'vue';\n\nconst count = ref(0);\n\n// ❌ Infinite loop\nwatchEffect(() => {\n  if (count.value < 10) {\n    count.value++; // This mutation retriggers the effect\n  }\n});"
        },
        {
          "type": "text",
          "text": "The same bug can happen with <code>watch()</code> if you write back to the watched source without guarding:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "watch(count, (v) => {\n  // ❌ This will loop forever\n  count.value = v + 1;\n});"
        },
        {
          "type": "text",
          "text": "<strong>5. How to avoid infinite loops</strong><br><br><ul><li>Don’t mutate the same source you are watching.</li><li>If you must, add guards (if conditions, equality checks).</li><li>Prefer deriving state with <code>computed</code> instead of syncing state with watchers.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>6. Subtle watchEffect trap: accidental dependencies</strong><br><br>Because <code>watchEffect</code> tracks everything you read, even a <code>console.log(someRef.value)</code> or a debug read can become a dependency and retrigger the effect."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "watchEffect(() => {\n  console.log(debugFlag.value); // now this is a dependency\n  fetchData(query.value);\n});"
        },
        {
          "type": "text",
          "text": "<strong>7. Cleanup and async effects</strong><br><br>Both APIs support cleanup via <code>onCleanup</code>, which is critical for cancelling requests or timers."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "watchEffect((onCleanup) => {\n  const controller = new AbortController();\n  fetch(url.value, { signal: controller.signal });\n\n  onCleanup(() => controller.abort());\n});"
        },
        {
          "type": "text",
          "text": "<strong>8. Practical rule of thumb</strong><br><br>- If you can describe the dependency in one sentence: use <code>watch()</code>.<br>- If the dependency is “whatever I touch in here”: use <code>watchEffect()</code>.<br>- If you’re syncing state: ask yourself if this should be a <code>computed</code> instead."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Mental model: <strong>watch is declarative (“watch this”)</strong>, <strong>watchEffect is reactive magic (“rerun when anything I use changes”)</strong>. Magic is convenient — and that’s why it’s easier to shoot yourself in the foot."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li><code>watch()</code> is explicit, lazy, and gives you old/new values.</li><li><code>watchEffect()</code> is automatic, eager, and tracks dependencies implicitly.</li><li>Infinite loops happen when the effect mutates the same state it depends on.</li><li>Prefer <code>computed</code> for derived state, and use guards when mutating inside watchers.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "watch",
      "effects",
      "reactivity",
      "performance"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 0,
      "passCritical": 0,
      "detailPenalty": 2,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-nexttick-dom-update-queue",
    "title": "What does nextTick() do in Vue, and why are DOM measurements wrong immediately after a state change?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 3,
    "description": "Explain what nextTick() does in Vue, how Vue batches and schedules DOM updates asynchronously, why the DOM is not updated immediately after reactive state changes, and when you must wait for nextTick() to safely read layout or measure elements.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In Vue, <strong>state changes do not update the DOM synchronously</strong>. Vue batches multiple reactive updates and applies them in the next render cycle for performance. <code>nextTick()</code> lets you <strong>wait until Vue has flushed all pending DOM updates</strong>. If you measure the DOM immediately after changing state, you often read the <em>old layout</em>."
        },
        {
          "type": "text",
          "text": "<strong>1. The core idea: Vue updates are async and batched</strong><br><br>When you change reactive state, Vue does <em>not</em> patch the DOM immediately. It queues the component for re-render and processes all changes together in the next microtask tick."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { ref, nextTick } from 'vue';\n\nconst open = ref(false);\n\nfunction show() {\n  open.value = true;\n  // ❌ DOM is NOT updated yet\n}"
        },
        {
          "type": "text",
          "text": "<strong>2. The classic bug: measuring too early</strong><br><br>This is why DOM measurements right after a state change are often wrong:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function show() {\n  open.value = true;\n\n  const h = panelRef.value.offsetHeight;\n  console.log(h); // ❌ Often 0 or old value\n}"
        },
        {
          "type": "text",
          "text": "The template has not been re-rendered yet, so the element is still in its previous state."
        },
        {
          "type": "text",
          "text": "<strong>3. nextTick(): wait until the DOM is updated</strong><br><br><code>nextTick()</code> returns a Promise that resolves <strong>after Vue has finished flushing the DOM updates</strong> for the current batch."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { nextTick } from 'vue';\n\nasync function show() {\n  open.value = true;\n\n  await nextTick();\n  // ✅ Now the DOM reflects the new state\n  const h = panelRef.value.offsetHeight;\n  console.log(h); // correct value\n}"
        },
        {
          "type": "text",
          "text": "<strong>4. What nextTick() actually means</strong><br><br>It does <em>not</em> mean “wait one frame” or “wait some time”. It means: <strong>wait until Vue’s pending render queue is flushed</strong>."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "What happens"
          ],
          "rows": [
            [
              "1. You change reactive state",
              "Vue marks components as dirty and queues an update"
            ],
            [
              "2. Your synchronous code continues",
              "DOM is still old"
            ],
            [
              "3. Vue flushes the update queue (microtask)",
              "Virtual DOM re-renders and patches the real DOM"
            ],
            [
              "4. nextTick() resolves",
              "DOM is now up-to-date"
            ]
          ],
          "caption": "The Vue update cycle simplified"
        },
        {
          "type": "text",
          "text": "<strong>5. Why Vue does this (performance)</strong><br><br>If Vue updated the DOM immediately on every state change, multiple changes in one tick would cause <strong>multiple layouts, reflows, and repaints</strong>. By batching them, Vue can update the DOM <strong>once</strong> per tick."
        },
        {
          "type": "text",
          "text": "<strong>6. Common real-world cases where you need nextTick()</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "Why nextTick is needed"
          ],
          "rows": [
            [
              "Opening/closing a panel or modal",
              "You need to measure its size after it appears"
            ],
            [
              "v-if / v-for changes",
              "The element does not exist in the DOM yet"
            ],
            [
              "Scrolling to a newly rendered item",
              "The element is not in the DOM until after render"
            ],
            [
              "Integrating with non-Vue libraries",
              "They expect the DOM to already be updated"
            ]
          ],
          "caption": "Typical nextTick() use cases"
        },
        {
          "type": "text",
          "text": "<strong>7. nextTick vs setTimeout / requestAnimationFrame</strong><br><br><code>nextTick()</code> waits for <strong>Vue’s render flush</strong>, not for a timer or the next frame. It is more precise and faster than <code>setTimeout(..., 0)</code> hacks."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// ❌ Hacky and less precise\nsetTimeout(() => measure(), 0);\n\n// ✅ Correct\nawait nextTick();\nmeasure();"
        },
        {
          "type": "text",
          "text": "<strong>8. Subtle case: multiple state changes</strong><br><br>Even if you change state multiple times synchronously, Vue will still only update the DOM once, and <code>nextTick()</code> waits for that single final result."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "count.value++;\ncount.value++;\ncount.value++;\n\nawait nextTick();\n// DOM is updated once with the final value"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Mental model: <strong>state changes schedule a render, nextTick waits for that render to finish</strong>."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Vue batches DOM updates and applies them asynchronously.</li><li>Right after a state change, the DOM is still in the old state.</li><li><code>nextTick()</code> waits until Vue has flushed the pending DOM updates.</li><li>Use it whenever you need to read layout, measure elements, or interact with DOM that depends on the new state.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "timing",
      "dom",
      "performance",
      "reactivity"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 1,
      "passCritical": 1,
      "detailPenalty": 0,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  },
  {
    "id": "vue-v-for-keys-why-not-index",
    "title": "Why are keys critical in v-for? What exactly breaks when you use array index as a key?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 1,
    "description": "Explain why keys are required in v-for, how Vue uses them during virtual DOM diffing, and what subtle but serious bugs happen when you use array index as a key (state reuse, wrong DOM nodes, broken animations, and input mix-ups).",
    "seo": {
      "title": "Vue v-for keys: why index breaks state & inputs",
      "description": "Using array index as a key makes Vue reuse the wrong DOM nodes. Learn what breaks (inputs swap, stale state, glitchy animations) and the safe pattern."
    },
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Keys are how Vue <strong>identifies which virtual DOM node corresponds to which real DOM node</strong> across renders. If keys are stable and unique, Vue can correctly <em>reuse, move, or destroy</em> elements. If keys are wrong (or you use the array index), Vue will <strong>reuse the wrong DOM nodes</strong>, causing bugs like inputs swapping values, components keeping the wrong state, and animations glitching."
        },
        {
          "type": "text",
          "text": "<strong>1. What Vue actually does when a list changes</strong><br><br>When a list rendered with <code>v-for</code> changes, Vue does not recreate the whole DOM. It <strong>diffs the old list and the new list</strong> and tries to match items using their <code>key</code>."
        },
        {
          "type": "list",
          "columns": [
            "With good keys",
            "With bad keys (or index)"
          ],
          "rows": [
            [
              "Vue moves the correct DOM nodes",
              "Vue reuses DOM nodes for the wrong items"
            ],
            [
              "Component state stays with the right item",
              "Component state gets attached to the wrong item"
            ],
            [
              "Minimal DOM operations",
              "Unpredictable patches and visual glitches"
            ]
          ],
          "caption": "How keys affect Vue’s diffing behavior"
        },
        {
          "type": "text",
          "text": "<strong>2. The correct pattern</strong><br><br>Always use a <strong>stable, unique ID</strong> that represents the identity of the item, not its position."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<li v-for=\"todo in todos\" :key=\"todo.id\">\n  <TodoItem :todo=\"todo\" />\n</li>"
        },
        {
          "type": "text",
          "text": "<strong>3. The tempting but dangerous pattern</strong><br><br>Using the array index looks fine… until the list changes."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ❌ Bad -->\n<li v-for=\"(todo, index) in todos\" :key=\"index\">\n  <TodoItem :todo=\"todo\" />\n</li>"
        },
        {
          "type": "text",
          "text": "<strong>4. What exactly breaks when you use index as key?</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Operation",
            "What you expect",
            "What actually happens with index key"
          ],
          "rows": [
            [
              "Insert item at top",
              "New DOM node is created at top",
              "Vue reuses every existing DOM node and just shifts data"
            ],
            [
              "Remove an item",
              "That item’s DOM and component state are destroyed",
              "A different item’s DOM gets reused and keeps stale state"
            ],
            [
              "Reorder list (sort, drag & drop)",
              "Items move with their DOM and state",
              "DOM stays in place, only data changes → state mismatch"
            ],
            [
              "Edit inputs in a list",
              "Each input keeps its own value",
              "Values appear to jump to other rows"
            ]
          ],
          "caption": "Concrete bugs caused by index as key"
        },
        {
          "type": "text",
          "text": "<strong>5. The classic horror demo: inputs swapping values</strong>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<div v-for=\"(user, i) in users\" :key=\"i\">\n  <input v-model=\"user.name\" />\n</div>\n\n<button @click=\"users.unshift({ name: '' })\">Add to top</button>"
        },
        {
          "type": "text",
          "text": "When you click the button, <strong>the text you typed appears to move to a different row</strong>. Vue reused DOM nodes by position, not by identity."
        },
        {
          "type": "text",
          "text": "<strong>6. Why Vue can’t magically fix this</strong><br><br>Vue has no way to know whether an item at index 0 is “the same logical item as before” or a different one. The <code>key</code> is the <strong>only identity signal</strong> you give to the diffing algorithm."
        },
        {
          "type": "text",
          "text": "<strong>7. When is index as key actually safe?</strong><br><br>Almost never — but technically OK if <strong>all of these are true</strong>:<ul><li>The list is static (no insert/remove/reorder).</li><li>The list items have no internal state (no inputs, no components with state).</li><li>You will never filter or sort it.</li></ul>In practice: for real apps, just don’t."
        },
        {
          "type": "text",
          "text": "<strong>8. How this relates to performance</strong><br><br>Good keys don’t just fix bugs — they also make updates <strong>faster</strong> because Vue can move nodes instead of destroying and recreating them."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Mental model: <strong>keys tell Vue “who is who”</strong>. If you lie about identity (using index), Vue will faithfully do the wrong thing — very efficiently."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Keys define the identity of list items for Vue’s diffing algorithm.</li><li>Using index as key ties identity to position, not to the actual item.</li><li>This causes state to stick to the wrong DOM nodes: broken inputs, wrong component state, glitchy animations.</li><li>Always use a stable, unique ID from the data itself.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia",
    "tags": [
      "vue",
      "lists",
      "iteration",
      "performance",
      "structure",
      "keys"
    ],
    "updatedAt": "2026-01-30",
    "importanceRubric": {
      "coreness": 0,
      "passCritical": 0,
      "detailPenalty": 1,
      "crossCompany": 0,
      "frequencyBonus": 0
    }
  }
]
