[
  {
    "id": "vue-reactivity-vs-react-concepts",
    "title": "What problems does Vue’s reactivity system solve, and how does Vue differ from React conceptually?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what Vue’s reactivity engine (dependency tracking + batched updates) gives you in day-to-day UI work, and contrast Vue’s mental model with React’s render/reconciliation model.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>What Vue reactivity solves (the practical problems)</strong><br><br>In UI code you constantly fight the same issues: keeping DOM in sync with state, updating derived values efficiently, and avoiding “update everything” work. Vue’s reactivity system solves these by automatically tracking what your UI depends on and updating only what’s affected when state changes."
        },
        {
          "type": "list",
          "columns": [
            "Problem in UI apps",
            "Without reactivity you do...",
            "Vue reactivity gives you..."
          ],
          "rows": [
            [
              "State → DOM synchronization",
              "Manually set text/classes/attributes or write glue code everywhere",
              "Declarative templates; mutate state and the DOM updates automatically"
            ],
            [
              "Derived state (filters, totals, formatting)",
              "Recompute on every render or cache manually",
              "computed() is cached automatically and invalidated only when dependencies change"
            ],
            [
              "Avoiding unnecessary work",
              "Re-render or recompute too much, then add manual memoization",
              "Dependency tracking updates only the effects/components that actually touched the changed property"
            ],
            [
              "Batching multiple changes",
              "Accidentally trigger multiple paints/renders in a row",
              "Updates are queued/deduped and flushed (microtask) so many mutations typically produce one DOM patch"
            ],
            [
              "Side effects based on state changes",
              "Wire custom subscriptions and cleanup",
              "watch()/watchEffect() run when tracked dependencies change, with controlled timing (flush options)"
            ]
          ],
          "caption": "What problems Vue reactivity solves"
        },
        {
          "type": "text",
          "text": "<strong>What Vue is doing under the hood (high level)</strong><br><br>Vue 3 wraps state in Proxies. When code runs inside a reactive “effect” (component render, computed, watcher), any reactive <code>get</code> is tracked. When you later <code>set</code> a reactive property, Vue triggers only the effects that previously read that property. Those effects are scheduled and batched, then Vue patches the DOM."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Vue 3 (Composition API) - fine-grained dependency tracking -->\n<script setup>\nimport { ref, computed } from 'vue';\n\nconst price = ref(100);\nconst qty = ref(2);\n\n// Cached until price/qty changes\nconst total = computed(() => price.value * qty.value);\n\nfunction addOne() {\n  qty.value++;\n}\n</script>\n\n<template>\n  <p>Qty: {{ qty }}</p>\n  <p>Total: {{ total }}</p>\n  <button @click=\"addOne\">+1</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>How Vue differs from React conceptually</strong><br><br>The biggest difference is the update model:<br>• <strong>Vue:</strong> “push” model. Dependency graph decides what to update (<em>who depends on what</em>). Component updates happen because reactive reads were tracked.<br>• <strong>React:</strong> “render-as-a-function” model. State updates schedule a re-render of a component; during re-render React re-executes your component function to compute the next UI, then reconciles."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Vue (conceptual model)",
            "React (conceptual model)"
          ],
          "rows": [
            [
              "Update trigger",
              "Reactive property write triggers tracked dependents (effects/components)",
              "setState/useState setter schedules component re-render"
            ],
            [
              "Granularity",
              "Property-level dependency tracking; avoids updating unrelated dependents",
              "Component-level re-render by default; you add memoization/selectors to skip work"
            ],
            [
              "Authoring UI",
              "Templates (compiled) + directives; JS in script section (SFC)",
              "JSX/TSX (UI is JS); everything expressed as functions/components"
            ],
            [
              "Optimization story",
              "Compiler hints (patch flags/block tree) + reactive tracking reduce diffing work",
              "Reconciliation + memo/useMemo/useCallback + architecture patterns reduce re-render cost"
            ],
            [
              "Derived state",
              "computed() is first-class and cached by default",
              "Derived values computed during render; caching is manual (useMemo) or via external stores"
            ],
            [
              "Two-way binding",
              "Built-in pattern (<code>v-model</code>) for form bindings",
              "Explicit: value + onChange (controlled components) or uncontrolled refs"
            ],
            [
              "Mental model summary",
              "Mutate reactive state; Vue figures out what depends on it",
              "Update state; React re-runs render to recompute UI"
            ]
          ],
          "caption": "Vue vs React: conceptual differences"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// React - re-render computes next UI\nimport { useMemo, useState } from 'react';\n\nexport function Cart() {\n  const [price, setPrice] = useState(100);\n  const [qty, setQty] = useState(2);\n\n  // Optional caching (manual)\n  const total = useMemo(() => price * qty, [price, qty]);\n\n  return (\n    <>\n      <p>Qty: {qty}</p>\n      <p>Total: {total}</p>\n      <button onClick={() => setQty(q => q + 1)}>+1</button>\n    </>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br>Vue’s reactivity exists to remove manual DOM sync and to make updates precise via dependency tracking + batching. React’s core idea is re-running component functions to describe the next UI and reconciling the result. Vue leans on a reactive graph + compiler; React leans on a render cycle + reconciliation, with optimization patterns layered on top."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-vs-react",
    "title": "What is the difference between Vue.js and React?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Vue.js and React are both popular JavaScript frameworks for building user interfaces, but they differ in design philosophy, syntax, reactivity handling, and learning curve. Vue is more opinionated and template-based, while React emphasizes JavaScript-driven, declarative UI creation using JSX.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vue.js and React are two of the most widely used front-end frameworks in modern web development. Both aim to make building user interfaces more efficient, but they differ in structure, syntax, and design philosophy. While Vue is a full-featured framework with a focus on simplicity and declarative templates, React is a flexible library centered around JSX and functional programming."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Vue.js",
            "React"
          ],
          "rows": [
            [
              "Design Philosophy",
              "A progressive framework focusing on simplicity and integration.",
              "A library for building UIs emphasizing flexibility and JavaScript control."
            ],
            [
              "Syntax",
              "Uses HTML-based templates with directives (like v-if, v-for).",
              "Uses JSX — a syntax extension allowing HTML inside JavaScript."
            ],
            [
              "Reactivity",
              "Built-in reactivity system using proxies and dependency tracking.",
              "Uses a virtual DOM and state updates through hooks like useState()."
            ],
            [
              "Learning Curve",
              "Gentle — easy for beginners to pick up with existing HTML/CSS knowledge.",
              "Moderate — requires understanding of JSX, props, and functional components."
            ],
            [
              "State Management",
              "Uses Vuex (v2) or Pinia (v3+) as official state libraries.",
              "Uses Redux, Zustand, or React Context API for global state management."
            ],
            [
              "Routing",
              "Official router: Vue Router, tightly integrated.",
              "React Router is community-driven and separately maintained."
            ],
            [
              "Performance",
              "Excellent due to dependency tracking and efficient updates.",
              "Excellent due to virtual DOM and optimized diffing algorithm."
            ],
            [
              "Community",
              "Smaller but highly dedicated and documentation-focused.",
              "Larger ecosystem with extensive community support and third-party tools."
            ]
          ],
          "caption": "Comparison Between Vue.js and React"
        },
        {
          "type": "text",
          "text": "<strong>Vue.js Approach</strong><br>Vue focuses on simplicity and separation of concerns. It allows developers to use declarative templates (HTML) while maintaining reactivity through its internal system. Vue offers official libraries for routing, state management, and animation, ensuring consistency across projects."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <div>\n    <p>{{ message }}</p>\n    <button @click=\"changeMessage\">Change</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return { message: 'Hello Vue!' };\n  },\n  methods: {\n    changeMessage() {\n      this.message = 'Message Updated!';\n    }\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>React Approach</strong><br>React promotes a JavaScript-first design. The UI is defined using JSX and controlled entirely through component state and props. This gives developers greater flexibility and control, but also requires a deeper understanding of JavaScript and rendering flow."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React, { useState } from 'react';\n\nfunction App() {\n  const [message, setMessage] = useState('Hello React!');\n\n  return (\n    <div>\n      <p>{message}</p>\n      <button onClick={() => setMessage('Message Updated!')}>Change</button>\n    </div>\n  );\n}\n\nexport default App;"
        },
        {
          "type": "text",
          "text": "<strong>Performance Comparison</strong><br>Both frameworks use a virtual DOM for efficient rendering. Vue’s advantage lies in its fine-grained reactivity system that tracks dependencies automatically, while React relies on re-rendering virtual nodes and reconciling them efficiently through its diffing algorithm."
        },
        {
          "type": "text",
          "text": "<strong>Use Cases</strong><br><ul><li><strong>Vue.js:</strong> Best for teams looking for simplicity, quick prototyping, and clear separation between logic and template.</li><li><strong>React:</strong> Ideal for complex UIs, large-scale apps, and teams familiar with JavaScript-first development.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Vue.js as a structured painter’s canvas — HTML templates define the layout, and reactivity adds life. React, on the other hand, is a sculptor’s tool — everything is carved directly with JavaScript."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Vue.js offers simplicity with HTML templates and built-in reactivity.</li><li>React offers flexibility with JSX and a functional, JavaScript-driven approach.</li><li>Both provide high performance, strong ecosystems, and component-based architecture.</li><li>Choice depends on team preference, project scale, and developer experience.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-internal-rendering-pipeline",
    "title": "How does Vue track state changes and trigger re-renders internally?",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 5,
    "description": "Vue re-renders components by combining (1) reactive state (Proxy-based in Vue 3), (2) dependency tracking (track/trigger), and (3) a scheduler that batches component updates, then patches the DOM via virtual DOM diffing (optimized with compiler hints like patch flags).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Vue doesn’t “poll” your state. It records <em>who read what</em> during render, and when that state changes it re-runs only the affected render effects."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "What happens internally",
            "Why it matters"
          ],
          "rows": [
            [
              "1) Make state reactive",
              "Vue wraps objects with a Proxy (Vue 3) so it can intercept <code>get</code>/<code>set</code>.",
              "Lets Vue observe reads/writes without you calling setState."
            ],
            [
              "2) Render inside an effect",
              "Each component render runs inside a reactive “effect” (think: tracked function).",
              "Any reactive reads during render become dependencies."
            ],
            [
              "3) Track dependencies on reads",
              "On <code>get</code>, Vue calls <code>track(target, key)</code> to link (target,key) → activeEffect.",
              "Vue learns exactly which component depends on which property."
            ],
            [
              "4) Trigger on writes",
              "On <code>set</code>, Vue calls <code>trigger(target, key)</code> to find all effects depending on (target,key).",
              "Only affected components/computed/watchers are scheduled."
            ],
            [
              "5) Batch updates",
              "Component effects are queued (deduped) and flushed in a microtask (scheduler).",
              "Multiple synchronous mutations cause only one re-render per component."
            ],
            [
              "6) Re-render + patch DOM",
              "Re-run render → new VNode tree → <code>patch(oldVNode, newVNode)</code> updates DOM.",
              "Virtual DOM diff updates only what changed."
            ]
          ],
          "caption": "Vue’s internal reactivity → rendering pipeline"
        },
        {
          "type": "text",
          "text": "<strong>Dependency tracking (track/trigger) in simplified pseudo-code</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Highly simplified mental model (not Vue source)\nconst targetMap = new WeakMap();\nlet activeEffect = null;\n\nfunction track(target, key) {\n  if (!activeEffect) return;\n  let depsMap = targetMap.get(target);\n  if (!depsMap) targetMap.set(target, (depsMap = new Map()));\n  let dep = depsMap.get(key);\n  if (!dep) depsMap.set(key, (dep = new Set()));\n  dep.add(activeEffect);\n}\n\nfunction trigger(target, key) {\n  const depsMap = targetMap.get(target);\n  const dep = depsMap?.get(key);\n  if (!dep) return;\n  dep.forEach(effect => effect.scheduler ? effect.scheduler(effect) : effect.run());\n}\n\nfunction effect(fn, scheduler) {\n  const e = {\n    run() {\n      activeEffect = e;\n      try { return fn(); } finally { activeEffect = null; }\n    },\n    scheduler\n  };\n  e.run();\n  return e;\n}"
        },
        {
          "type": "text",
          "text": "<strong>How “re-render” is actually wired</strong><br><br>Each component has a render effect. When its dependencies trigger, Vue doesn’t immediately run it; it queues it."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Conceptually\nconst componentUpdateEffect = effect(\n  () => {\n    const nextVNodeTree = renderComponent();\n    patch(prevVNodeTree, nextVNodeTree);\n    prevVNodeTree = nextVNodeTree;\n  },\n  (job) => queueJob(job) // scheduler batching\n);"
        },
        {
          "type": "text",
          "text": "<strong>Scheduler / batching</strong><br><br>Vue queues component jobs and flushes them in a microtask. So if you do <code>state.a++</code> then <code>state.b++</code> synchronously, the component typically renders once. <code>nextTick()</code> resolves after the queued DOM patches are applied."
        },
        {
          "type": "text",
          "text": "<strong>Vue 3 render performance extra</strong><br><br>Vue 3’s compiler adds hints (patch flags + block tree) so the runtime can skip diffing stable parts of the template and focus on dynamic bindings. Reactivity decides <em>which components update</em>; patch flags help decide <em>how much work the DOM patch does</em> within that update."
        },
        {
          "type": "list",
          "columns": [
            "Reactive primitive",
            "Internal behavior",
            "Update timing"
          ],
          "rows": [
            [
              "computed()",
              "Runs as a lazy effect; caches value until a dependency triggers (marks it “dirty”).",
              "Recomputes on next access, not immediately on every change."
            ],
            [
              "watch()",
              "Creates an effect on a getter; on trigger runs a callback (side effects).",
              "Flush can be <code>pre</code>/<code>post</code>/<code>sync</code> (controls when callback runs relative to render)."
            ],
            [
              "ref()",
              "Wraps a value; reads/writes track/trigger via <code>.value</code>.",
              "Same scheduler rules when used by components."
            ]
          ],
          "caption": "Where computed/watch/ref fit in the same engine"
        },
        {
          "type": "text",
          "text": "<strong>Practical implications / common gotchas</strong><br><br>• If you destructure reactive objects (e.g., <code>const { x } = reactiveObj</code>), you may lose tracking because the render no longer reads through the Proxy.<br>• If you mutate many things in a row, expect one render (batched), and use <code>await nextTick()</code> when you need DOM to be updated.<br>• If something doesn’t update, it usually means the render didn’t read that reactive source (no dependency tracked)."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Vue tracks reactive reads during render (track), schedules dependent component effects on writes (trigger → queue), then re-renders and patches the DOM in a batched flush. That’s the whole “state change → re-render” loop."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-data-must-be-function",
    "title": "Why must data be a function in Vue components, and what breaks if it isn’t?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "In Vue’s Options API, component state must be defined with data() returning a fresh object per component instance. Explain why this matters and what bugs appear when data is a plain object.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>data()</code> must be a function in reusable component definitions so Vue can create a <em>new state object per component instance</em>. If you use a plain object, every instance points to the <em>same object reference</em> (shared state)."
        },
        {
          "type": "list",
          "columns": [
            "data option",
            "What Vue needs",
            "What happens in practice"
          ],
          "rows": [
            [
              "<code>data() { return { ... } }</code>",
              "A factory that returns a new object per instance",
              "Each component instance has isolated state"
            ],
            [
              "<code>data: { ... }</code>",
              "A single object",
              "All instances share the same state (cross-instance leaks)"
            ]
          ],
          "caption": "Why Vue requires data() in components"
        },
        {
          "type": "text",
          "text": "<strong>What breaks if <code>data</code> is an object?</strong><br><br>Nothing “crashes” immediately—Vue can still make it reactive—but your component stops being instance-safe. The bugs show up as state leaking between instances."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- WRONG: shared state across instances -->\n<script>\nconst Counter = {\n  template: `\n    <button @click=\"count++\">Count: {{ count }}</button>\n  `,\n  data: { count: 0 } // ❌ shared reference\n};\n\nexport default {\n  components: { Counter }\n};\n</script>\n\n<template>\n  <Counter />\n  <Counter />\n</template>\n\n<!-- Click one button -> both counters update because they share the same 'count'. -->"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- CORRECT: per-instance state -->\n<script>\nconst Counter = {\n  template: `\n    <button @click=\"count++\">Count: {{ count }}</button>\n  `,\n  data() {\n    return { count: 0 }; // ✅ new object per instance\n  }\n};\n\nexport default {\n  components: { Counter }\n};\n</script>\n\n<template>\n  <Counter />\n  <Counter />\n</template>"
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "Symptom",
            "Why it happens"
          ],
          "rows": [
            [
              "Rendering the same component multiple times",
              "Changing state in one instance changes the others",
              "All instances reference the same object"
            ],
            [
              "Lists (<code>v-for</code>) of stateful components",
              "Items “share” state unexpectedly (especially with filtering/sorting)",
              "Instances are supposed to be isolated; shared data violates that"
            ],
            [
              "SSR (Nuxt / server rendering)",
              "Request-to-request state leakage between users",
              "Server process reuses the same module/object across requests"
            ]
          ],
          "caption": "Real-world breakages from shared component data"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>• If you want <em>instance state</em> (almost always): use <code>data()</code>.<br>• If you want <em>intentionally shared state</em>: don’t “accidentally” share via <code>data: {}</code>—use a store (Pinia) or a clearly named shared module/composable."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Vue requires <code>data()</code> in component definitions because components are instantiated multiple times. A function returns a fresh object per instance. If <code>data</code> is a plain object, state becomes shared, causing cross-instance bugs and (in SSR) even cross-user data leaks."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-reactive-interpolation-into-dom",
    "title": "How does Vue interpolate reactive state into the DOM?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what happens from a template expression like {{ count }} to a real DOM text node update: template compilation, dependency tracking during render, scheduling/batching, and DOM patching. Mention how Vue handles refs in templates and why interpolation escapes HTML by default.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>The core idea</strong><br><br>Vue doesn’t “re-run the whole DOM.” It compiles <code>{{ ... }}</code> into a render function that creates a Virtual DOM (VNode) tree. During render, Vue tracks which reactive properties were read. When one of those properties changes, Vue schedules the component update, re-runs the render function, diffs old vs new VNodes, and patches only the affected DOM nodes (e.g., a single text node)."
        },
        {
          "type": "list",
          "columns": [
            "Stage",
            "What Vue does",
            "Why it matters"
          ],
          "rows": [
            [
              "1) Compile template",
              "<code>{{ count }}</code> becomes code that produces a text VNode (via <code>toDisplayString(count)</code>).",
              "Interpolation is not “magic at runtime”; it’s mostly compiler output + runtime patching."
            ],
            [
              "2) Mount (first render)",
              "Runs render inside a reactive effect. Any reactive read (like <code>count</code>) is tracked.",
              "Vue learns exactly which component depends on which reactive keys."
            ],
            [
              "3) State change",
              "When you mutate reactive state, Vue <em>triggers</em> the dependent render effect(s).",
              "Only components that used that state are scheduled to update."
            ],
            [
              "4) Batch + schedule",
              "Updates are queued/deduped and flushed in a microtask.",
              "Multiple sync mutations typically lead to one DOM patch per component."
            ],
            [
              "5) Patch DOM",
              "Re-render → new VNodes → diff/patch updates only the dynamic parts (often a single text node).",
              "Efficient updates without manual DOM manipulation."
            ]
          ],
          "caption": "Template interpolation → reactive update → DOM patch"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { ref, nextTick } from 'vue';\n\nconst count = ref(0);\n\nasync function incTwice() {\n  count.value++;\n  count.value++;\n\n  // DOM is patched after the batched flush\n  await nextTick();\n  // Now the DOM reflects the final value\n}\n</script>\n\n<template>\n  <!-- Note: refs are auto-unwrapped in templates -->\n  <p>Count: {{ count }}</p>\n  <button @click=\"incTwice\">+2</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>What the compiler roughly generates</strong><br><br>Vue compiles templates to a render function that produces VNodes. For a dynamic text binding, the runtime can optimize patching using compiler hints (e.g., patch flags). Exact output varies, but the shape looks like this:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Pseudo-ish compiled shape (not exact Vue output)\nimport { openBlock, createElementBlock, toDisplayString } from 'vue';\n\nexport function render(_ctx) {\n  return (\n    openBlock(),\n    createElementBlock(\n      'p',\n      null,\n      'Count: ' + toDisplayString(_ctx.count),\n      /* patchFlag */ 1 // TEXT (runtime knows only text needs updating)\n    )\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Security: interpolation escapes HTML</strong><br><br><code>{{ value }}</code> renders text content (escaped). If you need to render HTML, Vue provides <code>v-html</code>, but you must treat it as XSS-sensitive and only use trusted/sanitized content."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <!-- Escaped: renders literally as \"<strong>Hi</strong>\" -->\n  <p>{{ raw }}</p>\n\n  <!-- Not escaped: injects HTML into the DOM (danger if untrusted) -->\n  <p v-html=\"raw\"></p>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nconst raw = ref('<strong>Hi</strong>');\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br>Interpolation in Vue is: template compile → render effect tracks reactive reads → state writes trigger scheduled re-render → VDOM diff + patch updates only the dynamic DOM nodes. Templates auto-unwrap refs, and interpolation is HTML-escaped by default."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-v-bind-reactive-attributes",
    "title": "How does v-bind connect reactive state to DOM attributes?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain how v-bind (:) turns reactive state into DOM attribute/prop updates: template compilation into a render function, dependency tracking during render, scheduled component updates, and how the runtime patches attributes vs DOM properties (including class/style and boolean attrs).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>v-bind</code> (shorthand <code>:</code>) is not a runtime “watcher on attributes”. Vue compiles your template into a render function. During render, Vue <em>reads</em> the reactive values used in bindings (so they get tracked). When those reactive values change, Vue re-runs the component render and then patches only the changed attributes/DOM props on the affected elements."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { ref, computed } from 'vue';\n\nconst img = ref('https://example.com/a.png');\nconst loading = ref(false);\nconst size = ref('sm');\n\nconst classes = computed(() => ({\n  'btn': true,\n  'btn--sm': size.value === 'sm',\n  'btn--lg': size.value === 'lg',\n  'is-loading': loading.value\n}));\n\nfunction toggle() {\n  loading.value = !loading.value;\n  size.value = size.value === 'sm' ? 'lg' : 'sm';\n}\n</script>\n\n<template>\n  <img :src=\"img\" :alt=\"loading ? 'Loading' : 'Ready'\" />\n\n  <!-- boolean + aria + class object -->\n  <button\n    :class=\"classes\"\n    :disabled=\"loading\"\n    :aria-busy=\"loading\"\n    @click=\"toggle\"\n  >\n    Toggle\n  </button>\n</template>"
        },
        {
          "type": "list",
          "columns": [
            "Stage",
            "What happens",
            "Why it matters"
          ],
          "rows": [
            [
              "1) Compile",
              "Template <code>:src=\"img\"</code> becomes a VNode prop binding in the render function.",
              "Bindings become plain JS expressions; no magic string parsing at runtime."
            ],
            [
              "2) Render in an effect",
              "Component render runs inside a reactive effect; reading <code>img.value</code>/<code>loading.value</code> is tracked.",
              "Vue learns exactly which component depends on which reactive keys."
            ],
            [
              "3) Reactive change",
              "A write like <code>loading.value = true</code> triggers the tracked render effect.",
              "Only components that used that reactive value are scheduled."
            ],
            [
              "4) Batch + flush",
              "Multiple synchronous writes are queued/deduped; update happens in a microtask.",
              "Avoids multiple DOM patches for back-to-back mutations."
            ],
            [
              "5) Patch",
              "Vue diffs old vs new VNodes and applies prop/attr changes to the real DOM node.",
              "Only changed attributes/properties are touched."
            ]
          ],
          "caption": "How a v-bind update flows from state → DOM"
        },
        {
          "type": "text",
          "text": "<strong>Attribute vs DOM property (the part interviewers probe)</strong><br><br>Vue’s patcher decides whether a binding should be applied as a DOM <em>property</em> (<code>el.value</code>, <code>el.checked</code>, <code>el.innerHTML</code> etc.) or as an HTML <em>attribute</em> (<code>setAttribute</code>). Most of the time Vue handles this for you, but knowing the difference explains edge cases (especially with form controls and boolean attributes)."
        },
        {
          "type": "list",
          "columns": [
            "Binding",
            "Vue patch behavior (typical)",
            "Notes / gotchas"
          ],
          "rows": [
            [
              "<code>:class</code>",
              "Special-cased: normalized + set as <code>className</code> efficiently.",
              "Object/array syntax is merged; avoids string concat in templates."
            ],
            [
              "<code>:style</code>",
              "Special-cased: patches individual style properties.",
              "Avoids rewriting the whole style string when only one value changes."
            ],
            [
              "Boolean attrs (e.g. <code>disabled</code>)",
              "Sets/removes based on truthiness (and often uses the DOM property).",
              "If false, Vue removes the attribute; DOM reflects enabled state."
            ],
            [
              "Form-related props (e.g. <code>value</code>, <code>checked</code>)",
              "Prefer DOM properties for correctness.",
              "Attributes don’t always reflect live state; properties do."
            ],
            [
              "SVG attrs",
              "Often must be attributes (SVG DOM differs from HTML).",
              "Vue handles element namespace differences for you."
            ]
          ],
          "caption": "What v-bind actually patches"
        },
        {
          "type": "text",
          "text": "<strong>What the compiler roughly generates</strong><br><br>The exact output varies, but conceptually <code>:src</code>/<code>:disabled</code>/<code>:class</code> become a props object on the VNode. The runtime uses patch flags / dynamic props so it can update only what’s dynamic."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Pseudo-ish shape (not exact Vue output)\nimport { openBlock, createElementBlock } from 'vue';\n\nexport function render(_ctx) {\n  return (\n    openBlock(),\n    createElementBlock('button', {\n      class: _ctx.classes,\n      disabled: _ctx.loading,\n      'aria-busy': _ctx.loading,\n      onClick: _ctx.toggle\n    }, 'Toggle', /* patchFlag */ 8 /* PROPS */, /* dynamicProps */ ['class','disabled','aria-busy'])\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Useful patterns</strong><br><br>1) Bind many attrs at once with an object (great for pass-through props / wrapper components).<br>2) Use dynamic argument when the attribute name itself is data-driven."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { computed, ref } from 'vue';\n\nconst attrs = computed(() => ({\n  id: 'cta',\n  title: 'Call to action',\n  'data-track': 'signup'\n}));\n\nconst attrName = ref('aria-label');\nconst label = ref('Sign up');\n</script>\n\n<template>\n  <a href=\"/signup\" v-bind=\"attrs\">Sign up</a>\n\n  <!-- dynamic attribute name -->\n  <button :[attrName]=\"label\">Hover me</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><code>v-bind</code> works because the template is compiled into a render function that <em>reads</em> reactive state during render (dependency tracking). State changes trigger a scheduled re-render, and Vue patches only the changed VNode props—mapping them to DOM properties or HTML attributes (with special handling for class/style/booleans)."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-v-if-component-creation-destruction",
    "title": "How does v-if affect component creation and destruction?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what happens to a component instance when a v-if condition toggles: when it is created (mounted), when it is destroyed (unmounted), what lifecycle hooks run, and why local state resets. Contrast with v-show and mention when you should prefer one over the other.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>v-if</code> controls whether a template branch <em>exists</em>. For plain elements it means “insert/remove DOM”. For components it means “mount/unmount the component instance” — so the instance is created when the condition becomes true and destroyed when it becomes false."
        },
        {
          "type": "list",
          "columns": [
            "When condition...",
            "What Vue does",
            "What you observe"
          ],
          "rows": [
            [
              "becomes true (first time)",
              "Creates component instance and mounts it",
              "setup()/data() runs, DOM is created, mounted hooks fire"
            ],
            [
              "becomes false",
              "Unmounts component instance and removes DOM",
              "unmounted hooks fire, watchers/listeners cleaned up, DOM disappears"
            ],
            [
              "becomes true again",
              "Creates a new component instance (fresh)",
              "Local state resets (unless state lives outside the component)"
            ]
          ],
          "caption": "v-if toggling = mount/unmount (new instance each time)"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<script setup>\nimport { ref } from 'vue';\nimport Child from './Child.vue';\n\nconst show = ref(true);\n</script>\n\n<template>\n  <button @click=\"show = !show\">Toggle</button>\n  <Child v-if=\"show\" />\n</template>\n\n<!-- Child.vue -->\n<script setup>\nimport { onMounted, onBeforeUnmount, ref } from 'vue';\n\nconst clicks = ref(0);\nlet id;\n\nonMounted(() => {\n  console.log('mounted');\n  id = window.setInterval(() => console.log('tick'), 1000);\n});\n\nonBeforeUnmount(() => {\n  console.log('beforeUnmount (cleanup)');\n  window.clearInterval(id);\n});\n</script>\n\n<template>\n  <button @click=\"clicks++\">Clicks (resets after v-if): {{ clicks }}</button>\n</template>"
        },
        {
          "type": "list",
          "columns": [
            "Area",
            "What happens on v-if=false (unmount)",
            "Why it matters"
          ],
          "rows": [
            [
              "Local component state",
              "Discarded (next mount starts from initial state)",
              "You lose UI state like input values, counters, local caches"
            ],
            [
              "Watchers / effects",
              "Stopped automatically",
              "Avoids leaks, but also means side effects restart on next mount"
            ],
            [
              "DOM + focus",
              "Removed from DOM",
              "Focus is lost; selection/caret state is gone"
            ],
            [
              "Lifecycle hooks",
              "Vue 3: beforeUnmount/unmounted (Vue 2: beforeDestroy/destroyed)",
              "Interviewers often check that you know it’s actual destruction"
            ]
          ],
          "caption": "What “destroy” really implies with v-if"
        },
        {
          "type": "text",
          "text": "<strong>v-if vs v-show (performance + behavior)</strong><br><br><code>v-if</code> has higher toggle cost (create/destroy) but zero cost when false (nothing exists). <code>v-show</code> has higher initial cost (always renders once) but cheap toggles (CSS display only)."
        },
        {
          "type": "list",
          "columns": [
            "Use case",
            "Prefer",
            "Reason"
          ],
          "rows": [
            [
              "Toggles frequently (tabs, dropdown open/close)",
              "v-show",
              "Avoid repeated mount/unmount work; keeps state + DOM"
            ],
            [
              "Toggles rarely (auth gate, expensive panel, route-like branches)",
              "v-if",
              "Don’t pay initial render cost until needed; removes heavy DOM when off"
            ],
            [
              "Must preserve state across toggles but still avoid rendering when hidden",
              "Move state out / keep-alive (when applicable)",
              "State lives outside the destroyed instance, or instance is cached"
            ]
          ],
          "caption": "Choosing between v-if and v-show"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- v-show: component stays mounted, just hidden -->\n<template>\n  <Child v-show=\"show\" />\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Forcing recreation even when staying on-screen</strong><br><br>If you want to deliberately reset a component, you can change its <code>key</code>. A key change forces Vue to treat it as a different instance (destroy + create)."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <Child :key=\"resetVersion\" />\n  <button @click=\"resetVersion++\">Hard reset Child</button>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nimport Child from './Child.vue';\n\nconst resetVersion = ref(0);\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><code>v-if</code> is structural: it creates and destroys DOM and component instances. Toggling it re-runs setup/data and resets local state. Use <code>v-show</code> for frequent toggles, and keep state outside the component (or cache instances where appropriate) when you need persistence."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-v-for-keys",
    "title": "Why are keys critical in v-for, and what breaks without them?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain why :key is required/recommended in v-for, what Vue uses it for during virtual DOM diffing, and give concrete examples of bugs you can get when keys are missing or unstable (including why using the index as key is usually wrong).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>:key</code> gives Vue a <em>stable identity</em> for each rendered item. During updates, Vue matches old VNodes to new VNodes primarily by <code>type + key</code>. With good keys, Vue can move/reuse the right DOM nodes and component instances. Without keys, Vue falls back to a mostly <em>index-based / in-place patch</em> strategy, which can reuse the wrong DOM/component for a different item."
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "With stable keys (e.g., item.id)",
            "Without keys / bad keys (e.g., index)"
          ],
          "rows": [
            [
              "Insert/remove in the middle",
              "Vue inserts/removes the correct node and keeps other items' DOM/state attached",
              "Vue reuses DOM nodes by position; DOM/state may “shift” to the wrong item"
            ],
            [
              "Sorting / reordering",
              "Vue moves existing nodes (minimal DOM work) and preserves per-item state",
              "Vue patches in place; items can display wrong state (inputs, toggles, child state)"
            ],
            [
              "Stateful child components in a list",
              "Each child instance stays with its data item",
              "Child instances can get reassigned to different data items (state leak/mismatch)"
            ],
            [
              "Transitions (<code>&lt;transition-group&gt;</code>)",
              "Correct enter/leave/move animations",
              "Animations glitch or don’t run correctly (Vue can’t track moves reliably)"
            ]
          ],
          "caption": "What keys enable vs what breaks without them"
        },
        {
          "type": "text",
          "text": "<strong>What “breaks” in practice</strong><br><br>Typical real bugs when keys are missing or unstable:<br>• <strong>Inputs show the wrong value</strong> after sorting/filtering because the DOM input element is reused for a different item.<br>• <strong>Focus/caret jumps</strong> (typing in an input, list updates, and the focused DOM node is reused/moved incorrectly).<br>• <strong>Checkboxes/toggles flip on the wrong row</strong> (DOM state vs data association breaks).<br>• <strong>Child component local state leaks</strong> (e.g., expanded/collapsed, internal caches, timers) to a different item after reordering.<br>• <strong>Transition-group move animations break</strong> because Vue can’t reliably compute “this node moved from A to B” without keys."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- BAD: no key (or :key=\"index\") can cause DOM/state to shift on reorder -->\n<script setup>\nimport { ref } from 'vue';\n\nconst items = ref([\n  { id: 1, name: 'Alpha' },\n  { id: 2, name: 'Bravo' },\n  { id: 3, name: 'Charlie' }\n]);\n\nfunction reverse() {\n  items.value = [...items.value].reverse();\n}\n</script>\n\n<template>\n  <button @click=\"reverse\">Reverse</button>\n\n  <ul>\n    <li v-for=\"(item, index) in items\">\n      <!-- Try typing in Alpha, then Reverse: the typed DOM input may appear under a different item -->\n      <label>\n        {{ item.name }}\n        <input placeholder=\"type here\" />\n      </label>\n    </li>\n  </ul>\n</template>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- GOOD: stable key preserves DOM association and component instances -->\n<script setup>\nimport { ref } from 'vue';\n\nconst items = ref([\n  { id: 1, name: 'Alpha' },\n  { id: 2, name: 'Bravo' },\n  { id: 3, name: 'Charlie' }\n]);\n\nfunction reverse() {\n  items.value = [...items.value].reverse();\n}\n</script>\n\n<template>\n  <button @click=\"reverse\">Reverse</button>\n\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">\n      <label>\n        {{ item.name }}\n        <input placeholder=\"type here\" />\n      </label>\n    </li>\n  </ul>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Index as key: when it’s wrong vs acceptable</strong><br><br><code>:key=\"index\"</code> is effectively “no stable identity” when the list can reorder, filter, insert, or delete. It tells Vue: “identity is position”, so Vue will keep DOM/state by index, not by data item. It’s only acceptable when the list is truly static (never changes order/length) or when each row has no meaningful state (rare in real apps)."
        },
        {
          "type": "list",
          "columns": [
            "Key rule",
            "Why",
            "Example"
          ],
          "rows": [
            [
              "Use a stable unique id",
              "Preserves identity across reorder/insert/delete",
              ":key=\"item.id\""
            ],
            [
              "Don’t use random/unstable keys",
              "Forces full destroy/recreate every render (kills performance/state)",
              ":key=\"Math.random()\" (bad)"
            ],
            [
              "Avoid index for dynamic lists",
              "Index changes when list changes, so identity shifts",
              ":key=\"index\" (usually bad)"
            ],
            [
              "Key must be primitive + stable",
              "Vue compares keys; stable primitives keep matching predictable",
              "number/string id"
            ],
            [
              "transition-group needs keys",
              "Move/enter/leave tracking depends on identity",
              "<transition-group> children must be keyed"
            ]
          ],
          "caption": "Best practices for :key in v-for"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br>Keys aren’t about “performance only”. They’re primarily about <em>correctness</em>: ensuring DOM nodes and component instances stay attached to the same logical data item across updates. Without stable keys (or with index keys), you risk state/DOM mismatches when the list changes."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-v-model-syntax-sugar-expansion",
    "title": "Why is v-model syntax sugar, and what does it expand to?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain why v-model is considered syntax sugar in Vue: it’s compiled into a prop binding + an event listener. Show what it expands to for native form elements (text input, checkbox, select) and for custom components in Vue 3 (modelValue + update:modelValue). Include how v-model arguments (v-model:foo) and common modifiers (.trim, .number, .lazy) change the expansion.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><code>v-model</code> is <em>syntax sugar</em> because it doesn’t add a new runtime “two-way binding engine”. Vue’s template compiler rewrites it into:<br>1) a <strong>prop/attribute binding</strong> (state → DOM/component)<br>2) an <strong>event listener</strong> (DOM/component → state)<br><br>So it’s just a shorter way to write “bind value + update on event”."
        },
        {
          "type": "list",
          "columns": [
            "Usage",
            "Expands to (conceptually)",
            "Notes"
          ],
          "rows": [
            [
              "<code>&lt;input v-model=\"msg\" /&gt;</code>",
              "<code>:value=\"msg\"</code> + <code>@input=\"msg = $event.target.value\"</code>",
              "Text-like inputs use <code>input</code> event."
            ],
            [
              "<code>&lt;input type=\"checkbox\" v-model=\"ok\" /&gt;</code>",
              "<code>:checked=\"ok\"</code> + <code>@change=\"ok = $event.target.checked\"</code>",
              "Checkbox binds <code>checked</code>, not <code>value</code>."
            ],
            [
              "<code>&lt;select v-model=\"pick\"&gt;...</code>",
              "<code>:value=\"pick\"</code> + <code>@change=\"pick = $event.target.value\"</code>",
              "Select updates on <code>change</code>."
            ],
            [
              "<code>&lt;MyComp v-model=\"val\" /&gt;</code> (Vue 3)",
              "<code>:modelValue=\"val\"</code> + <code>@update:modelValue=\"val = $event\"</code>",
              "Custom components use <code>modelValue</code> + <code>update:modelValue</code> by default."
            ],
            [
              "<code>&lt;MyComp v-model:title=\"title\" /&gt;</code> (Vue 3)",
              "<code>:title=\"title\"</code> + <code>@update:title=\"title = $event\"</code>",
              "Argument changes prop/event name."
            ]
          ],
          "caption": "What v-model expands to (high level)"
        },
        {
          "type": "text",
          "text": "<strong>Native input example (the “long form”)</strong>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <!-- Sugar -->\n  <input v-model=\"msg\" />\n\n  <!-- Desugared -->\n  <input\n    :value=\"msg\"\n    @input=\"msg = $event.target.value\"\n  />\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nconst msg = ref('hello');\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Checkbox + select (different DOM properties/events)</strong><br><br>People call <code>v-model</code> “smart sugar” because it chooses the correct DOM property and event per form control."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <!-- Checkbox: checked + change -->\n  <input type=\"checkbox\" v-model=\"ok\" />\n  <input\n    type=\"checkbox\"\n    :checked=\"ok\"\n    @change=\"ok = $event.target.checked\"\n  />\n\n  <!-- Select: value + change -->\n  <select v-model=\"pick\">\n    <option value=\"a\">A</option>\n    <option value=\"b\">B</option>\n  </select>\n  <select\n    :value=\"pick\"\n    @change=\"pick = $event.target.value\"\n  >\n    <option value=\"a\">A</option>\n    <option value=\"b\">B</option>\n  </select>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nconst ok = ref(false);\nconst pick = ref('a');\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Custom components (Vue 3): modelValue + update:modelValue</strong><br><br>For components, <code>v-model</code> becomes a normal prop + a normal emitted event. The parent “listens” and assigns."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<template>\n  <!-- Sugar -->\n  <UserNameInput v-model=\"name\" />\n\n  <!-- Desugared -->\n  <UserNameInput\n    :modelValue=\"name\"\n    @update:modelValue=\"name = $event\"\n  />\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nimport UserNameInput from './UserNameInput.vue';\n\nconst name = ref('Müslüm');\n</script>\n\n<!-- UserNameInput.vue -->\n<template>\n  <input\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n\n<script setup>\ndefineProps({\n  modelValue: { type: String, required: true }\n});\n\ndefineEmits(['update:modelValue']);\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>v-model arguments (Vue 3): v-model:foo</strong><br><br>Arguments just swap the prop/event names. This enables multiple v-model bindings on one component."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<template>\n  <RangePicker v-model:start=\"start\" v-model:end=\"end\" />\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nimport RangePicker from './RangePicker.vue';\n\nconst start = ref('2025-01-01');\nconst end = ref('2025-12-31');\n</script>\n\n<!-- RangePicker.vue -->\n<template>\n  <input :value=\"start\" @input=\"$emit('update:start', $event.target.value)\" />\n  <input :value=\"end\" @input=\"$emit('update:end', $event.target.value)\" />\n</template>\n\n<script setup>\ndefineProps({\n  start: String,\n  end: String\n});\n\ndefineEmits(['update:start', 'update:end']);\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Modifiers (.trim, .number, .lazy) change the update expression</strong><br><br>Modifiers don’t change the “prop + event” structure, they change how the incoming value is read/coerced and when updates happen."
        },
        {
          "type": "list",
          "columns": [
            "Modifier",
            "Effect",
            "Desugared idea"
          ],
          "rows": [
            [
              "<code>.trim</code>",
              "Trims whitespace",
              "<code>msg = $event.target.value.trim()</code>"
            ],
            [
              "<code>.number</code>",
              "Coerces to number",
              "<code>age = Number($event.target.value)</code>"
            ],
            [
              "<code>.lazy</code>",
              "Updates on change/blur-like timing instead of input",
              "Uses <code>@change</code> instead of <code>@input</code> for text inputs"
            ]
          ],
          "caption": "How v-model modifiers affect the expansion"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><code>v-model</code> is compile-time sugar for “bind current value + listen and assign updates”. For native inputs it picks the correct DOM property/event. For components in Vue 3 it maps to <code>modelValue</code> + <code>update:modelValue</code> (or <code>v-model:arg</code> → <code>arg</code> + <code>update:arg</code>)."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-v-show-vs-v-if-dom-lifecycle",
    "title": "How do v-show and v-if differ in DOM behavior and lifecycle impact?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain the DOM-level difference (remove/insert vs CSS hide/show) and the lifecycle/state impact for components when toggling v-if vs v-show. Include performance tradeoffs and when to prefer each.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core difference</strong><br><br><code>v-if</code> is <em>structural</em>: the branch exists only when the condition is true (DOM nodes are created/inserted and later removed).<br><code>v-show</code> is <em>presentational</em>: the element/component is always rendered once, and Vue toggles visibility by setting <code>style.display</code> (typically <code>display: none</code>)."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "v-if",
            "v-show"
          ],
          "rows": [
            [
              "DOM when false",
              "Not in DOM (nodes removed / never created if initially false)",
              "Still in DOM, but hidden via CSS (display:none)"
            ],
            [
              "Component instance",
              "Destroyed when false; recreated when true again",
              "Stays mounted; same instance reused"
            ],
            [
              "Lifecycle hooks",
              "Mount/unmount hooks run on each toggle (Vue 3: mounted/beforeUnmount/unmounted; Vue 2: mounted/beforeDestroy/destroyed)",
              "Mount hooks run once; toggling does not unmount"
            ],
            [
              "Local state (inputs, refs, component data)",
              "Resets on re-mount (new instance)",
              "Preserved across toggles"
            ],
            [
              "Work when hidden",
              "Zero (no render, no DOM patching, no watchers inside because instance is gone)",
              "Still reactive; component can still update/compute even while hidden"
            ],
            [
              "Performance profile",
              "Higher toggle cost, lower steady-state cost when off",
              "Higher initial cost, very cheap toggles"
            ]
          ],
          "caption": "v-if vs v-show: DOM + lifecycle impact"
        },
        {
          "type": "text",
          "text": "<strong>DOM behavior (plain elements)</strong><br><br>• <code>v-if</code>: creates/removes the element. If it starts false, it is lazy (nothing is rendered until it becomes true).<br>• <code>v-show</code>: element exists, but Vue sets inline <code>display: none</code> when false (removed from layout and accessibility tree)."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <!-- v-if: element is created/removed -->\n  <div v-if=\"open\">Heavy DOM branch</div>\n\n  <!-- v-show: element always exists; only display toggles -->\n  <div v-show=\"open\">Same DOM node, just hidden</div>\n</template>\n\n<script setup>\nimport { ref } from 'vue';\nconst open = ref(false);\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Lifecycle impact (components)</strong><br><br>With <code>v-if</code>, toggling false unmounts the child component (cleanup runs, subscriptions stop, DOM removed). Toggling true creates a <em>fresh</em> instance, so local state resets.<br><br>With <code>v-show</code>, the child stays mounted the whole time; toggling only changes visibility. The instance, refs, and local state remain intact."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<script setup>\nimport { ref } from 'vue';\nimport Child from './Child.vue';\n\nconst show = ref(true);\n</script>\n\n<template>\n  <button @click=\"show = !show\">Toggle</button>\n\n  <!-- Swap between these to observe behavior -->\n  <Child v-if=\"show\" />\n  <!-- <Child v-show=\"show\" /> -->\n</template>\n\n<!-- Child.vue -->\n<script setup>\nimport { onMounted, onBeforeUnmount, ref } from 'vue';\n\nconst local = ref(0);\nlet timerId;\n\nonMounted(() => {\n  console.log('Child mounted');\n  timerId = window.setInterval(() => console.log('tick'), 1000);\n});\n\nonBeforeUnmount(() => {\n  console.log('Child beforeUnmount (cleanup)');\n  window.clearInterval(timerId);\n});\n</script>\n\n<template>\n  <button @click=\"local++\">Local state: {{ local }}</button>\n</template>\n\n<!-- v-if: local resets after hide/show; cleanup runs.\n     v-show: local keeps its value; cleanup does NOT run on hide/show. -->"
        },
        {
          "type": "list",
          "columns": [
            "Use case",
            "Prefer",
            "Reason"
          ],
          "rows": [
            [
              "Frequently toggled UI (tabs, dropdowns, accordions)",
              "v-show",
              "Cheap toggles; preserves state; avoids repeated mount/unmount"
            ],
            [
              "Rarely shown + heavy branch (expensive DOM, large list, complex child)",
              "v-if",
              "Avoid initial render cost; zero work while off"
            ],
            [
              "Need state preserved but also want to avoid background work while hidden",
              "v-if + state lifted (store/composable) or caching (keep-alive where applicable)",
              "Unmount stops work; externalized state prevents losing user input/state"
            ]
          ],
          "caption": "How to choose"
        },
        {
          "type": "text",
          "text": "<strong>Common gotchas interviewers like</strong><br><br>• <code>v-show</code> does not support <code>v-else</code>/<code>v-else-if</code> chains; <code>v-if</code> does.<br>• <code>v-show</code> hides via <code>display:none</code> (not just “invisible”); it won’t take space and won’t be reachable by screen readers while hidden.<br>• Hidden-with-<code>v-show</code> components can still run watchers/computed updates; <code>v-if</code> removes them entirely."
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><code>v-if</code> changes the DOM tree and component lifecycle (mount/unmount, state resets). <code>v-show</code> keeps the same DOM and instance, only toggling <code>display</code>. Use <code>v-show</code> for frequent toggles; use <code>v-if</code> when the branch is rarely needed or expensive and you want zero cost while it’s off."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-computed-properties",
    "title": "What are computed properties in Vue?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Computed properties in Vue are special properties that automatically update when their dependent data changes. They are primarily used to calculate derived state efficiently, caching results until their dependencies change.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Computed properties in Vue are a powerful way to define reactive logic that depends on existing data. They act like dynamic properties that automatically re-evaluate when the data they depend on changes — and they cache the result until dependencies are updated again."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <div>\n    <p>First Name: {{ firstName }}</p>\n    <p>Last Name: {{ lastName }}</p>\n    <p>Full Name (computed): {{ fullName }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      firstName: 'Mina',\n      lastName: 'Yilmaz'\n    };\n  },\n  computed: {\n    fullName() {\n      return this.firstName + ' ' + this.lastName;\n    }\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "In this example, <code>fullName</code> is a computed property that automatically re-calculates when <code>firstName</code> or <code>lastName</code> changes. Vue caches its value until one of these dependencies updates, avoiding unnecessary re-renders."
        },
        {
          "type": "text",
          "text": "<strong>How Computed Properties Work</strong><br>When Vue initializes a computed property, it tracks the reactive dependencies used inside the property. When any of those dependencies change, Vue marks the computed property as 'dirty' and re-evaluates it upon the next access."
        },
        {
          "type": "text",
          "text": "<strong>Computed vs Methods</strong><br>While both can return derived values, computed properties are cached and only re-run when dependencies change. In contrast, methods are executed every time they are called, regardless of data changes."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Computed",
            "Method"
          ],
          "rows": [
            [
              "Caching",
              "Yes (re-evaluates only when dependencies change)",
              "No (runs every time it’s called)"
            ],
            [
              "Use Case",
              "For derived or reactive data",
              "For event-driven or non-reactive actions"
            ],
            [
              "Performance",
              "Optimized for efficiency",
              "Less efficient for repeated calls"
            ]
          ],
          "caption": "Comparison Between Computed Properties and Methods"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "computed: {\n  reversedMessage() {\n    return this.message.split('').reverse().join('');\n  }\n}"
        },
        {
          "type": "text",
          "text": "Here, the computed property <code>reversedMessage</code> will only re-run when <code>message</code> changes, not on every render cycle."
        },
        {
          "type": "text",
          "text": "<strong>Computed Getters and Setters</strong><br>Computed properties can also include a setter to handle updates in both directions."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "computed: {\n  fullName: {\n    get() {\n      return this.firstName + ' ' + this.lastName;\n    },\n    set(value) {\n      const parts = value.split(' ');\n      this.firstName = parts[0];\n      this.lastName = parts[1];\n    }\n  }\n}"
        },
        {
          "type": "text",
          "text": "Now, assigning a value like <code>this.fullName = 'Jane Doe'</code> automatically updates <code>firstName</code> and <code>lastName</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of computed properties as smart variables that know when and how to update — they deliver dynamic results while minimizing unnecessary recalculations."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Computed properties calculate values based on reactive data.</li><li>They are cached until dependencies change.</li><li>Useful for derived state and transformations.</li><li>Support both getters and setters for two-way interaction.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-methods-in-templates",
    "title": "What happens when you call methods inside Vue templates?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain how template method calls are executed during render, why they run again on every component re-render, the performance/correctness pitfalls (expensive work, unstable references, side effects), and when to prefer computed properties or precomputed data.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Anything you reference in a Vue template is evaluated during the component’s <em>render</em>. A method call in the template is just a function call inside the compiled render function. That means:<br>• The method runs on the initial render.<br>• The method runs again on <em>every</em> subsequent re-render of that component.<br><br>Vue will track reactive reads that happen <em>inside</em> the method (because it runs during render), but the <em>result is not cached</em> like a computed property."
        },
        {
          "type": "list",
          "columns": [
            "Approach",
            "How often it runs",
            "Caching",
            "Best for"
          ],
          "rows": [
            [
              "Method call in template: {{ format() }}",
              "Every render of the component",
              "No",
              "Event-ish logic, cheap formatting, simple helpers"
            ],
            [
              "Computed: {{ formatted }}",
              "Only when its reactive deps change (then reused)",
              "Yes (until invalidated)",
              "Derived state, expensive transforms, stable references"
            ],
            [
              "Inline expression: {{ a + b }}",
              "Every render",
              "No",
              "Very small expressions only"
            ]
          ],
          "caption": "Method calls vs computed in templates"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { ref, computed } from 'vue';\n\nconst count = ref(0);\nconst theme = ref('light');\n\nfunction expensiveFormat(n) {\n  // pretend heavy work\n  let s = '';\n  for (let i = 0; i < 50000; i++) s = String(n);\n  return `Count: ${s}`;\n}\n\nconst formatted = computed(() => expensiveFormat(count.value));\n</script>\n\n<template>\n  <!-- Method: runs whenever this component re-renders (even if only theme changes) -->\n  <p>{{ expensiveFormat(count) }}</p>\n\n  <!-- Computed: recomputes only when count changes -->\n  <p>{{ formatted }}</p>\n\n  <button @click=\"count++\">inc</button>\n  <button @click=\"theme = theme === 'light' ? 'dark' : 'light'\">toggle theme</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Why this can hurt performance</strong><br><br>A component can re-render for many reasons (any reactive dependency used in render changes). If you call a method in the template, it’s executed again even when the method’s “inputs” didn’t change. In lists, it’s worse: a method used inside <code>v-for</code> can run <em>per item</em> per render."
        },
        {
          "type": "list",
          "columns": [
            "Pitfall",
            "What you’ll see",
            "Fix"
          ],
          "rows": [
            [
              "Expensive method in template",
              "UI jank / slow typing / slow toggles",
              "Move work into a computed, or precompute once (e.g., computed map / cached lookup)"
            ],
            [
              "Method allocates new objects/arrays each render",
              "Child components update unnecessarily (new prop reference each render)",
              "Return stable references via computed, or compute once and reuse"
            ],
            [
              "Method has side effects (mutates reactive state, logs, API calls)",
              "Infinite update loops, warnings, repeated API calls",
              "Keep template-called methods pure; do side effects in events/watchers"
            ],
            [
              "Method depends on params (e.g., format(item))",
              "You can’t just “convert to computed” 1:1",
              "Precompute a derived structure (Map/object) via computed; or memoize by key"
            ]
          ],
          "caption": "Common problems and fixes"
        },
        {
          "type": "text",
          "text": "<strong>When it’s OK to use a method in the template</strong><br><br>• It’s cheap (simple string/number formatting).<br>• It’s pure (no state writes, no I/O).<br>• It doesn’t allocate large new structures on every call.<br><br><strong>Rule of thumb</strong>: if you’d be annoyed seeing it run on every render in a profiler, make it a computed (or precomputed data) instead."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-native-vs-component-events",
    "title": "What is the difference between native and component events in Vue?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain the difference between native DOM events (click/input/submit...) and component events emitted with $emit/emit in Vue. Cover what happens when you write @click on a real element vs on a component tag, how propagation differs (DOM bubbling vs parent-only emits), and the Vue 2 .native vs Vue 3 fallthrough/emits behavior.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br><strong>Native events</strong> are browser DOM events fired by real elements (<code>&lt;button&gt;</code>, <code>&lt;input&gt;</code>, ...).<br><strong>Component events</strong> are custom events emitted by a Vue component (<code>emit('eventName', payload)</code>) and received by the parent."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Native (DOM) event",
            "Component event (emit)"
          ],
          "rows": [
            [
              "Where it originates",
              "Browser fires it on a real DOM node",
              "Component code emits it explicitly"
            ],
            [
              "How you listen",
              "On an element: <code>&lt;button @click=...&gt;</code>",
              "On a component tag: <code>&lt;MyComp @save=...&gt;</code>"
            ],
            [
              "Propagation",
              "Bubbles/captures through the DOM tree",
              "Goes to the direct parent only (no DOM bubbling)"
            ],
            [
              "Payload",
              "Usually a real <code>Event</code> object",
              "Whatever you emit (could be an Event, but often custom data)"
            ],
            [
              "Default behavior",
              "May have defaults (submit navigates, link navigates, etc.)",
              "No browser default; it’s app-level messaging"
            ]
          ],
          "caption": "Native DOM events vs component-emitted events"
        },
        {
          "type": "text",
          "text": "<strong>Example: native DOM event</strong>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<script setup>\nfunction onNativeClick(e) {\n  console.log('native click', e.type);\n}\n</script>\n\n<template>\n  <button type=\"button\" @click=\"onNativeClick\">Native click</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Example: component event (custom)</strong><br><br>The parent listens on the component tag, but it only fires if the child emits it."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- MyButton.vue -->\n<script setup>\nconst emit = defineEmits(['press']);\nfunction handleClick(e) {\n  emit('press', { originalEvent: e, ts: Date.now() });\n}\n</script>\n\n<template>\n  <button type=\"button\" @click=\"handleClick\">\n    <slot>Press</slot>\n  </button>\n</template>\n\n<!-- Parent.vue -->\n<script setup>\nfunction onPress(payload) {\n  console.log('component event press', payload.ts);\n}\n</script>\n\n<template>\n  <MyButton @press=\"onPress\">Component press</MyButton>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>The confusing part: @click on a component</strong><br><br>When you write <code>&lt;MyButton @click=... /&gt;</code>, it does <em>not</em> automatically mean “listen to the internal DOM click”. It depends on Vue version and how the component is authored."
        },
        {
          "type": "list",
          "columns": [
            "Case",
            "What @click means",
            "How to make it work intentionally"
          ],
          "rows": [
            [
              "Vue 2: <code>@click</code> on component",
              "Listens for a component-emitted <code>click</code> event (not DOM)",
              "Emit it from the child: <code>this.$emit('click', $event)</code>"
            ],
            [
              "Vue 2: <code>@click.native</code>",
              "Attach a native listener to the component’s root DOM element",
              "Use <code>.native</code> (Vue 2 only)"
            ],
            [
              "Vue 3: listener fallthrough (single-root component)",
              "If the event name is <em>not</em> declared in <code>emits</code>, Vue treats it as an attribute listener and can pass it to the root element",
              "Rely on fallthrough only when you really want “wrapper behaves like a DOM element”; otherwise use explicit custom events"
            ],
            [
              "Vue 3: declared in <code>emits</code>",
              "<code>@click</code> becomes a component event listener (must be emitted)",
              "Declare + emit: <code>defineEmits(['click'])</code> and <code>emit('click', $event)</code>"
            ]
          ],
          "caption": "Vue 2 vs Vue 3 behavior on component listeners"
        },
        {
          "type": "list",
          "columns": [
            "Gotcha",
            "Why it happens",
            "Rule of thumb"
          ],
          "rows": [
            [
              "Assuming DOM bubbling for component events",
              "Custom emits don’t bubble through DOM; only parent receives it",
              "If grandparents need it, re-emit upward or use a store"
            ],
            [
              "Using DOM event modifiers on custom events (.stop/.prevent)",
              "Those call <code>event.stopPropagation()</code>/<code>preventDefault()</code> — only meaningful if your payload is a real Event",
              "Use modifiers mainly for DOM events; for custom events, design payloads and logic explicitly"
            ],
            [
              "Naming a component event the same as a native event ('click')",
              "Can be valid but easily confuses “is this DOM or emitted?” (plus fallthrough rules in Vue 3)",
              "Prefer semantic names: <code>press</code>, <code>submit</code>, <code>close</code>, <code>update:modelValue</code>"
            ],
            [
              "Not declaring <code>emits</code> in Vue 3",
              "Vue can’t validate emitted events and listeners may fall through to DOM unintentionally",
              "Declare <code>emits</code> for your component API; it prevents accidental fallthrough for those event names"
            ]
          ],
          "caption": "Common interview-level pitfalls"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><strong>Native event</strong> = browser event on a real element (bubbles in DOM).<br><strong>Component event</strong> = explicit <code>emit</code> from child to parent (no DOM bubbling).<br>On a component tag, <code>@event</code> primarily means “listen for an emitted event”, except Vue 3 can also treat undeclared listeners as fallthrough attributes to the root element."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-architecture-decisions-scalability",
    "title": "What architectural decisions are made when creating a Vue project, and how do they affect scalability?",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 5,
    "description": "When starting a Vue app, teams choose the build/runtime platform, state and routing strategy, code organization, and quality/performance tooling. These decisions directly affect maintainability, performance, testability, and how well multiple teams can work in parallel.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>“Scalability” in Vue isn’t just about performance — it’s mainly about keeping complexity manageable as features and teams grow. Early architectural choices determine whether your codebase stays modular, testable, and predictable."
        },
        {
          "type": "list",
          "columns": [
            "Decision",
            "Common Options",
            "Scalability Impact"
          ],
          "rows": [
            [
              "App platform",
              "SPA (Vite) vs SSR/SSG (Nuxt)",
              "SSR/SSG improves SEO/perf for content-heavy apps but adds complexity (server runtime, hydration, caching). SPA is simpler operationally."
            ],
            [
              "Language & typing",
              "JS vs TypeScript",
              "TS improves refactors, API contracts, and large-team collaboration; initial setup and discipline required."
            ],
            [
              "Component API style",
              "Composition API vs Options API",
              "Composition API scales better for logic reuse (composables) and complex components; easier to enforce patterns."
            ],
            [
              "Routing strategy",
              "Vue Router, nested routes, lazy-loaded route chunks",
              "Route-level code splitting + clear route boundaries prevents “one giant bundle” and encourages feature isolation."
            ],
            [
              "State management",
              "Local state, provide/inject, Pinia, server-state libs (e.g., TanStack Query)",
              "Over-globalizing state creates coupling. Use Pinia for shared cross-feature state; keep UI state local; use server-state caching for API data."
            ],
            [
              "Project structure",
              "By type (components/views/stores) vs by feature/domain",
              "Feature-based structure scales better: isolates dependencies, enables ownership per domain, reduces cross-import spaghetti."
            ],
            [
              "UI system",
              "Ad-hoc components vs design system (base components + tokens)",
              "A design system reduces duplication and UI drift; speeds up development and improves consistency."
            ],
            [
              "Data access layer",
              "Direct fetch in components vs services/repositories",
              "Central API layer improves testability, retries/caching, error handling, and consistent DTO↔domain mapping."
            ],
            [
              "Validation & forms",
              "Native handling vs schema-based validation (e.g., Zod/Yup) + form libs",
              "Schema-based validation scales better with complex forms and shared contracts."
            ],
            [
              "Testing strategy",
              "Unit (Vitest), component tests, E2E (Cypress/Playwright)",
              "Clear test pyramid prevents regressions as team grows; makes refactors safe."
            ],
            [
              "Code quality gates",
              "ESLint, Prettier, typecheck CI, commit hooks",
              "Automated consistency reduces review load and prevents style/typing drift across contributors."
            ],
            [
              "Performance strategy",
              "Code splitting, async components, virtual lists, memoization, image strategy",
              "Prevents performance debt. Without standards, large apps degrade from bundle bloat and unnecessary re-renders."
            ],
            [
              "Configuration & environments",
              "Env files + runtime config",
              "Clean env separation prevents “works on my machine” issues and supports multi-environment deployments safely."
            ]
          ],
          "caption": "Key Vue project architecture decisions and their scalability impact"
        },
        {
          "type": "text",
          "text": "<strong>Recommended baseline for a scalable Vue 3 app</strong><br><br>• Vite + Vue 3 + TypeScript<br>• Vue Router with lazy-loaded routes<br>• Pinia for true shared state only; keep UI state local<br>• Composition API + composables for shared logic<br>• Feature-based folder structure (domain modules)<br>• Central API layer (services) + consistent error handling<br>• Vitest for unit/component tests + Playwright/Cypress for E2E<br>• ESLint/Prettier + typecheck in CI"
        },
        {
          "type": "code",
          "language": "typescript",
          "code": "// Example: route-level code splitting (Vue Router)\nconst routes = [\n  {\n    path: '/admin',\n    component: () => import('./features/admin/AdminLayout.vue'),\n    children: [\n      {\n        path: 'users',\n        component: () => import('./features/admin/users/AdminUsersPage.vue')\n      }\n    ]\n  }\n];"
        },
        {
          "type": "code",
          "language": "text",
          "code": "# Example: feature-based structure\nsrc/\n  app/                 # app bootstrap, router, global plugins\n  features/\n    admin/\n      users/\n        components/\n        pages/\n        store/\n        api/\n        types/\n    booking/\n      ...\n  shared/\n    ui/                # base components\n    composables/\n    utils/\n    api/\n"
        },
        {
          "type": "text",
          "text": "<strong>Common scalability failures</strong><br><br>1) “Everything in the global store” → tight coupling + hard debugging.<br>2) No domain boundaries → circular imports + unclear ownership.<br>3) No API layer → duplicated fetch logic + inconsistent error handling.<br>4) No code splitting → slow initial load as app grows.<br>5) No enforced conventions → PR reviews turn into style/pattern debates."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Vue scales well when you enforce boundaries (features/domains), keep state usage intentional (local vs shared), reuse logic via composables, and standardize routing, API access, testing, and CI quality gates early. Most scalability problems are architecture + conventions, not Vue itself."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-computed-vs-watchers",
    "title": "What is the difference between computed properties and watchers in Vue?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Computed properties and watchers in Vue both respond to changes in reactive data, but they serve different purposes. Computed properties are used to derive and cache data, while watchers are used to perform side effects or execute logic when data changes.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Both computed properties and watchers in Vue observe reactive data and react to changes, but they are designed for different use cases. Computed properties are ideal for deriving values based on other data, whereas watchers are useful for performing side effects like API calls, logging, or manual data updates."
        },
        {
          "type": "text",
          "text": "<strong>Computed Properties</strong><br>Computed properties automatically update when their reactive dependencies change. They are **cached** until a dependency changes again, making them ideal for data transformation or calculated outputs."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "export default {\n  data() {\n    return {\n      firstName: 'Mina',\n      lastName: 'Yilmaz'\n    };\n  },\n  computed: {\n    fullName() {\n      return this.firstName + ' ' + this.lastName;\n    }\n  }\n};"
        },
        {
          "type": "text",
          "text": "Here, <code>fullName</code> automatically re-calculates whenever <code>firstName</code> or <code>lastName</code> changes, but Vue caches the result for performance until those dependencies update."
        },
        {
          "type": "text",
          "text": "<strong>Watchers</strong><br>Watchers allow you to 'watch' specific data sources and execute a function whenever that data changes. They are useful for performing asynchronous or imperative tasks — for example, calling an API when a value changes."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "export default {\n  data() {\n    return {\n      searchQuery: ''\n    };\n  },\n  watch: {\n    searchQuery(newValue, oldValue) {\n      console.log(`Search changed from ${oldValue} to ${newValue}`);\n      this.fetchResults(newValue);\n    }\n  },\n  methods: {\n    fetchResults(query) {\n      // Example API call\n      console.log('Fetching data for', query);\n    }\n  }\n};"
        },
        {
          "type": "text",
          "text": "In this example, the watcher tracks <code>searchQuery</code> and triggers an API call whenever the value changes. Unlike computed properties, watchers do not return a value — they perform side effects."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Computed Properties",
            "Watchers"
          ],
          "rows": [
            [
              "Purpose",
              "Derive or calculate new data",
              "Perform side effects when data changes"
            ],
            [
              "Caching",
              "Yes – cached until dependencies change",
              "No – runs every time data changes"
            ],
            [
              "Return Value",
              "Returns a computed value",
              "Executes a function, no return value"
            ],
            [
              "Use Case",
              "Display reactive derived data",
              "API calls, logging, manual data synchronization"
            ]
          ],
          "caption": "Comparison Between Computed Properties and Watchers"
        },
        {
          "type": "text",
          "text": "<strong>When to Use Each</strong><ul><li>Use <code>computed</code> for declarative data transformations that are displayed in the template.</li><li>Use <code>watch</code> for imperative logic, like fetching data or reacting to user input changes.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of computed properties as <em>smart derived variables</em> and watchers as <em>reactive observers</em> that perform tasks when data changes."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Computed properties are used for data derivation and are cached for performance.</li><li>Watchers are used for running code or side effects when data changes.</li><li>Computed = declarative; Watch = imperative.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-lifecycle-hooks",
    "title": "What are lifecycle hooks in Vue and when are they used?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Lifecycle hooks in Vue are special methods that run at specific stages of a component’s lifecycle — from creation to destruction. They allow developers to perform logic like fetching data, manipulating the DOM, or cleaning up resources.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Every Vue component goes through a series of lifecycle stages — creation, mounting, updating, and unmounting. Vue provides lifecycle hooks, which are special functions you can define to run code automatically at these stages."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "export default {\n  data() {\n    return {\n      message: 'Hello Vue!'\n    };\n  },\n  created() {\n    console.log('Component is created!');\n  },\n  mounted() {\n    console.log('Component is mounted to the DOM!');\n  },\n  updated() {\n    console.log('Component has re-rendered!');\n  },\n  unmounted() {\n    console.log('Component has been removed from the DOM!');\n  }\n};"
        },
        {
          "type": "text",
          "text": "Each hook corresponds to a specific stage of the component lifecycle. For example, <code>created()</code> runs when the component is initialized, while <code>mounted()</code> runs when the component is added to the DOM."
        },
        {
          "type": "text",
          "text": "<strong>Commonly Used Lifecycle Hooks</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Hook",
            "When It Runs",
            "Typical Use Case"
          ],
          "rows": [
            [
              "beforeCreate",
              "Before data observation and events are set up",
              "Rarely used; low-level hook for advanced debugging"
            ],
            [
              "created",
              "After instance is created and reactive data is available",
              "Initialize data or fetch initial data"
            ],
            [
              "beforeMount",
              "Before component is mounted to the DOM",
              "Prepare final changes before mounting"
            ],
            [
              "mounted",
              "After the component is mounted to the DOM",
              "Access the DOM or third-party libraries"
            ],
            [
              "beforeUpdate",
              "Before reactive data causes re-rendering",
              "Perform checks before DOM updates"
            ],
            [
              "updated",
              "After DOM updates due to reactive data changes",
              "React to DOM changes or perform animations"
            ],
            [
              "beforeUnmount",
              "Before the component is destroyed",
              "Cleanup operations or cancel timers"
            ],
            [
              "unmounted",
              "After the component is destroyed and removed from DOM",
              "Release resources, event listeners, or observers"
            ]
          ],
          "caption": "Vue Lifecycle Hook Sequence"
        },
        {
          "type": "text",
          "text": "<strong>Lifecycle Hook Flow</strong><br>1️⃣ <code>beforeCreate</code> → 2️⃣ <code>created</code> → 3️⃣ <code>beforeMount</code> → 4️⃣ <code>mounted</code><br>Then for updates: 5️⃣ <code>beforeUpdate</code> → 6️⃣ <code>updated</code><br>And finally for teardown: 7️⃣ <code>beforeUnmount</code> → 8️⃣ <code>unmounted</code>."
        },
        {
          "type": "text",
          "text": "<strong>Use Case Example</strong><br>Fetching data when a component mounts is one of the most common lifecycle hook patterns:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "export default {\n  data() {\n    return { users: [] };\n  },\n  async mounted() {\n    const res = await fetch('https://api.example.com/users');\n    this.users = await res.json();\n  }\n};"
        },
        {
          "type": "text",
          "text": "In this example, the <code>mounted()</code> hook ensures the component is attached to the DOM before fetching and displaying data."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of lifecycle hooks as checkpoints — moments in a component’s journey where you can pause, inspect, or intervene to perform logic, cleanup, or side effects."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Lifecycle hooks run at specific stages of a component’s creation, update, and destruction.</li><li>Commonly used hooks include <code>created()</code>, <code>mounted()</code>, and <code>updated()</code>.</li><li>They’re essential for handling initialization, DOM access, and cleanup logic.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-directives",
    "title": "What are Vue directives and how do they work?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Vue directives are special HTML attributes prefixed with 'v-' that allow you to bind data, react to events, or manipulate the DOM dynamically. They are the foundation of Vue’s declarative rendering system.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In Vue, directives are custom HTML attributes prefixed with <code>v-</code> that provide reactive behavior to DOM elements. They allow you to bind data, listen for events, show or hide elements, and apply dynamic logic directly in templates without writing manual JavaScript for DOM manipulation."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <div>\n    <p v-if=\"isVisible\">This paragraph is conditionally rendered.</p>\n    <p v-bind:title=\"message\">Hover to see the message.</p>\n    <button v-on:click=\"toggleVisibility\">Toggle Visibility</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      isVisible: true,\n      message: 'Hello from Vue!'\n    };\n  },\n  methods: {\n    toggleVisibility() {\n      this.isVisible = !this.isVisible;\n    }\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "In this example, three directives are used:<br>• <code>v-if</code> conditionally renders an element.<br>• <code>v-bind</code> dynamically binds a JavaScript value to an attribute.<br>• <code>v-on</code> listens for user events like clicks."
        },
        {
          "type": "text",
          "text": "<strong>How Directives Work</strong><br>When Vue compiles a template, it parses all directives and establishes reactivity links between the DOM and your component data. Whenever the underlying data changes, Vue automatically updates the DOM to reflect the new state — no manual DOM manipulation required."
        },
        {
          "type": "text",
          "text": "<strong>Common Built-in Directives</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Directive",
            "Description"
          ],
          "rows": [
            [
              "v-if / v-else / v-else-if",
              "Conditionally render elements based on a boolean expression."
            ],
            [
              "v-show",
              "Toggles visibility using the CSS display property."
            ],
            [
              "v-for",
              "Loops through arrays or objects to render lists."
            ],
            [
              "v-bind",
              "Binds dynamic attributes or props to elements and components."
            ],
            [
              "v-on",
              "Attaches event listeners to DOM elements."
            ],
            [
              "v-model",
              "Creates two-way data binding with form inputs."
            ],
            [
              "v-html",
              "Renders raw HTML content inside an element."
            ],
            [
              "v-text",
              "Updates an element’s text content directly."
            ]
          ],
          "caption": "Common Vue Directives and Their Usage"
        },
        {
          "type": "text",
          "text": "<strong>Custom Directives</strong><br>Vue also allows developers to define custom directives for specialized DOM behavior. Custom directives are registered using <code>app.directive()</code> in Vue 3."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "app.directive('focus', {\n  mounted(el) {\n    el.focus();\n  }\n});"
        },
        {
          "type": "text",
          "text": "Now, using <code>v-focus</code> in your template automatically focuses the element when mounted."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of directives as instructions for the DOM — they tell Vue what to do with elements when your data changes, keeping everything reactive and declarative."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Directives in Vue start with the prefix <code>v-</code> and enhance HTML behavior.</li><li>They dynamically bind data, handle events, and control the DOM.</li><li>Vue provides built-in directives like <code>v-if</code>, <code>v-for</code>, <code>v-bind</code>, and <code>v-on</code>.</li><li>You can create custom directives for advanced, reusable behavior.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-v-bind-v-on-fundamental-template-syntax",
    "title": "Why are v-bind and v-on fundamental to Vue’s template syntax?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain why Vue templates are basically HTML + data bindings + event bindings. Cover what v-bind and v-on compile to (VNode props + event listeners), how they connect reactivity to DOM updates, and why features like v-model build on them.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Vue templates are mostly static HTML. The two things that make templates <em>dynamic</em> are:<br>• <code>v-bind</code> (shorthand <code>:</code>) — state ➜ DOM (attributes/props/class/style)<br>• <code>v-on</code> (shorthand <code>@</code>) — DOM/component events ➜ code (which usually mutates state)<br><br>Those two directives are “fundamental” because they are the main bridges between your reactive state and the rendered output. Most higher-level conveniences (<code>v-model</code>, component prop/event APIs, many patterns) compile down to some combination of <code>v-bind</code> + <code>v-on</code>."
        },
        {
          "type": "list",
          "columns": [
            "Directive",
            "What you write in templates",
            "What it means (conceptually)"
          ],
          "rows": [
            [
              "v-bind (:)",
              "<code>:src=\"url\"</code>, <code>:class=\"cls\"</code>, <code>:disabled=\"loading\"</code>",
              "Evaluate expression during render; when reactive deps change, Vue patches only those bound props/attrs"
            ],
            [
              "v-on (@)",
              "<code>@click=\"inc\"</code>, <code>@input=\"onInput\"</code>, <code>@submit.prevent=\"save\"</code>",
              "Attach a listener; when event fires, run handler (often mutating reactive state)"
            ],
            [
              "Together",
              "UI updates flow: user event ➜ state change ➜ DOM patch",
              "This is the main “reactive loop” in Vue apps"
            ]
          ],
          "caption": "Why templates revolve around v-bind and v-on"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<script setup>\nimport { computed, ref } from 'vue';\n\nconst count = ref(0);\nconst loading = ref(false);\n\nconst buttonClass = computed(() => ({\n  btn: true,\n  'is-loading': loading.value,\n  'is-positive': count.value > 0\n}));\n\nfunction inc() {\n  count.value++;\n}\n\nfunction toggleLoading() {\n  loading.value = !loading.value;\n}\n</script>\n\n<template>\n  <!-- v-bind: state -> DOM -->\n  <button\n    :class=\"buttonClass\"\n    :disabled=\"loading\"\n    :aria-busy=\"loading\"\n    @click=\"inc\"\n  >\n    Count: {{ count }}\n  </button>\n\n  <!-- v-on: event -> code -> state change -->\n  <button @click=\"toggleLoading\">\n    Toggle loading\n  </button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>What happens under the hood</strong><br><br>Vue compiles templates into a render function that produces VNodes. <code>v-bind</code> becomes VNode props (including special handling for <code>class</code>/<code>style</code> and boolean props). <code>v-on</code> becomes event listener props like <code>onClick</code>.<br><br>During render, reactive reads are tracked. When reactive state changes, Vue schedules a re-render and patches only changed VNode props/listeners onto the real DOM."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Pseudo-ish compiled shape (not exact Vue output)\nexport function render(_ctx) {\n  return h('button', {\n    class: _ctx.buttonClass,\n    disabled: _ctx.loading,\n    'aria-busy': _ctx.loading,\n    onClick: _ctx.inc\n  }, `Count: ${_ctx.count}`);\n}\n\n// Later, when count/loading changes:\n// Vue re-runs render -> diffs VNodes -> patches only changed props on the same DOM node."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "How it uses v-bind/v-on",
            "Why it matters"
          ],
          "rows": [
            [
              "Props on components",
              "<code>&lt;Child :value=\"x\" /&gt;</code>",
              "Same binding mechanism, but targets component props instead of DOM attrs"
            ],
            [
              "Component events",
              "<code>&lt;Child @save=\"onSave\" /&gt;</code>",
              "Same listener mechanism, but listens to emitted events (child ➜ parent)"
            ],
            [
              "v-model",
              "Compiles to a prop bind + an update listener",
              "Explains why v-model is “syntax sugar”"
            ],
            [
              "Object spread binding",
              "<code>v-bind=\"attrs\"</code>",
              "Pass-through attributes/props in a single place (wrapper components)"
            ],
            [
              "Event modifiers",
              "<code>@submit.prevent</code>, <code>@click.stop</code>, <code>@keyup.enter</code>",
              "Declarative control of default behavior and propagation"
            ],
            [
              "Dynamic arguments",
              "<code>:[name]=\"val\"</code>, <code>@[event]=\"handler\"</code>",
              "Attribute/event names can be data-driven (use carefully; readability)"
            ]
          ],
          "caption": "Most template features are variations of binding props and listening to events"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- v-model is just v-bind + v-on (Vue 3, custom component) -->\n<!-- Sugar -->\n<UserInput v-model=\"name\" />\n\n<!-- Desugared -->\n<UserInput\n  :modelValue=\"name\"\n  @update:modelValue=\"name = $event\"\n/>\n\n<!-- For native inputs (conceptually) -->\n<input :value=\"name\" @input=\"name = $event.target.value\" />"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br><code>v-bind</code> and <code>v-on</code> are the core primitives because templates become dynamic only by (1) binding reactive values into VNode props and (2) wiring events back into your code. Everything else is either additional syntax around those primitives (like <code>v-model</code>) or structural directives that still rely on them to express dynamic attributes and interactivity."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-child-mutates-prop-directly",
    "title": "What breaks if a child mutates a prop directly?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "In Vue, props are meant to be read-only inputs from parent to child. Explain what breaks (correctness + debugging) when a child component directly mutates a prop, including the nested object/array case, and show the correct patterns (emit updates / v-model).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Props are the parent’s state flowing <em>down</em>. If the child mutates a prop, you lose the “single source of truth” and the update path becomes ambiguous (who changed it, when, and why). Vue will warn in dev, but the bigger issue is correctness + maintainability."
        },
        {
          "type": "list",
          "columns": [
            "What the child does",
            "What breaks",
            "Why it’s bad"
          ],
          "rows": [
            [
              "Assigns a prop directly (e.g. props.count++)",
              "Vue warns; update is rejected / overwritten on next parent render",
              "Child is trying to mutate parent-owned state without going through the parent"
            ],
            [
              "Mutates a nested field on an object/array prop (e.g. props.user.name = 'x')",
              "You silently mutate the parent’s object (shared reference) and create “action at a distance” bugs",
              "Objects/arrays are passed by reference; child mutation becomes parent mutation"
            ],
            [
              "Uses a prop as local state (editing it directly)",
              "UI can desync (parent re-renders and resets the child), race conditions with async updates",
              "Parent can re-send the prop anytime; child-local edits aren’t a stable source of truth"
            ],
            [
              "Triggers watchers/computed based on mutated prop",
              "Hard-to-trace update loops / unexpected re-renders",
              "You bypass the intended data flow and can create circular updates"
            ]
          ],
          "caption": "What actually breaks when a child mutates a prop"
        },
        {
          "type": "text",
          "text": "<strong>Bad example: child mutates a primitive prop</strong><br><br>In Vue 3, <code>defineProps()</code> is shallow readonly. Mutating it causes a dev warning and is considered an anti-pattern."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ChildCounter.vue (BAD) -->\n<script setup>\nconst props = defineProps({\n  count: { type: Number, required: true }\n});\n\nfunction inc() {\n  // ❌ anti-pattern: mutating a prop\n  // Vue warns in dev; parent can overwrite on next render.\n  props.count++;\n}\n</script>\n\n<template>\n  <button @click=\"inc\">Count: {{ count }}</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Correct pattern: emit an update (parent stays the source of truth)</strong><br><br>The child requests a change; the parent applies it."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ChildCounter.vue (GOOD) -->\n<script setup>\nconst props = defineProps({\n  count: { type: Number, required: true }\n});\n\nconst emit = defineEmits(['update:count']);\n\nfunction inc() {\n  emit('update:count', props.count + 1);\n}\n</script>\n\n<template>\n  <button @click=\"inc\">Count: {{ count }}</button>\n</template>\n\n<!-- Parent.vue -->\n<script setup>\nimport { ref } from 'vue';\nimport ChildCounter from './ChildCounter.vue';\n\nconst count = ref(0);\n</script>\n\n<template>\n  <!-- v-model:count = :count + @update:count -->\n  <ChildCounter v-model:count=\"count\" />\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>The tricky case: object/array props</strong><br><br>Even if Vue warns, mutating <code>props.user.name</code> is still mutating the same object the parent passed. This couples child behavior to parent state and makes bugs look “random” because the mutation didn’t go through an explicit parent update."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ChildUserEditor.vue (BAD) -->\n<script setup>\nconst props = defineProps({\n  user: { type: Object, required: true }\n});\n\nfunction rename() {\n  // ❌ Mutates parent-owned object via shared reference\n  props.user.name = 'New Name';\n}\n</script>\n\n<template>\n  <button @click=\"rename\">Rename</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>When you need “editable local state”</strong><br><br>Make a local copy for editing, and emit the final value (or emit on each change)."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- ChildNameInput.vue (local draft -> emit) -->\n<script setup>\nimport { ref, watch } from 'vue';\n\nconst props = defineProps({\n  name: { type: String, required: true }\n});\nconst emit = defineEmits(['update:name']);\n\nconst draft = ref(props.name);\n\n// Keep draft in sync if parent changes the prop externally\nwatch(() => props.name, (v) => { draft.value = v; });\n\nfunction commit() {\n  emit('update:name', draft.value);\n}\n</script>\n\n<template>\n  <input v-model=\"draft\" />\n  <button @click=\"commit\">Save</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Interview-ready takeaway</strong><br><br>Mutating props breaks one-way data flow: the parent is no longer the single source of truth, updates become non-deterministic to trace, and nested object/array props can mutate parent state by reference. Correct approach: child <em>emits intent</em> (update events / v-model) and the parent owns the actual state mutation."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-child-to-parent",
    "title": "How does Vue handle component communication (child to parent)?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "In Vue, child components communicate with parent components using custom events. The child emits an event with optional data using $emit(), and the parent listens for that event using v-on or the @ shorthand.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vue’s event system allows child components to send messages to their parent components. This is done using the <code>$emit()</code> method, which emits a custom event that the parent can listen for. This keeps data flow structured — from parent to child via props, and from child to parent via events."
        },
        {
          "type": "text",
          "text": "<strong>Step 1: Emit an Event from the Child Component</strong><br>The child component uses the <code>$emit()</code> method to trigger an event, optionally passing data as an argument."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Child.vue -->\n<template>\n  <button @click=\"$emit('increment', 1)\">Add 1</button>\n</template>"
        },
        {
          "type": "text",
          "text": "In this example, when the button is clicked, the child component emits an event called <code>increment</code> and passes a value of <code>1</code> as data."
        },
        {
          "type": "text",
          "text": "<strong>Step 2: Listen for the Event in the Parent Component</strong><br>The parent component listens for the event using <code>v-on</code> or the shorthand <code>@</code> syntax and executes a corresponding method."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Parent.vue -->\n<template>\n  <div>\n    <p>Count: {{ count }}</p>\n    <Child @increment=\"increaseCount\" />\n  </div>\n</template>\n\n<script>\nimport Child from './Child.vue';\n\nexport default {\n  components: { Child },\n  data() {\n    return { count: 0 };\n  },\n  methods: {\n    increaseCount(amount) {\n      this.count += amount;\n    }\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "The parent listens for the <code>increment</code> event and runs <code>increaseCount()</code> when it occurs, updating the <code>count</code> value accordingly."
        },
        {
          "type": "text",
          "text": "<strong>Step 3: Emitting Custom Events with Data</strong><br>You can emit complex data like objects or arrays, not just numbers or strings."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Child.vue -->\n<button @click=\"$emit('send-user', { name: 'Mina', age: 28 })\">\n  Send User Data\n</button>\n\n<!-- Parent.vue -->\n<Child @send-user=\"handleUserData\" />\n\n<script>\nexport default {\n  methods: {\n    handleUserData(user) {\n      console.log('Received user:', user);\n    }\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>One-Way Communication Rule</strong><br>Vue enforces a clear, one-way communication structure:<ul><li><strong>Parent → Child:</strong> via props</li><li><strong>Child → Parent:</strong> via custom events</li></ul>This makes applications more predictable and easier to debug."
        },
        {
          "type": "text",
          "text": "<strong>Event Names</strong><br>Event names are typically written in kebab-case (e.g., <code>user-selected</code>). The parent must use the same case when listening for the event."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<Child @user-selected=\"onUserSelected\" />"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>$emit</code> as the child’s voice — it notifies the parent that something happened, while the parent decides how to respond."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Child components communicate with parents using <code>$emit()</code>.</li><li>Parents listen for events with <code>v-on</code> or <code>@</code>.</li><li>Data can be passed upward as event arguments.</li><li>Combining props and events ensures a clean, one-way data flow between components.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-composition-api-vs-mixins",
    "title": "Why does Vue recommend the Composition API over mixins today?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain the practical problems with mixins in real Vue codebases (implicit behavior, naming collisions, unclear data sources, typing issues), and why Composition API + composables is the preferred alternative for reuse and scalability.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Vue recommends the Composition API over mixins because mixins scale poorly: they hide where logic/state comes from, can collide/override silently, and are hard to type and refactor. Composition API fixes that by making reuse <em>explicit</em> (import + call a composable), <em>composable</em> (combine multiple functions safely), and <em>TypeScript-friendly</em> (inference works through function signatures)."
        },
        {
          "type": "list",
          "columns": [
            "Problem with mixins",
            "What it looks like in code",
            "How Composition API fixes it"
          ],
          "rows": [
            [
              "Implicit sources (\"Where did this come from?\")",
              "Template/method uses <code>loading</code>/<code>save</code> but you can’t tell if it’s local or from a mixin",
              "You see it: <code>const { loading, save } = useSave()</code> (explicit import + call)"
            ],
            [
              "Name collisions / overrides",
              "Two mixins (or mixin + component) define the same <code>data</code>/<code>methods</code>/<code>computed</code> keys",
              "Return names you control (rename on destructure) and keep state scoped per composable call"
            ],
            [
              "Hard refactors",
              "Renaming a field in a mixin can break many components in non-obvious ways",
              "Refactor via normal TS/JS tooling: function exports, parameters, return types"
            ],
            [
              "Weak TypeScript inference",
              "Options API + mixins make it hard for TS to know what exists on <code>this</code>",
              "Composables are just functions: TS infers return types and narrows correctly"
            ],
            [
              "Hidden coupling and lifecycle side effects",
              "A mixin adds watchers/hooks that run in every component using it, often unexpectedly",
              "Composables make effects explicit and local; you call it only where needed"
            ],
            [
              "Testing friction",
              "Testing mixin behavior often requires mounting components or relying on <code>this</code>",
              "Test composables as plain functions (or with minimal Vue reactivity helpers)"
            ]
          ],
          "caption": "Why Composition API wins over mixins in large codebases"
        },
        {
          "type": "text",
          "text": "<strong>The big pain point: collisions and “action at a distance”</strong><br><br>Mixins merge into the component options. If multiple sources define the same key, you can get overrides or merged behavior (hooks). The result: you read a component and can’t confidently tell what runs, in what order, and which definition “wins”."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Example: mixin collisions are easy to introduce -->\n<script>\nconst SavingMixin = {\n  data() {\n    return { loading: false };\n  },\n  methods: {\n    save() {\n      // ...\n    }\n  }\n};\n\nconst AnalyticsMixin = {\n  data() {\n    return { loading: true }; // collision: same key name\n  },\n  methods: {\n    save() {\n      // collision: same method name (which one runs is non-obvious)\n    }\n  }\n};\n\nexport default {\n  name: 'UserForm',\n  mixins: [SavingMixin, AnalyticsMixin],\n  // component may also define loading/save again\n};\n</script>\n\n<template>\n  <button :disabled=\"loading\" @click=\"save\">Save</button>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>Composition API approach: explicit, local, and composable</strong><br><br>With composables, logic reuse is just function composition: you import what you need, call it, and use returned refs/functions. Naming is explicit (and renameable), collisions are controlled, and types are predictable."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// useSave.ts\nimport { ref } from 'vue';\n\nexport function useSave() {\n  const loading = ref(false);\n\n  async function save(payload) {\n    loading.value = true;\n    try {\n      // ...api call\n    } finally {\n      loading.value = false;\n    }\n  }\n\n  return { loading, save };\n}\n\n// useAnalyticsSave.ts\nexport function useAnalyticsSave(baseSave) {\n  async function saveWithAnalytics(payload) {\n    // track(...)\n    return baseSave(payload);\n  }\n\n  return { saveWithAnalytics };\n}"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- UserForm.vue (Composition API, explicit reuse) -->\n<script setup>\nimport { useSave } from './useSave';\nimport { useAnalyticsSave } from './useAnalyticsSave';\n\nconst { loading, save } = useSave();\nconst { saveWithAnalytics } = useAnalyticsSave(save);\n</script>\n\n<template>\n  <button :disabled=\"loading\" @click=\"saveWithAnalytics({ /* ... */ })\">\n    Save\n  </button>\n</template>"
        },
        {
          "type": "list",
          "columns": [
            "Interview-ready point",
            "What to say"
          ],
          "rows": [
            [
              "Why mixins are discouraged",
              "They create implicit APIs on the component, cause collisions/overrides, and make large codebases harder to reason about and type."
            ],
            [
              "Why Composition API is preferred",
              "Reusable logic becomes explicit (import + call), composable (combine functions safely), and TypeScript-friendly (good inference)."
            ],
            [
              "How reuse is done today",
              "Use composables (e.g., <code>useX()</code>) instead of mixins; keep component API clear and local."
            ],
            [
              "Are mixins forbidden?",
              "No—still supported, but composables are the recommended default for logic reuse in Vue 3-era apps."
            ]
          ],
          "caption": "What interviewers want you to highlight"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-sfc-vs-global-components",
    "title": "What is the difference between single-file components and global components?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Single-File Components (SFCs) and global components differ in scope and structure. SFCs define components in .vue files with encapsulated templates, scripts, and styles, while global components are registered once and accessible throughout the application.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vue components can be created as <strong>Single-File Components (SFCs)</strong> or <strong>Global Components</strong>. Both define reusable UI pieces, but they differ in organization, scope, and how they are registered within a Vue application."
        },
        {
          "type": "text",
          "text": "<strong>Single-File Components (SFCs)</strong><br>Single-File Components are stored in <code>.vue</code> files and include three main sections — <template>, <script>, and <style>. They provide a modular, maintainable way to build complex applications."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- UserCard.vue -->\n<template>\n  <div class=\"user-card\">\n    <h2>{{ name }}</h2>\n    <p>{{ email }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['name', 'email']\n};\n</script>\n\n<style scoped>\n.user-card { border: 1px solid #ddd; padding: 10px; }\n</style>"
        },
        {
          "type": "text",
          "text": "SFCs promote better organization by separating structure, logic, and styling within a single file while keeping them tightly coupled for easier maintenance. They are registered locally within the parent component or automatically via file-based routing tools like Vite or Nuxt."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// App.vue\n<template>\n  <UserCard name=\"Mina\" email=\"mina@example.com\" />\n</template>\n\n<script>\nimport UserCard from './UserCard.vue';\nexport default { components: { UserCard } };\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Global Components</strong><br>Global components, on the other hand, are registered once in your app’s entry point (usually <code>main.js</code>) and can be used anywhere without importing them explicitly."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nimport BaseButton from './components/BaseButton.vue';\n\nconst app = createApp(App);\napp.component('BaseButton', BaseButton);\napp.mount('#app');"
        },
        {
          "type": "text",
          "text": "Now the <code>BaseButton</code> component can be used in any template throughout the app without the need for imports."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- AnyComponent.vue -->\n<template>\n  <BaseButton>Click Me</BaseButton>\n</template>"
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Single-File Components (SFCs)",
            "Global Components"
          ],
          "rows": [
            [
              "Definition",
              "Components defined in .vue files with template, script, and style sections",
              "Components registered globally via app.component()"
            ],
            [
              "Scope",
              "Available only in components where imported",
              "Available everywhere in the app"
            ],
            [
              "Usage",
              "Locally registered and explicitly imported",
              "Globally available without import"
            ],
            [
              "Organization",
              "Encourages modularity and reusability",
              "Useful for shared UI elements like buttons or modals"
            ],
            [
              "Performance",
              "Scoped registration reduces memory overhead",
              "Can increase bundle size if overused"
            ]
          ],
          "caption": "Comparison Between Single-File and Global Components"
        },
        {
          "type": "text",
          "text": "<strong>When to Use Each</strong><ul><li>Use <strong>SFCs</strong> for application-specific, modular, and reusable components that benefit from encapsulation.</li><li>Use <strong>Global Components</strong> for shared UI elements like buttons, icons, or form fields that appear across multiple views.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of global components as public utilities — accessible everywhere but should be used sparingly, while SFCs are private blueprints — focused and modular for specific tasks."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>SFCs are defined in <code>.vue</code> files and locally registered for better modularity.</li><li>Global components are registered once and accessible throughout the app.</li><li>Use SFCs for maintainable large-scale apps, and global components for common UI building blocks.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-conditional-list-rendering",
    "title": "How does Vue handle conditional rendering and list rendering efficiently?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Vue handles conditional and list rendering efficiently through its virtual DOM diffing system. Directives like v-if, v-show, and v-for control what is rendered while Vue updates only the necessary parts of the DOM when data changes.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vue provides efficient and declarative ways to control rendering using directives like <code>v-if</code>, <code>v-show</code>, and <code>v-for</code>. These directives determine whether elements should appear in the DOM and how lists of elements are dynamically generated and updated. Vue’s virtual DOM efficiently detects what has changed and updates only the affected parts, rather than re-rendering the entire DOM."
        },
        {
          "type": "text",
          "text": "<strong>Conditional Rendering</strong><br>Conditional rendering in Vue is handled primarily with <code>v-if</code>, <code>v-else-if</code>, <code>v-else</code>, and <code>v-show</code>."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <div>\n    <p v-if=\"isLoggedIn\">Welcome back, {{ username }}!</p>\n    <p v-else>Please log in to continue.</p>\n\n    <button v-show=\"!isLoggedIn\">Login</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      isLoggedIn: false,\n      username: 'Mina'\n    };\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "Here’s how it works:<ul><li><code>v-if</code> adds or removes elements from the DOM completely based on the condition. It’s useful when the condition changes infrequently.</li><li><code>v-show</code> toggles the element’s CSS <code>display</code> property without adding or removing it from the DOM, which is more efficient for frequent toggling.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>List Rendering</strong><br>Vue’s <code>v-for</code> directive is used to render lists of items efficiently. Each list item is tracked using a <code>key</code>, allowing Vue to reuse and reorder DOM elements instead of re-creating them from scratch."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <ul>\n    <li v-for=\"user in users\" :key=\"user.id\">\n      {{ user.name }}\n    </li>\n  </ul>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      users: [\n        { id: 1, name: 'Alice' },\n        { id: 2, name: 'Bob' },\n        { id: 3, name: 'Charlie' }\n      ]\n    };\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "The <code>:key</code> attribute helps Vue track each item’s identity when updating the DOM. This makes updates more efficient, as Vue can determine what has changed, added, or removed using its virtual DOM diffing algorithm."
        },
        {
          "type": "list",
          "columns": [
            "Directive",
            "Purpose",
            "Efficiency Note"
          ],
          "rows": [
            [
              "v-if / v-else-if / v-else",
              "Conditionally add or remove elements from the DOM",
              "Slower if toggled frequently (creates/destroys elements)"
            ],
            [
              "v-show",
              "Toggle element visibility using CSS display",
              "Faster for frequent toggling"
            ],
            [
              "v-for",
              "Render a list of elements based on an array or object",
              "Highly optimized with key tracking and virtual DOM diffing"
            ]
          ],
          "caption": "Comparison of Conditional and List Rendering Techniques"
        },
        {
          "type": "text",
          "text": "<strong>Why It’s Efficient</strong><br>Vue uses a <em>virtual DOM</em> to compare the current and previous states of the UI. When changes occur, Vue only updates the parts that differ, instead of re-rendering the entire view. This ensures performance even in large lists or when toggling content rapidly."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>v-if</code> as removing or inserting items from a shelf and <code>v-show</code> as simply covering or uncovering them — both are efficient, but suited for different situations."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li><code>v-if</code> removes or inserts elements into the DOM.</li><li><code>v-show</code> toggles visibility via CSS.</li><li><code>v-for</code> efficiently renders dynamic lists using keys.</li><li>Vue’s virtual DOM minimizes unnecessary DOM updates for smooth performance.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-router-navigation",
    "title": "What is the Vue Router and how is it used for navigation?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Vue Router is the official routing library for Vue.js. It allows developers to create single-page applications (SPAs) with dynamic navigation and component-based routing without reloading the page.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vue Router is an official library that enables navigation between different views or components in a Vue application. It transforms a Vue app into a Single-Page Application (SPA) by mapping URLs (routes) to specific components and handling transitions dynamically without reloading the page."
        },
        {
          "type": "text",
          "text": "<strong>Installing Vue Router</strong><br>To use Vue Router, install it with npm or yarn:"
        },
        {
          "type": "code",
          "language": "bash",
          "code": "npm install vue-router\n# or\nyarn add vue-router"
        },
        {
          "type": "text",
          "text": "<strong>Defining Routes</strong><br>Routes are defined as objects, where each route maps a URL path to a specific component."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// router.js\nimport { createRouter, createWebHistory } from 'vue-router';\nimport Home from './components/Home.vue';\nimport About from './components/About.vue';\n\nconst routes = [\n  { path: '/', component: Home },\n  { path: '/about', component: About }\n];\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes\n});\n\nexport default router;"
        },
        {
          "type": "text",
          "text": "<strong>Using the Router in Your App</strong><br>Once defined, the router must be registered in the main Vue application instance."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nimport router from './router';\n\nconst app = createApp(App);\napp.use(router);\napp.mount('#app');"
        },
        {
          "type": "text",
          "text": "Now your application can handle different pages without reloading. The <code>&lt;router-view&gt;</code> element acts as a placeholder that dynamically displays the active route’s component."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<template>\n  <div>\n    <nav>\n      <router-link to=\"/\">Home</router-link>\n      <router-link to=\"/about\">About</router-link>\n    </nav>\n\n    <router-view></router-view>\n  </div>\n</template>"
        },
        {
          "type": "text",
          "text": "<strong>How Navigation Works</strong><br>• <code>&lt;router-link&gt;</code> creates navigable links without refreshing the page.<br>• <code>&lt;router-view&gt;</code> displays the matched component for the current route.<br>• Vue Router automatically updates the browser’s history using the HTML5 History API."
        },
        {
          "type": "text",
          "text": "<strong>Dynamic and Nested Routes</strong><br>Vue Router supports dynamic routes (e.g., user profiles) and nested routes for hierarchical views."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "{ path: '/user/:id', component: UserProfile }"
        },
        {
          "type": "text",
          "text": "Access dynamic parameters in the component using <code>this.$route.params.id</code>."
        },
        {
          "type": "text",
          "text": "<strong>Programmatic Navigation</strong><br>You can also navigate using JavaScript instead of router-link components:"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "this.$router.push('/about');\nthis.$router.replace('/');"
        },
        {
          "type": "text",
          "text": "<strong>Navigation Guards</strong><br>Vue Router includes navigation guards (e.g., <code>beforeEach</code>) to control access to routes, often used for authentication or logging."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "router.beforeEach((to, from, next) => {\n  if (to.path === '/admin' && !isLoggedIn()) {\n    next('/login');\n  } else {\n    next();\n  }\n});"
        },
        {
          "type": "text",
          "text": "<strong>Advantages of Vue Router</strong><ul><li>Enables navigation without page reloads.</li><li>Supports nested, dynamic, and lazy-loaded routes.</li><li>Integrates with browser history and back navigation.</li><li>Works seamlessly with Vue’s reactivity system.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Vue Router as the GPS of your application — it knows where you are, where you’re going, and updates the view without ever refreshing the page."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Vue Router maps URL paths to components for single-page navigation.</li><li>Use <router-link> for navigation and <router-view> to display views.</li><li>Supports dynamic, nested, and programmatic navigation.</li><li>Navigation guards help manage route access and user flow.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-reactivity-system",
    "title": "What is the Vue reactivity system and how does it work internally?",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 5,
    "description": "The Vue reactivity system is the core mechanism that automatically updates the DOM whenever data changes. Internally, it uses proxies (in Vue 3) to track dependencies and trigger re-renders when reactive data is modified.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>The Vue reactivity system is what makes Vue applications dynamic and responsive. It allows your UI to automatically update when underlying data changes — without manually manipulating the DOM. In Vue 3, this system is powered by <strong>ES6 Proxies</strong>, which intercept and track operations on reactive objects."
        },
        {
          "type": "text",
          "text": "<strong>How Vue Reactivity Works</strong><br>Vue’s reactivity is built around three key concepts:<ul><li><strong>Reactive Data</strong>: Data that Vue tracks for changes.</li><li><strong>Dependency Tracking</strong>: Vue keeps track of which components or functions depend on which pieces of data.</li><li><strong>Reactivity Triggers</strong>: When data changes, Vue automatically re-runs or re-renders the parts of the app that depend on that data.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>1. Creating Reactive Data</strong><br>In Vue 3, the <code>reactive()</code> and <code>ref()</code> APIs from the Composition API are used to create reactive data sources."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive, ref } from 'vue';\n\nconst state = reactive({ count: 0 });\nconst message = ref('Hello Vue!');"
        },
        {
          "type": "text",
          "text": "Here, both <code>state</code> and <code>message</code> become reactive — Vue wraps them in a proxy that intercepts reads and writes to track changes."
        },
        {
          "type": "text",
          "text": "<strong>2. Tracking Dependencies</strong><br>When a component renders and accesses reactive properties, Vue records which reactive values were used. These dependencies are stored in an internal data structure called a <strong>Dependency Map</strong> (a WeakMap under the hood)."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Pseudo-code of dependency tracking\nfunction track(target, key) {\n  const effect = activeEffect; // current rendering effect\n  if (effect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) targetMap.set(target, (depsMap = new Map()));\n\n    let dep = depsMap.get(key);\n    if (!dep) depsMap.set(key, (dep = new Set()));\n\n    dep.add(effect);\n  }\n}"
        },
        {
          "type": "text",
          "text": "Every time a reactive property is accessed during rendering, Vue calls <code>track()</code> to register the current watcher or computed effect as a dependency."
        },
        {
          "type": "text",
          "text": "<strong>3. Triggering Updates</strong><br>When a reactive value changes, Vue triggers an update by looking up all the effects (like component re-renders or computed properties) that depend on that property, then re-executes them."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Pseudo-code of triggering updates\nfunction trigger(target, key) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) return;\n  const dep = depsMap.get(key);\n  if (dep) {\n    dep.forEach(effect => effect());\n  }\n}"
        },
        {
          "type": "text",
          "text": "This ensures that only the parts of the app that depend on the modified property are re-run, leading to efficient updates instead of full-page re-renders."
        },
        {
          "type": "text",
          "text": "<strong>4. Vue 2 vs Vue 3 Reactivity</strong><br>In Vue 2, reactivity was achieved with <code>Object.defineProperty()</code> — Vue defined getters and setters for each property. However, it couldn’t detect new properties or array index changes easily.<br><br>In Vue 3, the system uses <strong>Proxies</strong>, which can intercept all property operations (get, set, delete, etc.), enabling full reactivity without these limitations."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Vue 2 (Object.defineProperty)",
            "Vue 3 (Proxy)"
          ],
          "rows": [
            [
              "Detect new properties",
              "❌ Not supported",
              "✅ Supported"
            ],
            [
              "Detect array index changes",
              "❌ Limited",
              "✅ Fully supported"
            ],
            [
              "Performance",
              "Moderate",
              "Faster and more efficient"
            ],
            [
              "Memory usage",
              "Higher due to watchers",
              "Lower, centralized dependency tracking"
            ]
          ],
          "caption": "Comparison of Vue 2 and Vue 3 Reactivity Systems"
        },
        {
          "type": "text",
          "text": "<strong>5. Computed Properties and Watchers</strong><br>Computed properties in Vue use this same reactivity mechanism but cache results until their dependencies change. Watchers use reactive tracking to run custom logic when specific data updates."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "import { reactive, computed, watch } from 'vue';\n\nconst state = reactive({ count: 0 });\nconst doubled = computed(() => state.count * 2);\n\nwatch(() => state.count, (newVal, oldVal) => {\n  console.log('Count changed:', oldVal, '→', newVal);\n});"
        },
        {
          "type": "text",
          "text": "Here, both <code>computed()</code> and <code>watch()</code> rely on Vue’s dependency tracking to know when <code>state.count</code> changes."
        },
        {
          "type": "text",
          "text": "<strong>6. Virtual DOM Integration</strong><br>When data changes, Vue marks affected components for re-rendering. During the next render cycle, Vue’s virtual DOM efficiently diffs the new and old virtual trees and updates only the changed elements in the real DOM."
        },
        {
          "type": "text",
          "text": "<strong>Why It’s Efficient</strong><br>Vue’s reactivity is fine-grained — it tracks dependencies at the property level. This means only the parts of your UI that depend on changed data are updated. Combined with virtual DOM diffing, this provides excellent runtime performance even for large applications."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of the Vue reactivity system as an intelligent observer — it watches over your data, remembers what depends on it, and instantly updates only what’s necessary when something changes."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Vue’s reactivity system tracks dependencies using Proxies and WeakMaps.</li><li>Reactive objects trigger updates only for the affected properties.</li><li>Vue 3’s Proxy-based reactivity is faster, more complete, and easier to maintain than Vue 2’s system.</li><li>Computed properties and watchers build upon the same reactive foundation.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-composition-api",
    "title": "What are Vue Composition APIs (setup(), ref, reactive) and why were they introduced?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "The Vue Composition API provides a flexible and scalable way to organize component logic using functions like setup(), ref(), and reactive(). It was introduced in Vue 3 to improve reusability, maintainability, and TypeScript support compared to the Options API.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>The Composition API is a new way to write components in Vue 3. It provides greater flexibility and control over organizing logic inside components by using functions like <code>setup()</code>, <code>ref()</code>, and <code>reactive()</code>. This API was introduced to address the limitations of the traditional Options API, making complex component logic easier to read, reuse, and test."
        },
        {
          "type": "text",
          "text": "<strong>Why the Composition API Was Introduced</strong><br>In large applications, the Options API (using data, methods, computed, etc.) often leads to scattered logic — related code gets separated into different options, making it harder to maintain and reuse. The Composition API solves this by allowing developers to group related logic together using plain JavaScript functions."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example of Composition API\n<template>\n  <div>\n    <p>Count: {{ count }}</p>\n    <button @click=\"increment\">Increment</button>\n  </div>\n</template>\n\n<script>\nimport { ref } from 'vue';\n\nexport default {\n  setup() {\n    const count = ref(0);\n    const increment = () => count.value++;\n\n    return { count, increment };\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "<strong>Key Concepts in the Composition API</strong>"
        },
        {
          "type": "text",
          "text": "<strong>1. setup() Function</strong><br>The <code>setup()</code> function is the entry point of the Composition API. It runs before the component is created and is used to declare reactive state, computed properties, watchers, and lifecycle hooks.<br><br>Anything returned from <code>setup()</code> becomes available in the component template."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "setup() {\n  const name = ref('Mina');\n  const greet = () => console.log(`Hello, ${name.value}!`);\n\n  return { name, greet };\n}"
        },
        {
          "type": "text",
          "text": "<strong>2. ref()</strong><br><code>ref()</code> creates a reactive reference to a primitive value (like numbers, strings, or booleans). When you update <code>ref.value</code>, Vue automatically tracks and re-renders any parts of the UI that depend on it."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const message = ref('Hello');\nmessage.value = 'Hi there!';"
        },
        {
          "type": "text",
          "text": "<strong>3. reactive()</strong><br><code>reactive()</code> creates a reactive object instead of a primitive. It’s ideal for tracking multiple properties within an object or array."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const user = reactive({ name: 'Alice', age: 25 });\nuser.age++; // Triggers reactivity automatically"
        },
        {
          "type": "text",
          "text": "<strong>4. Combining ref() and reactive()</strong><br>You can combine both approaches — use <code>ref()</code> for single values and <code>reactive()</code> for complex objects. They can also be mixed within the same component for flexibility."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "const count = ref(0);\nconst user = reactive({ name: 'Mina', score: 10 });"
        },
        {
          "type": "text",
          "text": "<strong>Advantages of the Composition API</strong><ul><li>Better logic organization and reuse through composable functions.</li><li>Improved TypeScript support and static analysis.</li><li>Cleaner separation of concerns for large components.</li><li>Fully compatible with existing Options API — both can coexist in the same project.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of the Composition API as building blocks: instead of being restricted to predefined sections (data, methods, computed), you freely compose logic like LEGO pieces — reusable, organized, and scalable."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li><code>setup()</code> is the core entry point for the Composition API.</li><li><code>ref()</code> makes primitive values reactive.</li><li><code>reactive()</code> makes entire objects reactive.</li><li>Introduced to improve reusability, readability, and TypeScript compatibility.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vuex-state-management",
    "title": "What is the purpose of Vuex, and how does it help manage state in large applications?",
    "technology": "vue",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Vuex is a state management library for Vue.js applications. It provides a centralized store for all components, ensuring predictable state mutations and simplifying data flow across large-scale apps.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vuex is Vue’s official <strong>state management pattern and library</strong>. It serves as a centralized store that manages shared data and ensures all components access and modify it in a consistent, predictable way. This is crucial in large-scale applications where multiple components depend on or modify the same state."
        },
        {
          "type": "text",
          "text": "<strong>Why Vuex Is Needed</strong><br>In small apps, passing data via <code>props</code> and emitting events (<code>$emit</code>) works fine. However, in large applications with deeply nested components, data flow becomes hard to manage. Vuex solves this by providing a single source of truth — the <strong>store</strong> — from which all components can read or update data in a controlled manner."
        },
        {
          "type": "text",
          "text": "<strong>Core Concepts of Vuex</strong><br>Vuex is built around four key elements: <strong>State</strong>, <strong>Getters</strong>, <strong>Mutations</strong>, and <strong>Actions</strong>."
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Purpose",
            "Example"
          ],
          "rows": [
            [
              "State",
              "Holds the centralized data",
              "user.name, cartItems, authToken"
            ],
            [
              "Getters",
              "Computed properties for the store",
              "getters.cartTotal"
            ],
            [
              "Mutations",
              "Synchronous functions to modify state",
              "commit('addToCart', item)"
            ],
            [
              "Actions",
              "Asynchronous operations that commit mutations",
              "dispatch('fetchProducts')"
            ]
          ],
          "caption": "Core Elements of Vuex Store"
        },
        {
          "type": "text",
          "text": "<strong>Vuex Store Example</strong>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// store.js\nimport { createStore } from 'vuex';\n\nconst store = createStore({\n  state() {\n    return {\n      count: 0,\n      user: { name: 'Mina' }\n    };\n  },\n  getters: {\n    upperName: (state) => state.user.name.toUpperCase()\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    }\n  },\n  actions: {\n    asyncIncrement({ commit }) {\n      setTimeout(() => commit('increment'), 500);\n    }\n  }\n});\n\nexport default store;"
        },
        {
          "type": "text",
          "text": "<strong>Using the Store in Components</strong><br>Once created, the store is registered globally and accessed via the <code>useStore()</code> function in components."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "<template>\n  <div>\n    <p>Count: {{ store.state.count }}</p>\n    <button @click=\"store.commit('increment')\">Increment</button>\n  </div>\n</template>\n\n<script>\nimport { useStore } from 'vuex';\n\nexport default {\n  setup() {\n    const store = useStore();\n    return { store };\n  }\n};\n</script>"
        },
        {
          "type": "text",
          "text": "Here, the component accesses the store’s <code>state</code> and triggers updates using <code>commit()</code> and <code>dispatch()</code>."
        },
        {
          "type": "text",
          "text": "<strong>Data Flow in Vuex</strong><br>Vuex enforces a one-way data flow:<br><br><ul><li><strong>State</strong>: The single source of truth.</li><li><strong>View</strong>: Displays state and triggers actions.</li><li><strong>Actions</strong>: Commit mutations asynchronously (e.g., API calls).</li><li><strong>Mutations</strong>: Synchronously change state.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Advantages of Vuex</strong><ul><li>Centralized state management — a single source of truth.</li><li>Predictable state transitions through mutations.</li><li>Improved debugging and time-travel debugging via DevTools.</li><li>Easy synchronization between components sharing data.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Vuex vs. Pinia</strong><br>Pinia, introduced later, is the official replacement for Vuex in Vue 3. It simplifies syntax, supports the Composition API natively, and reduces boilerplate while maintaining similar concepts like <code>state</code>, <code>getters</code>, and <code>actions</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Vuex as a shared control center: instead of each component managing its own data independently, they all communicate with the same centralized store — ensuring consistency and predictability."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>Vuex provides a centralized, predictable state management system.</li><li>Components share data through a single source of truth — the store.</li><li>Mutations update state synchronously; actions handle async operations.</li><li>Ideal for large-scale apps where multiple components depend on shared state.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "vue-virtual-dom-diffing",
    "title": "How does Vue’s virtual DOM and diffing algorithm optimize updates?",
    "technology": "vue",
    "difficulty": "hard",
    "importance": 5,
    "description": "Vue’s virtual DOM acts as an in-memory representation of the actual DOM. Its diffing algorithm efficiently detects and applies only the necessary updates to the real DOM, reducing reflows and improving performance.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Vue’s virtual DOM is a lightweight JavaScript representation of the real DOM. Instead of directly manipulating the browser’s DOM — which is slow — Vue updates a virtual copy in memory and then compares it to the previous version using a process called <strong>diffing</strong>. After detecting the differences, Vue efficiently updates only the parts of the real DOM that have changed, resulting in faster rendering performance."
        },
        {
          "type": "text",
          "text": "<strong>1. The Problem with Direct DOM Manipulation</strong><br>Manipulating the real DOM frequently can be slow because each update triggers <em>recalculations of layout</em> and <em>repaints</em>. This becomes especially costly when multiple updates happen in quick succession, such as when reacting to user input or large data changes."
        },
        {
          "type": "text",
          "text": "To solve this, Vue uses a <strong>virtual DOM</strong> (a memory-based representation of the DOM structure). This allows Vue to compute the minimal set of changes needed before touching the real DOM."
        },
        {
          "type": "text",
          "text": "<strong>2. What Is the Virtual DOM?</strong><br>The virtual DOM (vDOM) is a tree of JavaScript objects that mirrors the structure of your UI. Each element in the UI is represented as a <strong>VNode</strong> (Virtual Node), containing information like the tag name, attributes, children, and event listeners."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example virtual DOM node representation\n{\n  tag: 'div',\n  props: { id: 'app' },\n  children: [\n    { tag: 'h1', children: ['Hello Vue!'] },\n    { tag: 'button', props: { onClick: handleClick }, children: ['Click me'] }\n  ]\n}"
        },
        {
          "type": "text",
          "text": "Instead of touching the actual DOM immediately, Vue constructs and updates this virtual representation during rendering."
        },
        {
          "type": "text",
          "text": "<strong>3. The Diffing Algorithm</strong><br>When reactive data changes, Vue re-renders the component and creates a <strong>new virtual DOM tree</strong>. It then compares this new tree to the previous one (a process known as <em>diffing</em>), determines what has changed, and applies only the minimal set of updates to the real DOM."
        },
        {
          "type": "text",
          "text": "Vue’s diffing algorithm works efficiently using several strategies:<ul><li><strong>Same Type Check:</strong> If two nodes have different tags, Vue replaces the old one entirely.</li><li><strong>Props Diffing:</strong> If two nodes have the same tag, Vue compares their attributes and updates only the changed ones.</li><li><strong>Children Comparison:</strong> For lists or nested elements, Vue compares keys and reuses existing DOM nodes whenever possible.</li></ul>"
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "// Example of diffing behavior\nconst oldVNode = h('div', { class: 'red' }, 'Hello');\nconst newVNode = h('div', { class: 'blue' }, 'Hello World');\n\n// Vue detects:\n// - class changed from 'red' → 'blue'\n// - text changed from 'Hello' → 'Hello World'\n// Only these updates are applied to the real DOM."
        },
        {
          "type": "text",
          "text": "<strong>4. Keyed Updates for Lists</strong><br>When rendering lists (using v-for), Vue uses <code>key</code> attributes to efficiently track items. This prevents unnecessary re-renders when items are reordered or updated."
        },
        {
          "type": "code",
          "language": "html",
          "code": "<ul>\n  <li v-for=\"user in users\" :key=\"user.id\">{{ user.name }}</li>\n</ul>"
        },
        {
          "type": "text",
          "text": "Without a proper <code>key</code>, Vue may re-render entire lists unnecessarily because it cannot tell which item corresponds to which DOM element. With keys, Vue can reorder elements instead of recreating them, which saves performance."
        },
        {
          "type": "text",
          "text": "<strong>5. Batch and Async Updates</strong><br>Vue batches DOM updates asynchronously. When multiple reactive changes occur in the same tick, Vue queues them and performs all updates together in the next event loop cycle using its <strong>nextTick()</strong> mechanism. This prevents unnecessary re-renders and ensures smooth UI updates."
        },
        {
          "type": "text",
          "text": "<strong>6. Virtual DOM vs Real DOM Performance</strong><br>Direct DOM manipulation triggers expensive layout recalculations, whereas virtual DOM updates are computed in memory. Only the minimal, necessary DOM operations are performed, drastically reducing CPU and memory overhead."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Real DOM",
            "Virtual DOM"
          ],
          "rows": [
            [
              "Update Speed",
              "Slow (direct manipulation)",
              "Fast (in-memory comparison)"
            ],
            [
              "Re-rendering",
              "Whole tree may refresh",
              "Only changed parts updated"
            ],
            [
              "Memory Usage",
              "Lower",
              "Slightly higher (virtual tree stored in memory)"
            ],
            [
              "Performance",
              "Costly on frequent updates",
              "Optimized via batching and diffing"
            ]
          ],
          "caption": "Comparison between Real DOM and Virtual DOM"
        },
        {
          "type": "text",
          "text": "<strong>7. Internal Optimization Techniques</strong><ul><li><strong>Static Tree Hoisting:</strong> Static parts of the template are skipped during updates.</li><li><strong>Patch Flags:</strong> Vue marks which parts of the template are dynamic, so it updates only those parts.</li><li><strong>Block Tree Optimization:</strong> Groups dynamic nodes together for faster diffing.</li></ul>These compiler-level optimizations further minimize the amount of DOM work during updates."
        },
        {
          "type": "text",
          "text": "<strong>8. Real-World Example</strong><br>When you update a single value in a large list, Vue doesn’t re-render the whole list. Instead, the virtual DOM detects exactly which element changed and only patches that DOM node — often just one line of text."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of Vue’s virtual DOM like a smart editor — it reviews the changes before applying them to the final document, ensuring only the necessary parts are rewritten instead of retyping the entire page."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><ul><li>The virtual DOM is a lightweight JS representation of the UI.</li><li>Vue’s diffing algorithm compares new and old virtual trees to detect changes.</li><li>Only the changed parts of the DOM are updated (patching).</li><li>Batching and compiler optimizations ensure smooth and efficient rendering.</li><li>This system enables Vue to maintain high performance even with complex UIs.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  }
]