[
    {
        "id": "react-counter",
        "title": "Counter (Component with Guarded Decrement)",
        "type": "coding",
        "technology": "react",
        "difficulty": "beginner",
        "importance": 3,
        "tags": [
            "react",
            "state",
            "event-handlers",
            "components"
        ],
        "description": {
            "summary": "Build a simple <Counter /> component that displays a value and has '+' and '-' buttons. The count must never go below 0.",
            "specs": {
                "requirements": [
                    "Render a <Counter /> as the main UI.",
                    "Display the current count value.",
                    "Provide '+' and '-' buttons to increment and decrement.",
                    "Prevent the count from ever going below 0."
                ],
                "expectedBehavior": [
                    "Clicking '+' increases the count by 1.",
                    "Clicking '-' decreases the count by 1, but never below 0.",
                    "Initial count starts at 0."
                ],
                "implementationNotes": [
                    "Use React state (useState) to store the count.",
                    "Guard the decrement so it never sets a negative value.",
                    "Keep everything in a single small component for this exercise."
                ],
                "techFocus": [
                    "React useState",
                    "Event handlers",
                    "Basic component structure"
                ]
            }
        },
        "solutionBlock": {
            "overview": "Use a single piece of state managed with `useState(0)` to store the count. The '+' button increments by 1. The '-' button should call `setCount` with `Math.max(0, count - 1)` (or equivalent) so the value never goes negative.\n\n**Key ideas**\n- Co-locate state in the component.\n- Use click handlers for both buttons.\n- Always guard the decrement.\n\n**Test cases**\n- Initial render shows `0`.\n- Clicking '+' increments.\n- Clicking '-' at 0 leaves the value at 0.\n- From a positive value, clicking '-' decrements by 1 but never below 0.",
            "approaches": [
                {
                    "title": "Single component with guarded decrement",
                    "prose": "Store `count` in state and provide two handlers: one to increment, one to decrement. The decrement handler uses `Math.max(0, count - 1)` so the count never becomes negative.",
                    "codeJs": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  const inc = () => setCount(count + 1);\n  const dec = () => setCount(Math.max(0, count - 1));\n\n  return (\n    <main style={{ fontFamily: 'system-ui', padding: 16 }}>\n      <h1>Counter</h1>\n      <p data-testid=\"value\">{count}</p>\n      <button onClick={dec} aria-label=\"decrement\">-</button>\n      <button onClick={inc} aria-label=\"increment\">+</button>\n    </main>\n  );\n}\n"
                }
            ],
            "notes": {
                "pitfalls": [
                    "Updating the value without clamping, which allows negatives.",
                    "Recomputing from stale state instead of using the current value correctly."
                ],
                "techniques": [
                    "Using `useState` for local component state.",
                    "Guarding updates with `Math.max`."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/react/question/react-counter.v1.json",
            "openFile": "/src/App.tsx",
            "storageKey": "v2:ui:react:react-counter"
        },
        "solutionAsset": "assets/sb/react/solution/react-counter-solution.v1.json",
        "companies": [
            "meta",
            "google"
        ]
    },
    {
        "id": "react-contact-form-starter",
        "title": "Contact Form (Component + HTTP)",
        "type": "coding",
        "technology": "react",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "react",
            "forms",
            "http",
            "validation",
            "user-input"
        ],
        "description": {
            "summary": "Build a contact form using a React component with controlled inputs and basic validation. You will only work in `src/App.tsx` – the HTML shell and CSS are already set up. On submit, validate the input and send the form data with a POST request to a fake JSON API endpoint, showing loading, success, and error states.",
            "specs": {
                "requirements": [
                    "Work only inside `src/App.tsx` (the CSS in `App.css` and `public/index.html` are already wired up to the expected classes).",
                    "Render a `Contact Us` form with fields for name, email, and message.",
                    "Make all fields required; validate the email with a basic email check.",
                    "Disable the submit button while the form is invalid or while a request is in progress.",
                    "On a valid submit, send a POST request with the form body to `https://jsonplaceholder.typicode.com/posts` using `fetch`.",
                    "If the request succeeds, show the success text: `\"Your message has been sent. Thank you!\"`.",
                    "If the request fails, show the error text: `\"Something went wrong. Please try again.\"`.",
                    "Track an `isSubmitting` flag so the user cannot trigger multiple requests at the same time."
                ],
                "expectedBehavior": [
                    "Initially, the submit button is disabled until all required fields are filled and the email looks valid.",
                    "If the user submits invalid data, all fields are marked as touched and inline validation error messages are shown where appropriate.",
                    "On a valid submit, a POST request is sent to `https://jsonplaceholder.typicode.com/posts` and the button is disabled while `isSubmitting` is `true`.",
                    "On success, `isSubmitting` becomes `false`, the message `\"Your message has been sent. Thank you!\"` is displayed, and the form may optionally be reset.",
                    "On error, `isSubmitting` becomes `false`, the message `\"Something went wrong. Please try again.\"` is displayed, and the user can fix the issue and resubmit."
                ],
                "implementationNotes": [
                    "Use React controlled inputs with `useState` to store the values for `name`, `email`, and `message`.",
                    "Track `isSubmitting`, `successMessage`, and `errorMessage` in component state for UX and request lifecycle.",
                    "Track simple `touched` flags for each field so you only show error messages after a field has been visited or after the user submits.",
                    "Derive a boolean like `formIsValid` from the current values and use it (plus `isSubmitting`) to control the disabled state of the submit button.",
                    "Use the built-in `fetch` API to send a `POST` request to `https://jsonplaceholder.typicode.com/posts` with a JSON body `{ name, email, message }`.",
                    "Always clear previous `successMessage` / `errorMessage` at the start of the submit handler so only the latest result is visible.",
                    "Keep everything inside `App` in `App.tsx`; you don’t need additional components or state management libraries for this exercise."
                ],
                "techFocus": [
                    "React `useState` and controlled form inputs",
                    "Form validation and UX (touched state, inline errors, disabled submit)",
                    "Using `fetch` for a POST request and handling loading/success/error states"
                ]
            }
        },
        "solutionBlock": {
            "overview": "This exercise uses a single React component (`App`) with controlled inputs and a simple HTTP POST using `fetch`. You only change `src/App.tsx`; the HTML shell and CSS already match the design used in the Angular version.\n\nThe component holds state for the three fields (`name`, `email`, `message`), three `touched` flags (so you know when to show errors), an `isSubmitting` flag to disable the button during the request, and two strings: `successMessage` and `errorMessage`.\n\nOn submit, you prevent the default form event, mark all fields as touched, clear previous messages, and compute whether the form is valid (all fields non-empty, email passes a basic pattern, message at least 10 characters). If invalid, you bail out. If valid, you set `isSubmitting = true`, call `fetch('https://jsonplaceholder.typicode.com/posts', ...)` with a JSON body and `Content-Type: application/json`, then handle success and error:\n- On success, set `successMessage` to `\"Your message has been sent. Thank you!\"`, reset the field values, and clear the touched flags.\n- On error, set `errorMessage` to `\"Something went wrong. Please try again.\"`.\nIn both cases you must set `isSubmitting` back to `false` when the request is finished.\n\n**Test cases**\n- With all fields empty, the submit button is disabled.\n- Typing an invalid email keeps the form invalid and the button disabled.\n- Submitting with invalid fields marks them as touched and shows inline error text.\n- With valid inputs, clicking submit sends a POST request to `https://jsonplaceholder.typicode.com/posts` and disables the button while `isSubmitting` is true.\n- On success, `\"Your message has been sent. Thank you!\"` appears and the form resets.\n- On error, `\"Something went wrong. Please try again.\"` appears and the user can resubmit.",
            "approaches": [
                {
                    "title": "Single React component with controlled inputs and fetch",
                    "prose": "Keep everything inside a single `App` component. Use `useState` to store `name`, `email`, `message`, `isSubmitting`, `successMessage`, `errorMessage`, and three touched flags (one per field). Derive `nameIsValid`, `emailIsValid`, and `messageIsValid`, then combine them into `formIsValid`. The JSX uses controlled inputs bound to these state values and `onChange` handlers, plus `onBlur` to mark fields as touched. Error messages are conditionally rendered based on `touchedX` and the validity booleans. The submit handler is an `async` function that prevents default, marks all fields as touched, checks `formIsValid`, and if valid, sends a `fetch` POST to `https://jsonplaceholder.typicode.com/posts`. It sets the exact success and error messages required by the exercise and always toggles `isSubmitting` appropriately.\n\nThis mirrors the Angular exercise but using idiomatic React patterns (controlled components, local state, and `fetch`).",
                    "codeJs": "import React from 'react';\nimport './App.css';\n\nexport default function App() {\n  const [name, setName] = React.useState('');\n  const [email, setEmail] = React.useState('');\n  const [message, setMessage] = React.useState('');\n\n  const [touchedName, setTouchedName] = React.useState(false);\n  const [touchedEmail, setTouchedEmail] = React.useState(false);\n  const [touchedMessage, setTouchedMessage] = React.useState(false);\n\n  const [isSubmitting, setIsSubmitting] = React.useState(false);\n  const [successMessage, setSuccessMessage] = React.useState('');\n  const [errorMessage, setErrorMessage] = React.useState('');\n\n  const nameIsValid = name.trim().length > 0;\n  const emailIsValid = /\\S+@\\S+\\.\\S+/.test(email);\n  const messageIsValid = message.trim().length >= 10;\n  const formIsValid = nameIsValid && emailIsValid && messageIsValid;\n\n  const handleSubmit = async (event) => {\n    event.preventDefault();\n\n    setTouchedName(true);\n    setTouchedEmail(true);\n    setTouchedMessage(true);\n\n    setSuccessMessage('');\n    setErrorMessage('');\n\n    if (!formIsValid) {\n      return;\n    }\n\n    setIsSubmitting(true);\n\n    try {\n      const response = await fetch('https://jsonplaceholder.typicode.com/posts', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ name, email, message }),\n      });\n\n      if (!response.ok) {\n        throw new Error('Request failed');\n      }\n\n      setSuccessMessage('Your message has been sent. Thank you!');\n      setName('');\n      setEmail('');\n      setMessage('');\n      setTouchedName(false);\n      setTouchedEmail(false);\n      setTouchedMessage(false);\n    } catch (err) {\n      setErrorMessage('Something went wrong. Please try again.');\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <main className=\"main\">\n      <section className=\"section\">\n        <h1>Contact Us</h1>\n\n        <form className=\"panel\" noValidate onSubmit={handleSubmit}>\n          <div className=\"field\">\n            <label htmlFor=\"name\">Name</label>\n            <input\n              id=\"name\"\n              type=\"text\"\n              value={name}\n              onChange={(e) => setName(e.target.value)}\n              onBlur={() => setTouchedName(true)}\n            />\n            {touchedName && !nameIsValid && (\n              <p className=\"error\">Name is required.</p>\n            )}\n          </div>\n\n          <div className=\"field\">\n            <label htmlFor=\"email\">Email</label>\n            <input\n              id=\"email\"\n              type=\"email\"\n              value={email}\n              onChange={(e) => setEmail(e.target.value)}\n              onBlur={() => setTouchedEmail(true)}\n            />\n            {touchedEmail && !email && (\n              <p className=\"error\">Email is required.</p>\n            )}\n            {touchedEmail && email && !emailIsValid && (\n              <p className=\"error\">Enter a valid email address.</p>\n            )}\n          </div>\n\n          <div className=\"field\">\n            <label htmlFor=\"message\">Message</label>\n            <textarea\n              id=\"message\"\n              rows={4}\n              value={message}\n              onChange={(e) => setMessage(e.target.value)}\n              onBlur={() => setTouchedMessage(true)}\n            />\n            {touchedMessage && !message && (\n              <p className=\"error\">Message is required.</p>\n            )}\n            {touchedMessage && message && !messageIsValid && (\n              <p className=\"error\">Message should be at least 10 characters.</p>\n            )}\n          </div>\n\n          <button\n            type=\"submit\"\n            className=\"primary\"\n            disabled={!formIsValid || isSubmitting}\n          >\n            {isSubmitting ? 'Sending…' : 'Send message'}\n          </button>\n\n          {successMessage && <p className=\"success\">{successMessage}</p>}\n          {errorMessage && <p className=\"error\">{errorMessage}</p>}\n        </form>\n      </section>\n    </main>\n  );\n}\n"
                }
            ],
            "notes": {
                "pitfalls": [
                    "Leaving validation only in the JSX and forgetting to guard inside the submit handler, which lets invalid data be sent.",
                    "Not resetting `isSubmitting` in both success and error paths.",
                    "Using different success/error messages than the ones specified, which can cause tests to fail.",
                    "Forgetting to call `event.preventDefault()` in the submit handler, causing a full page reload."
                ],
                "techniques": [
                    "Using React controlled inputs for form fields.",
                    "Deriving validation flags from current state instead of storing them separately.",
                    "Using `fetch` to call a fake JSON API endpoint.",
                    "Managing loading, success, and error states with simple boolean and string state variables."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/react/question/react-contact-form.v1.json",
            "openFile": "/src/App.tsx",
            "storageKey": "v2:ui:react:react-contact-form-starter"
        },
        "solutionAsset": "assets/sb/react/solution/react-contact-form-solution.v1.json",
        "companies": [
            "meta",
            "google",
            "airbnb"
        ]
    },
    {
        "id": "react-todo-list",
        "title": "Todo List (Component with Local State)",
        "type": "coding",
        "technology": "react",
        "difficulty": "beginner",
        "importance": 3,
        "tags": [
            "react",
            "state",
            "lists",
            "forms",
            "event-handlers"
        ],
        "description": {
            "summary": "Build a small Todo List using a single React component. Users can add tasks, mark them as done with a checkbox, remove individual tasks, and clear all completed tasks.",
            "specs": {
                "requirements": [
                    "Render a Todo List UI as the main component.",
                    "Provide a text input and an 'Add' button to create new tasks.",
                    "Render a list of todos with a checkbox and label for each task.",
                    "When a task is checked, its text should appear with a line-through style.",
                    "Provide a 'Remove' button for each task.",
                    "Provide a 'Clear completed' button that removes all completed tasks."
                ],
                "expectedBehavior": [
                    "Typing into the input updates local component state.",
                    "Clicking 'Add' with non-empty text adds a new todo and clears the input.",
                    "Checking a todo toggles its completed state and updates the line-through style.",
                    "Clicking 'Remove' deletes that todo only.",
                    "Clicking 'Clear completed' removes all todos whose checkbox is checked.",
                    "The empty state message is shown when there are no todos."
                ],
                "implementationNotes": [
                    "Use `useState` to manage the input value and the array of todo items.",
                    "Each todo item should at minimum have `id`, `text`, and `done` fields.",
                    "Use array methods like `map` and `filter` to update the todos immutably.",
                    "Use a derived boolean to decide when to show the empty state and footer."
                ],
                "techFocus": [
                    "React `useState` for local state",
                    "Controlled inputs",
                    "Rendering lists with `map`",
                    "Event handlers for click and change events",
                    "Immutable updates for arrays of objects"
                ]
            }
        },
        "solutionBlock": {
            "overview": "Store the current input text and the list of todos in component state using `useState`. When the user clicks 'Add', trim the input, guard against empty strings, and append a new todo object to the array. Use `map` to toggle a todo's `done` flag, and `filter` to remove a specific todo or all completed todos.\n\n**Key ideas**\n- Represent each todo with an object containing `id`, `text`, and `done`.\n- Treat the input as a controlled component.\n- Use immutable array updates (`map`, `filter`) when changing state.\n- Derive UI state, such as whether there are any todos, from the current array.",
            "approaches": [
                {
                    "title": "Single component with `useState` and immutable updates",
                    "prose": "Keep everything in a single `App` component. Use `useState<string>` for the input and `useState<Todo[]>` for the list. Implement helpers `addTask`, `toggleTask`, `removeTask`, and `clearCompleted`. Each helper uses immutable array operations: `addTask` spreads the previous array with a new item, `toggleTask` uses `map` to flip `done` for the matching `id`, `removeTask` and `clearCompleted` use `filter` to drop items. The checkbox `checked` prop is bound to `todo.done`, and the text element gets a `done` class when `true`."
                }
            ],
            "notes": {
                "pitfalls": [
                    "Mutating the array in place instead of returning a new array.",
                    "Forgetting to clear the input after successfully adding a task.",
                    "Using uncontrolled inputs, which makes it harder to reset and test.",
                    "Forgetting to use a stable key when rendering the list."
                ],
                "techniques": [
                    "Using `useState` with functional updates when state depends on the previous value.",
                    "Using `map` / `filter` for immutable updates.",
                    "Deriving booleans like `hasTodos` from existing state instead of storing them separately."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/react/question/react-todo-list.v1.json",
            "openFile": "/src/App.tsx",
            "storageKey": "v2:ui:react:react-todo-list"
        },
        "solutionAsset": "assets/sb/react/solution/react-todo-list-solution.v1.json",
        "companies": [
            "meta",
            "google",
            "uber"
        ]
    },
    {
        "id": "react-image-slider",
        "title": "Image Slider (Dots + Previous/Next)",
        "type": "coding",
        "technology": "react",
        "difficulty": "beginner",
        "importance": 3,
        "tags": [
            "react",
            "state",
            "event-handlers",
            "components",
            "ui"
        ],
        "description": {
            "summary": "Build a simple React image slider with previous/next buttons and dot navigation. Show the current slide, its title, and the slide index (e.g. \"Slide 1 of 3\"). Disable navigation buttons when you reach the start or end.",
            "specs": {
                "requirements": [
                    "Render an <App /> component as the main UI.",
                    "Display the current slide image and its title.",
                    "Show text like \"Slide X of N\" under the image.",
                    "Provide \"Previous\" and \"Next\" buttons to move through slides.",
                    "Render dot buttons for each slide and allow jumping directly to a slide.",
                    "Disable \"Previous\" on the first slide and \"Next\" on the last slide."
                ],
                "expectedBehavior": [
                    "Initial render shows the first slide (index 0).",
                    "Clicking \"Next\" moves forward by one slide until the last slide.",
                    "Clicking \"Previous\" moves backward by one slide until the first slide.",
                    "Dots update to reflect the current slide and clicking a dot jumps directly to that slide.",
                    "Buttons are disabled when their action would go out of range."
                ],
                "implementationNotes": [
                    "Use React state (useState) to store the current slide index.",
                    "Keep the slides in a static array rather than in state.",
                    "Derive booleans like canGoPrev and canGoNext from the current index.",
                    "Guard index changes so you never read outside the slides array.",
                    "Use an aria-label on each dot like \"Go to slide 1\" for accessibility."
                ],
                "techFocus": [
                    "React useState for simple UI state",
                    "Derived values (canGoPrev / canGoNext) from state",
                    "Event handlers for buttons and dot navigation",
                    "Conditional disabled states and dynamic classNames"
                ]
            }
        },
        "solutionBlock": {
            "overview": "Use a static SLIDES array and a single piece of state, currentIndex, to track which slide is shown. Derive totalSlides, currentSlide, canGoPrev, and canGoNext from that index. The \"Previous\" and \"Next\" buttons update the index by -1 or +1 when allowed, and the dot buttons call a goTo(index) helper that guards against out-of-range values.\n\n**Key ideas**\n- State holds only the current index, not the entire slides array.\n- Navigation helpers (prev, next, goTo) all respect the valid index range.\n- Disabled states and active dot styling are derived from the same index.\n\n**Test cases**\n- Initial render shows slide 1 of N and the first dot is active.\n- Clicking \"Next\" repeatedly walks through the slides until the last one and then stops (button disabled).\n- Clicking \"Previous\" from the first slide does nothing (button disabled).\n- Clicking any dot jumps directly to that slide and updates the text and navigation buttons.",
            "approaches": [
                {
                    "title": "Single component with index-based navigation",
                    "prose": "Define a SLIDES array and store currentIndex in component state. Derive currentSlide from SLIDES[currentIndex], plus canGoPrev and canGoNext booleans from the index. Implement prev and next using setState callbacks that clamp the new index to the [0, totalSlides - 1] range. Implement goTo(index) to early-return if the index is out of range. Use these helpers in the button onClick handlers and bind an aria-label on each dot for better accessibility.",
                    "codeJs": "import React from 'react';\nimport './App.css';\n\nconst SLIDES = [\n  {\n    id: 1,\n    title: 'Snowflakes glowing under city lights',\n    imageUrl: 'https://picsum.photos/seed/slide-1/800/400'\n  },\n  {\n    id: 2,\n    title: 'Forest trail in the morning',\n    imageUrl: 'https://images.pexels.com/photos/1563604/pexels-photo-1563604.jpeg'\n  },\n  {\n    id: 3,\n    title: 'City lights at night',\n    imageUrl: 'https://images.pexels.com/photos/220067/pexels-photo-220067.jpeg'\n  }\n];\n\nexport default function App() {\n  const [currentIndex, setCurrentIndex] = React.useState(0);\n\n  const totalSlides = SLIDES.length;\n  const currentSlide = SLIDES[currentIndex];\n\n  const canGoPrev = currentIndex > 0;\n  const canGoNext = currentIndex < totalSlides - 1;\n\n  const goTo = (index) => {\n    if (index < 0 || index >= totalSlides) return;\n    setCurrentIndex(index);\n  };\n\n  const prev = () => {\n    if (!canGoPrev) return;\n    setCurrentIndex((i) => i - 1);\n  };\n\n  const next = () => {\n    if (!canGoNext) return;\n    setCurrentIndex((i) => i + 1);\n  };\n\n  return (\n    <main className=\"main\">\n      <section className=\"section\">\n        <h1>Image Slider</h1>\n\n        <figure className=\"frame\">\n          <img\n            className=\"image\"\n            src={currentSlide.imageUrl}\n            alt={currentSlide.title}\n          />\n          <figcaption className=\"caption\">{currentSlide.title}</figcaption>\n        </figure>\n\n        <div className=\"meta\">\n          Slide {currentIndex + 1} of {totalSlides}\n        </div>\n\n        <div className=\"actions\">\n          <button type=\"button\" onClick={prev} disabled={!canGoPrev}>\n            Previous\n          </button>\n          <button type=\"button\" onClick={next} disabled={!canGoNext}>\n            Next\n          </button>\n        </div>\n\n        <div className=\"dots\">\n          {SLIDES.map((slide, index) => (\n            <button\n              key={slide.id}\n              type=\"button\"\n              className={\n                'dot' + (index === currentIndex ? ' dot--active' : '')\n              }\n              onClick={() => goTo(index)}\n              aria-label={`Go to slide ${index + 1}`}\n            />\n          ))}\n        </div>\n      </section>\n    </main>\n  );\n}\n"
                }
            ],
            "notes": {
                "pitfalls": [
                    "Letting currentIndex go below 0 or beyond the last slide, which leads to undefined slides.",
                    "Forgetting to disable navigation buttons at the edges, making it unclear why nothing happens.",
                    "Recomputing derived values in multiple places instead of centralising them."
                ],
                "techniques": [
                    "Keeping only the minimum necessary state (the index) and deriving everything else.",
                    "Using functional setState forms to avoid stale closures when updating indices.",
                    "Driving both UI and accessibility (aria-label, active dot class) from the same source of truth."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/react/question/react-image-slider.v1.json",
            "openFile": "/src/App.tsx",
            "storageKey": "v1:ui:react:react-image-slider"
        },
        "solutionAsset": "assets/sb/react/solution/react-image-slider-solution.v1.json",
        "companies": [
            "meta",
            "google"
        ]
    },
    {
        "id": "react-tabs-switcher",
        "title": "Tabs / Multi-View Switcher",
        "type": "coding",
        "technology": "react",
        "difficulty": "beginner",
        "importance": 3,
        "tags": [
            "react",
            "state",
            "conditional-rendering",
            "components"
        ],
        "description": {
            "summary": "Build a simple tabbed interface with three tabs (\"Overview\", \"Details\", \"Settings\") that controls which content is visible.",
            "specs": {
                "requirements": [
                    "Render a tabbed UI with three tabs labeled \"Overview\", \"Details\", and \"Settings\".",
                    "Track which tab is currently active and visually highlight it.",
                    "Render only the active tab's content at a time."
                ],
                "expectedBehavior": [
                    "The initial active tab should be \"Overview\".",
                    "Clicking a tab makes it the active tab.",
                    "Only the active tab's panel is visible at any time.",
                    "The active tab button has a distinct visual style (e.g. filled pill) compared to inactive ones."
                ],
                "implementationNotes": [
                    "Use React state (useState) to store the currently active tab.",
                    "Model the tab id as a union type like `'overview' | 'details' | 'settings'` for clarity in TypeScript.",
                    "Use conditional rendering (e.g. `isActive('overview') && (...)`) to show/hide each panel.",
                    "Apply conditional classes (e.g. `className={isActive('overview') ? 'tab active' : 'tab'}`) to style the active tab."
                ],
                "techFocus": [
                    "React useState",
                    "Basic state management for view selection",
                    "Conditional rendering and className toggling"
                ]
            }
        },
        "solutionBlock": {
            "overview": "This exercise is about representing a small piece of UI state (which tab is active) and using that state to drive both styles and conditional rendering.\n\nKeep everything in a single React component that owns an `activeTab` state value. Tab buttons call a `selectTab(tab)` handler, and a helper like `isActive(tab)` is used in JSX for the active styles and for choosing which panel to render.\n\n**Test cases**\n- Initial render shows the Overview panel and its tab appears active.\n- Clicking Details switches the active tab and hides Overview content.\n- Clicking Settings switches again and only the Settings content is visible.\n- Clicking the already active tab keeps the current view and styles unchanged.",
            "approaches": [
                {
                    "title": "Single component with `activeTab` state and helper function",
                    "prose": "Use a functional component with one piece of state: `activeTab`. Model the tab ids as a TypeScript union type (e.g. `'overview' | 'details' | 'settings'`).\n\n1. Define a `type TabId = 'overview' | 'details' | 'settings';`.\n2. Initialize `const [activeTab, setActiveTab] = React.useState<TabId>('overview');`.\n3. Implement `const isActive = (tab: TabId) => activeTab === tab;`.\n4. Implement `const selectTab = (tab: TabId) => setActiveTab(tab);`.\n5. Use `className={isActive('overview') ? 'tab active' : 'tab'}` for buttons and `isActive('overview') && (...)` for the panels.\n\nThis mirrors a common pattern used in real-world tab components while staying small enough for beginners.",
                    "codeJs": "import React from 'react';\nimport './App.css';\n\ntype TabId = 'overview' | 'details' | 'settings';\n\nexport default function App() {\n  const [activeTab, setActiveTab] = React.useState<TabId>('overview');\n\n  const isActive = (tab: TabId) => activeTab === tab;\n  const selectTab = (tab: TabId) => {\n    setActiveTab(tab);\n  };\n\n  return (\n    <main className=\"shell\">\n      <section className=\"card\">\n        <h1>Tabs / Multi-View Switcher</h1>\n        <p className=\"subtitle\">\n          Click the tabs to switch between different content panels.\n        </p>\n\n        <nav className=\"tabs\" aria-label=\"Example tabs\">\n          <button\n            className={isActive('overview') ? 'tab active' : 'tab'}\n            onClick={() => selectTab('overview')}\n          >\n            Overview\n          </button>\n          <button\n            className={isActive('details') ? 'tab active' : 'tab'}\n            onClick={() => selectTab('details')}\n          >\n            Details\n          </button>\n          <button\n            className={isActive('settings') ? 'tab active' : 'tab'}\n            onClick={() => selectTab('settings')}\n          >\n            Settings\n          </button>\n        </nav>\n\n        {isActive('overview') && (\n          <section className=\"panel\" aria-label=\"Overview content\">\n            <h2>Overview</h2>\n            <p>Show a short summary or welcome message in this panel.</p>\n          </section>\n        )}\n\n        {isActive('details') && (\n          <section className=\"panel\" aria-label=\"Details content\">\n            <h2>Details</h2>\n            <p>Render some more detailed information here.</p>\n          </section>\n        )}\n\n        {isActive('settings') && (\n          <section className=\"panel\" aria-label=\"Settings content\">\n            <h2>Settings</h2>\n            <p>Display simple settings-like text or placeholders in this panel.</p>\n          </section>\n        )}\n      </section>\n    </main>\n  );\n}\n"
                }
            ],
            "notes": {
                "pitfalls": [
                    "Using multiple booleans (e.g. `isOverview`, `isDetails`, `isSettings`) instead of a single `activeTab` value.",
                    "Forgetting to visually differentiate the active tab from inactive ones.",
                    "Rendering all panels at once instead of conditionally rendering the active one."
                ],
                "techniques": [
                    "Modeling view state with a discriminated union/enum-like type.",
                    "Using helper functions (`isActive`) to keep JSX clean.",
                    "Driving both styles and rendering from a single source of truth (`activeTab`)."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/react/question/react-tabs.v1.json",
            "openFile": "/src/App.tsx",
            "storageKey": "v2:ui:react:react-tabs-switcher"
        },
        "solutionAsset": "assets/sb/react/solution/react-tabs-solution.v1.json",
        "companies": [
            "meta",
            "google",
            "uber"
        ]
    },
    {
        "id": "react-filterable-user-list",
        "title": "Filterable / Searchable User List",
        "type": "coding",
        "technology": "react",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "react",
            "state",
            "lists",
            "filtering",
            "forms"
        ],
        "description": {
            "summary": "Build a React component that renders a user list with a search box, role filter, and \"only active\" checkbox.",
            "specs": {
                "requirements": [
                    "Render a filter UI and a list of users as the main UI.",
                    "Use a fixed in-memory list of users (name, role, active flag).",
                    "Provide a text input that filters by name (case-insensitive).",
                    "Provide a role dropdown (All, Admin, Editor, Viewer) that filters by role.",
                    "Provide a checkbox that, when checked, shows only active users.",
                    "Render the filtered list below the controls."
                ],
                "expectedBehavior": [
                    "Initially, all users are shown.",
                    "Typing in the search box filters users whose name includes the search text (case-insensitive).",
                    "Changing the role dropdown filters by that role (or shows all roles when \"All\" is selected).",
                    "Checking the \"Only active users\" checkbox hides inactive users.",
                    "When no users match the filters, an empty state message is shown instead of an empty list."
                ],
                "implementationNotes": [
                    "Keep the user data in a fixed array inside the component (no fetch or API).",
                    "Store `searchTerm`, `selectedRole`, and `showOnlyActive` in React state using `useState`.",
                    "Derive a `filteredUsers` array on each render based on current state.",
                    "Controlled inputs: bind `value`/`checked` and `onChange` handlers.",
                    "For interview discussion, you can mention `useMemo` for memoizing filtered results, but it isn't required to solve this exercise."
                ],
                "techFocus": [
                    "React `useState` for multiple pieces of UI state",
                    "Controlled inputs (text, select, checkbox)",
                    "Derived state for filtered lists",
                    "Rendering lists with `map` and keys"
                ]
            }
        },
        "solutionBlock": {
            "overview": "This exercise centers on managing three pieces of state (search text, selected role, and an \"only active\" toggle) and deriving a filtered list from them without mutating the original data.\n\n**Test cases**\n- Default render shows all users.\n- Typing part of a user's name filters down to matching users.\n- Changing the role filter to `Admin` shows only admins; switching back to `All` restores all roles.\n- Ticking \"Only active users\" hides inactive users.\n- Combining search, role, and active filters behaves as expected.\n- When the filters exclude all users, an empty state text is rendered.",
            "approaches": [
                {
                    "title": "Single component with `useState` and derived `filteredUsers`",
                    "prose": "Keep everything inside a single `App` component. Define a static `USERS` array that never changes. Inside the component, use `useState` for `searchTerm`, `selectedRole`, and `showOnlyActive`. On each render, compute `filteredUsers` by chaining `Array.prototype.filter`:\n\n1. Normalize the search term to lower-case and match it against `user.name.toLowerCase()`.\n2. Apply the role filter only when the selected role is not `\"all\"`.\n3. If `showOnlyActive` is true, filter out inactive users.\n\nThe inputs (`<input>`, `<select>`, `<input type=\"checkbox\">`) are controlled components with `value` / `checked` driven by state and `onChange` handlers updating that state. Finally, render `filteredUsers` with `map`, show badges for role and status, and fall back to a \"No users match\" row when the list is empty.",
                    "codeJs": "import React, { useState } from 'react';\n\nconst USERS = [\n  { id: 1, name: 'Alice Johnson', role: 'admin', active: true },\n  { id: 2, name: 'Bob Smith', role: 'editor', active: false },\n  { id: 3, name: 'Charlie Kim', role: 'viewer', active: true },\n  { id: 4, name: 'Dana Patel', role: 'editor', active: true },\n  { id: 5, name: 'Elliot Brown', role: 'viewer', active: false }\n];\n\nexport default function App() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [selectedRole, setSelectedRole] = useState('all');\n  const [showOnlyActive, setShowOnlyActive] = useState(false);\n\n  const filteredUsers = USERS.filter((user) => {\n    const term = searchTerm.trim().toLowerCase();\n\n    if (term && !user.name.toLowerCase().includes(term)) {\n      return false;\n    }\n\n    if (selectedRole !== 'all' && user.role !== selectedRole) {\n      return false;\n    }\n\n    if (showOnlyActive && !user.active) {\n      return false;\n    }\n\n    return true;\n  });\n\n  return (\n    <main className=\"shell\">\n      <section className=\"card\">\n        <h1>Filterable User List</h1>\n        <p className=\"subtitle\">\n          Search by name, filter by role, and show only active users.\n        </p>\n\n        <div className=\"controls\">\n          <div className=\"field\">\n            <label htmlFor=\"search\">Search</label>\n            <input\n              id=\"search\"\n              type=\"text\"\n              placeholder=\"Search by name...\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n            />\n          </div>\n\n          <div className=\"field\">\n            <label htmlFor=\"role\">Role</label>\n            <select\n              id=\"role\"\n              value={selectedRole}\n              onChange={(e) => setSelectedRole(e.target.value)}\n            >\n              <option value=\"all\">All roles</option>\n              <option value=\"admin\">Admin</option>\n              <option value=\"editor\">Editor</option>\n              <option value=\"viewer\">Viewer</option>\n            </select>\n          </div>\n\n          <label className=\"checkbox-field\">\n            <input\n              type=\"checkbox\"\n              checked={showOnlyActive}\n              onChange={(e) => setShowOnlyActive(e.target.checked)}\n            />\n            <span>Only active users</span>\n          </label>\n        </div>\n\n        <ul className=\"list\" aria-label=\"Filtered users\">\n          {filteredUsers.map((user) => (\n            <li key={user.id} className=\"row\">\n              <div className=\"primary\">{user.name}</div>\n              <div className=\"meta\">\n                <span className=\"pill\">{user.role}</span>\n                <span className={user.active ? 'status' : 'status inactive'}>\n                  {user.active ? 'Active' : 'Inactive'}\n                </span>\n              </div>\n            </li>\n          ))}\n\n          {filteredUsers.length === 0 && (\n            <li className=\"empty\">No users match your filters.</li>\n          )}\n        </ul>\n      </section>\n    </main>\n  );\n}\n"
                }
            ],
            "notes": {
                "pitfalls": [
                    "Mutating the original `USERS` array instead of deriving a new filtered array.",
                    "Forgetting to make inputs controlled (no `value` / `checked` binding).",
                    "Not normalizing the search term and name to the same case for comparison.",
                    "Applying only one of the filters instead of combining search, role, and active state."
                ],
                "techniques": [
                    "Using `useState` to manage multiple related UI filters.",
                    "Deriving state with `Array.prototype.filter` on each render.",
                    "Using controlled inputs for predictable form behavior.",
                    "Discussing when `useMemo` might be used for optimization on larger lists."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/react/question/react-filterable-user-list.v1.json",
            "openFile": "/src/App.tsx",
            "storageKey": "v2:ui:react:react-filterable-user-list"
        },
        "solutionAsset": "assets/sb/react/solution/react-filterable-user-list-solution.v1.json",
        "companies": [
            "meta",
            "google"
        ]
    },
    {
        "id": "react-accordion-faq",
        "title": "Accordion / FAQ Component",
        "type": "coding",
        "technology": "react",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "react",
            "state",
            "components",
            "props",
            "lifting-state"
        ],
        "description": {
            "summary": "Build a simple FAQ (accordion) UI in React that renders 3–4 questions. Clicking a question should toggle its answer. By default, only one item can be open at a time, but the user can enable a mode where multiple items can stay open.",
            "specs": {
                "requirements": [
                    "Render a main <App /> component that shows a FAQ card with 3–4 FAQ items.",
                    "Each FAQ item has a question (header) and an answer (body).",
                    "Clicking a question toggles its answer open/closed.",
                    "In the default mode, only one FAQ item can be open at a time.",
                    "Add a control (e.g. a checkbox) to switch to 'allow multiple open' mode.",
                    "In 'allow multiple open' mode, more than one FAQ item can be open at the same time."
                ],
                "expectedBehavior": [
                    "Initially all FAQ items are closed.",
                    "Clicking a closed question opens its answer.",
                    "In single-open mode: opening one item closes any other open item.",
                    "Switching to multi-open mode keeps currently open items and allows opening more.",
                    "Clicking an open question closes its answer in both modes."
                ],
                "implementationNotes": [
                    "Keep the FAQ data (question + answer) in the parent component.",
                    "Create a child component (e.g. <FaqItem />) that receives `question`, `answer`, and `isOpen` as props and calls an `onToggle` callback when its header is clicked.",
                    "Use `map` to render the list of FAQ items.",
                    "Use React state to track which index(es) are open; do not let each item manage its own state."
                ],
                "techFocus": [
                    "React function components and props",
                    "Lifting state up to control child components",
                    "State structures for single vs multi selection (array of open indexes)",
                    "Conditional rendering and class toggling based on state"
                ]
            }
        },
        "solutionBlock": {
            "overview": "This exercise is about controlling which FAQ items are open from the parent component. The parent holds an array of FAQ items (question + answer) and state describing which indexes are currently open. A child <FaqItem /> component renders the UI for a single FAQ row and notifies the parent when clicked.\n\nIn single-open mode, the open state behaves like a radio group: the parent keeps at most one index in its `openIndexes` list. Clicking an item either makes it the only open item or closes all if it was already open. In multi-open mode, the parent treats `openIndexes` like a set: clicking an item adds or removes that index from the array.\n\n**Test cases**\n- On initial render, all answers are hidden.\n- Clicking the first question opens its answer and leaves others closed.\n- In single-open mode, clicking a second question closes the first and opens the second.\n- Toggling 'Allow multiple open' keeps already open items and allows opening additional ones.\n- Clicking an open question closes it in both modes.",
            "approaches": [
                {
                    "title": "Parent-controlled openIndexes with a child <FaqItem /> component",
                    "prose": "Use a top-level <App /> component that owns:\n\n1. A `faqItems` array of plain objects (`{ question, answer }`).\n2. A boolean `allowMultiple` piece of state controlled by a checkbox.\n3. An array `openIndexes: number[]` held in state to track which items are currently open.\n\nExpose helper functions:\n- `isItemOpen(index)` → whether `openIndexes` includes the given index.\n- `onItemToggle(index)` → updates `openIndexes` differently depending on `allowMultiple`.\n\nIn multi-open mode, `onItemToggle` behaves like a set toggle: if the index is present, remove it; otherwise add it. In single-open mode, the logic becomes radio-like: the array is either `[index]` or empty. The child <FaqItem /> component remains stateless: it receives `isOpen` and calls `onToggle` when clicked. This shows clearly how to lift state and centralize control in one place.",
                    "codeJs": "import React from 'react';\n\nconst faqItems = [\n  {\n    question: 'Lorem ipsum dolor sit amet?',\n    answer: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus euismod, posuere justo ut, pulvinar neque.'\n  },\n  {\n    question: 'Curabitur blandit tempus porttitor?',\n    answer: 'Curabitur blandit tempus porttitor. Integer posuere erat a ante venenatis dapibus posuere velit aliquet.'\n  },\n  {\n    question: 'Aenean lacinia bibendum nulla sed consectetur?',\n    answer: 'Aenean lacinia bibendum nulla sed consectetur. Cras justo odio, dapibus ac facilisis in, egestas eget quam.'\n  },\n  {\n    question: 'Vivamus sagittis lacus vel augue laoreet rutrum?',\n    answer: 'Vivamus sagittis lacus vel augue laoreet rutrum faucibus dolor auctor. Maecenas faucibus mollis interdum.'\n  }\n];\n\nfunction FaqItem({ question, answer, isOpen, onToggle }) {\n  const handleClick = () => {\n    onToggle();\n  };\n\n  return (\n    <article className={\"faq-item\" + (isOpen ? \" open\" : \"\") }>\n      <button\n        type=\"button\"\n        className=\"faq-header\"\n        onClick={handleClick}\n        aria-expanded={isOpen}\n      >\n        <span className=\"question\">{question}</span>\n        <span className=\"indicator\">{isOpen ? '-' : '+'}</span>\n      </button>\n      {isOpen && (\n        <div className=\"faq-body\">\n          <p>{answer}</p>\n        </div>\n      )}\n    </article>\n  );\n}\n\nexport default function App() {\n  const [allowMultiple, setAllowMultiple] = React.useState(false);\n  const [openIndexes, setOpenIndexes] = React.useState([]); // number[]\n\n  const isItemOpen = (index) => openIndexes.includes(index);\n\n  const onItemToggle = (index) => {\n    const currentlyOpen = isItemOpen(index);\n\n    if (allowMultiple) {\n      setOpenIndexes((prev) =>\n        currentlyOpen ? prev.filter((i) => i !== index) : [...prev, index]\n      );\n      return;\n    }\n\n    if (currentlyOpen) {\n      setOpenIndexes([]);\n    } else {\n      setOpenIndexes([index]);\n    }\n  };\n\n  const onToggleAllowMultiple = () => {\n    setAllowMultiple((prev) => {\n      const next = !prev;\n      if (!next && openIndexes.length > 1) {\n        // When going back to single-open, keep only the first open item\n        setOpenIndexes((current) => (current.length ? [current[0]] : []));\n      }\n      return next;\n    });\n  };\n\n  return (\n    <main className=\"app-root\">\n      <section className=\"card\">\n        <header className=\"header\">\n          <h1>FAQ</h1>\n          <label className=\"mode-toggle\">\n            <input\n              type=\"checkbox\"\n              checked={allowMultiple}\n              onChange={onToggleAllowMultiple}\n            />\n            <span>Allow multiple open</span>\n          </label>\n        </header>\n\n        <div className=\"faq-list\">\n          {faqItems.map((item, index) => (\n            <FaqItem\n              key={item.question}\n              question={item.question}\n              answer={item.answer}\n              isOpen={isItemOpen(index)}\n              onToggle={() => onItemToggle(index)}\n            />\n          ))}\n        </div>\n      </section>\n    </main>\n  );\n}\n"
                }
            ],
            "notes": {
                "pitfalls": [
                    "Letting each <FaqItem /> manage its own internal open/closed state, which makes it hard to enforce 'only one open' behavior.",
                    "Using a single `openIndex` number but then trying to support multi-open mode without changing the state shape.",
                    "Mutating the `openIndexes` array directly instead of producing a new array when updating state."
                ],
                "techniques": [
                    "Lifting UI state to the parent and passing down `isOpen`/`onToggle`.",
                    "Representing UI selection as an array of indexes, which generalizes to both single and multi selection.",
                    "Using functional `setState` updates (`setOpenIndexes(prev => ...)`) to avoid stale state bugs."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/react/question/react-accordion-faq.v1.json",
            "openFile": "/src/App.tsx",
            "storageKey": "v2:ui:react:react-accordion-faq"
        },
        "solutionAsset": "assets/sb/react/solution/react-accordion-faq-solution.v1.json",
        "companies": [
            "meta",
            "google",
            "uber"
        ]
    },
    {
        "id": "react-pagination-table",
        "title": "Paginated Data Table",
        "type": "coding",
        "technology": "react",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "react",
            "state",
            "pagination",
            "arrays",
            "components"
        ],
        "description": {
            "summary": "Build a simple paginated data table in React that shows a static list of users. Display 5 rows per page, with Previous / Next controls and a \"Page X of Y\" indicator. Disable the navigation buttons appropriately on the first and last pages.",
            "specs": {
                "requirements": [
                    "Render a main <App /> component that shows a table of users.",
                    "Use a static list (around 20 users) with id, name, email, and role.",
                    "Show 5 rows per page.",
                    "Add \"Previous\" and \"Next\" buttons to change the current page.",
                    "Display the current page and total pages (for example \"Page 2 of 4\").",
                    "Disable \"Previous\" on the first page and \"Next\" on the last page."
                ],
                "expectedBehavior": [
                    "Initial render shows the first 5 users (page 1).",
                    "Clicking \"Next\" advances by 5 users until the last page.",
                    "Clicking \"Previous\" moves back by 5 users until the first page.",
                    "On the first page, \"Previous\" is disabled and does nothing when clicked.",
                    "On the last page, \"Next\" is disabled and does nothing when clicked.",
                    "The label \"Page X of Y\" always matches the current page."
                ],
                "implementationNotes": [
                    "Use React state (useState) to store the current page index.",
                    "Keep the full users list in a separate module and import it into App.",
                    "Use a constant page size (5) and derive slice start/end from currentPage.",
                    "Compute booleans like isFirstPage and isLastPage to drive button disabled state."
                ],
                "techFocus": [
                    "React useState for component state",
                    "Derived data from minimal state (current page + list length)",
                    "Array slicing with slice(start, end)",
                    "Handling UI edge cases for first/last pages"
                ]
            }
        },
        "solutionBlock": {
            "overview": "This exercise revolves around a single piece of state: the current page index. The full users array stays static in a separate module. From that, you derive the slice of users to display, the total page count, and booleans for whether you're on the first or last page.\n\n**Core ideas**\n- Use `useState(0)` for a 0-based `currentPage`.\n- Keep a constant `PAGE_SIZE = 5`.\n- Compute `totalPages` with `Math.ceil(USERS.length / PAGE_SIZE)`.\n- Derive `pagedUsers` with `USERS.slice(start, end)`, where `start = currentPage * PAGE_SIZE`.\n- Use `isFirstPage` / `isLastPage` flags to drive button disabled state and guard navigation.\n\n**Test cases**\n- Initial render → first 5 users, label shows `Page 1 of N`, Previous is disabled.\n- Repeatedly clicking Next moves through the list and disables Next on the last page.\n- Repeatedly clicking Previous moves back and disables Previous on the first page.\n- The label always stays in sync with the current page index.",
            "approaches": [
                {
                    "title": "Single React component with derived pagination slice",
                    "prose": "Use a single <App /> component that imports a static users array. Store the current page in state with `useState(0)` and keep PAGE_SIZE as a constant.\n\n1. Import `USERS` and `User` from a separate `users.ts` module.\n2. In `App`, define `const [currentPage, setCurrentPage] = useState(0);` and `const PAGE_SIZE = 5;`.\n3. Derive `totalPages` via `Math.ceil(USERS.length / PAGE_SIZE)`.\n4. Compute `start` and `end` indices and slice `USERS` to get `pagedUsers`.\n5. Derive `isFirstPage` and `isLastPage` booleans.\n6. Implement `goPrevious` and `goNext` so they bail out when already on the first/last page.\n7. Render the table from `pagedUsers` and bind buttons to the navigation handlers.\n\nThis keeps App small and focused while demonstrating derived state and basic paginated UI.",
                    "codeJs": "import React, { useState } from 'react';\nimport './App.css';\nimport { USERS, User } from './users';\n\nconst PAGE_SIZE = 5;\n\nexport default function App() {\n  const [currentPage, setCurrentPage] = useState(0);\n\n  const totalPages = Math.ceil(USERS.length / PAGE_SIZE) || 1;\n\n  const start = currentPage * PAGE_SIZE;\n  const end = start + PAGE_SIZE;\n  const pagedUsers: User[] = USERS.slice(start, end);\n\n  const isFirstPage = currentPage === 0;\n  const isLastPage = currentPage >= totalPages - 1;\n\n  const goPrevious = () => {\n    setCurrentPage((page) => (page > 0 ? page - 1 : page));\n  };\n\n  const goNext = () => {\n    setCurrentPage((page) => (page < totalPages - 1 ? page + 1 : page));\n  };\n\n  return (\n    <main className=\"main\">\n      <section className=\"section\">\n        <header className=\"header\">\n          <div>\n            <h1>Users (Pagination)</h1>\n            <p className=\"subtitle\">Simple paginated table (5 per page)</p>\n          </div>\n          <div className=\"meta\">Total users: {USERS.length}</div>\n        </header>\n\n        <div className=\"panel\">\n          <table className=\"table\" aria-label=\"Users table\">\n            <thead>\n              <tr>\n                <th>ID</th>\n                <th>Name</th>\n                <th>Email</th>\n                <th>Role</th>\n              </tr>\n            </thead>\n            <tbody>\n              {pagedUsers.map((user) => (\n                <tr key={user.id}>\n                  <td>{user.id}</td>\n                  <td>{user.name}</td>\n                  <td>{user.email}</td>\n                  <td>{user.role}</td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n\n          <footer className=\"footer\">\n            <button\n              type=\"button\"\n              className=\"ghost\"\n              onClick={goPrevious}\n              disabled={isFirstPage}\n            >\n              Previous\n            </button>\n            <span className=\"page-info\">\n              Page {currentPage + 1} of {totalPages}\n            </span>\n            <button\n              type=\"button\"\n              onClick={goNext}\n              disabled={isLastPage}\n            >\n              Next\n            </button>\n          </footer>\n        </div>\n      </section>\n    </main>\n  );\n}\n"
                }
            ],
            "notes": {
                "pitfalls": [
                    "Treating currentPage as 1-based while doing slice calculations and getting off-by-one errors.",
                    "Letting currentPage go negative or larger than totalPages - 1 because navigation handlers are not guarded.",
                    "Slicing directly in JSX instead of using a named variable, which makes the render harder to read.",
                    "Forgetting to disable Previous/Next when on the first or last page."
                ],
                "techniques": [
                    "Deriving data (page slices and flags) from minimal state.",
                    "Using useState for simple numeric state.",
                    "Separating static data into its own module for clarity."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/react/question/react-pagination-table.v1.json",
            "openFile": "/src/App.tsx",
            "storageKey": "v2:ui:react:react-pagination-table"
        },
        "solutionAsset": "assets/sb/react/solution/react-pagination-table-solution.v1.json",
        "companies": [
            "meta",
            "google",
            "uber"
        ]
    },
    {
        "id": "react-theme-toggle",
        "title": "Theme Toggle with Persisted Light/Dark Mode (React)",
        "type": "coding",
        "technology": "react",
        "difficulty": "intermediate",
        "importance": 4,
        "tags": [
            "react",
            "context",
            "state",
            "local-storage",
            "theming",
            "components"
        ],
        "description": {
            "summary": "Add a global light/dark theme toggle in the top-right of the page using React Context. The selected theme should be stored in localStorage and restored when the page reloads.",
            "specs": {
                "requirements": [
                    "Render a main page layout with a simple content card and a theme toggle control in the top-right corner (UI is already provided via CSS).",
                    "Support two themes: \"light\" and \"dark\".",
                    "Store the current theme in a React Context provider (global-ish state).",
                    "Persist the selected theme in localStorage under a stable key.",
                    "On initial load, read the theme from localStorage and apply it before the user interacts.",
                    "Apply the theme at the document level by setting `data-theme` on `<html>`, so the existing CSS can react to it.",
                    "You only need to edit React/TypeScript files: `/src/theme.tsx` and `/src/App.tsx`. The CSS in `/src/App.css` is already wired to respond to `data-theme` and should be left as-is."
                ],
                "expectedBehavior": [
                    "By default, the app starts in light mode if there is no previous theme stored.",
                    "If the user toggles to dark mode, the page background, text, and card colors change.",
                    "Reloading the page keeps the user’s last theme selection (light or dark).",
                    "The toggle UI (label and emoji) always reflects the actual current theme.",
                    "Switching themes is instant and does not require a full reload."
                ],
                "implementationNotes": [
                    "`/src/theme.tsx`: Create a `ThemeContext` with a `ThemeProvider` that holds the current theme in state, reads/writes localStorage, and updates `document.documentElement.dataset.theme` (or `setAttribute('data-theme', ...)`).",
                    "`/src/App.tsx`: Wrap the page UI with `ThemeProvider`, use a custom hook like `useTheme()` to access `theme` and `toggleTheme()`, derive `isDark` from the current theme, and wire the toggle button click handler.",
                    "`/src/App.css`: Already contains light defaults and `:root[data-theme='dark']` overrides for the page, card, and toggle colors. You don't need to modify it; just drive the `data-theme` attribute from your React logic.",
                    "Keep the theme state in Context as the single source of truth and avoid duplicating theme flags in multiple components."
                ],
                "techFocus": [
                    "React Context as global-ish state",
                    "Combining `useState` and `useEffect` for side-effects",
                    "Using localStorage safely in a browser environment",
                    "Applying global theme via `data-theme` on `<html>` and letting CSS handle visuals"
                ]
            }
        },
        "solutionBlock": {
            "overview": "This exercise is about lifting theme state into a React Context and wiring it to both the UI and the DOM. You store the current theme (\"light\" or \"dark\") inside a `ThemeProvider`, read an initial value from localStorage when the provider initializes, and apply that value to the `<html>` element via a `data-theme` attribute. The `App` component is wrapped in this provider, uses a `useTheme()` hook to read `theme` and call `toggleTheme()`, and renders a toggle button in the top-right.\n\nThe provided CSS in `App.css` already listens to `data-theme` using `:root[data-theme='dark']` selectors to switch page, card, and toggle colors, so the React code is only responsible for state and side-effects.\n\n**Test cases**\n- First visit with empty localStorage → app starts in light mode and shows the light theme.\n- Click the toggle once → app switches to dark mode, the background becomes dark, and the toggle shows the moon icon and \"Dark\" label.\n- Reload the page after switching to dark mode → app initializes in dark mode, with `data-theme=\"dark\"` already applied.\n- Toggle back to light → theme changes immediately, `data-theme` updates, and localStorage is updated.",
            "approaches": [
                {
                    "title": "ThemeProvider + `useTheme()` with `data-theme` on `<html>`",
                    "prose": "Use React Context as the global source of truth for the theme.\n\n1. In `/src/theme.tsx`, define a `Theme` type (`'light' | 'dark'`), a storage key, and a `ThemeContext` that exposes `{ theme, setTheme, toggleTheme }`.\n2. Implement a `ThemeProvider` that:\n   - Uses `useState` with a lazy initializer to read the initial theme from localStorage (defaulting to `'light'`).\n   - Applies the chosen initial theme to `document.documentElement` via `setAttribute('data-theme', theme)`.\n   - Uses `useEffect` to write the theme back to localStorage and keep `data-theme` in sync whenever `theme` changes.\n3. Export a `useTheme()` hook that reads the context and throws if used outside the provider.\n4. In `/src/App.tsx`, wrap the page in `<ThemeProvider>...</ThemeProvider>` and create a `Page` component that calls `useTheme()`.\n5. Derive `isDark` from `theme === 'dark'` and wire the button’s `onClick` to `toggleTheme()`. Use `isDark` to switch between ☀️/🌙 and \"Light\"/\"Dark\".\n6. Leave `App.css` untouched; it relies on `:root[data-theme='dark']` to adjust `.main`, `.card`, and `.theme-toggle` colors.\n\nThis keeps theme logic in one place (Context), makes UI components thin, and demonstrates how React state, side-effects, and DOM-level theming work together.",
                    "codeJs": "import React from 'react';\nimport './App.css';\nimport { ThemeProvider, useTheme } from './theme';\n\nfunction Page() {\n  const { theme, toggleTheme } = useTheme();\n  const isDark = theme === 'dark';\n\n  const handleToggleClick = () => {\n    toggleTheme();\n  };\n\n  return (\n    <main className=\"main\">\n      <header className=\"app-header\">\n        <h1 className=\"app-title\">Theme Toggle (React)</h1>\n        <button\n          type=\"button\"\n          className=\"theme-toggle\"\n          onClick={handleToggleClick}\n          aria-label=\"Toggle theme\"\n        >\n          <span className=\"icon\" aria-hidden=\"true\">{isDark ? '🌙' : '☀️'}</span>\n          <span className=\"label\">{isDark ? 'Dark' : 'Light'}</span>\n        </button>\n      </header>\n\n      <section className=\"content\">\n        <div className=\"card\">\n          <h2>Preview area</h2>\n          <p>\n            This card reacts to the current theme via CSS. Toggle between light and dark\n            and refresh the page to confirm your choice is persisted.\n          </p>\n        </div>\n      </section>\n    </main>\n  );\n}\n\nexport default function App() {\n  return (\n    <ThemeProvider>\n      <Page />\n    </ThemeProvider>\n  );\n}\n"
                }
            ],
            "notes": {
                "pitfalls": [
                    "Reading from localStorage only in an effect but never applying the initial value to `<html>`, causing a flash of the wrong theme.",
                    "Updating the toggle label/icon without actually updating `data-theme` on `<html>`.",
                    "Keeping separate theme flags in multiple components instead of using Context as the single source of truth.",
                    "Mutating the DOM directly in many components instead of centralizing side-effects inside the provider."
                ],
                "techniques": [
                    "Using React Context as a simple app-wide state container.",
                    "Lazy initialization of state from localStorage.",
                    "Synchronizing React state with `document.documentElement` via `data-theme`.",
                    "Letting CSS handle visuals through `:root[data-theme='dark']` selectors while React only controls the attribute."
                ]
            }
        },
        "sdk": {
            "asset": "assets/sb/react/question/react-theme-toggle.v1.json",
            "openFile": "/src/App.tsx",
            "storageKey": "v2:ui:react:react-theme-toggle"
        },
        "solutionAsset": "assets/sb/react/solution/react-theme-toggle-solution.v1.json",
        "companies": [
            "meta",
            "google"
        ]
    }
]