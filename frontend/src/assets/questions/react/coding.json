[
  {
    "id": "react-counter",
    "title": "React Counter (Guarded Decrement)",
    "type": "coding",
    "technology": "react",
    "difficulty": "easy",
    "importance": 2,
    "tags": [
      "react",
      "state",
      "event-handlers",
      "components",
      "basics"
    ],
    "description": {
      "summary": "Build a React counter component with increment/decrement and a zero floor. Use state for the count, disable decrement at zero, and keep UI text in sync with state changes so the user always sees valid values. Concepts: react, state, event handlers, components, basics. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a <Counter /> as the main UI.",
          "Display the current count value.",
          "Provide '+' and '-' buttons to increment and decrement.",
          "Prevent the count from ever going below 0."
        ],
        "expectedBehavior": [
          "Clicking '+' increases the count by 1.",
          "Clicking '-' decreases the count by 1, but never below 0.",
          "Initial count starts at 0."
        ],
        "implementationNotes": [
          "Use React state (useState) to store the count.",
          "Guard the decrement so it never sets a negative value.",
          "Keep everything in a single small component for this exercise."
        ],
        "techFocus": [
          "React useState",
          "Event handlers",
          "Basic component structure"
        ]
      }
    },
    "solutionBlock": {
      "overview": "A single count state drives the UI. Increment adds 1, decrement subtracts 1 but clamps at 0. Disabling the minus button at zero communicates the rule to users and prevents invalid negative values. This is a clean example of state-driven UI and controlled updates. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "Single component with guarded decrement",
          "prose": "Initialize `count` with `useState(0)`. Implement `inc` as `setCount(c => c + 1)` and `dec` as `setCount(c => Math.max(0, c - 1))`. Bind the decrement button’s `disabled` prop when `count === 0`, and render the count in the UI so every click immediately reflects the new state. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates.",
          "codeJs": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  const inc = () => setCount(count + 1);\n  const dec = () => setCount(Math.max(0, count - 1));\n\n  return (\n    <main style={{ fontFamily: 'system-ui', padding: 16 }}>\n      <h1>Counter</h1>\n      <p data-testid=\"value\">{count}</p>\n      <button onClick={dec} aria-label=\"decrement\">-</button>\n      <button onClick={inc} aria-label=\"increment\">+</button>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Updating the value without clamping, which allows negatives.",
          "Recomputing from stale state instead of using the current value correctly."
        ],
        "techniques": [
          "Using `useState` for local component state.",
          "Guarding updates with `Math.max`."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-counter.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-counter"
    },
    "solutionAsset": "assets/sb/react/solution/react-counter-solution.v1.json",
    "companies": [],
    "access": "free",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build React Counter Component",
      "description": "Build a counter UI that increments and decrements value, prevents negative counts, and reflects disabled states correctly."
    }
  },
  {
    "id": "react-contact-form-starter",
    "title": "Contact Form (Component + HTTP)",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "react",
      "forms",
      "http",
      "validation",
      "user-input"
    ],
    "description": {
      "summary": "Build a contact form using a React component with controlled inputs and basic validation. You will only work in `src/App.tsx` – the HTML shell and CSS are already set up. On submit, validate the input and send the form data with a POST request to a fake JSON API endpoint, showing loading, success, and error states. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Work only inside `src/App.tsx` (the CSS in `App.css` and `public/index.html` are already wired up to the expected classes).",
          "Render a `Contact Us` form with fields for name, email, and message.",
          "Make all fields required; validate the email with a basic email check.",
          "Disable the submit button while the form is invalid or while a request is in progress.",
          "On a valid submit, send a POST request with the form body to `https://jsonplaceholder.typicode.com/posts` using `fetch`.",
          "If the request succeeds, show the success text: `\"Your message has been sent. Thank you!\"`.",
          "If the request fails, show the error text: `\"Something went wrong. Please try again.\"`.",
          "Track an `isSubmitting` flag so the user cannot trigger multiple requests at the same time."
        ],
        "expectedBehavior": [
          "Initially, the submit button is disabled until all required fields are filled and the email looks valid.",
          "If the user submits invalid data, all fields are marked as touched and inline validation error messages are shown where appropriate.",
          "On a valid submit, a POST request is sent to `https://jsonplaceholder.typicode.com/posts` and the button is disabled while `isSubmitting` is `true`.",
          "On success, `isSubmitting` becomes `false`, the message `\"Your message has been sent. Thank you!\"` is displayed, and the form may optionally be reset.",
          "On error, `isSubmitting` becomes `false`, the message `\"Something went wrong. Please try again.\"` is displayed, and the user can fix the issue and resubmit."
        ],
        "implementationNotes": [
          "Use React controlled inputs with `useState` to store the values for `name`, `email`, and `message`.",
          "Track `isSubmitting`, `successMessage`, and `errorMessage` in component state for UX and request lifecycle.",
          "Track simple `touched` flags for each field so you only show error messages after a field has been visited or after the user submits.",
          "Derive a boolean like `formIsValid` from the current values and use it (plus `isSubmitting`) to control the disabled state of the submit button.",
          "Use the built-in `fetch` API to send a `POST` request to `https://jsonplaceholder.typicode.com/posts` with a JSON body `{ name, email, message }`.",
          "Always clear previous `successMessage` / `errorMessage` at the start of the submit handler so only the latest result is visible.",
          "Keep everything inside `App` in `App.tsx`; you don’t need additional components or state management libraries for this exercise."
        ],
        "techFocus": [
          "React `useState` and controlled form inputs",
          "Form validation and UX (touched state, inline errors, disabled submit)",
          "Using `fetch` for a POST request and handling loading/success/error states"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise uses a single React component (`App`) with controlled inputs and a simple HTTP POST using `fetch`. You only change `src/App.tsx`; the HTML shell and CSS already match the design used in the Angular version.\n\nThe component holds state for the three fields (`name`, `email`, `message`), three `touched` flags (so you know when to show errors), an `isSubmitting` flag to disable the button during the request, and two strings: `successMessage` and `errorMessage`.\n\nOn submit, you prevent the default form event, mark all fields as touched, clear previous messages, and compute whether the form is valid (all fields non-empty, email passes a basic pattern, message at least 10 characters). If invalid, you bail out. If valid, you set `isSubmitting = true`, call `fetch('https://jsonplaceholder.typicode.com/posts', ...)` with a JSON body and `Content-Type: application/json`, then handle success and error:\n- On success, set `successMessage` to `\"Your message has been sent. Thank you!\"`, reset the field values, and clear the touched flags.\n- On error, set `errorMessage` to `\"Something went wrong. Please try again.\"`.\nIn both cases you must set `isSubmitting` back to `false` when the request is finished.\n\n**Test cases**\n- With all fields empty, the submit button is disabled.\n- Typing an invalid email keeps the form invalid and the button disabled.\n- Submitting with invalid fields marks them as touched and shows inline error text.\n- With valid inputs, clicking submit sends a POST request to `https://jsonplaceholder.typicode.com/posts` and disables the button while `isSubmitting` is true.\n- On success, `\"Your message has been sent. Thank you!\"` appears and the form resets.\n- On error, `\"Something went wrong. Please try again.\"` appears and the user can resubmit.",
      "approaches": [
        {
          "title": "Single React component with controlled inputs and fetch",
          "prose": "Keep everything inside a single `App` component. Use `useState` to store `name`, `email`, `message`, `isSubmitting`, `successMessage`, `errorMessage`, and three touched flags (one per field). Derive `nameIsValid`, `emailIsValid`, and `messageIsValid`, then combine them into `formIsValid`. The JSX uses controlled inputs bound to these state values and `onChange` handlers, plus `onBlur` to mark fields as touched. Error messages are conditionally rendered based on `touchedX` and the validity booleans. The submit handler is an `async` function that prevents default, marks all fields as touched, checks `formIsValid`, and if valid, sends a `fetch` POST to `https://jsonplaceholder.typicode.com/posts`. It sets the exact success and error messages required by the exercise and always toggles `isSubmitting` appropriately.\n\nThis mirrors the Angular exercise but using idiomatic React patterns (controlled components, local state, and `fetch`).",
          "codeJs": "import React from 'react';\nimport './App.css';\n\nexport default function App() {\n  const [name, setName] = React.useState('');\n  const [email, setEmail] = React.useState('');\n  const [message, setMessage] = React.useState('');\n\n  const [touchedName, setTouchedName] = React.useState(false);\n  const [touchedEmail, setTouchedEmail] = React.useState(false);\n  const [touchedMessage, setTouchedMessage] = React.useState(false);\n\n  const [isSubmitting, setIsSubmitting] = React.useState(false);\n  const [successMessage, setSuccessMessage] = React.useState('');\n  const [errorMessage, setErrorMessage] = React.useState('');\n\n  const nameIsValid = name.trim().length > 0;\n  const emailIsValid = /\\S+@\\S+\\.\\S+/.test(email);\n  const messageIsValid = message.trim().length >= 10;\n  const formIsValid = nameIsValid && emailIsValid && messageIsValid;\n\n  const handleSubmit = async (event) => {\n    event.preventDefault();\n\n    setTouchedName(true);\n    setTouchedEmail(true);\n    setTouchedMessage(true);\n\n    setSuccessMessage('');\n    setErrorMessage('');\n\n    if (!formIsValid) {\n      return;\n    }\n\n    setIsSubmitting(true);\n\n    try {\n      const response = await fetch('https://jsonplaceholder.typicode.com/posts', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ name, email, message }),\n      });\n\n      if (!response.ok) {\n        throw new Error('Request failed');\n      }\n\n      setSuccessMessage('Your message has been sent. Thank you!');\n      setName('');\n      setEmail('');\n      setMessage('');\n      setTouchedName(false);\n      setTouchedEmail(false);\n      setTouchedMessage(false);\n    } catch (err) {\n      setErrorMessage('Something went wrong. Please try again.');\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <main className=\"main\">\n      <section className=\"section\">\n        <h1>Contact Us</h1>\n\n        <form className=\"panel\" noValidate onSubmit={handleSubmit}>\n          <div className=\"field\">\n            <label htmlFor=\"name\">Name</label>\n            <input\n              id=\"name\"\n              type=\"text\"\n              value={name}\n              onChange={(e) => setName(e.target.value)}\n              onBlur={() => setTouchedName(true)}\n            />\n            {touchedName && !nameIsValid && (\n              <p className=\"error\">Name is required.</p>\n            )}\n          </div>\n\n          <div className=\"field\">\n            <label htmlFor=\"email\">Email</label>\n            <input\n              id=\"email\"\n              type=\"email\"\n              value={email}\n              onChange={(e) => setEmail(e.target.value)}\n              onBlur={() => setTouchedEmail(true)}\n            />\n            {touchedEmail && !email && (\n              <p className=\"error\">Email is required.</p>\n            )}\n            {touchedEmail && email && !emailIsValid && (\n              <p className=\"error\">Enter a valid email address.</p>\n            )}\n          </div>\n\n          <div className=\"field\">\n            <label htmlFor=\"message\">Message</label>\n            <textarea\n              id=\"message\"\n              rows={4}\n              value={message}\n              onChange={(e) => setMessage(e.target.value)}\n              onBlur={() => setTouchedMessage(true)}\n            />\n            {touchedMessage && !message && (\n              <p className=\"error\">Message is required.</p>\n            )}\n            {touchedMessage && message && !messageIsValid && (\n              <p className=\"error\">Message should be at least 10 characters.</p>\n            )}\n          </div>\n\n          <button\n            type=\"submit\"\n            className=\"primary\"\n            disabled={!formIsValid || isSubmitting}\n          >\n            {isSubmitting ? 'Sending…' : 'Send message'}\n          </button>\n\n          {successMessage && <p className=\"success\">{successMessage}</p>}\n          {errorMessage && <p className=\"error\">{errorMessage}</p>}\n        </form>\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Leaving validation only in the JSX and forgetting to guard inside the submit handler, which lets invalid data be sent.",
          "Not resetting `isSubmitting` in both success and error paths.",
          "Using different success/error messages than the ones specified, which can cause tests to fail.",
          "Forgetting to call `event.preventDefault()` in the submit handler, causing a full page reload."
        ],
        "techniques": [
          "Using React controlled inputs for form fields.",
          "Deriving validation flags from current state instead of storing them separately.",
          "Using `fetch` to call a fake JSON API endpoint.",
          "Managing loading, success, and error states with simple boolean and string state variables."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-contact-form.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-contact-form-starter"
    },
    "solutionAsset": "assets/sb/react/solution/react-contact-form-solution.v1.json",
    "companies": [
      "netflix"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build React Contact Form with Validation and Submit",
      "description": "Create a contact form that captures user input, validates required fields, submits data, and shows loading, success, and error states."
    }
  },
  {
    "id": "react-todo-list",
    "title": "Todo List (Component with Local State)",
    "type": "coding",
    "technology": "react",
    "difficulty": "easy",
    "importance": 3,
    "tags": [
      "react",
      "state",
      "lists",
      "forms",
      "event-handlers"
    ],
    "description": {
      "summary": "Create a local-state todo list: add, toggle, and remove items. Keep input state controlled, generate stable ids, and update the todos array immutably so React can detect changes and re-render correctly. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a Todo List UI as the main component.",
          "Provide a text input and an 'Add' button to create new tasks.",
          "Render a list of todos with a checkbox and label for each task.",
          "When a task is checked, its text should appear with a line-through style.",
          "Provide a 'Remove' button for each task.",
          "Provide a 'Clear completed' button that removes all completed tasks."
        ],
        "expectedBehavior": [
          "Typing into the input updates local component state.",
          "Clicking 'Add' with non-empty text adds a new todo and clears the input.",
          "Checking a todo toggles its completed state and updates the line-through style.",
          "Clicking 'Remove' deletes that todo only.",
          "Clicking 'Clear completed' removes all todos whose checkbox is checked.",
          "The empty state message is shown when there are no todos."
        ],
        "implementationNotes": [
          "Use `useState` to manage the input value and the array of todo items.",
          "Each todo item should at minimum have `id`, `text`, and `done` fields.",
          "Use array methods like `map` and `filter` to update the todos immutably.",
          "Use a derived boolean to decide when to show the empty state and footer."
        ],
        "techFocus": [
          "React `useState` for local state",
          "Controlled inputs",
          "Rendering lists with `map`",
          "Event handlers for click and change events",
          "Immutable updates for arrays of objects"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Store the current input text and the list of todos in component state using `useState`. When the user clicks 'Add', trim the input, guard against empty strings, and append a new todo object to the array. Use `map` to toggle a todo's `done` flag, and `filter` to remove a specific todo or all completed todos.\n\n**Key ideas**\n- Represent each todo with an object containing `id`, `text`, and `done`.\n- Treat the input as a controlled component.\n- Use immutable array updates (`map`, `filter`) when changing state.\n- Derive UI state, such as whether there are any todos, from the current array.",
      "approaches": [
        {
          "title": "Single component with `useState` and immutable updates",
          "prose": "Keep everything in a single `App` component. Use `useState<string>` for the input and `useState<Todo[]>` for the list. Implement helpers `addTask`, `toggleTask`, `removeTask`, and `clearCompleted`. Each helper uses immutable array operations: `addTask` spreads the previous array with a new item, `toggleTask` uses `map` to flip `done` for the matching `id`, `removeTask` and `clearCompleted` use `filter` to drop items. The checkbox `checked` prop is bound to `todo.done`, and the text element gets a `done` class when `true`."
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating the array in place instead of returning a new array.",
          "Forgetting to clear the input after successfully adding a task.",
          "Using uncontrolled inputs, which makes it harder to reset and test.",
          "Forgetting to use a stable key when rendering the list."
        ],
        "techniques": [
          "Using `useState` with functional updates when state depends on the previous value.",
          "Using `map` / `filter` for immutable updates.",
          "Deriving booleans like `hasTodos` from existing state instead of storing them separately."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-todo-list.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-todo-list"
    },
    "solutionAsset": "assets/sb/react/solution/react-todo-list-solution.v1.json",
    "companies": [],
    "access": "free",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build React Todo List (Add Toggle Delete)",
      "description": "Create a todo list interface that supports adding items, toggling completion, and deleting tasks while keeping UI state consistent."
    }
  },
  {
    "id": "react-image-slider",
    "title": "Image Slider (Dots + Previous/Next)",
    "type": "coding",
    "technology": "react",
    "difficulty": "easy",
    "importance": 3,
    "tags": [
      "react",
      "state",
      "event-handlers",
      "components",
      "ui"
    ],
    "description": {
      "summary": "Build a simple React image slider with previous/next buttons and dot navigation. Show the current slide, its title, and the slide index (e.g. \"Slide 1 of 3\"). Disable navigation buttons when you reach the start or end. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render an <App /> component as the main UI.",
          "Display the current slide image and its title.",
          "Show text like \"Slide X of N\" under the image.",
          "Provide \"Previous\" and \"Next\" buttons to move through slides.",
          "Render dot buttons for each slide and allow jumping directly to a slide.",
          "Disable \"Previous\" on the first slide and \"Next\" on the last slide."
        ],
        "expectedBehavior": [
          "Initial render shows the first slide (index 0).",
          "Clicking \"Next\" moves forward by one slide until the last slide.",
          "Clicking \"Previous\" moves backward by one slide until the first slide.",
          "Dots update to reflect the current slide and clicking a dot jumps directly to that slide.",
          "Buttons are disabled when their action would go out of range."
        ],
        "implementationNotes": [
          "Use React state (useState) to store the current slide index.",
          "Keep the slides in a static array rather than in state.",
          "Derive booleans like canGoPrev and canGoNext from the current index.",
          "Guard index changes so you never read outside the slides array.",
          "Use an aria-label on each dot like \"Go to slide 1\" for accessibility."
        ],
        "techFocus": [
          "React useState for simple UI state",
          "Derived values (canGoPrev / canGoNext) from state",
          "Event handlers for buttons and dot navigation",
          "Conditional disabled states and dynamic classNames"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Use a static SLIDES array and a single piece of state, currentIndex, to track which slide is shown. Derive totalSlides, currentSlide, canGoPrev, and canGoNext from that index. The \"Previous\" and \"Next\" buttons update the index by -1 or +1 when allowed, and the dot buttons call a goTo(index) helper that guards against out-of-range values.\n\n**Key ideas**\n- State holds only the current index, not the entire slides array.\n- Navigation helpers (prev, next, goTo) all respect the valid index range.\n- Disabled states and active dot styling are derived from the same index.\n\n**Test cases**\n- Initial render shows slide 1 of N and the first dot is active.\n- Clicking \"Next\" repeatedly walks through the slides until the last one and then stops (button disabled).\n- Clicking \"Previous\" from the first slide does nothing (button disabled).\n- Clicking any dot jumps directly to that slide and updates the text and navigation buttons.",
      "approaches": [
        {
          "title": "Single component with index-based navigation",
          "prose": "Define a SLIDES array and store currentIndex in component state. Derive currentSlide from SLIDES[currentIndex], plus canGoPrev and canGoNext booleans from the index. Implement prev and next using setState callbacks that clamp the new index to the [0, totalSlides - 1] range. Implement goTo(index) to early-return if the index is out of range. Use these helpers in the button onClick handlers and bind an aria-label on each dot for better accessibility.",
          "codeJs": "import React from 'react';\nimport './App.css';\n\nconst SLIDES = [\n  {\n    id: 1,\n    title: 'Snowflakes glowing under city lights',\n    imageUrl: 'https://picsum.photos/seed/slide-1/800/400'\n  },\n  {\n    id: 2,\n    title: 'Forest trail in the morning',\n    imageUrl: 'https://images.pexels.com/photos/1563604/pexels-photo-1563604.jpeg'\n  },\n  {\n    id: 3,\n    title: 'City lights at night',\n    imageUrl: 'https://images.pexels.com/photos/220067/pexels-photo-220067.jpeg'\n  }\n];\n\nexport default function App() {\n  const [currentIndex, setCurrentIndex] = React.useState(0);\n\n  const totalSlides = SLIDES.length;\n  const currentSlide = SLIDES[currentIndex];\n\n  const canGoPrev = currentIndex > 0;\n  const canGoNext = currentIndex < totalSlides - 1;\n\n  const goTo = (index) => {\n    if (index < 0 || index >= totalSlides) return;\n    setCurrentIndex(index);\n  };\n\n  const prev = () => {\n    if (!canGoPrev) return;\n    setCurrentIndex((i) => i - 1);\n  };\n\n  const next = () => {\n    if (!canGoNext) return;\n    setCurrentIndex((i) => i + 1);\n  };\n\n  return (\n    <main className=\"main\">\n      <section className=\"section\">\n        <h1>Image Slider</h1>\n\n        <figure className=\"frame\">\n          <img\n            className=\"image\"\n            src={currentSlide.imageUrl}\n            alt={currentSlide.title}\n          />\n          <figcaption className=\"caption\">{currentSlide.title}</figcaption>\n        </figure>\n\n        <div className=\"meta\">\n          Slide {currentIndex + 1} of {totalSlides}\n        </div>\n\n        <div className=\"actions\">\n          <button type=\"button\" onClick={prev} disabled={!canGoPrev}>\n            Previous\n          </button>\n          <button type=\"button\" onClick={next} disabled={!canGoNext}>\n            Next\n          </button>\n        </div>\n\n        <div className=\"dots\">\n          {SLIDES.map((slide, index) => (\n            <button\n              key={slide.id}\n              type=\"button\"\n              className={\n                'dot' + (index === currentIndex ? ' dot--active' : '')\n              }\n              onClick={() => goTo(index)}\n              aria-label={`Go to slide ${index + 1}`}\n            />\n          ))}\n        </div>\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Letting currentIndex go below 0 or beyond the last slide, which leads to undefined slides.",
          "Forgetting to disable navigation buttons at the edges, making it unclear why nothing happens.",
          "Recomputing derived values in multiple places instead of centralising them."
        ],
        "techniques": [
          "Keeping only the minimum necessary state (the index) and deriving everything else.",
          "Using functional setState forms to avoid stale closures when updating indices.",
          "Driving both UI and accessibility (aria-label, active dot class) from the same source of truth."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-image-slider.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v1:ui:react:react-image-slider"
    },
    "solutionAsset": "assets/sb/react/solution/react-image-slider-solution.v1.json",
    "companies": [
      "amazon",
      "google"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build React Image Slider with Navigation Controls",
      "description": "Create an image slider that supports previous and next navigation, dot indicators, boundary behavior, and current-slide display updates."
    }
  },
  {
    "id": "react-tabs-switcher",
    "title": "React Tabs / Multi-View Switcher",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 2,
    "tags": [
      "react",
      "state",
      "conditional-rendering",
      "components"
    ],
    "description": {
      "summary": "Implement React tabs with a single activeTab state. Buttons update the value and conditional rendering shows only the active panel, with clear active styles and accessible button semantics. Include keyboard navigation and focus management for accessibility; test edge cases like repeated clicks and long labels. React focus: keep a single activeTab state and render panels conditionally. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a tabbed UI with three tabs labeled \"Overview\", \"Details\", and \"Settings\".",
          "Track which tab is currently active and visually highlight it.",
          "Render only the active tab's content at a time."
        ],
        "expectedBehavior": [
          "The initial active tab should be \"Overview\".",
          "Clicking a tab makes it the active tab.",
          "Only the active tab's panel is visible at any time.",
          "The active tab button has a distinct visual style (e.g. filled pill) compared to inactive ones."
        ],
        "implementationNotes": [
          "Use React state (useState) to store the currently active tab.",
          "Model the tab id as a union type like `'overview' | 'details' | 'settings'` for clarity in TypeScript.",
          "Use conditional rendering (e.g. `isActive('overview') && (...)`) to show/hide each panel.",
          "Apply conditional classes (e.g. `className={isActive('overview') ? 'tab active' : 'tab'}`) to style the active tab."
        ],
        "techFocus": [
          "React useState",
          "Basic state management for view selection",
          "Conditional rendering and className toggling"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about representing a small piece of UI state (which tab is active) and using that state to drive both styles and conditional rendering.\n\nKeep everything in a single React component that owns an `activeTab` state value. Tab buttons call a `selectTab(tab)` handler, and a helper like `isActive(tab)` is used in JSX for the active styles and for choosing which panel to render.\n\n**Test cases**\n- Initial render shows the Overview panel and its tab appears active.\n- Clicking Details switches the active tab and hides Overview content.\n- Clicking Settings switches again and only the Settings content is visible.\n- Clicking the already active tab keeps the current view and styles unchanged.",
      "approaches": [
        {
          "title": "Single component with `activeTab` state and helper function",
          "prose": "Use a functional component with one piece of state: `activeTab`. Model the tab ids as a TypeScript union type (e.g. `'overview' | 'details' | 'settings'`).\n\n1. Define a `type TabId = 'overview' | 'details' | 'settings';`.\n2. Initialize `const [activeTab, setActiveTab] = React.useState<TabId>('overview');`.\n3. Implement `const isActive = (tab: TabId) => activeTab === tab;`.\n4. Implement `const selectTab = (tab: TabId) => setActiveTab(tab);`.\n5. Use `className={isActive('overview') ? 'tab active' : 'tab'}` for buttons and `isActive('overview') && (...)` for the panels.\n\nThis mirrors a common pattern used in real-world tab components while staying small enough for beginners.",
          "codeJs": "import React from 'react';\nimport './App.css';\n\ntype TabId = 'overview' | 'details' | 'settings';\n\nexport default function App() {\n  const [activeTab, setActiveTab] = React.useState<TabId>('overview');\n\n  const isActive = (tab: TabId) => activeTab === tab;\n  const selectTab = (tab: TabId) => {\n    setActiveTab(tab);\n  };\n\n  return (\n    <main className=\"shell\">\n      <section className=\"card\">\n        <h1>Tabs / Multi-View Switcher</h1>\n        <p className=\"subtitle\">\n          Click the tabs to switch between different content panels.\n        </p>\n\n        <nav className=\"tabs\" aria-label=\"Example tabs\">\n          <button\n            className={isActive('overview') ? 'tab active' : 'tab'}\n            onClick={() => selectTab('overview')}\n          >\n            Overview\n          </button>\n          <button\n            className={isActive('details') ? 'tab active' : 'tab'}\n            onClick={() => selectTab('details')}\n          >\n            Details\n          </button>\n          <button\n            className={isActive('settings') ? 'tab active' : 'tab'}\n            onClick={() => selectTab('settings')}\n          >\n            Settings\n          </button>\n        </nav>\n\n        {isActive('overview') && (\n          <section className=\"panel\" aria-label=\"Overview content\">\n            <h2>Overview</h2>\n            <p>Show a short summary or welcome message in this panel.</p>\n          </section>\n        )}\n\n        {isActive('details') && (\n          <section className=\"panel\" aria-label=\"Details content\">\n            <h2>Details</h2>\n            <p>Render some more detailed information here.</p>\n          </section>\n        )}\n\n        {isActive('settings') && (\n          <section className=\"panel\" aria-label=\"Settings content\">\n            <h2>Settings</h2>\n            <p>Display simple settings-like text or placeholders in this panel.</p>\n          </section>\n        )}\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using multiple booleans (e.g. `isOverview`, `isDetails`, `isSettings`) instead of a single `activeTab` value.",
          "Forgetting to visually differentiate the active tab from inactive ones.",
          "Rendering all panels at once instead of conditionally rendering the active one."
        ],
        "techniques": [
          "Modeling view state with a discriminated union/enum-like type.",
          "Using helper functions (`isActive`) to keep JSX clean.",
          "Driving both styles and rendering from a single source of truth (`activeTab`)."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-tabs.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-tabs-switcher"
    },
    "solutionAsset": "assets/sb/react/solution/react-tabs-solution.v1.json",
    "companies": [
      "amazon"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Accessible React Tabs with Active Panel",
      "description": "Create a tabs component that switches active panels, updates visual state, and supports keyboard-friendly tab interaction."
    }
  },
  {
    "id": "react-filterable-user-list",
    "title": "React Filterable / Searchable User List",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "react",
      "state",
      "lists",
      "filtering",
      "forms"
    ],
    "description": {
      "summary": "Filter a React user list by search text and role. Derive filtered results without mutating the source array, and show an empty state when no matches exist. Add performance notes (memoization or debouncing), accessibility for filter controls, and tests for empty/error states and large datasets. React focus: derive filtered lists in render or useMemo without mutating source data. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a filter UI and a list of users as the main UI.",
          "Use a fixed in-memory list of users (name, role, active flag).",
          "Provide a text input that filters by name (case-insensitive).",
          "Provide a role dropdown (All, Admin, Editor, Viewer) that filters by role.",
          "Provide a checkbox that, when checked, shows only active users.",
          "Render the filtered list below the controls."
        ],
        "expectedBehavior": [
          "Initially, all users are shown.",
          "Typing in the search box filters users whose name includes the search text (case-insensitive).",
          "Changing the role dropdown filters by that role (or shows all roles when \"All\" is selected).",
          "Checking the \"Only active users\" checkbox hides inactive users.",
          "When no users match the filters, an empty state message is shown instead of an empty list."
        ],
        "implementationNotes": [
          "Keep the user data in a fixed array inside the component (no fetch or API).",
          "Store `searchTerm`, `selectedRole`, and `showOnlyActive` in React state using `useState`.",
          "Derive a `filteredUsers` array on each render based on current state.",
          "Controlled inputs: bind `value`/`checked` and `onChange` handlers.",
          "For interview discussion, you can mention `useMemo` for memoizing filtered results, but it isn't required to solve this exercise."
        ],
        "techFocus": [
          "React `useState` for multiple pieces of UI state",
          "Controlled inputs (text, select, checkbox)",
          "Derived state for filtered lists",
          "Rendering lists with `map` and keys"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise centers on managing three pieces of state (search text, selected role, and an \"only active\" toggle) and deriving a filtered list from them without mutating the original data.\n\n**Test cases**\n- Default render shows all users.\n- Typing part of a user's name filters down to matching users.\n- Changing the role filter to `Admin` shows only admins; switching back to `All` restores all roles.\n- Ticking \"Only active users\" hides inactive users.\n- Combining search, role, and active filters behaves as expected.\n- When the filters exclude all users, an empty state text is rendered.",
      "approaches": [
        {
          "title": "Single component with `useState` and derived `filteredUsers`",
          "prose": "Keep everything inside a single `App` component. Define a static `USERS` array that never changes. Inside the component, use `useState` for `searchTerm`, `selectedRole`, and `showOnlyActive`. On each render, compute `filteredUsers` by chaining `Array.prototype.filter`:\n\n1. Normalize the search term to lower-case and match it against `user.name.toLowerCase()`.\n2. Apply the role filter only when the selected role is not `\"all\"`.\n3. If `showOnlyActive` is true, filter out inactive users.\n\nThe inputs (`<input>`, `<select>`, `<input type=\"checkbox\">`) are controlled components with `value` / `checked` driven by state and `onChange` handlers updating that state. Finally, render `filteredUsers` with `map`, show badges for role and status, and fall back to a \"No users match\" row when the list is empty.",
          "codeJs": "import React, { useState } from 'react';\n\nconst USERS = [\n  { id: 1, name: 'Alice Johnson', role: 'admin', active: true },\n  { id: 2, name: 'Bob Smith', role: 'editor', active: false },\n  { id: 3, name: 'Charlie Kim', role: 'viewer', active: true },\n  { id: 4, name: 'Dana Patel', role: 'editor', active: true },\n  { id: 5, name: 'Elliot Brown', role: 'viewer', active: false }\n];\n\nexport default function App() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [selectedRole, setSelectedRole] = useState('all');\n  const [showOnlyActive, setShowOnlyActive] = useState(false);\n\n  const filteredUsers = USERS.filter((user) => {\n    const term = searchTerm.trim().toLowerCase();\n\n    if (term && !user.name.toLowerCase().includes(term)) {\n      return false;\n    }\n\n    if (selectedRole !== 'all' && user.role !== selectedRole) {\n      return false;\n    }\n\n    if (showOnlyActive && !user.active) {\n      return false;\n    }\n\n    return true;\n  });\n\n  return (\n    <main className=\"shell\">\n      <section className=\"card\">\n        <h1>Filterable User List</h1>\n        <p className=\"subtitle\">\n          Search by name, filter by role, and show only active users.\n        </p>\n\n        <div className=\"controls\">\n          <div className=\"field\">\n            <label htmlFor=\"search\">Search</label>\n            <input\n              id=\"search\"\n              type=\"text\"\n              placeholder=\"Search by name...\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n            />\n          </div>\n\n          <div className=\"field\">\n            <label htmlFor=\"role\">Role</label>\n            <select\n              id=\"role\"\n              value={selectedRole}\n              onChange={(e) => setSelectedRole(e.target.value)}\n            >\n              <option value=\"all\">All roles</option>\n              <option value=\"admin\">Admin</option>\n              <option value=\"editor\">Editor</option>\n              <option value=\"viewer\">Viewer</option>\n            </select>\n          </div>\n\n          <label className=\"checkbox-field\">\n            <input\n              type=\"checkbox\"\n              checked={showOnlyActive}\n              onChange={(e) => setShowOnlyActive(e.target.checked)}\n            />\n            <span>Only active users</span>\n          </label>\n        </div>\n\n        <ul className=\"list\" aria-label=\"Filtered users\">\n          {filteredUsers.map((user) => (\n            <li key={user.id} className=\"row\">\n              <div className=\"primary\">{user.name}</div>\n              <div className=\"meta\">\n                <span className=\"pill\">{user.role}</span>\n                <span className={user.active ? 'status' : 'status inactive'}>\n                  {user.active ? 'Active' : 'Inactive'}\n                </span>\n              </div>\n            </li>\n          ))}\n\n          {filteredUsers.length === 0 && (\n            <li className=\"empty\">No users match your filters.</li>\n          )}\n        </ul>\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating the original `USERS` array instead of deriving a new filtered array.",
          "Forgetting to make inputs controlled (no `value` / `checked` binding).",
          "Not normalizing the search term and name to the same case for comparison.",
          "Applying only one of the filters instead of combining search, role, and active state."
        ],
        "techniques": [
          "Using `useState` to manage multiple related UI filters.",
          "Deriving state with `Array.prototype.filter` on each render.",
          "Using controlled inputs for predictable form behavior.",
          "Discussing when `useMemo` might be used for optimization on larger lists."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-filterable-user-list.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-filterable-user-list"
    },
    "solutionAsset": "assets/sb/react/solution/react-filterable-user-list-solution.v1.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Filterable User List in React",
      "description": "Create a user list that updates results based on search text and role filters, with clear behavior for empty matches."
    }
  },
  {
    "id": "react-accordion-faq",
    "title": "React Accordion / FAQ Component",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "react",
      "state",
      "components",
      "props",
      "lifting-state"
    ],
    "description": {
      "summary": "Build a simple FAQ (accordion) UI in React using component state. Clicking a question should toggle its answer. By default, only one item can be open at a time, but the user can enable a mode where multiple items can stay open. React focus: lift open state to the parent and pass isOpen/onToggle props to items. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a main <App /> component that shows a FAQ card with 3–4 FAQ items.",
          "Each FAQ item has a question (header) and an answer (body).",
          "Clicking a question toggles its answer open/closed.",
          "In the default mode, only one FAQ item can be open at a time.",
          "Add a control (e.g. a checkbox) to switch to 'allow multiple open' mode.",
          "In 'allow multiple open' mode, more than one FAQ item can be open at the same time."
        ],
        "expectedBehavior": [
          "Initially all FAQ items are closed.",
          "Clicking a closed question opens its answer.",
          "In single-open mode: opening one item closes any other open item.",
          "Switching to multi-open mode keeps currently open items and allows opening more.",
          "Clicking an open question closes its answer in both modes."
        ],
        "implementationNotes": [
          "Keep the FAQ data (question + answer) in the parent component.",
          "Create a child component (e.g. <FaqItem />) that receives `question`, `answer`, and `isOpen` as props and calls an `onToggle` callback when its header is clicked.",
          "Use `map` to render the list of FAQ items.",
          "Use React state to track which index(es) are open; do not let each item manage its own state."
        ],
        "techFocus": [
          "React function components and props",
          "Lifting state up to control child components",
          "State structures for single vs multi selection (array of open indexes)",
          "Conditional rendering and class toggling based on state"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about controlling which FAQ items are open from the parent component. The parent holds an array of FAQ items (question + answer) and state describing which indexes are currently open. A child <FaqItem /> component renders the UI for a single FAQ row and notifies the parent when clicked.\n\nIn single-open mode, the open state behaves like a radio group: the parent keeps at most one index in its `openIndexes` list. Clicking an item either makes it the only open item or closes all if it was already open. In multi-open mode, the parent treats `openIndexes` like a set: clicking an item adds or removes that index from the array.\n\n**Test cases**\n- On initial render, all answers are hidden.\n- Clicking the first question opens its answer and leaves others closed.\n- In single-open mode, clicking a second question closes the first and opens the second.\n- Toggling 'Allow multiple open' keeps already open items and allows opening additional ones.\n- Clicking an open question closes it in both modes.",
      "approaches": [
        {
          "title": "Parent-controlled openIndexes with a child <FaqItem /> component",
          "prose": "Use a top-level <App /> component that owns:\n\n1. A `faqItems` array of plain objects (`{ question, answer }`).\n2. A boolean `allowMultiple` piece of state controlled by a checkbox.\n3. An array `openIndexes: number[]` held in state to track which items are currently open.\n\nExpose helper functions:\n- `isItemOpen(index)` → whether `openIndexes` includes the given index.\n- `onItemToggle(index)` → updates `openIndexes` differently depending on `allowMultiple`.\n\nIn multi-open mode, `onItemToggle` behaves like a set toggle: if the index is present, remove it; otherwise add it. In single-open mode, the logic becomes radio-like: the array is either `[index]` or empty. The child <FaqItem /> component remains stateless: it receives `isOpen` and calls `onToggle` when clicked. This shows clearly how to lift state and centralize control in one place.",
          "codeJs": "import React from 'react';\n\nconst faqItems = [\n  {\n    question: 'Lorem ipsum dolor sit amet?',\n    answer: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus euismod, posuere justo ut, pulvinar neque.'\n  },\n  {\n    question: 'Curabitur blandit tempus porttitor?',\n    answer: 'Curabitur blandit tempus porttitor. Integer posuere erat a ante venenatis dapibus posuere velit aliquet.'\n  },\n  {\n    question: 'Aenean lacinia bibendum nulla sed consectetur?',\n    answer: 'Aenean lacinia bibendum nulla sed consectetur. Cras justo odio, dapibus ac facilisis in, egestas eget quam.'\n  },\n  {\n    question: 'Vivamus sagittis lacus vel augue laoreet rutrum?',\n    answer: 'Vivamus sagittis lacus vel augue laoreet rutrum faucibus dolor auctor. Maecenas faucibus mollis interdum.'\n  }\n];\n\nfunction FaqItem({ question, answer, isOpen, onToggle }) {\n  const handleClick = () => {\n    onToggle();\n  };\n\n  return (\n    <article className={\"faq-item\" + (isOpen ? \" open\" : \"\") }>\n      <button\n        type=\"button\"\n        className=\"faq-header\"\n        onClick={handleClick}\n        aria-expanded={isOpen}\n      >\n        <span className=\"question\">{question}</span>\n        <span className=\"indicator\">{isOpen ? '-' : '+'}</span>\n      </button>\n      {isOpen && (\n        <div className=\"faq-body\">\n          <p>{answer}</p>\n        </div>\n      )}\n    </article>\n  );\n}\n\nexport default function App() {\n  const [allowMultiple, setAllowMultiple] = React.useState(false);\n  const [openIndexes, setOpenIndexes] = React.useState([]); // number[]\n\n  const isItemOpen = (index) => openIndexes.includes(index);\n\n  const onItemToggle = (index) => {\n    const currentlyOpen = isItemOpen(index);\n\n    if (allowMultiple) {\n      setOpenIndexes((prev) =>\n        currentlyOpen ? prev.filter((i) => i !== index) : [...prev, index]\n      );\n      return;\n    }\n\n    if (currentlyOpen) {\n      setOpenIndexes([]);\n    } else {\n      setOpenIndexes([index]);\n    }\n  };\n\n  const onToggleAllowMultiple = () => {\n    setAllowMultiple((prev) => {\n      const next = !prev;\n      if (!next && openIndexes.length > 1) {\n        // When going back to single-open, keep only the first open item\n        setOpenIndexes((current) => (current.length ? [current[0]] : []));\n      }\n      return next;\n    });\n  };\n\n  return (\n    <main className=\"app-root\">\n      <section className=\"card\">\n        <header className=\"header\">\n          <h1>FAQ</h1>\n          <label className=\"mode-toggle\">\n            <input\n              type=\"checkbox\"\n              checked={allowMultiple}\n              onChange={onToggleAllowMultiple}\n            />\n            <span>Allow multiple open</span>\n          </label>\n        </header>\n\n        <div className=\"faq-list\">\n          {faqItems.map((item, index) => (\n            <FaqItem\n              key={item.question}\n              question={item.question}\n              answer={item.answer}\n              isOpen={isItemOpen(index)}\n              onToggle={() => onItemToggle(index)}\n            />\n          ))}\n        </div>\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Letting each <FaqItem /> manage its own internal open/closed state, which makes it hard to enforce 'only one open' behavior.",
          "Using a single `openIndex` number but then trying to support multi-open mode without changing the state shape.",
          "Mutating the `openIndexes` array directly instead of producing a new array when updating state."
        ],
        "techniques": [
          "Lifting UI state to the parent and passing down `isOpen`/`onToggle`.",
          "Representing UI selection as an array of indexes, which generalizes to both single and multi selection.",
          "Using functional `setState` updates (`setOpenIndexes(prev => ...)`) to avoid stale state bugs."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-accordion-faq.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-accordion-faq"
    },
    "solutionAsset": "assets/sb/react/solution/react-accordion-faq-solution.v1.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build React Accordion FAQ Component",
      "description": "Create an FAQ accordion that toggles sections open and closed, supporting both single-open and multi-open interaction rules."
    }
  },
  {
    "id": "react-pagination-table",
    "title": "React Paginated Data Table",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "react",
      "state",
      "pagination",
      "arrays",
      "components"
    ],
    "description": {
      "summary": "Build a simple paginated data table in React that shows a static list of users. Display 5 rows per page, with Previous / Next controls and a \"Page X of Y\" indicator. Disable the navigation buttons appropriately on the first and last pages. React focus: keep page index in state and derive page slices. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a main <App /> component that shows a table of users.",
          "Use a static list (around 20 users) with id, name, email, and role.",
          "Show 5 rows per page.",
          "Add \"Previous\" and \"Next\" buttons to change the current page.",
          "Display the current page and total pages (for example \"Page 2 of 4\").",
          "Disable \"Previous\" on the first page and \"Next\" on the last page."
        ],
        "expectedBehavior": [
          "Initial render shows the first 5 users (page 1).",
          "Clicking \"Next\" advances by 5 users until the last page.",
          "Clicking \"Previous\" moves back by 5 users until the first page.",
          "On the first page, \"Previous\" is disabled and does nothing when clicked.",
          "On the last page, \"Next\" is disabled and does nothing when clicked.",
          "The label \"Page X of Y\" always matches the current page."
        ],
        "implementationNotes": [
          "Use React state (useState) to store the current page index.",
          "Keep the full users list in a separate module and import it into App.",
          "Use a constant page size (5) and derive slice start/end from currentPage.",
          "Compute booleans like isFirstPage and isLastPage to drive button disabled state."
        ],
        "techFocus": [
          "React useState for component state",
          "Derived data from minimal state (current page + list length)",
          "Array slicing with slice(start, end)",
          "Handling UI edge cases for first/last pages"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise revolves around a single piece of state: the current page index. The full users array stays static in a separate module. From that, you derive the slice of users to display, the total page count, and booleans for whether you're on the first or last page.\n\n**Core ideas**\n- Use `useState(0)` for a 0-based `currentPage`.\n- Keep a constant `PAGE_SIZE = 5`.\n- Compute `totalPages` with `Math.ceil(USERS.length / PAGE_SIZE)`.\n- Derive `pagedUsers` with `USERS.slice(start, end)`, where `start = currentPage * PAGE_SIZE`.\n- Use `isFirstPage` / `isLastPage` flags to drive button disabled state and guard navigation.\n\n**Test cases**\n- Initial render → first 5 users, label shows `Page 1 of N`, Previous is disabled.\n- Repeatedly clicking Next moves through the list and disables Next on the last page.\n- Repeatedly clicking Previous moves back and disables Previous on the first page.\n- The label always stays in sync with the current page index.",
      "approaches": [
        {
          "title": "Single React component with derived pagination slice",
          "prose": "Use a single <App /> component that imports a static users array. Store the current page in state with `useState(0)` and keep PAGE_SIZE as a constant.\n\n1. Import `USERS` and `User` from a separate `users.ts` module.\n2. In `App`, define `const [currentPage, setCurrentPage] = useState(0);` and `const PAGE_SIZE = 5;`.\n3. Derive `totalPages` via `Math.ceil(USERS.length / PAGE_SIZE)`.\n4. Compute `start` and `end` indices and slice `USERS` to get `pagedUsers`.\n5. Derive `isFirstPage` and `isLastPage` booleans.\n6. Implement `goPrevious` and `goNext` so they bail out when already on the first/last page.\n7. Render the table from `pagedUsers` and bind buttons to the navigation handlers.\n\nThis keeps App small and focused while demonstrating derived state and basic paginated UI.",
          "codeJs": "import React, { useState } from 'react';\nimport './App.css';\nimport { USERS, User } from './users';\n\nconst PAGE_SIZE = 5;\n\nexport default function App() {\n  const [currentPage, setCurrentPage] = useState(0);\n\n  const totalPages = Math.ceil(USERS.length / PAGE_SIZE) || 1;\n\n  const start = currentPage * PAGE_SIZE;\n  const end = start + PAGE_SIZE;\n  const pagedUsers: User[] = USERS.slice(start, end);\n\n  const isFirstPage = currentPage === 0;\n  const isLastPage = currentPage >= totalPages - 1;\n\n  const goPrevious = () => {\n    setCurrentPage((page) => (page > 0 ? page - 1 : page));\n  };\n\n  const goNext = () => {\n    setCurrentPage((page) => (page < totalPages - 1 ? page + 1 : page));\n  };\n\n  return (\n    <main className=\"main\">\n      <section className=\"section\">\n        <header className=\"header\">\n          <div>\n            <h1>Users (Pagination)</h1>\n            <p className=\"subtitle\">Simple paginated table (5 per page)</p>\n          </div>\n          <div className=\"meta\">Total users: {USERS.length}</div>\n        </header>\n\n        <div className=\"panel\">\n          <table className=\"table\" aria-label=\"Users table\">\n            <thead>\n              <tr>\n                <th>ID</th>\n                <th>Name</th>\n                <th>Email</th>\n                <th>Role</th>\n              </tr>\n            </thead>\n            <tbody>\n              {pagedUsers.map((user) => (\n                <tr key={user.id}>\n                  <td>{user.id}</td>\n                  <td>{user.name}</td>\n                  <td>{user.email}</td>\n                  <td>{user.role}</td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n\n          <footer className=\"footer\">\n            <button\n              type=\"button\"\n              className=\"ghost\"\n              onClick={goPrevious}\n              disabled={isFirstPage}\n            >\n              Previous\n            </button>\n            <span className=\"page-info\">\n              Page {currentPage + 1} of {totalPages}\n            </span>\n            <button\n              type=\"button\"\n              onClick={goNext}\n              disabled={isLastPage}\n            >\n              Next\n            </button>\n          </footer>\n        </div>\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Treating currentPage as 1-based while doing slice calculations and getting off-by-one errors.",
          "Letting currentPage go negative or larger than totalPages - 1 because navigation handlers are not guarded.",
          "Slicing directly in JSX instead of using a named variable, which makes the render harder to read.",
          "Forgetting to disable Previous/Next when on the first or last page."
        ],
        "techniques": [
          "Deriving data (page slices and flags) from minimal state.",
          "Using useState for simple numeric state.",
          "Separating static data into its own module for clarity."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-pagination-table.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-pagination-table"
    },
    "solutionAsset": "assets/sb/react/solution/react-pagination-table-solution.v1.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Paginated Data Table in React",
      "description": "Create a table with page navigation that shows only current-page rows and handles first or last page boundaries correctly."
    }
  },
  {
    "id": "react-theme-toggle",
    "title": "React Theme Toggle with Persisted Light/Dark Mode",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 2,
    "tags": [
      "react",
      "context",
      "state",
      "local-storage",
      "theming",
      "components"
    ],
    "description": {
      "summary": "Add a global light/dark theme toggle using React Context. The selected theme should be stored in localStorage and restored when the page reloads. React focus: use Context to persist theme in localStorage and sync the DOM attribute. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a main page layout with a simple content card and a theme toggle control in the top-right corner (UI is already provided via CSS).",
          "Support two themes: \"light\" and \"dark\".",
          "Store the current theme in a React Context provider (global-ish state).",
          "Persist the selected theme in localStorage under a stable key.",
          "On initial load, read the theme from localStorage and apply it before the user interacts.",
          "Apply the theme at the document level by setting `data-theme` on `<html>`, so the existing CSS can react to it.",
          "You only need to edit React/TypeScript files: `/src/theme.tsx` and `/src/App.tsx`. The CSS in `/src/App.css` is already wired to respond to `data-theme` and should be left as-is."
        ],
        "expectedBehavior": [
          "By default, the app starts in light mode if there is no previous theme stored.",
          "If the user toggles to dark mode, the page background, text, and card colors change.",
          "Reloading the page keeps the user’s last theme selection (light or dark).",
          "The toggle UI (label and emoji) always reflects the actual current theme.",
          "Switching themes is instant and does not require a full reload."
        ],
        "implementationNotes": [
          "`/src/theme.tsx`: Create a `ThemeContext` with a `ThemeProvider` that holds the current theme in state, reads/writes localStorage, and updates `document.documentElement.dataset.theme` (or `setAttribute('data-theme', ...)`).",
          "`/src/App.tsx`: Wrap the page UI with `ThemeProvider`, use a custom hook like `useTheme()` to access `theme` and `toggleTheme()`, derive `isDark` from the current theme, and wire the toggle button click handler.",
          "`/src/App.css`: Already contains light defaults and `:root[data-theme='dark']` overrides for the page, card, and toggle colors. You don't need to modify it; just drive the `data-theme` attribute from your React logic.",
          "Keep the theme state in Context as the single source of truth and avoid duplicating theme flags in multiple components."
        ],
        "techFocus": [
          "React Context as global-ish state",
          "Combining `useState` and `useEffect` for side-effects",
          "Using localStorage safely in a browser environment",
          "Applying global theme via `data-theme` on `<html>` and letting CSS handle visuals"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about lifting theme state into a React Context and wiring it to both the UI and the DOM. You store the current theme (\"light\" or \"dark\") inside a `ThemeProvider`, read an initial value from localStorage when the provider initializes, and apply that value to the `<html>` element via a `data-theme` attribute. The `App` component is wrapped in this provider, uses a `useTheme()` hook to read `theme` and call `toggleTheme()`, and renders a toggle button in the top-right.\n\nThe provided CSS in `App.css` already listens to `data-theme` using `:root[data-theme='dark']` selectors to switch page, card, and toggle colors, so the React code is only responsible for state and side-effects.\n\n**Test cases**\n- First visit with empty localStorage → app starts in light mode and shows the light theme.\n- Click the toggle once → app switches to dark mode, the background becomes dark, and the toggle shows the moon icon and \"Dark\" label.\n- Reload the page after switching to dark mode → app initializes in dark mode, with `data-theme=\"dark\"` already applied.\n- Toggle back to light → theme changes immediately, `data-theme` updates, and localStorage is updated.",
      "approaches": [
        {
          "title": "ThemeProvider + `useTheme()` with `data-theme` on `<html>`",
          "prose": "Use React Context as the global source of truth for the theme.\n\n1. In `/src/theme.tsx`, define a `Theme` type (`'light' | 'dark'`), a storage key, and a `ThemeContext` that exposes `{ theme, setTheme, toggleTheme }`.\n2. Implement a `ThemeProvider` that:\n   - Uses `useState` with a lazy initializer to read the initial theme from localStorage (defaulting to `'light'`).\n   - Applies the chosen initial theme to `document.documentElement` via `setAttribute('data-theme', theme)`.\n   - Uses `useEffect` to write the theme back to localStorage and keep `data-theme` in sync whenever `theme` changes.\n3. Export a `useTheme()` hook that reads the context and throws if used outside the provider.\n4. In `/src/App.tsx`, wrap the page in `<ThemeProvider>...</ThemeProvider>` and create a `Page` component that calls `useTheme()`.\n5. Derive `isDark` from `theme === 'dark'` and wire the button’s `onClick` to `toggleTheme()`. Use `isDark` to switch between ☀️/🌙 and \"Light\"/\"Dark\".\n6. Leave `App.css` untouched; it relies on `:root[data-theme='dark']` to adjust `.main`, `.card`, and `.theme-toggle` colors.\n\nThis keeps theme logic in one place (Context), makes UI components thin, and demonstrates how React state, side-effects, and DOM-level theming work together.",
          "codeJs": "import React from 'react';\nimport './App.css';\nimport { ThemeProvider, useTheme } from './theme';\n\nfunction Page() {\n  const { theme, toggleTheme } = useTheme();\n  const isDark = theme === 'dark';\n\n  const handleToggleClick = () => {\n    toggleTheme();\n  };\n\n  return (\n    <main className=\"main\">\n      <header className=\"app-header\">\n        <h1 className=\"app-title\">Theme Toggle (React)</h1>\n        <button\n          type=\"button\"\n          className=\"theme-toggle\"\n          onClick={handleToggleClick}\n          aria-label=\"Toggle theme\"\n        >\n          <span className=\"icon\" aria-hidden=\"true\">{isDark ? '🌙' : '☀️'}</span>\n          <span className=\"label\">{isDark ? 'Dark' : 'Light'}</span>\n        </button>\n      </header>\n\n      <section className=\"content\">\n        <div className=\"card\">\n          <h2>Preview area</h2>\n          <p>\n            This card reacts to the current theme via CSS. Toggle between light and dark\n            and refresh the page to confirm your choice is persisted.\n          </p>\n        </div>\n      </section>\n    </main>\n  );\n}\n\nexport default function App() {\n  return (\n    <ThemeProvider>\n      <Page />\n    </ThemeProvider>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Reading from localStorage only in an effect but never applying the initial value to `<html>`, causing a flash of the wrong theme.",
          "Updating the toggle label/icon without actually updating `data-theme` on `<html>`.",
          "Keeping separate theme flags in multiple components instead of using Context as the single source of truth.",
          "Mutating the DOM directly in many components instead of centralizing side-effects inside the provider."
        ],
        "techniques": [
          "Using React Context as a simple app-wide state container.",
          "Lazy initialization of state from localStorage.",
          "Synchronizing React state with `document.documentElement` via `data-theme`.",
          "Letting CSS handle visuals through `:root[data-theme='dark']` selectors while React only controls the attribute."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-theme-toggle.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-theme-toggle"
    },
    "solutionAsset": "assets/sb/react/solution/react-theme-toggle-solution.v1.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build React Theme Toggle with Persistence",
      "description": "Create a light and dark theme toggle that applies globally and restores the saved preference on page reload."
    }
  },
  {
    "id": "react-multi-step-signup",
    "title": "Multi-step Signup Form",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "react",
      "forms",
      "state",
      "validation",
      "multi-step",
      "controlled-inputs"
    ],
    "description": {
      "summary": "Build a 3-step signup flow in React that collects basic info, address info, and then shows a read-only summary before submitting. Each step should only advance when its inputs are valid.",
      "specs": {
        "requirements": [
          "Render a multi-step signup UI as the main component.",
          "Step 1 (Basic info): collect name and email.",
          "Step 2 (Address info): collect street, city, country, and an optional postal code.",
          "Step 3 (Summary): display a read-only summary of all collected fields and a final Submit button.",
          "Use controlled inputs for all fields (values come from component state).",
          "Expose \"Back\" and \"Next\" buttons to move between steps (Back is disabled on the first step).",
          "\"Next\" must be disabled when the current step is invalid.",
          "Only allow Submit when all required fields across all steps are valid."
        ],
        "expectedBehavior": [
          "Initial render shows Step 1 and indicates the overall step (e.g. \"Step 1 of 3\").",
          "Typing into inputs updates React state immediately (controlled inputs).",
          "Clicking \"Next\" on Step 1 moves to Step 2 only when name and email are both non-empty (and email is valid if you choose to validate format).",
          "Clicking \"Next\" on Step 2 moves to Step 3 only when street, city, and country are non-empty.",
          "\"Back\" moves to the previous step without losing already-entered values.",
          "Step 3 shows a summary of all values and a \"Submit\" button.",
          "Clicking \"Submit\" validates all steps and then logs (or sends) the aggregated data."
        ],
        "implementationNotes": [
          "Use React state (e.g. useState) to hold both the current step index and the form data object.",
          "Model the form data as a nested object, e.g. { basic: { name, email }, address: { street, city, country, postalCode } }.",
          "Derive simple boolean flags like isFirstStep, isLastStep, and canGoNext from the current step and validation logic.",
          "Keep all logic in a single component for the exercise, or optionally extract step subcomponents that receive props/callbacks.",
          "Validation can be as simple as \"non-empty strings for required fields\"; the important part is wiring it into button disabled states and step navigation."
        ],
        "techFocus": [
          "Controlled inputs and form state in React",
          "Deriving validation and disabled states from data",
          "Multi-step flow state (current step, next/prev)",
          "Basic component-level architecture and data modelling"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Use React state to store both the current step index and the full form data object. Each input is controlled (its value comes from state, and onChange writes back into that state). A small validation function per step determines whether the current step is valid. The \"Next\" button is disabled when invalid and, when clicked, either shows errors or advances to the next step. The \"Back\" button decrements the step index but leaves all previously entered values intact. On the last step, render a summary and wire a \"Submit\" handler that validates everything and then logs (or posts) the final payload.\n\n**Key ideas**\n- Keep all form data in a single React state object.\n- Use derived flags like `isFirstStep`, `isLastStep`, and `canGoNext` instead of ad-hoc booleans.\n- Derive simple validation from the current state and use it to drive \"Next\"/\"Submit\" disabled states.\n\n**Test cases**\n- Step 1: \"Next\" is disabled until both name and email are non-empty.\n- Step 2: \"Next\" is disabled until street, city, and country are non-empty.\n- Step 3: shows the correct summary of all fields.\n- Clicking \"Back\" preserves previously entered values.\n- Clicking \"Submit\" with invalid data forces the user back to the invalid step and shows errors.",
      "approaches": [
        {
          "title": "Single top-level component with nested state object per step",
          "prose": "Use a single `<App />` component that holds both the step index and a nested form state object. Model the state as `{ basic: { name, email }, address: { street, city, country, postalCode } }`. Each input is controlled, reading from that object and updating with a helper like `updateBasic('name', value)`. Write small helpers `isBasicValid` and `isAddressValid` and derive `canGoNext` from them based on `currentStep`. Clicking \"Next\" runs validation and advances only when valid. Clicking \"Back\" just decrements the step index. The final step renders a summary and a `submit()` function validates everything and logs the data.",
          "codeJs": "import React, { useState } from 'react';\n\nfunction App() {\n  const [currentStep, setCurrentStep] = useState(0); // 0, 1, 2\n  const [form, setForm] = useState({\n    basic: { name: '', email: '' },\n    address: { street: '', city: '', country: '', postalCode: '' }\n  });\n  const [showErrors, setShowErrors] = useState(false);\n\n  const { basic, address } = form;\n\n  const basicErrors = {\n    name: basic.name.trim().length === 0,\n    email: basic.email.trim().length === 0\n  };\n  const isBasicValid = !basicErrors.name && !basicErrors.email;\n\n  const addressErrors = {\n    street: address.street.trim().length === 0,\n    city: address.city.trim().length === 0,\n    country: address.country.trim().length === 0\n  };\n  const isAddressValid = !addressErrors.street && !addressErrors.city && !addressErrors.country;\n\n  const isFirstStep = currentStep === 0;\n  const isLastStep = currentStep === 2;\n\n  const canGoNext = currentStep === 0\n    ? isBasicValid\n    : currentStep === 1\n      ? isAddressValid\n      : false;\n\n  function updateBasic(key, value) {\n    setForm(prev => ({\n      ...prev,\n      basic: { ...prev.basic, [key]: value }\n    }));\n  }\n\n  function updateAddress(key, value) {\n    setForm(prev => ({\n      ...prev,\n      address: { ...prev.address, [key]: value }\n    }));\n  }\n\n  function next() {\n    if (!canGoNext) {\n      setShowErrors(true);\n      return;\n    }\n    setShowErrors(false);\n    setCurrentStep(step => (step < 2 ? step + 1 : step));\n  }\n\n  function prev() {\n    setShowErrors(false);\n    setCurrentStep(step => (step > 0 ? step - 1 : step));\n  }\n\n  function submit() {\n    const isValid = isBasicValid && isAddressValid;\n    if (!isValid) {\n      setShowErrors(true);\n      if (!isBasicValid) setCurrentStep(0);\n      else if (!isAddressValid) setCurrentStep(1);\n      return;\n    }\n    console.log('Signup submitted', form);\n  }\n\n  // ...render steps and buttons using currentStep, showErrors, errors, next/prev/submit\n  return <main>{/* UI omitted for brevity */}</main>;\n}\n\nexport default App;\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Duplicating state per step instead of keeping a single form object.",
          "Allowing the user to go \"Next\" even when required fields are empty.",
          "Resetting or losing previously entered values when navigating back and forth.",
          "Writing complex if/else chains inside the JSX instead of using small derived helpers like `isFirstStep`, `isLastStep`, and `canGoNext`."
        ],
        "techniques": [
          "Using a nested object in React state to represent form data across steps.",
          "Deriving validation booleans from current state and using them for `disabled` and navigation logic.",
          "Using small helper functions to update nested state in an immutable way.",
          "Separating state/validation from rendering by computing flags before the JSX."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-multi-step-form.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-multi-step-signup"
    },
    "solutionAsset": "assets/sb/react/solution/react-multi-step-form-solution.v1.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Multi-Step Signup Form in React",
      "description": "Create a multi-step signup flow with step-by-step navigation, validation requirements, and final review before submit."
    }
  },
  {
    "id": "react-shopping-cart",
    "title": "React Shopping Cart Mini",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "react",
      "state",
      "arrays",
      "derived-state",
      "immutability",
      "ecommerce"
    ],
    "description": {
      "summary": "Build a small shopping cart UI in React. Show a list of products, let the user add them to the cart, adjust quantities, remove items, and display derived totals for item count and price. React focus: use immutable updates for cart lines and derived totals. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a list of products with name, price, and an \"Add to cart\" button for each.",
          "Maintain a `cartItems` collection where each item has `id`, `name`, `price`, and `quantity`.",
          "In the cart, show each item's name, unit price, quantity, and line total (`price * quantity`).",
          "Provide controls to increase and decrease quantity for each cart item.",
          "Allow removing an item from the cart entirely.",
          "Display derived values: total item count and total cart price.",
          "Visually stack the cart card *under* the products card (single-column layout)."
        ],
        "expectedBehavior": [
          "Clicking \"Add to cart\" for a product that is not yet in the cart adds it with quantity `1`.",
          "Clicking \"Add to cart\" again for the same product increases its quantity by `1`.",
          "Clicking the \"+\" button in the cart increases that item's quantity by `1`.",
          "Clicking the \"−\" button decreases quantity by `1`. When quantity would drop below `1`, the item is removed from the cart (or left out entirely).",
          "Clicking \"Remove\" immediately removes that item from the cart.",
          "Total item count and total price update correctly whenever the cart changes."
        ],
        "implementationNotes": [
          "Use React state (`useState`) to hold `cartItems` as an array.",
          "Treat `cartItems` as immutable: use `map`, `filter`, and array spreads (`[...]`) instead of mutating in place.",
          "Derive `totalQty` and `totalPrice` from `cartItems` using `Array.prototype.reduce`.",
          "Prefer functional `setState` updates (`setCartItems(prev => ...)`) when the next value depends on the previous one.",
          "Keep everything in a single `<App />` component for this exercise; no context or external state library is required.",
          "Match the given UI: products in a card on top, cart in a card below, consistent spacing and typography."
        ],
        "techFocus": [
          "React `useState` for array-based state",
          "Immutable updates (`map`, `filter`, spreads)",
          "Derived state (total quantity, total price)",
          "Controlled click handlers for add / increase / decrease / remove",
          "Simple list rendering with `key` props"
        ]
      }
    },
    "starterCodeHint": "Use a `cartItems` state array and treat it immutably. When adding or updating, always create a new array instead of mutating the existing one. Derive `totalQty` and `totalPrice` from `cartItems` using `reduce`.",
    "solutionBlock": {
      "overview": "The core of this exercise is managing nested, array-based state immutably and deriving totals from it. Keep `cartItems` as a single array in `App` state, where each item contains `id`, `name`, `price`, and `quantity`. When the user adds a product, either append a new cart item with `quantity: 1` or map over existing items and increase the quantity for the matching id. All updates should use immutable patterns: `map`, `filter`, and array spreads.\n\n`totalQty` and `totalPrice` are derived values, calculated with `reduce` so they always reflect the current cart. The UI is a single column: a \"Products\" card on top and a \"Cart\" card below, each using simple lists and buttons for cart actions.\n\n**Key ideas**\n- Store the cart as an array of items with quantities.\n- Use immutable updates instead of mutating arrays in place.\n- Derive totals from state instead of storing them separately.\n- Keep layout simple but polished: products card first, cart card below.",
      "approaches": [
        {
          "title": "Single component with immutable cart array",
          "prose": "Implement everything inside a single `App` component. Declare `const [cartItems, setCartItems] = useState<CartItem[]>([])`. To add a product, call `setCartItems(prev => { ... })`, find an existing item, and either append a new one or return a `map`ped array with an updated `quantity`. For `increaseQty` and `decreaseQty`, update the matching item by id. When decreasing below 1, filter the item out. Compute `totalQty` and `totalPrice` using `reduce` so they are always derived from the current cart.\n\nThis approach keeps state centralized, shows clear immutable patterns, and makes derived values straightforward. It's a good litmus test for React developers' comfort with array updates and derived state.",
          "codeJs": "// Sketch of the core logic (simplified)\nfunction App() {\n  const [cartItems, setCartItems] = React.useState([]);\n\n  const totalQty = cartItems.reduce((sum, item) => sum + item.quantity, 0);\n  const totalPrice = cartItems.reduce(\n    (sum, item) => sum + item.price * item.quantity,\n    0\n  );\n\n  function addToCart(product) {\n    setCartItems(prev => {\n      const existing = prev.find(i => i.id === product.id);\n      if (!existing) {\n        return [...prev, { ...product, quantity: 1 }];\n      }\n      return prev.map(i =>\n        i.id === product.id ? { ...i, quantity: i.quantity + 1 } : i\n      );\n    });\n  }\n\n  function increaseQty(item) {\n    setCartItems(prev =>\n      prev.map(i =>\n        i.id === item.id ? { ...i, quantity: i.quantity + 1 } : i\n      )\n    );\n  }\n\n  function decreaseQty(item) {\n    setCartItems(prev => {\n      const current = prev.find(i => i.id === item.id);\n      if (!current) return prev;\n      if (current.quantity <= 1) {\n        return prev.filter(i => i.id !== item.id);\n      }\n      return prev.map(i =>\n        i.id === item.id ? { ...i, quantity: i.quantity - 1 } : i\n      );\n    });\n  }\n\n  function removeItem(item) {\n    setCartItems(prev => prev.filter(i => i.id !== item.id));\n  }\n\n  // ...render products card on top, cart card below...\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating `cartItems` directly (e.g. `cartItems.push(...)` or `item.quantity++`), which can lead to stale renders or hidden bugs.",
          "Storing `totalQty` and `totalPrice` separately and forgetting to keep them in sync with `cartItems`.",
          "Keying list items by array index instead of stable `id`, causing weird UI behavior when items are added or removed.",
          "Letting quantities drop to 0 but still keeping the row in the cart."
        ],
        "techniques": [
          "Immutable React state updates using `map`, `filter`, and spreads.",
          "Derived state with `reduce` instead of extra state variables.",
          "Single-responsibility handlers: `addToCart`, `increaseQty`, `decreaseQty`, `removeItem`.",
          "Aligning React JSX structure and CSS classes with an existing Angular/Vue design for consistent cross-framework UI."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-shopping-cart.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-shopping-cart"
    },
    "solutionAsset": "assets/sb/react/solution/react-shopping-cart-solution.v1.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build React Shopping Cart Component",
      "description": "Create a shopping cart UI that supports adding items, updating quantities, removing items, and showing totals accurately."
    }
  },
  {
    "id": "react-debounced-search",
    "title": "React Debounced Search with Fake API",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "react",
      "state",
      "effects",
      "async",
      "debounce",
      "api-calls"
    ],
    "description": {
      "summary": "Build a React debounced search input with fake API calls. Use useEffect + setTimeout cleanup to cancel stale requests, and manage loading, error, and empty states for realistic UX. Concepts: react, state, effects. React focus: debounce with useEffect + setTimeout cleanup, and manage loading/error state. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a search input as the main UI.",
          "Hold the current query, loading flag, error message, and results list in React state.",
          "Trigger the search 500ms after the user stops typing (debounced).",
          "Call a provided fake API function that returns a filtered list of users.",
          "Show a loading message while the debounced request is in-flight.",
          "Show a friendly error message when the fake API rejects.",
          "Show result rows with user name and email on success.",
          "Show an empty state when there are no results for a non-empty query."
        ],
        "expectedBehavior": [
          "Typing in the input updates the query immediately.",
          "No API calls happen while the user is still typing quickly.",
          "500ms after the user stops typing, a search request is fired.",
          "While the debounced request is running, a loading state is visible.",
          "If the query is cleared, results are cleared and no request is fired.",
          "If the query is \"error\", the fake API rejects and an error message is displayed.",
          "On success, the list shows matching users by name or email.",
          "When there are no matches, an explicit 'no results' message is shown."
        ],
        "implementationNotes": [
          "Use React state (useState) to store query, results, loading, and error.",
          "Use useEffect with a 500ms setTimeout for the debounced behavior.",
          "Clean up the timeout and in-flight request in the effect cleanup to avoid race conditions.",
          "Guard against stale responses by using a flag in the effect cleanup or by tracking a request id."
        ],
        "techFocus": [
          "React useState",
          "React useEffect",
          "Effect cleanup and race conditions",
          "Debounced async calls",
          "Error and loading state management"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Use a controlled input for the query and keep `results`, `isLoading`, and `error` in state. In a `useEffect` that depends on `query`, start a 500ms timeout. Inside the timeout callback, call `fakeApiSearch(query)` and update state on success or failure. Clear results and flags immediately when the query becomes empty.\n\nTo avoid race conditions, clear the timeout and mark the effect as stale in the cleanup function so older requests can't overwrite newer state.\n\n**Test cases**\n- Typing quickly does not fire a request until 500ms after typing stops.\n- Clearing the input clears results and stops loading.\n- Query `\"ali\"` returns users whose name or email contains that substring.\n- Query `\"error\"` triggers the fake API rejection and shows the error message.\n- With no matches, a 'no results' message is shown. Key concepts: react, state, effects.",
      "approaches": [
        {
          "title": "Single component with useEffect debounce",
          "prose": "Keep all state and logic in the `App` component. Use `useState` for `query`, `results`, `isLoading`, and `error`. In a `useEffect` that depends on `query`, handle three cases:\n\n1. If `query.trim()` is empty, clear results and reset flags, then return early.\n2. Otherwise, set `isLoading` to `true`, clear any previous error, and start a `setTimeout` with 500ms delay.\n3. In the timeout callback, call `fakeApiSearch(query)` which returns a Promise. On success, update `results` and set `isLoading` to `false`. On failure, set `error`, clear `results`, and set `isLoading` to `false`.\n\nUse a cleanup function to clear the pending timeout and mark the effect as stale so that earlier requests cannot update state after a later keystroke.",
          "codeJs": "import React from 'react';\n\nconst FAKE_DATA = [\n  { id: 1, name: 'Alice Johnson', email: 'alice@example.com' },\n  { id: 2, name: 'Bob Smith', email: 'bob@example.com' },\n  { id: 3, name: 'Charlie Kim', email: 'charlie@example.com' },\n  { id: 4, name: 'Diana Lopez', email: 'diana@example.com' },\n  { id: 5, name: 'Ethan Brown', email: 'ethan@example.com' },\n  { id: 6, name: 'Fiona Patel', email: 'fiona@example.com' }\n];\n\nfunction fakeApiSearch(term) {\n  const trimmed = term.trim().toLowerCase();\n  const delayMs = 600;\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (!trimmed) {\n        resolve([]);\n        return;\n      }\n\n      if (trimmed === 'error') {\n        reject(new Error('Fake API error'));\n        return;\n      }\n\n      const filtered = FAKE_DATA.filter((item) => {\n        const name = item.name.toLowerCase();\n        const email = item.email.toLowerCase();\n        return name.includes(trimmed) || email.includes(trimmed);\n      });\n\n      resolve(filtered);\n    }, delayMs);\n  });\n}\n\nexport default function App() {\n  const [query, setQuery] = React.useState('');\n  const [results, setResults] = React.useState([]);\n  const [isLoading, setIsLoading] = React.useState(false);\n  const [error, setError] = React.useState(null);\n\n  React.useEffect(() => {\n    let isCurrent = true;\n\n    const trimmed = query.trim();\n    if (!trimmed) {\n      setResults([]);\n      setIsLoading(false);\n      setError(null);\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    const timeoutId = window.setTimeout(() => {\n      fakeApiSearch(trimmed)\n        .then((data) => {\n          if (!isCurrent) return;\n          setResults(data);\n          setIsLoading(false);\n        })\n        .catch((err) => {\n          if (!isCurrent) return;\n          setResults([]);\n          setIsLoading(false);\n          setError(err instanceof Error ? err.message : 'Something went wrong.');\n        });\n    }, 500);\n\n    return () => {\n      isCurrent = false;\n      window.clearTimeout(timeoutId);\n    };\n  }, [query]);\n\n  const handleChange = (event) => {\n    setQuery(event.target.value);\n  };\n\n  return (\n    <main className=\"main\">\n      <section className=\"card\">\n        <header className=\"header\">\n          <h1 className=\"title\">Debounced Search</h1>\n          <p className=\"subtitle\">\n            Type to search a fake user directory. Search runs 500ms after you stop typing.\n          </p>\n        </header>\n\n        <div className=\"field\">\n          <label className=\"label\" htmlFor=\"search-input\">Search</label>\n          <input\n            id=\"search-input\"\n            className=\"input\"\n            type=\"text\"\n            value={query}\n            onChange={handleChange}\n            placeholder=\"Start typing a name or email...\"\n            autoComplete=\"off\"\n          />\n        </div>\n\n        <div className=\"status-row\">\n          {isLoading && <span className=\"status status--loading\">Searching…</span>}\n          {!isLoading && !error && query && (\n            <span className=\"status\">Showing {results.length} result(s) for \"{query}\"</span>\n          )}\n          {!isLoading && !error && !query && (\n            <span className=\"status status--muted\">Start typing to search.</span>\n          )}\n          {error && <span className=\"status status--error\">{error}</span>}\n        </div>\n\n        {results.length > 0 && (\n          <ul className=\"results\">\n            {results.map((r) => (\n              <li key={r.id} className=\"result-row\">\n                <div className=\"result-name\">{r.name}</div>\n                <div className=\"result-email\">{r.email}</div>\n              </li>\n            ))}\n          </ul>\n        )}\n\n        {!results.length && !isLoading && query && !error && (\n          <p className=\"empty\">No results found for \"{query}\".</p>\n        )}\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to clean up the timeout or to guard against stale responses, which can cause earlier queries to override newer results.",
          "Triggering the search on every keystroke without a debounce, which spams the fake API.",
          "Not handling the empty-query case, leading to confusing loading states and unnecessary calls.",
          "Failing to reset error state when the user types a new query."
        ],
        "techniques": [
          "Using useEffect with a timeout and cleanup for debouncing.",
          "Managing async state (loading, error, results) in React.",
          "Guarding against race conditions in effects with a boolean flag.",
          "Deriving UI states (status text, empty messages) from a small set of state variables."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-debounced-search.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-debounced-search"
    },
    "solutionAsset": "assets/sb/react/solution/react-debounced-search-solution.v1.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Debounced Search in React",
      "description": "Create a search experience that delays rapid input triggers and handles loading, empty, success, and error result states."
    }
  },
  {
    "id": "react-star-rating",
    "title": "React Star Rating Widget",
    "type": "coding",
    "technology": "react",
    "difficulty": "easy",
    "importance": 2,
    "tags": [
      "react",
      "state",
      "props",
      "event-handlers",
      "components"
    ],
    "description": {
      "summary": "Implement a reusable <StarRating /> widget in React. It should render a row of clickable stars, allow the user to select a rating, and notify a parent component when the rating changes. React focus: build a controlled component and notify parent on change. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a <StarRating /> component as part of the main UI.",
          "Display a row of stars (e.g. 5 by default).",
          "Allow the parent to control the current rating via props.",
          "Notify the parent when the user selects a new rating (e.g. via an onChange callback).",
          "Display the current rating value below the stars."
        ],
        "expectedBehavior": [
          "Stars render from 1 up to the configured max (default 5).",
          "Clicking the 3rd star sets the rating to 3 (and fills 3 stars).",
          "Clicking the 5th star sets the rating to 5 (and fills 5 stars).",
          "Updating the rating in the parent reflects in the <StarRating /> UI."
        ],
        "implementationNotes": [
          "Keep <StarRating /> as a controlled component: it receives `rating` and `onChange` props.",
          "Expose an optional `max` prop to configure the number of stars (default 5).",
          "Use an array like `[1, 2, 3, 4, 5]` to render stars via `map`.",
          "Use a CSS class (e.g. `.filled`) to visually differentiate selected stars.",
          "Render a simple text line like \"Current rating: X / 5\" below the widget."
        ],
        "techFocus": [
          "React component props",
          "Controlled components",
          "Event handlers and state lifting",
          "Basic UI composition"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Split the UI into two components: a top-level <App /> that holds the current rating in state, and a reusable <StarRating /> that renders stars and calls `onChange` when a star is clicked.\n\n<StarRating /> is a controlled component: it receives `rating` and `onChange` props, plus an optional `max` prop which defaults to 5. It builds an array `[1..max]` to render stars with `map`. Each star is a button that calls `onChange(starIndex)` when clicked.\n\n<App /> uses `useState(0)` to hold `currentRating` and passes `rating={currentRating}` and `onChange={setCurrentRating}` down to <StarRating />.\n\n**Test cases**\n- Initial render shows 5 outlined stars and \"Current rating: 0 / 5\".\n- Clicking the 3rd star fills 3 stars and sets the text to \"Current rating: 3 / 5\".\n- Clicking the 5th star fills all 5.\n- Changing `max` (e.g. to 10) renders that many stars.",
      "approaches": [
        {
          "title": "Controlled <StarRating /> component with lifted state",
          "prose": "Keep the rating state in the parent component and let <StarRating /> be a controlled widget. <StarRating /> knows how to render stars and which ones are filled, but the parent decides what the current rating is.\n\n1. In <App />, store `currentRating` with `useState(0)`.\n2. Render `<StarRating rating={currentRating} onChange={setCurrentRating} />`.\n3. In <StarRating />, accept `rating`, `max = 5`, and `onChange` props.\n4. Build a stars array with `Array.from({ length: max }, (_, i) => i + 1)`.\n5. For each star, render a button. Use `star <= rating` to decide if it should have the `filled` class.\n6. On click, call `onChange(star)`.\n\nThis keeps behavior predictable, easy to test, and reusable across different parents.",
          "codeJs": "import React from 'react';\n\nfunction StarRating({ max = 5, rating, onChange }) {\n  const stars = React.useMemo(\n    () => Array.from({ length: max }, (_, i) => i + 1),\n    [max]\n  );\n\n  return (\n    <div className=\"stars\" role=\"radiogroup\" aria-label=\"Star rating\">\n      {stars.map((star) => (\n        <button\n          key={star}\n          type=\"button\"\n          className={\"star\" + (star <= rating ? \" filled\" : \"\")}\n          onClick={() => onChange(star)}\n          aria-label={`${star} out of ${max}`}\n          aria-pressed={star <= rating}\n        >\n          ★\n        </button>\n      ))}\n    </div>\n  );\n}\n\nexport default function App() {\n  const [currentRating, setCurrentRating] = React.useState(0);\n\n  return (\n    <main className=\"main\">\n      <section className=\"section\">\n        <h1>Star Rating Widget</h1>\n        <div className=\"panel\">\n          <StarRating rating={currentRating} onChange={setCurrentRating} />\n          <p className=\"hint\">Current rating: {currentRating} / 5</p>\n        </div>\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Storing rating state inside <StarRating /> only, making it harder for parents to react to changes.",
          "Hardcoding five stars in JSX instead of generating from an array, which makes `max` unconfigurable.",
          "Not visually distinguishing filled vs empty stars."
        ],
        "techniques": [
          "Lifting state up into the parent component.",
          "Using a controlled component pattern for form-like widgets.",
          "Using array mapping to render repeated UI from data."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-star-rating.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-star-rating"
    },
    "solutionAsset": "assets/sb/react/solution/react-star-rating-solution.v1.json",
    "companies": [
      "amazon"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Reusable Star Rating Component in React",
      "description": "Create a star rating component that supports user selection, configurable limits, and predictable value updates."
    }
  },
  {
    "id": "react-dynamic-table",
    "title": "React Dynamic Table (Rows × Columns)",
    "type": "coding",
    "technology": "react",
    "difficulty": "easy",
    "importance": 2,
    "tags": [
      "react",
      "state",
      "event-handlers",
      "components",
      "lists",
      "dynamic-ui"
    ],
    "description": {
      "summary": "Generate a dynamic table in React from row/column inputs. Normalize values, rebuild the grid on action, and render consistent labels so users can verify correct dimensions. Concepts: react, state, event-handlers. React focus: generate rows/cols with map and keep inputs controlled. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a main <App /> UI that contains the dynamic table controls.",
          "Provide two numeric inputs: one for the number of rows and one for the number of columns.",
          "Provide a button (e.g. \"Generate table\") that rebuilds the table when clicked.",
          "Render an HTML table whose number of rows and columns matches the current inputs.",
          "Each cell should show something simple and visible, e.g. its row/column indices like R1C1."
        ],
        "expectedBehavior": [
          "Initially, showing an empty state or no table is fine. After the first generate action, a table appears.",
          "Changing the row or column input and clicking the button updates the table dimensions.",
          "If the user enters non-positive values (0 or negative), the implementation may either render no rows/columns or clamp to a minimum of 1, as long as behavior is consistent."
        ],
        "implementationNotes": [
          "Use React state (useState) to store the current numeric inputs (rows, columns) and the arrays driving the table.",
          "Keep separate state for the raw inputs and the derived arrays you map over (e.g. rows and cols).",
          "Normalize counts (e.g. clamp to >= 0 and a reasonable max) before generating the arrays.",
          "Use nested array mapping to generate table rows and cells."
        ],
        "techFocus": [
          "React useState for component state",
          "Handling controlled inputs and change events",
          "Dynamic rendering using array map",
          "Simple input normalization for UI safety"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Use React state to hold four values: rowInput, colInput, rows, and cols. The numeric inputs store raw values (rowInput, colInput). When the user clicks a \"Generate\" button, you normalize these values, then rebuild rows and cols arrays using something like Array.from({ length: n }). The component renders an HTML table using nested map calls over rows and cols, printing a label such as R1C1 in each cell.\n\n**Test cases**\n- With rowInput = 2 and colInput = 3, after clicking \"Generate\", the table has 2 <tr> rows and each row has 3 <td> cells.\n- Updating rowInput to 4 and clicking again updates the table to 4 rows.\n- Updating colInput to 1 and clicking again updates the table to 1 column per row.\n- When rows or columns are set to 0 (or negative), the implementation either renders no table or clamps to 0/1 consistently. Key concepts: react, state, event-handlers.",
      "approaches": [
        {
          "title": "Single component with derived row/column arrays",
          "prose": "Implement everything inside a single App component. Keep raw values in rowInput and colInput, and use rows and cols arrays to drive the rendered table via nested map.\n\n1. Keep rowInput and colInput as controlled inputs with onChange handlers.\n2. Implement normalizeCount to clamp and sanitize user-provided values.\n3. Implement updateTable so it calls normalizeCount for rows and columns and then builds arrays using Array.from.\n4. Render a \"Generate table\" button that calls updateTable.\n5. Render an HTML table with nested map calls, labeling each cell with its 1-based row and column index.\n\nThis keeps state colocated and demonstrates how to generate UI dynamically from user input.",
          "codeJs": "import React from 'react';\n\nexport default function App() {\n  const [rowInput, setRowInput] = React.useState(3);\n  const [colInput, setColInput] = React.useState(4);\n  const [rows, setRows] = React.useState<number[]>([]);\n  const [cols, setCols] = React.useState<number[]>([]);\n\n  const normalizeCount = (raw: number) => {\n    if (!Number.isFinite(raw)) return 0;\n    const n = Math.floor(raw);\n    const clamped = Math.max(0, Math.min(n, 20));\n    return clamped;\n  };\n\n  const updateTable = () => {\n    const r = normalizeCount(rowInput);\n    const c = normalizeCount(colInput);\n    setRows(Array.from({ length: r }, (_, i) => i));\n    setCols(Array.from({ length: c }, (_, i) => i));\n  };\n\n  return (\n    <main className=\"main\">\n      <section className=\"section\">\n        <h1>Dynamic Table</h1>\n        <p className=\"hint\">Enter rows & columns, then generate a table grid.</p>\n\n        <div className=\"controls\">\n          <label>\n            <span>Rows</span>\n            <input\n              type=\"number\"\n              min={0}\n              value={rowInput}\n              onChange={(e) => setRowInput(Number(e.target.value))}\n            />\n          </label>\n          <label>\n            <span>Columns</span>\n            <input\n              type=\"number\"\n              min={0}\n              value={colInput}\n              onChange={(e) => setColInput(Number(e.target.value))}\n            />\n          </label>\n          <button onClick={updateTable}>Generate table</button>\n        </div>\n\n        {rows.length > 0 && cols.length > 0 ? (\n          <div className=\"preview\" aria-label=\"dynamic table\">\n            <table className=\"grid\">\n              <tbody>\n                {rows.map((_, rowIndex) => (\n                  <tr key={rowIndex}>\n                    {cols.map((__, colIndex) => (\n                      <td key={colIndex}>R{rowIndex + 1}C{colIndex + 1}</td>\n                    ))}\n                  </tr>\n                ))}\n              </tbody>\n            </table>\n          </div>\n        ) : (\n          <p className=\"empty\">Set rows & columns, then generate the table.</p>\n        )}\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Trying to map directly over a number instead of an array (e.g. Array.from missing).",
          "Not normalizing input so negative or NaN values break the UI.",
          "Leaving inputs uncontrolled or forgetting to wire onChange."
        ],
        "techniques": [
          "Using useState for both raw inputs and derived arrays.",
          "Using Array.from({ length: n }) to create simple iterable ranges.",
          "Using nested map to build grid-like UIs."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-dynamic-table.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-dynamic-table"
    },
    "solutionAsset": "assets/sb/react/solution/react-dynamic-table-solution.v1.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Dynamic Rows and Columns Table in React",
      "description": "Create a table that renders from user-provided row and column counts with consistent layout and valid input handling."
    }
  },
  {
    "id": "react-nested-checkboxes",
    "title": "React Nested Checkbox Tree (Parent–Child Sync)",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "react",
      "state",
      "event-handlers",
      "components",
      "dom"
    ],
    "description": {
      "summary": "Build a small React UI that renders a parent checkbox and multiple child checkboxes. The parent controls all children, and the children keep the parent in sync (checked, unchecked, or indeterminate). React focus: compute parent indeterminate state from child selections. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a parent checkbox with a label, plus several child checkboxes listed under it.",
          "Checking the parent selects all children.",
          "Unchecking the parent clears all children.",
          "When children are toggled individually:",
          "- If all are checked → parent is checked.",
          "- If none are checked → parent is unchecked.",
          "- If some are checked → parent is indeterminate.",
          "Keep everything in a single <App /> component."
        ],
        "expectedBehavior": [
          "Each child checkbox toggles independently.",
          "The parent reflects the aggregate state of the children.",
          "The parent’s visual state shows indeterminate when selection is mixed.",
          "No external component libraries are required."
        ],
        "implementationNotes": [
          "Use React state (useState) to store an array of child items (e.g. { label, checked }).",
          "Use a ref (useRef) on the parent checkbox to assign the DOM-only `indeterminate` property.",
          "Derive the parent state (checked / unchecked / indeterminate) from the current children array."
        ],
        "techFocus": [
          "React useState for list state",
          "Event handlers for checkboxes",
          "Managing derived state (parent from children)",
          "Working with DOM-only properties via useRef"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This exercise is about synchronizing state between a parent checkbox and several children. Store the children as an array of objects in state. The parent checkbox does not have its own state; instead, its checked and indeterminate status are derived from how many children are selected. Because `indeterminate` is not a normal React prop, you use a ref to the DOM <input> and assign it manually.",
      "approaches": [
        {
          "title": "Children in state + derived parent via ref",
          "prose": "Keep the list of children in a single `useState` array of `{ label, checked }`. On parent toggle, map all children to the new checked value. On child toggle, flip only that element. After each change, compute how many children are checked and use a helper to update the parent checkbox via a ref: checked when all are selected, unchecked when none are selected, and indeterminate when the selection is mixed.",
          "codeJs": "import React, { useState, useRef } from 'react';\n\nfunction App() {\n  const [children, setChildren] = useState([\n    { label: 'Child 1', checked: false },\n    { label: 'Child 2', checked: false },\n    { label: 'Child 3', checked: false }\n  ]);\n\n  const parentRef = useRef(null);\n\n  const syncParent = (nodes) => {\n    const total = nodes.length;\n    const checkedCount = nodes.filter((n) => n.checked).length;\n    const parent = parentRef.current;\n    if (!parent) return;\n\n    if (checkedCount === total) {\n      parent.checked = true;\n      parent.indeterminate = false;\n    } else if (checkedCount === 0) {\n      parent.checked = false;\n      parent.indeterminate = false;\n    } else {\n      parent.checked = false;\n      parent.indeterminate = true;\n    }\n  };\n\n  const toggleParent = (event) => {\n    const checked = event.target.checked;\n    setChildren((prev) => {\n      const next = prev.map((child) => ({ ...child, checked }));\n      syncParent(next);\n      return next;\n    });\n  };\n\n  const toggleChild = (index) => {\n    setChildren((prev) => {\n      const next = prev.map((child, i) =>\n        i === index ? { ...child, checked: !child.checked } : child\n      );\n      syncParent(next);\n      return next;\n    });\n  };\n\n  return (\n    <main style={{ minHeight: '100vh', background: '#0a0a0a', color: '#e5e7eb', display: 'grid', placeItems: 'center', padding: 24 }}>\n      <section style={{ width: '100%', maxWidth: 420, display: 'grid', gap: 16 }}>\n        <h1 style={{ margin: 0, fontSize: 20, fontWeight: 700 }}>Nested Checkboxes</h1>\n\n        <div style={{ background: '#0b1020', border: '1px solid #1f2937', borderRadius: 12, padding: 16, display: 'grid', gap: 12 }}>\n          <label style={{ display: 'flex', alignItems: 'center', gap: 8, fontSize: 16, fontWeight: 600 }}>\n            <input ref={parentRef} type=\"checkbox\" onChange={toggleParent} />\n            <span>Parent</span>\n          </label>\n\n          <div style={{ display: 'grid', gap: 6, marginLeft: 24 }}>\n            {children.map((child, index) => (\n              <label key={child.label} style={{ display: 'flex', alignItems: 'center', gap: 8, fontSize: 14 }}>\n                <input\n                  type=\"checkbox\"\n                  checked={child.checked}\n                  onChange={() => toggleChild(index)}\n                />\n                <span>{child.label}</span>\n              </label>\n            ))}\n          </div>\n        </div>\n      </section>\n    </main>\n  );\n}\n\nexport default App;\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Trying to control `indeterminate` via JSX (e.g. `<input indeterminate={...} />`) — it must be set on the DOM node via a ref.",
          "Giving the parent its own independent `useState` instead of deriving it from the children.",
          "Forgetting to recompute and apply parent state after each child toggle."
        ],
        "techniques": [
          "Using `useState` with arrays of objects.",
          "Using `useRef` to reach DOM-only properties like `indeterminate`.",
          "Deriving UI state from existing state instead of duplicating it."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-nested-checkboxes.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-nested-checkboxes"
    },
    "solutionAsset": "assets/sb/react/solution/react-nested-checkboxes-solution.v1.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Nested Checkbox Tree in React",
      "description": "Create nested checkbox behavior where parent and child selections stay synchronized, including partial-selection states."
    }
  },
  {
    "id": "react-autocomplete-search-starter",
    "title": "Autocomplete Search Bar (Hooks)",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "react",
      "hooks",
      "state",
      "events",
      "debounce",
      "accessibility",
      "keyboard"
    ],
    "description": {
      "summary": "Build an **autocomplete search bar** in React. As the user types, show a dropdown of suggestions filtered from a dataset. Add debounced searching, mouse selection, keyboard navigation (↑/↓/Enter/Escape), and close-on-outside-click. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a single `<App />` as the main UI.",
          "Show an input with a dropdown of suggestions filtered by the current query (case-insensitive, substring match).",
          "Debounce input changes (e.g. 250–400ms) before searching.",
          "Support mouse selection (mousedown on an option selects it, closes dropdown, resets active index).",
          "Support keyboard navigation: ArrowDown/ArrowUp moves active option (wrap-around), Enter selects, Escape closes.",
          "Close the dropdown when clicking outside the component.",
          "Basic accessibility: `role=\"combobox\"`, `role=\"listbox\"`, `role=\"option\"`, `aria-expanded`, `aria-activedescendant`."
        ],
        "expectedBehavior": [
          "Typing updates suggestions after the debounce delay.",
          "If query is empty/whitespace, dropdown is closed and no suggestions are shown.",
          "ArrowDown from no selection activates the first option; ArrowUp activates the last option.",
          "Enter selects the active option (if any) and closes the dropdown.",
          "Escape closes the dropdown without changing the input.",
          "Clicking outside closes the dropdown."
        ],
        "implementationNotes": [
          "Create a fake async `search(q)` that returns a Promise of results (simulate latency with `setTimeout`).",
          "Drive results via a debounced effect; avoid stale results (use a sequence id or cleanup).",
          "Prefer derived rendering (`results` state + `isOpen`) rather than imperatively manipulating the DOM.",
          "Keep everything in a single component (no need for external libs)."
        ],
        "techFocus": [
          "React state + effects",
          "Debounce with timers in useEffect",
          "Keyboard navigation state management",
          "Click-outside handling with document listener",
          "A11y roles/aria"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Use `query`, `results`, `isOpen`, and `activeIndex` state. Debounce changes to `query` in an effect, then call an async `search()` that filters a local dataset and resolves after ~150ms. Open the dropdown when the query is non-empty, close it when empty or on Escape/outside click. For keyboard navigation, update `activeIndex` with wrap-around and select on Enter. Use `(onMouseDown)` on options so selection happens before input blur/click-outside closes.\n\n**Test cases**\n- Type \"san\" → after debounce, results include \"San Francisco\" / \"San Jose\".\n- Type \"\" → dropdown closes.\n- ArrowDown/ArrowUp wraps.\n- Enter selects active option.\n- Escape closes.\n- Outside click closes.\n- MouseDown on option selects and closes.",
      "approaches": [
        {
          "title": "Hooks + debounced effect + outside click",
          "prose": "1) Store `query`, `results`, `isOpen`, `activeIndex` in state.\n2) Debounce `query` changes in `useEffect` using `setTimeout` + cleanup.\n3) When query is empty, clear results and close.\n4) Implement `onKeyDown` for navigation/selection.\n5) Add a document `mousedown` listener for outside click; use `ref` to test containment.\n6) Highlight matches using escaped HTML and `<mark>`."
        }
      ],
      "notes": {
        "pitfalls": [
          "Not cleaning up debounce timers (causes race conditions).",
          "Using onClick on options (click-outside / blur can close before selection).",
          "Not trimming whitespace queries.",
          "Not guarding Enter when no active option."
        ],
        "techniques": [
          "Debounce with useEffect cleanup.",
          "Use refs for outside click detection.",
          "Wrap-around navigation with modulo arithmetic."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-autocomplete-search.v2.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-autocomplete-search-starter"
    },
    "solutionAsset": "assets/sb/react/solution/react-autocomplete-search-solution.v2.json",
    "companies": [
      "apple"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build React Autocomplete Search Component",
      "description": "Create an autocomplete input that shows matching suggestions, supports keyboard interaction, and handles selection and close states."
    }
  },
  {
    "id": "react-transfer-list",
    "title": "React Transfer List (Select + Move Between Two Lists)",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 3,
    "tags": [
      "react",
      "state",
      "event-handlers",
      "lists",
      "immutability"
    ],
    "description": {
      "summary": "Build a React transfer list UI with two panels and checkbox selection. Users select items in one list and move them to the other with arrow buttons. Preserve item order, clear selection after transfer, and disable buttons when nothing is selected. Include keyboard navigation, focus management, and performance for large lists; test selections after transfer. React focus: manage selected ids and list state immutably across two panels. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render two lists: Top and Bottom.",
          "Each list shows items with a checkbox to select.",
          "Provide two transfer buttons between lists: \"↓\" moves selected Top items to Bottom; \"↑\" moves selected Bottom items to Top.",
          "Disable \"↓\" when no Top items are selected; disable \"↑\" when no Bottom items are selected.",
          "After transfer, moved items must be unselected in the destination list.",
          "Preserve item order within each list (append moved items to the end of destination list)."
        ],
        "expectedBehavior": [
          "Selecting items in Top and clicking \"↓\" removes them from Top and appends them to Bottom.",
          "Selecting items in Bottom and clicking \"↑\" removes them from Bottom and appends them to Top.",
          "Buttons do nothing when disabled.",
          "Selections are tracked by stable `id` and cleared after transfer."
        ],
        "implementationNotes": [
          "Use React state: `topItems`, `bottomItems` arrays of `{ id, label }`.",
          "Track selection with `Set<string>` for Top and Bottom.",
          "Transfer should be computed as `moved` and `remaining` arrays; then `dest = [...dest, ...moved]` and `source = remaining`.",
          "Keep UI in a single `App` component for this exercise."
        ],
        "techFocus": [
          "useState",
          "Checkbox change handling",
          "Moving items between arrays",
          "Immutability patterns"
        ]
      }
    },
    "starterCodeHint": "Use two `Set<string>` selections. On move: split source list into `moved` and `remaining` by `selected.has(id)`, then update both arrays and clear that selection set.",
    "solutionBlock": {
      "overview": "Keep two arrays of items (top/bottom) and two selection sets for checked ids. Toggling a checkbox adds/removes the id from the correct set. When transferring, split the source list into `moved` and `remaining`, append `moved` to the destination list, and clear the selection. This mirrors common dual-list pickers in admin UIs.",
      "approaches": [
        {
          "title": "Two arrays + two selection sets",
          "prose": "Implementation plan: store `topItems`, `bottomItems`, `topSelected`, and `bottomSelected` in state. Use a `Set` to track checked ids and update it with functional state updates. On transfer, build `moved` and `remaining` by filtering the source list based on the selection set, update destination with `setDest([...dest, ...moved])`, update source with `setSource(remaining)`, and reset the selection set to empty. Disable the transfer buttons when the corresponding selection set is empty.",
          "codeJs": "import React, { useMemo, useState } from 'react';\nimport './App.css';\n\ntype Item = { id: string; label: string };\n\nexport default function App() {\n  const [topItems, setTopItems] = useState<Item[]>([\n    { id: 'a', label: 'Alpha' },\n    { id: 'b', label: 'Beta' },\n    { id: 'c', label: 'Gamma' },\n    { id: 'd', label: 'Delta' },\n    { id: 'e', label: 'Epsilon' }\n  ]);\n\n  const [bottomItems, setBottomItems] = useState<Item[]>([\n    { id: 'x', label: 'Xenon' },\n    { id: 'y', label: 'Yttrium' },\n    { id: 'z', label: 'Zinc' }\n  ]);\n\n  const [topSelected, setTopSelected] = useState<Set<string>>(() => new Set());\n  const [bottomSelected, setBottomSelected] = useState<Set<string>>(() => new Set());\n\n  const canMoveDown = topSelected.size > 0;\n  const canMoveUp = bottomSelected.size > 0;\n\n  const toggleTop = (id: string, checked: boolean) => {\n    setTopSelected((prev) => {\n      const next = new Set(prev);\n      if (checked) next.add(id);\n      else next.delete(id);\n      return next;\n    });\n  };\n\n  const toggleBottom = (id: string, checked: boolean) => {\n    setBottomSelected((prev) => {\n      const next = new Set(prev);\n      if (checked) next.add(id);\n      else next.delete(id);\n      return next;\n    });\n  };\n\n  const moveDown = () => {\n    if (!canMoveDown) return;\n\n    const moved: Item[] = [];\n    const remaining: Item[] = [];\n\n    for (const it of topItems) {\n      if (topSelected.has(it.id)) moved.push(it);\n      else remaining.push(it);\n    }\n\n    setTopItems(remaining);\n    setBottomItems((prev) => [...prev, ...moved]);\n    setTopSelected(new Set());\n  };\n\n  const moveUp = () => {\n    if (!canMoveUp) return;\n\n    const moved: Item[] = [];\n    const remaining: Item[] = [];\n\n    for (const it of bottomItems) {\n      if (bottomSelected.has(it.id)) moved.push(it);\n      else remaining.push(it);\n    }\n\n    setBottomItems(remaining);\n    setTopItems((prev) => [...prev, ...moved]);\n    setBottomSelected(new Set());\n  };\n\n  return (\n    <main className=\"page\">\n      <section className=\"card\">\n        <h1 className=\"title\">Transfer List</h1>\n        <p className=\"subtitle\">Select items and move them between lists.</p>\n\n        <div className=\"layout\">\n          <section className=\"listCard\">\n            <div className=\"listTitle\">Top</div>\n            <ul className=\"list\" role=\"list\">\n              {topItems.map((item) => (\n                <li key={item.id} className=\"row\">\n                  <label className=\"rowLabel\">\n                    <input\n                      type=\"checkbox\"\n                      checked={topSelected.has(item.id)}\n                      onChange={(e) => toggleTop(item.id, e.target.checked)}\n                    />\n                    <span>{item.label}</span>\n                  </label>\n                </li>\n              ))}\n              {topItems.length === 0 && <li className=\"empty\">Empty</li>}\n            </ul>\n          </section>\n\n          <section className=\"controls\">\n            <button className=\"btn\" onClick={moveDown} disabled={!canMoveDown} aria-label=\"move down\">\n              ↓\n            </button>\n            <button className=\"btn\" onClick={moveUp} disabled={!canMoveUp} aria-label=\"move up\">\n              ↑\n            </button>\n          </section>\n\n          <section className=\"listCard\">\n            <div className=\"listTitle\">Bottom</div>\n            <ul className=\"list\" role=\"list\">\n              {bottomItems.map((item) => (\n                <li key={item.id} className=\"row\">\n                  <label className=\"rowLabel\">\n                    <input\n                      type=\"checkbox\"\n                      checked={bottomSelected.has(item.id)}\n                      onChange={(e) => toggleBottom(item.id, e.target.checked)}\n                    />\n                    <span>{item.label}</span>\n                  </label>\n                </li>\n              ))}\n              {bottomItems.length === 0 && <li className=\"empty\">Empty</li>}\n            </ul>\n          </section>\n        </div>\n\n        <p className=\"hint\">Tip: selections are per-list. Move clears selection of moved items.</p>\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Tracking selection by index instead of stable `id`.",
          "Mutating the same Set instance (React won't re-render). Always create a new Set.",
          "Forgetting to clear selection after transfer."
        ],
        "techniques": [
          "Using `Set` with functional `setState` updates.",
          "Splitting arrays into moved/remaining for readable transfer logic."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-transfer-list.v2.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-transfer-list"
    },
    "solutionAsset": "assets/sb/react/solution/react-transfer-list-solution.v2.json",
    "companies": [
      "meta"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build React Transfer List Component",
      "description": "Create a transfer list UI that moves selected items between two lists while preserving expected ordering and selection behavior."
    }
  },
  {
    "id": "react-tictactoe",
    "title": "Tic-Tac-Toe (Component State + Winner Detection)",
    "type": "coding",
    "technology": "react",
    "difficulty": "easy",
    "importance": 2,
    "tags": [
      "react",
      "state",
      "event-handlers",
      "conditional-rendering",
      "arrays",
      "control-flow"
    ],
    "description": {
      "summary": "Build Tic-Tac-Toe with React state: a 9-cell board, alternating turns, win/draw detection, and a reset button. Prevent overwriting a filled cell and stop play once the game is over. Show a clear status message for next player, winner, or draw. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render the Tic-Tac-Toe UI as the main component.",
          "Render a 3×3 board (9 cells).",
          "Alternate turns between 'X' and 'O'.",
          "Clicking an empty cell places the current player's mark (only if the game is not over).",
          "Detect a winner (3 in a row) and stop further moves.",
          "Detect a draw when the board is full and there is no winner.",
          "Show status text (next player / winner / draw).",
          "Include a 'Reset' button to restart the game."
        ],
        "expectedBehavior": [
          "Initial state shows an empty board and indicates 'Next: X'.",
          "Turns alternate X then O.",
          "Clicking a filled cell does nothing.",
          "After a win, status shows 'Winner: X' or 'Winner: O' and moves stop.",
          "After a draw, status shows 'Draw' and moves stop.",
          "Reset clears the board and sets next player to X."
        ],
        "implementationNotes": [
          "Model the board as an array of 9 values (`'X' | 'O' | null`).",
          "Use `useState` to store board, current player, and winner.",
          "Compute draw as `board.every(c => c !== null)` when there is no winner.",
          "Use a helper that checks the 8 winning line combinations."
        ],
        "techFocus": [
          "React useState",
          "Event handlers",
          "Rendering lists",
          "Derived state (winner/draw/status)",
          "Basic game logic"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Store the board as a 9-element array and track the current player. When a cell is clicked, ignore the action if the cell is already filled or the game is over. After each move, compute a winner from the 8 possible line combinations; if none and the board is full, declare a draw. Provide a reset to restore the initial state.",
      "approaches": [
        {
          "title": "Single component with board array + winner helper",
          "prose": "Implementation plan: keep `board`, `current`, and `winner` in state. Render 9 buttons with `map`. In the click handler, guard against filled cells or a winner, then set `board[i]` to the current mark and swap the player. After each move, run `calculateWinner(board)` to update `winner` or detect a draw. Show a status line and a reset button that clears the board and sets `current` back to 'X'.",
          "codeTsx": "import React, { useMemo, useState } from 'react';\nimport './App.css';\n\ntype Cell = 'X' | 'O' | null;\n\nconst EMPTY_BOARD: Cell[] = Array.from({ length: 9 }, () => null);\n\nfunction calculateWinner(b: Cell[]): 'X' | 'O' | null {\n  const lines: number[][] = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6]\n  ];\n\n  for (const [a, c, d] of lines) {\n    const v = b[a];\n    if (v && v === b[c] && v === b[d]) return v;\n  }\n  return null;\n}\n\nexport default function App() {\n  const [board, setBoard] = useState<Cell[]>(EMPTY_BOARD);\n  const [currentPlayer, setCurrentPlayer] = useState<'X' | 'O'>('X');\n  const [winner, setWinner] = useState<'X' | 'O' | null>(null);\n\n  const isDraw = useMemo(() => !winner && board.every((c) => c !== null), [board, winner]);\n  const isGameOver = !!winner || isDraw;\n\n  const status = useMemo(() => {\n    if (winner) return `Winner: ${winner}`;\n    if (isDraw) return 'Draw';\n    return `Next: ${currentPlayer}`;\n  }, [currentPlayer, isDraw, winner]);\n\n  const play = (i: number) => {\n    if (isGameOver) return;\n    if (board[i] !== null) return;\n\n    const next = board.slice();\n    next[i] = currentPlayer;\n    setBoard(next);\n\n    const w = calculateWinner(next);\n    if (w) {\n      setWinner(w);\n      return;\n    }\n\n    // if not over, switch player\n    if (!next.every((c) => c !== null)) {\n      setCurrentPlayer((p) => (p === 'X' ? 'O' : 'X'));\n    }\n  };\n\n  const reset = () => {\n    setBoard(Array.from({ length: 9 }, () => null));\n    setCurrentPlayer('X');\n    setWinner(null);\n  };\n\n  return (\n    <main className=\"page\">\n      <section className=\"card\">\n        <h1 className=\"title\">Tic-Tac-Toe</h1>\n        <p className=\"subtitle\">Two players take turns. First to 3 in a row wins.</p>\n\n        <div className=\"status\" aria-live=\"polite\">{status}</div>\n\n        <div className=\"board\" role=\"grid\" aria-label=\"tic tac toe board\">\n          {board.map((cell, i) => (\n            <button\n              key={i}\n              className=\"cell\"\n              type=\"button\"\n              onClick={() => play(i)}\n              disabled={isGameOver || cell !== null}\n              aria-label={`cell ${i}`}\n            >\n              {cell ?? ''}\n            </button>\n          ))}\n        </div>\n\n        <div className=\"actions\">\n          <button className=\"ghost\" type=\"button\" onClick={reset}>\n            Reset\n          </button>\n        </div>\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing overwriting a filled cell.",
          "Allowing moves after winner/draw.",
          "Missing diagonal win checks.",
          "Mutating the board array in place."
        ],
        "techniques": [
          "Use a fixed list of winning index triples.",
          "Keep draw/game-over as derived state.",
          "Use functional updates for player toggling."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-tictactoe.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-tictactoe"
    },
    "solutionAsset": "assets/sb/react/solution/react-tictactoe-solution.v1.json",
    "companies": [
      "amazon"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Tic Tac Toe Game in React",
      "description": "Create a tic tac toe game that tracks turns, detects wins or draws, blocks invalid moves, and supports restart."
    }
  },
  {
    "id": "react-use-effect-once",
    "title": "useEffectOnce: Run an Effect Only Once",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "react",
      "hooks",
      "effects",
      "lifecycle",
      "components"
    ],
    "description": {
      "summary": "This hook should run the effect only on mount and clean up on unmount, even under React StrictMode development behavior. Concepts: react, hooks, effects, lifecycle, components. Mention StrictMode double-invocation, cleanup idempotency, and tests for unexpected reruns or stale closures.",
      "specs": {
        "requirements": [
          "Implement `useEffectOnce(effect)` in `useEffectOnce.ts`.",
          "The effect callback must run only once for the lifetime of a mounted component.",
          "If `effect` returns a cleanup function, it must run exactly once on unmount.",
          "The hook should be safe under React 18 StrictMode (dev): no duplicate real side-effects after the initial mount."
        ],
        "expectedBehavior": [
          "Mounting the demo triggers the effect exactly once (count increments from 0 to 1).",
          "Re-rendering the component does NOT re-run the effect.",
          "Unmounting runs cleanup exactly once (count increments by 100 in the demo)."
        ],
        "implementationNotes": [
          "Use `useEffect` internally.",
          "Use `useRef` to persist flags/cleanup between renders.",
          "Avoid `useMemo` for running effects. Effects belong in `useEffect`.",
          "Do not require callers to pass dependency arrays."
        ],
        "techFocus": [
          "React hooks",
          "Effect lifecycle (mount/unmount)",
          "StrictMode considerations",
          "useRef for stable mutable state"
        ]
      }
    },
    "solutionBlock": {
      "overview": "StrictMode can double-invoke effects in development, so the hook needs a ref guard to prevent accidental double side-effects while still allowing cleanup to run once. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "useEffect + useRef guard",
          "prose": "Store a didRun ref and a cleanup ref. If didRun is true, return early. Otherwise, run the effect, store cleanup, and return a cleanup function that runs the stored cleanup once. This keeps behavior deterministic across dev and prod. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Running side effects in render (or useMemo) instead of useEffect.",
          "Not handling cleanup correctly (cleanup called multiple times).",
          "Not accounting for React 18 StrictMode double-invoke in dev."
        ],
        "techniques": [
          "Persisting execution state using useRef.",
          "Storing cleanup in a ref to call it once."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-use-effect-once.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:react:react-use-effect-once"
    },
    "solutionAsset": "assets/sb/react/solution/react-use-effect-once-solution.v1.json",
    "companies": [
      "netflix"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Create useEffectOnce Hook in React",
      "description": "Build a custom hook for one-time effect behavior with clear cleanup handling and predictable lifecycle semantics."
    }
  },
  {
    "id": "react-like-button",
    "title": "React Like Button (Toggle + Counter)",
    "type": "coding",
    "technology": "react",
    "difficulty": "easy",
    "importance": 2,
    "tags": [
      "react",
      "state",
      "event-handlers",
      "components",
      "conditional-rendering"
    ],
    "description": {
      "summary": "Build a React Like button that toggles between liked/unliked and updates a count. Clicking should add or subtract one based on current state, and the counter must never drop below zero. This checks controlled state, event handling, and safe updates. Concepts: react, state, event handlers, components, conditional rendering. React focus: keep liked/count in state and guard against negative values. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a Like button and a like counter.",
          "Clicking toggles between 'Like' and 'Liked'.",
          "When toggling to liked: increment the counter by 1.",
          "When toggling to unliked: decrement the counter by 1.",
          "The counter must never go below 0.",
          "Update button styling based on liked state."
        ],
        "expectedBehavior": [
          "Initial state: not liked, counter shows an initial value (e.g., 120).",
          "Clicking the button toggles the label and active style.",
          "Counter updates by +1 / -1 depending on toggle direction.",
          "If the counter is 0, unliking should not make it negative."
        ],
        "implementationNotes": [
          "Use `useState` for `liked` and `count`.",
          "Implement `toggleLike()` with a guarded update (never below 0).",
          "Keep everything in a single `App.tsx` for this exercise."
        ],
        "techFocus": [
          "React useState",
          "Event handlers",
          "Derived UI from state",
          "Guarded updates"
        ]
      }
    },
    "starterCodeHint": "Implement `toggleLike()` and update both `liked` and `count`. Ensure the count never drops below 0.",
    "solutionBlock": {
      "overview": "Model two pieces of state: whether the item is liked and the current count. On click, flip the liked flag and update the count accordingly. Use functional state updates so the logic is resilient to React batching, and clamp the count at zero to avoid negative values. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "Single component with guarded toggle",
          "prose": "Use `useState` for `liked` (boolean) and `count` (number). In the click handler, update both via functional setters: `setLiked(prev => !prev)` and `setCount(prev => prev + (liked ? -1 : 1))`. If unliking would go negative, clamp with `Math.max(0, prev - 1)`. Render the button text based on `liked` and display the count next to it. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Updating count based on stale state instead of functional updates.",
          "Allowing count to go negative when unliking from 0.",
          "Deriving UI (label/style) from separate variables that can get out of sync."
        ],
        "techniques": [
          "Functional state updates with `setState((prev) => ...)`",
          "Conditional className based on state"
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-like-button.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-like-button"
    },
    "solutionAsset": "assets/sb/react/solution/react-like-button-solution.v2.json",
    "companies": [
      "amazon"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build React Like Button with Counter",
      "description": "Create a like button that toggles state and updates count while keeping labels and totals consistent with user actions."
    }
  },
  {
    "id": "react-progress-bar-thresholds",
    "title": "React Progress Bar (0–100 with Threshold Colors)",
    "type": "coding",
    "technology": "react",
    "difficulty": "easy",
    "importance": 2,
    "tags": [
      "react",
      "state",
      "event-handlers",
      "components",
      "styling"
    ],
    "description": {
      "summary": "Build a React progress bar for values 0–100 with +10%/−10% controls. Clamp progress to the valid range and change the bar color by thresholds (e.g., red &lt;34, orange 34–66, green &gt;66). Show the numeric percentage and keep the UI in sync with state. React focus: derive classes from state and clamp values before render. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render the progress bar UI as the main component.",
          "Display the current progress percentage (e.g., \"40%\").",
          "Provide \"-10%\" and \"+10%\" buttons to decrease/increase progress by 10.",
          "Clamp progress so it never goes below 0 or above 100.",
          "Change the bar color based on thresholds (red/orange/green)."
        ],
        "expectedBehavior": [
          "Initial progress starts at 0%.",
          "Clicking \"+10%\" increases progress by 10 up to 100.",
          "Clicking \"-10%\" decreases progress by 10 down to 0.",
          "Progress never renders below 0% or above 100%.",
          "Bar color changes by thresholds (example: <34 red, 34–66 orange, >66 green)."
        ],
        "implementationNotes": [
          "Use React state (`useState`) to store progress.",
          "Implement handlers `inc()` and `dec()` that clamp with `Math.min` / `Math.max`.",
          "Derive a className for the fill element based on thresholds.",
          "UI should match the Angular version: title + subtitle + value + track/fill + two buttons + hint."
        ],
        "techFocus": [
          "React useState",
          "Event handlers",
          "Clamped updates",
          "Derived UI state (threshold class)",
          "Basic styling"
        ]
      }
    },
    "starterCodeHint": "Keep `progress` in `useState(0)`. Implement `inc/dec` with functional updates and clamping. Compute `barClass` from progress (<34 red, 34–66 orange, >66 green) and bind width via `style={{ width: progress + '%' }}`.",
    "solutionBlock": {
      "overview": "Use a single `progress` state value and derive the UI from it: the fill width is `progress%`, the text shows the percentage, and the color class is computed from threshold rules. Button handlers should use `Math.min/Math.max` to clamp the value so it never leaves [0, 100].",
      "approaches": [
        {
          "title": "Single component with clamped progress and threshold class",
          "prose": "Store `progress` with `useState(0)`. Implement `inc()` and `dec()` as functional updates that clamp at 0 and 100. Derive `colorClass` based on the thresholds (for example: <34 red, 34–66 orange, >66 green). Render a track + fill where the fill width is `progress + '%'` and the class controls the color. This keeps all display logic derived from a single source of truth."
        }
      ],
      "notes": {
        "pitfalls": [
          "Not clamping updates (value can go negative or above 100).",
          "Deriving UI color in multiple places instead of one derived variable.",
          "Using non-functional `setState` updates when multiple clicks can batch (prefer functional updater)."
        ],
        "techniques": [
          "Functional state updates to avoid stale reads.",
          "Clamping with Math.min/Math.max.",
          "Derived className for threshold-based styling."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-progress-bar-thresholds.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-progress-bar-thresholds"
    },
    "solutionAsset": "assets/sb/react/solution/react-progress-bar-thresholds-solution.v1.json",
    "companies": [],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build React Progress Bar with Threshold Colors",
      "description": "Create a progress bar that updates from user actions, enforces valid range limits, and changes visual style by value thresholds."
    }
  },
  {
    "id": "react-nested-comments",
    "title": "React Nested Comments (Infinite Replies, Single Active Reply Input)",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "react",
      "state",
      "recursion",
      "tree",
      "event-handlers",
      "controlled-inputs"
    ],
    "description": {
      "summary": "Build a React nested comments panel with infinite replies. Users can add top-level comments and reply to any comment, creating an infinitely deep tree. Clicking Reply should open an input ONLY under that comment (single active reply box). Render nested replies with indentation. React focus: render recursive components and keep a single active reply id. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render a nested comments UI as the main screen.",
          "Allow adding top-level comments via a textarea + 'Add Comment' button.",
          "Each comment has a 'Reply' button.",
          "Clicking 'Reply' opens a reply input ONLY under that comment (single active reply at a time).",
          "Allow infinite depth replies (nested tree).",
          "Render replies hierarchically with indentation."
        ],
        "expectedBehavior": [
          "Top-level 'Add Comment' adds a new comment to the list.",
          "Clicking 'Reply' under a comment shows a reply input under that comment and hides any other open reply input.",
          "Posting a reply adds it as a child of the correct parent comment.",
          "Cancel closes the reply input without changes.",
          "Replies can be nested infinitely and indentation increases with depth."
        ],
        "implementationNotes": [
          "Use React state for the comment tree.",
          "Keep a single `activeReplyId` + `replyDraft` to ensure only one reply input exists.",
          "Use recursive rendering to display nested comments.",
          "IDs can be simple incrementing strings."
        ],
        "techFocus": [
          "Tree data structures in UI",
          "Recursive rendering",
          "Single active input state",
          "Controlled inputs and event handlers"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Maintain a comment tree in state. Add top-level comments by unshifting a new node into the root array. For replies, track `activeReplyId` and `replyDraft` so only one reply input is visible. When submitting a reply, find the parent node by id (DFS) and push a new child into `children`. Render the tree recursively and indent each node by `depth * 16`.",
      "approaches": [
        {
          "title": "Single component + recursive renderer + single active reply state",
          "prose": "1) Store comments in a `CommentNode[]` state.\n2) Store `activeReplyId` + `replyDraft` as UI state.\n3) Implement `addTop`, `openReply`, `cancelReply`, `submitReply`.\n4) Implement `findById` DFS to locate a node.\n5) Render a recursive `Tree` component that maps nodes and renders children with increased depth.\n\nImportant: ensure text colors are explicitly set so headings and comment text are readable on the dark background."
        }
      ],
      "notes": {
        "pitfalls": [
          "Opening multiple reply inputs (having per-node local reply state).",
          "Mutating state incorrectly when adding replies (losing children references).",
          "Forgetting to apply readable text colors; default styles may render text too dark on dark backgrounds."
        ],
        "techniques": [
          "DFS search in a tree (`findById`).",
          "Single active reply input via `activeReplyId`.",
          "Recursive React component for tree rendering."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-nested-comments.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v1:ui:react:react-nested-comments"
    },
    "solutionAsset": "assets/sb/react/solution/react-nested-comments-solution.v1.json",
    "companies": [
      "google"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Nested Comments UI in React",
      "description": "Create a nested comments interface that supports replying at any level and renders thread hierarchy correctly."
    }
  },
  {
    "id": "react-dynamic-counter-buttons",
    "title": "React Dynamic Counter Buttons (Grow-on-Click)",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 2,
    "tags": [
      "react",
      "state",
      "arrays",
      "event-handlers",
      "dynamic-ui"
    ],
    "description": {
      "summary": "In React, let users add or remove step buttons dynamically, and have each button update the counter by its own step value. Use state arrays and event handlers to keep the UI in sync. Concepts: react, state, arrays, event handlers, dynamic ui. React focus: store step buttons in state arrays and update immutably. Framework focus: React hooks (useState/useEffect), JSX event handling, and one-way props/state flow.",
      "specs": {
        "requirements": [
          "Render the dynamic counter buttons UI as the main screen.",
          "Initially render exactly 1 counter button with value 0.",
          "Clicking any button increments ONLY that button’s value by 1.",
          "After each click, append a NEW button at the bottom with value 0.",
          "All buttons keep their own values independently."
        ],
        "expectedBehavior": [
          "Initial UI: one button showing 0.",
          "Click first button once → first becomes 1, and a second button (0) appears below.",
          "Click second button twice → second becomes 2, and two more new buttons (0, 0) are appended over those clicks.",
          "Existing button values never reset when new buttons appear."
        ],
        "implementationNotes": [
          "Use React state with an array like `counts: number[]`.",
          "Render buttons with `counts.map(...)`.",
          "On click: increment the clicked index and append 0.",
          "Keep styling consistent with the dark UI theme (explicit readable text colors)."
        ],
        "techFocus": [
          "React useState with arrays",
          "Rendering lists",
          "Updating array state",
          "Event handlers with indices"
        ]
      }
    },
    "solutionBlock": {
      "overview": "This combines list state and counter state. Keep step values in an array, render them with map, and update the count with functional state updates. The UI should reflect edits immediately. Performance & pitfalls: consider edge cases (empty state, rapid clicks), trade-offs in state shape, and accessibility of interactive controls.",
      "approaches": [
        {
          "title": "Single component with counts[] array",
          "prose": "Use controlled inputs for new steps and append them immutably to the steps list. Render buttons from the list and update count with setCount(c => c + step). Optionally allow negative steps for decrement buttons and validate input. Edge cases & testing: cover invalid inputs, ensure predictable reactivity, and keep the UI stable under rapid updates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating state directly (e.g. `counts[i]++` without cloning) causing stale renders.",
          "Incrementing all buttons instead of just the clicked one.",
          "Missing explicit text colors on dark backgrounds (unreadable buttons)."
        ],
        "techniques": [
          "Immutable array updates via cloning",
          "Index-based updates",
          "List rendering with stable keys"
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-dynamic-counter-buttons.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v1:ui:react:react-dynamic-counter-buttons"
    },
    "solutionAsset": "assets/sb/react/solution/react-dynamic-counter-buttons-solution.v1.json",
    "companies": [
      "amazon"
    ],
    "access": "premium",
    "updatedAt": "2026-01-30",
    "seo": {
      "title": "Build Dynamic Counter Buttons in React",
      "description": "Create a counter interface with configurable step buttons that can be added or removed and still update shared state correctly."
    }
  },
  {
    "id": "react-debug-double-render",
    "title": "Debug: Component Renders Twice on Every Update",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "tags": [
      "react",
      "debugging",
      "rendering",
      "state",
      "effects"
    ],
    "description": {
      "summary": "Fix a component that renders twice per click because it stores derived state in `useEffect`. The correct fix is to remove the derived `parity` state and compute it directly from `count` during render, preventing the extra state update and render. Explain StrictMode double-invocation, idempotent effects, and testing for unintended side effects; use profiling for performance.",
      "specs": {
        "requirements": [
          "Work in `src/App.tsx`.",
          "Keep the UI structure and existing styles.",
          "Clicking \"Increment\" should increase the count by 1.",
          "The parity label must remain correct (even/odd).",
          "A single click should result in only one additional render (render count increases by 1)."
        ],
        "expectedBehavior": [
          "Count increases by 1 when Increment is clicked.",
          "Parity updates correctly to \"even\" or \"odd\".",
          "Render count increases by 1 per click (not 2).",
          "Reset returns the counter to 0 and parity to even."
        ],
        "implementationNotes": [
          "Avoid syncing derived state with `useEffect`.",
          "Compute derived values directly from state (or memoize) instead of storing them in state.",
          "StrictMode can double-invoke renders in development; the real fix is removing redundant updates."
        ],
        "techFocus": [
          "React state and derived values",
          "useEffect debugging",
          "Render behavior and performance"
        ]
      }
    },
    "solutionBlock": {
      "overview": "The double render happens because `count` updates, then `useEffect` runs and sets `parity`, which triggers another render. Derived values should be computed from source state during render (or via `useMemo` if expensive), not stored as separate state. Removing the effect eliminates the redundant render.",
      "approaches": [
        {
          "title": "Derive parity from count",
          "prose": "Remove the `parity` state and the `useEffect` that updates it. Compute `const parity = count % 2 === 0 ? 'even' : 'odd'` inside the component render and display it. This keeps a single source of truth (`count`) and prevents the extra state update that was causing double renders.",
          "codeJs": "import React, { useRef, useState } from 'react';\nimport './App.css';\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n  const parity = count % 2 === 0 ? 'even' : 'odd';\n\n  const renders = useRef(0);\n  renders.current += 1;\n\n  const increment = () => setCount((c) => c + 1);\n  const reset = () => setCount(0);\n\n  return (\n    <main className=\"page\">\n      <section className=\"card\">\n        <h1 className=\"title\">Debug Double Render</h1>\n        <p className=\"subtitle\">Fix the component so each click causes only one render.</p>\n\n        <div className=\"stats\">\n          <div className=\"stat\"><div className=\"k\">Count</div><div className=\"v\">{count}</div></div>\n          <div className=\"stat\"><div className=\"k\">Parity</div><div className=\"v\">{parity}</div></div>\n          <div className=\"stat\"><div className=\"k\">Renders</div><div className=\"v\">{renders.current}</div></div>\n        </div>\n\n        <div className=\"actions\">\n          <button className=\"btn\" onClick={increment}>Increment</button>\n          <button className=\"btn ghost\" onClick={reset}>Reset</button>\n        </div>\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Keeping derived state in sync with an effect.",
          "Calling `setState` twice for the same user action.",
          "Chasing dev-only StrictMode behavior instead of fixing the real update."
        ],
        "techniques": [
          "Derive values from state instead of duplicating state.",
          "Keep effects for side effects only.",
          "Use functional updates for counters."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-debug-double-render.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v2:ui:react:react-debug-double-render"
    },
    "solutionAsset": "assets/sb/react/solution/react-debug-double-render-solution.v1.json",
    "companies": [
      "netflix",
      "openai"
    ],
    "access": "premium",
    "updatedAt": "2026-01-31",
    "seo": {
      "title": "Fix Double Render State Issue in React",
      "description": "Given a component with duplicate renders, refactor state handling so output stays consistent without unnecessary render cycles."
    }
  },
  {
    "id": "react-chat-streaming-ui",
    "title": "Chat UI with Streaming Response",
    "type": "coding",
    "technology": "react",
    "difficulty": "hard",
    "importance": 4,
    "tags": [
      "react",
      "state",
      "effects",
      "async",
      "real-time",
      "streams",
      "api-calls",
      "ux"
    ],
    "description": {
      "summary": "Build a simplified ChatGPT-like interface that streams an assistant response token-by-token. The goal is to model chat state, append streaming chunks efficiently, and keep the UI responsive with clear loading/cancel states.",
      "specs": {
        "requirements": [
          "Render a chat layout with a scrollable message list, an input, and a Send button.",
          "On submit, append the user message immediately and clear the input.",
          "Append an assistant message placeholder and stream chunks into it over time.",
          "Disable Send while streaming and show a streaming indicator.",
          "Provide a Stop button to cancel the stream and keep the partial response."
        ],
        "expectedBehavior": [
          "User messages appear instantly after submit.",
          "Assistant messages grow incrementally as chunks arrive.",
          "Send is disabled while streaming and re-enabled when the stream finishes or is stopped.",
          "Stopping the stream halts further updates and leaves the partial text visible.",
          "Clearing the input does not affect existing messages."
        ],
        "implementationNotes": [
          "Store messages as an array of { id, role, text, status } objects.",
          "Use a helper to simulate streaming with setInterval; return a cancel function.",
          "Append chunks using a functional state update to avoid stale closures.",
          "Keep a ref to the active stream so it can be cancelled on stop or unmount."
        ],
        "techFocus": [
          "React state management",
          "Streaming updates with effects/refs",
          "Functional state updates",
          "Async UI states (loading/cancel)"
        ]
      }
    },
    "solutionBlock": {
      "overview": "Use a messages array as the single source of truth. On send, add a user message and an assistant placeholder. Start a fake stream that appends chunks into the assistant message by id, and clean up the interval when the stream ends or is cancelled.",
      "approaches": [
        {
          "title": "Single component with streaming helper",
          "prose": "Keep all chat state in the App component. Use a ref for the active stream cancel function and another ref for the active assistant message id. On submit, append two messages, then start streaming chunks into the assistant message with functional setState. Provide a Stop button that cancels the stream and clears the streaming flag.",
          "codeJs": "import React from 'react';\nimport './App.css';\n\nconst SAMPLE_RESPONSE = \"Sure! Here's a short streaming reply. It arrives token by token so the UI feels responsive.\";\n\nfunction startFakeStream(text, onChunk, onDone) {\n  const tokens = text.split(' ');\n  let i = 0;\n  const id = window.setInterval(() => {\n    const chunk = tokens[i] + (i < tokens.length - 1 ? ' ' : '');\n    onChunk(chunk);\n    i += 1;\n    if (i >= tokens.length) {\n      window.clearInterval(id);\n      onDone();\n    }\n  }, 120);\n  return () => window.clearInterval(id);\n}\n\nexport default function App() {\n  const [messages, setMessages] = React.useState([]);\n  const [input, setInput] = React.useState('');\n  const [isStreaming, setIsStreaming] = React.useState(false);\n\n  const cancelRef = React.useRef(null);\n  const streamIdRef = React.useRef(null);\n  const idRef = React.useRef(0);\n\n  const nextId = () => `m_${idRef.current++}`;\n\n  React.useEffect(() => {\n    return () => {\n      if (cancelRef.current) cancelRef.current();\n    };\n  }, []);\n\n  const stopStream = () => {\n    if (cancelRef.current) {\n      cancelRef.current();\n      cancelRef.current = null;\n    }\n    if (streamIdRef.current) {\n      const id = streamIdRef.current;\n      streamIdRef.current = null;\n      setMessages((prev) => prev.map((m) => (m.id === id ? { ...m, status: 'stopped' } : m)));\n    }\n    setIsStreaming(false);\n  };\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    const trimmed = input.trim();\n    if (!trimmed || isStreaming) return;\n\n    const userId = nextId();\n    const assistantId = nextId();\n\n    setMessages((prev) => [\n      ...prev,\n      { id: userId, role: 'user', text: trimmed, status: 'done' },\n      { id: assistantId, role: 'assistant', text: '', status: 'streaming' }\n    ]);\n\n    setInput('');\n    setIsStreaming(true);\n    streamIdRef.current = assistantId;\n\n    cancelRef.current = startFakeStream(\n      SAMPLE_RESPONSE,\n      (chunk) => {\n        setMessages((prev) =>\n          prev.map((m) => (m.id === assistantId ? { ...m, text: m.text + chunk } : m))\n        );\n      },\n      () => {\n        cancelRef.current = null;\n        streamIdRef.current = null;\n        setIsStreaming(false);\n        setMessages((prev) =>\n          prev.map((m) => (m.id === assistantId ? { ...m, status: 'done' } : m))\n        );\n      }\n    );\n  };\n\n  return (\n    <main className=\"chat-shell\">\n      <section className=\"chat-card\">\n        <header className=\"chat-header\">\n          <h1>Chat UI</h1>\n          <p className=\"subtitle\">Streaming assistant responses.</p>\n        </header>\n\n        <ul className=\"chat-list\" aria-live=\"polite\">\n          {messages.map((m) => (\n            <li key={m.id} className={`message message--${m.role}`}>\n              <div className=\"message-role\">{m.role === 'user' ? 'You' : 'Assistant'}</div>\n              <div className=\"message-bubble\">\n                {m.text || (m.status === 'streaming' ? '...' : '')}\n              </div>\n            </li>\n          ))}\n          {messages.length === 0 && (\n            <li className=\"empty\">Start a conversation.</li>\n          )}\n        </ul>\n\n        <form className=\"chat-input\" onSubmit={handleSubmit}>\n          <input\n            type=\"text\"\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            placeholder=\"Ask something...\"\n            disabled={isStreaming}\n          />\n          <button type=\"submit\" disabled={isStreaming || !input.trim()}>\n            Send\n          </button>\n          {isStreaming && (\n            <button type=\"button\" className=\"ghost\" onClick={stopStream}>\n              Stop\n            </button>\n          )}\n        </form>\n      </section>\n    </main>\n  );\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Mutating the messages array instead of creating a new one.",
          "Appending chunks with stale state (avoid by using functional updates).",
          "Forgetting to clear the interval on unmount or stop.",
          "Allowing multiple overlapping streams without cancellation."
        ],
        "techniques": [
          "Functional setState for incremental updates.",
          "useRef to store cancel handlers and streaming ids.",
          "Derive UI state (streaming indicator) from a single boolean flag."
        ]
      }
    },
    "companies": [
      "openai"
    ],
    "access": "premium",
    "updatedAt": "2026-01-31",
    "seo": {
      "title": "Build Streaming Chat UI in React",
      "description": "Create a chat interface that displays assistant responses incrementally and supports loading, canceling, and message state updates."
    }
  },
  {
    "id": "react-chips-input-autocomplete",
    "title": "Invite Chips Input (Tags + Autocomplete)",
    "type": "coding",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "tags": [
      "react",
      "state",
      "event-handlers",
      "autocomplete",
      "forms",
      "accessibility",
      "keyboard",
      "ui-components"
    ],
    "description": {
      "summary": "Build a Material-like invite field in React. As users type, show autocomplete suggestions, convert selections into removable chips, and support keyboard shortcuts (Enter/comma/backspace).",
      "specs": {
        "requirements": [
          "Render an input that creates chips below/inside the field.",
          "Show autocomplete suggestions filtered from a fixed users list.",
          "Exclude already-selected users from suggestions.",
          "Clicking a suggestion creates a chip and clears the input.",
          "Pressing Enter or comma creates/selects a chip.",
          "Backspace on empty input removes the last chip.",
          "Each chip has a remove button that updates state correctly.",
          "Support ArrowUp/ArrowDown + Enter keyboard navigation in the suggestion list."
        ],
        "expectedBehavior": [
          "Typing \"al\" surfaces matching user suggestions (name or email).",
          "Selecting \"Alice\" adds one chip and it no longer appears in suggestions.",
          "Typing custom text and pressing comma adds a custom chip.",
          "Pressing Enter with an active suggestion selects that suggestion.",
          "Pressing Enter/comma with no active suggestion adds a custom chip.",
          "Pressing backspace on empty input removes the most recently added chip."
        ],
        "implementationNotes": [
          "Represent selected chips as an array of { id, label, value }.",
          "Use a normalized id for custom chips (e.g. custom-<slug>).",
          "Prevent duplicates by id or case-insensitive value match.",
          "Use onMouseDown for suggestion click to avoid blur race conditions.",
          "Keep combobox/listbox/option roles and active-descendant wiring for accessibility."
        ],
        "techFocus": [
          "React hooks (useState/useMemo/useRef/useEffect)",
          "Keyboard interaction state",
          "Derived suggestion filtering",
          "Accessible combobox patterns"
        ]
      }
    },
    "starterCodeHint": "Implement TODOs in App.tsx: derive suggestions, wire keyboard behavior (arrow/enter/comma/backspace), prevent duplicates, and support suggestion selection + custom chips.",
    "solutionBlock": {
      "overview": "Keep `chips`, `query`, `isOpen`, and `activeIndex` in state. Derive suggestions from query + selected chips. Handle Enter/comma for add/select, Arrow keys for navigation, Backspace for last-chip delete, and outside click for dropdown close.",
      "approaches": [
        {
          "title": "Single component with derived suggestions and keyboard UX",
          "prose": "Use `useMemo` to filter a static dataset by query while excluding already selected chips. Add a helper that inserts chips only when unique. In `onKeyDown`, map ArrowUp/ArrowDown to active option movement, Enter/comma to select/create, and Backspace (when input empty) to remove the last chip. Use a root ref + document mousedown listener to close the dropdown outside clicks."
        }
      ],
      "notes": {
        "pitfalls": [
          "Using onClick instead of onMouseDown on suggestions can lose selection because blur runs first.",
          "Not normalizing text for duplicate checks leads to repeated chips with casing differences.",
          "Not resetting activeIndex when query changes causes stale keyboard focus."
        ],
        "techniques": [
          "Derived data with useMemo for suggestions.",
          "Stable keyboard interaction with activeIndex state.",
          "Case-insensitive de-duplication by id/value."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-chips-input-autocomplete.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v1:ui:react:react-chips-input-autocomplete"
    },
    "solutionAsset": "assets/sb/react/solution/react-chips-input-autocomplete-solution.v1.json",
    "companies": [
      "amazon",
      "airbnb"
    ],
    "access": "premium",
    "updatedAt": "2026-02-09",
    "seo": {
      "title": "Build React Chips Input with Autocomplete",
      "description": "Create an input that lets users add and remove chips, shows matching suggestions, and handles keyboard interaction states."
    }
  },
  {
    "id": "react-chessboard-click-highlight",
    "title": "React Chessboard Click/Highlight (N×N Board)",
    "type": "coding",
    "technology": "react",
    "difficulty": "easy",
    "importance": 2,
    "tags": [
      "react",
      "state",
      "event-handlers",
      "grid",
      "components",
      "dom"
    ],
    "description": {
      "summary": "Build an interactive N×N chessboard in React. Clicking a cell should highlight it and clear the previous selection. Include a size control so users can switch board dimensions.",
      "specs": {
        "requirements": [
          "Render an N×N chessboard where light/dark squares alternate correctly.",
          "Allow changing N via a numeric input (for example 2..20).",
          "Clicking a square highlights that square.",
          "Only one square can stay highlighted at a time.",
          "Changing board size re-renders the board and resets selection safely.",
          "Expose selected cell coordinates in the UI (row/column).",
          "Keep keyboard accessibility with semantic button/grid roles."
        ],
        "expectedBehavior": [
          "Initial render shows an 8×8 board with no selected square.",
          "Clicking row 3 column 5 highlights that square and updates status text.",
          "Clicking a different square removes previous highlight and applies new one.",
          "Entering N=4 re-renders as a 4×4 board and clears previous selection.",
          "Board never renders below min or above max size."
        ],
        "implementationNotes": [
          "Store board size in state and clamp updates inside input handler.",
          "Store selected square as a stable key like `row-col`.",
          "Compute checker pattern with `(row + col) % 2`.",
          "Use CSS classes for light/dark/active state and avoid inline color toggles."
        ],
        "techFocus": [
          "React hooks (useState/useMemo)",
          "Derived grid rendering",
          "Event handling for board interaction",
          "Accessible interactive UI"
        ]
      }
    },
    "starterCodeHint": "Implement TODOs in App.tsx: clamp board size, keep one active square, and keep selected coordinate text in sync.",
    "solutionBlock": {
      "overview": "Keep `size` and `selectedKey` in state. Render rows/columns from size, compute light/dark classes with parity, and set the selected key on click so only one square is active.",
      "approaches": [
        {
          "title": "State-driven board rendering with a selected-cell key",
          "prose": "Use one state variable for board size and one for selected cell (`row-col`). Map row/column indices to render buttons. Apply active style based on key equality. Clamp size changes to a safe range and clear selection on resize to avoid stale coordinates."
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to clear selection after size change can reference out-of-range cells.",
          "Using array index alone for keys in nested loops can create unstable highlight behavior.",
          "Inline style branching can make active/dark/light states harder to maintain than CSS classes."
        ],
        "techniques": [
          "Deterministic cell keys (`row-col`).",
          "Parity-based checker pattern: `(row + col) % 2`.",
          "Input clamping for predictable board constraints."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-chessboard-click-highlight.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v1:ui:react:react-chessboard-click-highlight"
    },
    "solutionAsset": "assets/sb/react/solution/react-chessboard-click-highlight-solution.v1.json",
    "companies": [
      "amazon",
      "microsoft"
    ],
    "access": "premium",
    "updatedAt": "2026-02-09",
    "seo": {
      "title": "Build Interactive N x N Chessboard in React",
      "description": "Create an n by n chessboard UI where selecting a cell updates highlight state and supports board-size changes."
    }
  },
  {
    "id": "react-snake-game",
    "title": "React Snake Game (Grid + Food + Collision)",
    "type": "coding",
    "technology": "react",
    "difficulty": "hard",
    "importance": 3,
    "tags": [
      "react",
      "state",
      "timers",
      "event-handlers",
      "components",
      "grid"
    ],
    "description": {
      "summary": "Build a Snake game in React using a grid board. Support keyboard controls, food spawning, score updates, and game-over handling for wall/body collisions.",
      "specs": {
        "requirements": [
          "Render a fixed-size board (for example 14×14) with snake body and food cells.",
          "Move the snake using Arrow keys (optionally WASD).",
          "Run game ticks on an interval while the game is running.",
          "Eating food should grow the snake and increment score.",
          "Colliding with walls or snake body should end the game.",
          "Provide Start/Pause and Reset controls.",
          "Expose score and current snake length in the UI.",
          "Keep keyboard interactions stable (no reverse-direction bug)."
        ],
        "expectedBehavior": [
          "Initial state shows a short snake, one food cell, and score 0.",
          "Press Start to begin movement; snake advances one cell per tick.",
          "When head reaches food, score increases and snake length grows by 1.",
          "Pressing opposite direction immediately should be ignored for safety.",
          "Hitting boundary or own body stops the game and shows game-over state.",
          "Reset returns to initial state with a new food position."
        ],
        "implementationNotes": [
          "Store snake as ordered coordinates, with index 0 as the head.",
          "Track both current direction and pending direction to avoid race conditions.",
          "Use Set/string keys for fast cell occupancy checks.",
          "Generate food only on free cells that are not occupied by snake.",
          "Clear interval correctly on pause, game over, and unmount."
        ],
        "techFocus": [
          "React hooks (useState/useEffect/useMemo)",
          "Interval lifecycle management",
          "Keyboard event handling",
          "Immutable state updates for moving/growing arrays"
        ]
      }
    },
    "starterCodeHint": "Implement TODOs in App.tsx: keyboard direction updates, game loop movement, collision checks, food growth, and reset flow.",
    "solutionBlock": {
      "overview": "Keep snake coordinates, direction, pendingDirection, food, score, and run state in React state. Tick with setInterval, prepend next head, and pop tail unless food is eaten. End the game on wall/body collision.",
      "approaches": [
        {
          "title": "Single-component game loop with immutable snake updates",
          "prose": "On each tick, compute next head from current direction. Validate collisions before mutating state. If food is eaten, keep the tail (grow) and spawn new food on a free cell. Otherwise remove tail for standard movement. Use keyboard handlers to map arrows/WASD and ignore immediate reverse direction."
        }
      ],
      "notes": {
        "pitfalls": [
          "Allowing immediate reverse direction can cause instant self-collision artifacts.",
          "Forgetting interval cleanup leads to duplicate timers and speed glitches.",
          "Spawning food without excluding snake cells can make unreachable food."
        ],
        "techniques": [
          "Occupancy keys like `x,y` for constant-time lookups.",
          "Pending direction buffer to avoid same-tick race conditions.",
          "Deterministic state transitions inside interval callback."
        ]
      }
    },
    "sdk": {
      "asset": "assets/sb/react/question/react-snake-game.v1.json",
      "openFile": "/src/App.tsx",
      "storageKey": "v1:ui:react:react-snake-game"
    },
    "solutionAsset": "assets/sb/react/solution/react-snake-game-solution.v1.json",
    "companies": [
      "amazon",
      "microsoft"
    ],
    "access": "premium",
    "updatedAt": "2026-02-09",
    "seo": {
      "title": "Build Snake Game in React",
      "description": "Create a snake game interface with movement, food collection, scoring, and clear game-over behavior for collisions."
    }
  }
]
