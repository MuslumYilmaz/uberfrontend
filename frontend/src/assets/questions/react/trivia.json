[
  {
    "id": "react-core-problem-and-non-goals",
    "title": "What core problem does React solve, and what does it deliberately NOT solve?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what React is responsible for (the UI layer: rendering + keeping UI in sync with state) and what it intentionally leaves to other tools (routing, data fetching, global state architecture, build tooling, etc.).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React solves one main problem: <em>reliably keeping the UI in sync with changing data</em> (state/props/context) without manually mutating the DOM. It gives you a component model + a declarative rendering system so you describe <em>what the UI should look like</em>, and React figures out <em>how to update</em> the DOM efficiently."
        },
        {
          "type": "list",
          "columns": [
            "Problem in UI apps",
            "What React provides",
            "Why it matters"
          ],
          "rows": [
            [
              "Manual DOM updates become complex and bug-prone",
              "Declarative rendering (re-render components from current inputs)",
              "Reduces “UI out of sync” bugs"
            ],
            [
              "Hard to structure large UIs",
              "Components (composition + reuse + isolation)",
              "Scales UI development and ownership"
            ],
            [
              "Frequent updates can be expensive",
              "Reconciliation + efficient commits",
              "Avoids unnecessary DOM work"
            ],
            [
              "State changes need predictable flow",
              "Unidirectional data flow (props down, events up)",
              "Makes changes easier to trace/debug"
            ]
          ],
          "caption": "What React is built to solve"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  // No manual DOM updates.\n  // UI is a pure result of current state.\n  return (\n    <button onClick={() => setCount((c) => c + 1)}>\n      Count: {count}\n    </button>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>What React deliberately does NOT solve</strong><br><br>React is intentionally a <em>UI library</em>, not a full framework. It avoids forcing a single “one true way” for the rest of the app (routing, data, architecture), so teams can choose what fits their needs."
        },
        {
          "type": "list",
          "columns": [
            "Concern",
            "React's stance",
            "What you typically add"
          ],
          "rows": [
            [
              "Routing",
              "Not included",
              "A router (client-side or framework routing)"
            ],
            [
              "Data fetching / server state",
              "Not included (useEffect exists, but no fetching strategy)",
              "A data-fetching/cache approach (query library or framework)"
            ],
            [
              "Global state architecture",
              "Not prescribed (Context exists, but not a full store pattern)",
              "Store pattern/library (or colocated state + lifting)"
            ],
            [
              "Forms and validation",
              "Not included",
              "Form library or custom form architecture"
            ],
            [
              "Styling approach",
              "Not included",
              "CSS Modules / CSS-in-JS / utility CSS / design system"
            ],
            [
              "Build tooling / bundling / SSR",
              "Not included",
              "A build tool or a React framework (for SSR/SSG, routing, etc.)"
            ]
          ],
          "caption": "React’s non-goals (by design)"
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say it like this: React owns <em>rendering</em> and <em>component composition</em>. Everything else is a product decision: choose a stack around React (router, data strategy, state strategy, build/SSR). The trade-off is flexibility vs having to assemble your own opinionated architecture."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React solves: <em>predictable UI updates from state</em> using declarative components + reconciliation. React does NOT solve: routing, data fetching strategy, global state architecture, forms, styling, or build/SSR tooling — those are intentionally left to the ecosystem."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-pure-function-of-props-and-state",
    "title": "Why are React components expected to be pure functions of props and state?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain why React expects rendering to be a pure computation (UI = f(props, state, context)) and why side effects must be moved to effects/event handlers. Connect it to render vs commit, Concurrent Rendering, StrictMode double-invocation, memoization, and predictable reconciliation.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React wants rendering to be a deterministic computation: given the same <code>props</code> + <code>state</code> (+ <code>context</code>), the component should return the same UI description. That purity lets React freely re-run renders, pause/abort work, and diff trees safely without causing “real-world” side effects."
        },
        {
          "type": "list",
          "columns": [
            "Why purity matters",
            "What it enables in React",
            "What breaks if you add side effects in render"
          ],
          "rows": [
            [
              "Render can run multiple times",
              "Retry / discard renders safely (especially in Concurrent Rendering)",
              "Duplicate API calls, duplicate subscriptions, duplicated logs, inconsistent state"
            ],
            [
              "Render can be paused / resumed / interleaved",
              "Scheduling + prioritization without committing to the DOM",
              "Effects happen at the wrong time, race conditions, tearing-like bugs"
            ],
            [
              "React uses diffing + memoization",
              "Predictable reconciliation, <code>React.memo</code>, caching, dev tooling",
              "Non-deterministic output makes “same inputs => same UI” false"
            ],
            [
              "StrictMode intentionally stress-tests",
              "Double-invocation in dev helps catch unsafe patterns",
              "Impure render causes “works in prod, weird in dev” behavior"
            ]
          ],
          "caption": "Purity is what makes React’s rendering model safe and optimizable"
        },
        {
          "type": "text",
          "text": "<strong>Render vs side effects</strong><br><br><em>Render phase</em> should only compute the next UI tree. <em>Side effects</em> belong in event handlers (user actions) or effects (<code>useEffect</code>/<code>useLayoutEffect</code>) which run after React commits changes."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ Impure render: side effects inside render\nlet renders = 0;\n\nfunction Profile({ user }) {\n  renders++; // side effect: mutating external state\n\n  // side effect: mutating props object\n  user.lastSeenAt = Date.now();\n\n  // side effect: starting async work during render\n  fetch('/api/track?u=' + user.id);\n\n  return <div>Renders: {renders} — {user.name}</div>;\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Side effect in render",
            "Why it’s bad",
            "Where it should go instead"
          ],
          "rows": [
            [
              "Mutating props/state/external variables",
              "Repeated renders produce cumulative mutations and hard-to-debug bugs",
              "Compute derived values immutably; update state via setters"
            ],
            [
              "Network calls / subscriptions / timers",
              "Render may be retried/aborted → duplicated work and leaks",
              "useEffect cleanup; subscribe/unsubscribe there"
            ],
            [
              "Reading time/randomness (Date.now, Math.random)",
              "Same inputs can yield different UI (non-deterministic)",
              "Initialize once with lazy state init, or store in state"
            ],
            [
              "DOM reads/writes",
              "DOM may not match the tree until commit; causes layout issues",
              "useLayoutEffect (reads/writes after commit) or refs"
            ]
          ],
          "caption": "Common impurities React wants you to avoid"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ✅ Pure render + side effects moved out\nfunction Profile({ user }) {\n  // Pure: derived UI only\n  return <div>{user.name}</div>;\n}\n\nfunction ProfileWithTracking({ user }) {\n  React.useEffect(() => {\n    let cancelled = false;\n\n    (async () => {\n      try {\n        await fetch('/api/track?u=' + user.id);\n      } finally {\n        // optional: handle completion\n      }\n    })();\n\n    return () => {\n      cancelled = true; // example cleanup flag\n    };\n  }, [user.id]);\n\n  return <Profile user={user} />;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>If running the component body twice would cause anything “real” to happen twice (API call, subscription, mutation, analytics), it’s not pure. Keep render as a calculation; do real work in effects and event handlers."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React expects components to be pure so it can re-run rendering freely (including retries/aborts), apply concurrent scheduling, and reconcile efficiently. Side effects in render break determinism and lead to duplicated work and inconsistent UI; move them to effects/event handlers where React guarantees timing relative to commits."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-functional-vs-class-components",
    "title": "What is the difference between functional and class components?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Functional and class components are two ways to define React components. While both produce UI, functional components are simpler, rely on hooks, and are preferred in modern React, whereas class components use ES6 classes and lifecycle methods for state and behavior.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>React offers two ways to create components — <em>functional</em> and <em>class-based</em>. Functional components are lightweight and use React Hooks to manage state and lifecycle behavior. Class components are older and use ES6 class syntax with built-in lifecycle methods like <code>componentDidMount</code> and <code>componentWillUnmount</code>."
        },
        {
          "type": "list",
          "columns": [
            "Aspect",
            "Functional Components",
            "Class Components"
          ],
          "rows": [
            [
              "Definition",
              "Functions that return JSX",
              "ES6 classes extending <code>React.Component</code>"
            ],
            [
              "State Management",
              "Use <code>useState</code> and other hooks",
              "Use <code>this.state</code> and <code>setState()</code>"
            ],
            [
              "Lifecycle Methods",
              "Use <code>useEffect</code>",
              "Use methods like <code>componentDidMount</code>"
            ],
            [
              "Performance",
              "Faster and simpler due to fewer abstractions",
              "Slightly heavier and more verbose"
            ],
            [
              "Syntax",
              "Functional and declarative",
              "Object-oriented with 'this' keyword"
            ],
            [
              "Hooks Support",
              "Fully supported",
              "Not applicable (pre-Hooks era)"
            ]
          ],
          "caption": "Differences between functional and class components"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Functional Component with Hooks\nimport { useState, useEffect } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `Count: ${count}`;\n  }, [count]);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n\n// Class Component Equivalent\nclass CounterClass extends React.Component {\n  state = { count: 0 };\n\n  componentDidUpdate() {\n    document.title = `Count: ${this.state.count}`;\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}"
        },
        {
          "type": "text",
          "text": "Both examples produce the same output, but the functional version uses hooks, which provide more flexibility and cleaner syntax without relying on class structure or the <code>this</code> keyword."
        },
        {
          "type": "text",
          "text": "<strong>When to Use Each</strong><br><ul><li><strong>Functional Components:</strong> Default choice for new React projects — simpler, faster, and compatible with hooks.</li><li><strong>Class Components:</strong> Useful in legacy codebases or when using older React versions (<16.8).</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Migration Tip</strong><br>Modern React applications should use functional components exclusively. Hooks can now replicate every class lifecycle and state feature, and provide additional power such as <code>useContext</code> and <code>useReducer</code>."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of functional components as the ‘modern React way’ — concise, powerful, and hook-driven."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Functional components use hooks and are the current React standard.</li><li>Class components rely on lifecycle methods and <code>this.state</code>.</li><li>Hooks eliminate the need for most class-based code.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-jsx-transform-and-why-not-required",
    "title": "How does JSX get transformed, and why doesn’t React require it?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what JSX actually is (syntax sugar), how a compiler (Babel/TypeScript) transforms it into plain JavaScript calls, and why React can work without JSX (you can call the element factory directly). Mention the two JSX runtimes (classic createElement vs automatic react/jsx-runtime) and the practical implications (React import, tooling, and why JSX isn’t HTML).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>JSX is <em>not</em> something React executes. JSX is syntax that your build tool (Babel or TypeScript) compiles into plain JavaScript function calls that create React elements. React doesn’t require JSX because React only needs the <em>result</em>: a React element tree (plain JS objects) — and you can create those objects without JSX."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "What happens",
            "Who does it"
          ],
          "rows": [
            [
              "1) Parse JSX",
              "JSX is parsed into an AST (like any JS syntax).",
              "Babel / TypeScript compiler"
            ],
            [
              "2) Transform",
              "JSX nodes become function calls (classic or automatic runtime).",
              "Babel plugin / TS JSX transform"
            ],
            [
              "3) Run",
              "Those function calls return React elements (JS objects).",
              "React runtime"
            ],
            [
              "4) Render",
              "React reconciles elements and updates the DOM.",
              "React + ReactDOM"
            ]
          ],
          "caption": "JSX is a compile-time feature, not a React runtime feature"
        },
        {
          "type": "text",
          "text": "<strong>Two JSX runtimes you’ll see</strong><br><br>There are two common outputs for JSX transforms: <em>classic</em> (calls <code>React.createElement</code>) and <em>automatic</em> (calls <code>jsx/jsxs</code> from <code>react/jsx-runtime</code>). Both produce the same kind of React elements."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Input (JSX)\nfunction App({ user }) {\n  return (\n    <main className=\"page\">\n      <h1>Hello, {user.name}</h1>\n      <button onClick={() => alert('hi')}>Click</button>\n    </main>\n  );\n}\n"
        },
        {
          "type": "code",
          "language": "js",
          "code": "// Output (classic runtime - conceptual)\nfunction App({ user }) {\n  return React.createElement(\n    'main',\n    { className: 'page' },\n    React.createElement('h1', null, 'Hello, ', user.name),\n    React.createElement('button', { onClick: () => alert('hi') }, 'Click')\n  );\n}\n"
        },
        {
          "type": "code",
          "language": "js",
          "code": "// Output (automatic runtime - conceptual)\nimport { jsx, jsxs } from 'react/jsx-runtime';\n\nfunction App({ user }) {\n  return jsxs('main', {\n    className: 'page',\n    children: [\n      jsxs('h1', { children: ['Hello, ', user.name] }),\n      jsx('button', { onClick: () => alert('hi'), children: 'Click' })\n    ]\n  });\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Detail",
            "What it means in practice"
          ],
          "rows": [
            [
              "Automatic runtime often removes the need to import React just for JSX",
              "You might not see <code>import React from 'react'</code> anymore, but the runtime still imports helpers (from <code>react/jsx-runtime</code>)."
            ],
            [
              "JSX becomes props + children",
              "Attributes become a props object; nested content becomes <code>children</code>."
            ],
            [
              "JSX is JavaScript expressions",
              "{...} is an expression slot, not “template interpolation” like HTML."
            ],
            [
              "Lowercase vs Uppercase matters",
              "<code>&lt;div /&gt;</code> becomes a string tag; <code>&lt;MyComp /&gt;</code> becomes a variable reference (a component function/class)."
            ]
          ],
          "caption": "Important mental model differences"
        },
        {
          "type": "text",
          "text": "<strong>Why React doesn’t require JSX</strong><br><br>React only needs you to produce React elements. JSX is just a nicer way to write those element factory calls. You can skip JSX entirely and write <code>createElement</code> (or <code>jsx</code>) calls yourself — it’s just more verbose."
        },
        {
          "type": "code",
          "language": "js",
          "code": "// React without JSX\nimport React from 'react';\n\nexport function App() {\n  return React.createElement('h1', null, 'No JSX here');\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>Say: “JSX is syntax sugar compiled by Babel/TS into element-creation calls (classic <code>createElement</code> or automatic <code>jsx/jsxs</code>). React doesn’t require JSX because it only consumes React elements — JSX never reaches React as JSX.”"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-function-treated-as-component-rules",
    "title": "What rules must a function follow to be treated as a React component?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what makes React treat a function as a component (element type), the JSX naming rule (Uppercase vs lowercase), what it must return, and the practical rules around calling it (don’t call directly if it uses Hooks). Include common runtime errors and gotchas.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React treats a function as a <em>component</em> when you use it as an <em>element type</em>: <code>&lt;MyComp /&gt;</code> (or <code>React.createElement(MyComp)</code>). Then React calls it during rendering and interprets its return value as UI."
        },
        {
          "type": "list",
          "columns": [
            "Rule",
            "What it means",
            "Why it matters"
          ],
          "rows": [
            [
              "Use it as an element type",
              "Render it as <code>&lt;MyComp /&gt;</code> (or <code>createElement(MyComp)</code>)",
              "If you just call <code>MyComp()</code>, React isn’t in control (Hooks/state model breaks)."
            ],
            [
              "Uppercase name in JSX",
              "<code>&lt;MyComp /&gt;</code> must start with a capital letter",
              "Lowercase tags are treated as DOM elements (<code>'div'</code>, <code>'span'</code>), not components."
            ],
            [
              "Return a valid React node",
              "Return JSX, string/number, fragment, array of nodes, <code>null</code>",
              "Returning an invalid type (like a plain object or Promise) crashes at runtime."
            ],
            [
              "Be render-safe (no side effects in render)",
              "Component body should compute UI; side effects go to effects/handlers",
              "Render can run multiple times (StrictMode / concurrent scheduling)."
            ]
          ],
          "caption": "The practical rules React relies on"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ✅ Component: uppercase usage\nfunction Hello({ name }) {\n  return <h1>Hello {name}</h1>;\n}\n\nexport default function App() {\n  return <Hello name=\"Ada\" />;\n}\n\n// ❌ Not a component in JSX: lowercase means DOM tag\nfunction hello() {\n  return <h1>hi</h1>;\n}\n\nexport function Broken() {\n  return <hello />; // React treats this as <\"hello\"> DOM element, not your function.\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Return value",
            "Allowed?",
            "Notes"
          ],
          "rows": [
            [
              "JSX element",
              "✅",
              "Most common: <code>&lt;div /&gt;</code>, <code>&lt;MyComp /&gt;</code>"
            ],
            [
              "string / number",
              "✅",
              "Renders a text node"
            ],
            [
              "<code>null</code> / <code>false</code>",
              "✅",
              "Renders nothing (intentional gating)"
            ],
            [
              "Array of nodes",
              "✅",
              "Use keys for stable lists"
            ],
            [
              "Plain object",
              "❌",
              "Error: <code>Objects are not valid as a React child</code>"
            ],
            [
              "Promise (async function)",
              "❌ (client)",
              "Async component returns a Promise; not a valid React node in client rendering"
            ]
          ],
          "caption": "What a function component is allowed to return"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ Invalid return\nfunction Bad() {\n  return { ok: true }; // runtime error\n}\n\n// ✅ Valid: render nothing\nfunction Gate({ enabled }) {\n  if (!enabled) return null;\n  return <div>Enabled</div>;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Hooks-specific rule</strong><br><br>If the function uses Hooks, it must be treated as a real component: call it only via React render (<code>&lt;Comp /&gt;</code>), and follow the Rules of Hooks (call hooks at the top level, not inside conditions/loops). Calling a Hook-using component like <code>Comp()</code> is a common mistake."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Counter() {\n  const [n, setN] = React.useState(0);\n  return <button onClick={() => setN((x) => x + 1)}>{n}</button>;\n}\n\n// ❌ Don’t do this\nfunction Wrong() {\n  const el = Counter(); // breaks Hooks model\n  return <div>{el}</div>;\n}\n\n// ✅ Do this\nfunction Right() {\n  return <Counter />;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>A function is treated as a React component when React sees it as the element type (<code>&lt;MyComp /&gt;</code> / <code>createElement(MyComp)</code>), it’s capitalized in JSX, and it returns a valid React node. If it uses Hooks, it must only be invoked by React’s render pipeline (not called directly)."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-rerender-decision-and-render",
    "title": "How does React decide when to re-render a component, and what role does render() play in that process?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what triggers a React component to re-render, what a “render” actually means (vs updating the DOM), and what role the class render() method (or function component body) plays in the render + commit pipeline.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React re-renders a component when it thinks that component’s <em>inputs</em> might have changed (state/props/context). A re-render means: “run the component again to produce a new element tree.” It does <em>not</em> necessarily mean the browser DOM will change."
        },
        {
          "type": "list",
          "columns": [
            "Trigger",
            "What changed?",
            "What React does",
            "Notes / common gotcha"
          ],
          "rows": [
            [
              "State update",
              "<code>setState</code> / <code>setX</code> / <code>dispatch</code>",
              "Schedules a render for that component",
              "<code>useState</code> bails out if the new state is <code>Object.is</code>-equal to the old state; new object/array references always count as “changed”."
            ],
            [
              "New props",
              "Parent renders and passes props down",
              "Child is rendered by default",
              "Even if props are “equal by value”, React still re-renders unless the child is memoized (<code>React.memo</code>/<code>PureComponent</code>)."
            ],
            [
              "Context update",
              "A <code>Context.Provider</code> value changes",
              "All consuming components re-render",
              "Context is identity-based: <code>{...}</code> created inline will change every render unless memoized."
            ],
            [
              "Force update",
              "<code>forceUpdate()</code> (class) or “dummy state”",
              "Forces a render",
              "Usually a code smell; prefer state/props-driven rendering."
            ]
          ],
          "caption": "The main reasons React decides to re-render a component"
        },
        {
          "type": "text",
          "text": "<strong>What happens during a re-render</strong><br><br>React runs the component (function body or class <code>render()</code>) to build a new React element tree. Then it <em>reconciles</em> (diffs) it against the previous tree. Only the differences are committed to the DOM."
        },
        {
          "type": "list",
          "columns": [
            "Phase",
            "What runs here",
            "What must be true"
          ],
          "rows": [
            [
              "Render phase",
              "Component function body / class <code>render()</code>",
              "Must be pure: no side effects (no data fetching, subscriptions, DOM writes)."
            ],
            [
              "Commit phase",
              "DOM mutations + layout effects",
              "Safe place for effects: <code>useEffect</code>, <code>useLayoutEffect</code>, lifecycle methods."
            ]
          ],
          "caption": "Render vs commit (why render() must be pure)"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Counter() {\n  const [count, setCount] = React.useState(0);\n\n  // This function body is the “render” for function components.\n  // It runs again when state/props/context changes.\n  return (\n    <button onClick={() => setCount((c) => c + 1)}>\n      Count: {count}\n    </button>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>So what is <code>render()</code> doing?</strong><br><br><code>render()</code> does not “trigger” updates. It’s the function React calls <em>after</em> an update is scheduled, to compute the next UI description. For function components, the component function itself plays the same role as <code>render()</code>."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "class Profile extends React.Component {\n  render() {\n    // Called during the render phase to compute UI.\n    return <h1>{this.props.name}</h1>;\n  }\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Skipping re-renders (bailouts)</strong><br><br>By default, parent re-renders propagate to children. To skip work, React needs an explicit bailout rule."
        },
        {
          "type": "list",
          "columns": [
            "Technique",
            "How it skips work",
            "When to use"
          ],
          "rows": [
            [
              "<code>React.memo(Component)</code>",
              "Shallow-compares props; if equal, skips re-render",
              "Pure presentational children with stable props"
            ],
            [
              "<code>PureComponent</code> / <code>shouldComponentUpdate</code>",
              "Controls whether class component re-renders",
              "Legacy/class codebases"
            ],
            [
              "Stable references",
              "Avoid changing prop identity unnecessarily",
              "Use <code>useCallback</code>/<code>useMemo</code> only when it prevents real re-renders"
            ]
          ],
          "caption": "Common ways to prevent unnecessary re-renders"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React re-renders when state/props/context might have changed. A “render” means recomputing the next React element tree, not necessarily updating the DOM. The class <code>render()</code> method (or function component body) is the pure computation React runs during the render phase; DOM updates happen later in the commit phase."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-render-nothing-return-value",
    "title": "Why does a React component sometimes render nothing, and how does React interpret its return value?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what React does with a component’s return value, and the common reasons a component ends up rendering nothing (intentionally or by mistake).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>A React component is basically a function that returns a <code>ReactNode</code> (what React should render). If the returned value is “empty” (<code>null</code> / <code>false</code>) React mounts nothing for that component. If you accidentally return <code>undefined</code> (often due to a missing <code>return</code>), React throws an error like: <code>Nothing was returned from render</code>."
        },
        {
          "type": "list",
          "columns": [
            "Return value",
            "How React treats it"
          ],
          "rows": [
            [
              "JSX element (e.g., <code>&lt;div /&gt;</code>)",
              "Renders that element."
            ],
            [
              "<code>string</code> / <code>number</code>",
              "Renders a text node."
            ],
            [
              "<code>null</code>",
              "Renders nothing (intentional “no UI”)."
            ],
            [
              "<code>false</code> / <code>true</code>",
              "Booleans are not rendered (treated like “nothing”)."
            ],
            [
              "Array / iterable of nodes",
              "Renders multiple siblings (keys required for stable lists)."
            ],
            [
              "Fragment (<code>&lt;&gt;...&lt;/&gt;</code>)",
              "Renders children without an extra DOM wrapper."
            ],
            [
              "Portal",
              "Renders into a different DOM container, still part of the React tree."
            ],
            [
              "<code>undefined</code>",
              "❌ Error (usually means you forgot to return)."
            ],
            [
              "Plain object (not a React element)",
              "❌ Error (<code>Objects are not valid as a React child</code>)."
            ]
          ],
          "caption": "How React interprets common component return values"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function LoadingGate({ isLoading, children }) {\n  if (isLoading) return null; // ✅ intentionally render nothing\n  return <>{children}</>; // ✅ render children\n}\n\nfunction TextOnly() {\n  return 'Hello'; // ✅ renders a text node\n}\n\nfunction Multi() {\n  return [\n    <span key=\"a\">A</span>,\n    <span key=\"b\">B</span>\n  ]; // ✅ multiple siblings\n}"
        },
        {
          "type": "text",
          "text": "<strong>Why it “renders nothing” in real life</strong><br><br>Sometimes this is intentional (feature flags, loading gates, access control). Other times it’s a bug where the component returns <code>undefined</code> or produces “empty” output via short-circuit expressions."
        },
        {
          "type": "list",
          "columns": [
            "Cause",
            "What happens",
            "Fix"
          ],
          "rows": [
            [
              "Missing <code>return</code> in a component",
              "Component returns <code>undefined</code> → React error / nothing displayed.",
              "Use explicit <code>return</code> or implicit return with parentheses."
            ],
            [
              "Arrow function with <code>{}</code> but no <code>return</code>",
              "Same: returns <code>undefined</code>.",
              "Change to <code>() =&gt; (&lt;div /&gt;)</code> or add <code>return</code>."
            ],
            [
              "Conditional early return",
              "<code>return null</code> hides UI until condition passes.",
              "Make sure the condition eventually becomes true; add fallback UI if needed."
            ],
            [
              "<code>condition &amp;&amp; &lt;X /&gt;</code> patterns",
              "If condition is <code>false</code>, result is <code>false</code> → nothing renders.",
              "Use ternary when you want an explicit else: <code>cond ? &lt;X /&gt; : null</code>."
            ],
            [
              "Forgetting <code>return</code> inside <code>map</code>",
              "Each item becomes <code>undefined</code> → list items render as “nothing”.",
              "Use implicit return or add <code>return</code> inside the callback."
            ]
          ],
          "caption": "Common reasons a component ends up rendering nothing"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ BUG: braces without return\nconst Bad = () => {\n  <div>Hi</div>;\n};\n\n// ✅ FIX 1: explicit return\nconst Good1 = () => {\n  return <div>Hi</div>;\n};\n\n// ✅ FIX 2: implicit return\nconst Good2 = () => (<div>Hi</div>);\n\n// ⚠️ Gotcha: && with numbers\n// If count is 0, this renders 0 (because 0 is rendered as text)\nfunction Badge({ count }) {\n  return <div>{count && <span>{count}</span>}</div>;\n}\n\n// ✅ Safer\nfunction BadgeSafe({ count }) {\n  return <div>{count > 0 ? <span>{count}</span> : null}</div>;\n}\n\n// ❌ BUG: missing return in map\nitems.map((x) => {\n  <li key={x.id}>{x.name}</li>;\n});\n\n// ✅ FIX: implicit return\nitems.map((x) => (\n  <li key={x.id}>{x.name}</li>\n));"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React renders whatever your component returns as a <code>ReactNode</code>. Returning <code>null</code>/<code>false</code> is a valid way to render nothing. The most common accidental “renders nothing” bug is returning <code>undefined</code> (missing <code>return</code>), especially with arrow functions and <code>map()</code> callbacks."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-one-way-data-flow",
    "title": "Why does React enforce one-way data flow?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain why React is designed around unidirectional data flow (state/props go down, events go up). Connect it to predictability, debugging, avoiding multiple-writers problems, and React’s rendering/reconciliation model (including concurrency-friendly rendering).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React’s UI model is: <em>UI = f(state, props, context)</em>. One-way data flow means the “source of truth” lives in one place (usually the nearest common parent), and children can’t directly mutate that data. Data goes <em>down</em> via props; changes go <em>up</em> via callbacks/events. This keeps updates predictable and traceable."
        },
        {
          "type": "list",
          "columns": [
            "Reason",
            "What React gets from it",
            "Why it matters"
          ],
          "rows": [
            [
              "Single writer per piece of state",
              "Avoids competing updates from multiple places",
              "Prevents “who overwrote my value?” bugs"
            ],
            [
              "Changes are explicit (events/actions)",
              "Clear update path: handler → state update → re-render",
              "Debugging becomes follow-the-event instead of hunting side effects"
            ],
            [
              "Rendering stays a pure computation",
              "React can re-run/abort renders safely",
              "Works well with concurrent rendering and scheduling"
            ],
            [
              "Stable component boundaries",
              "Props are inputs; components are reusable",
              "Encourages composition and testability"
            ],
            [
              "Reconciliation assumptions hold",
              "React diffs trees based on inputs changing",
              "Mutations that bypass state updates cause stale UI / missed updates"
            ]
          ],
          "caption": "Why unidirectional flow is a feature, not a limitation"
        },
        {
          "type": "text",
          "text": "<strong>What “enforce” means</strong><br><br>React doesn’t magically block you from mutating an object passed as a prop. But the API nudges you hard: props are treated as read-only, and state updates are expected to go through setters/dispatch. If you mutate data outside that flow, you break React’s mental model and optimization assumptions."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\nfunction Child({ value, onChange }) {\n  return (\n    <label>\n      Value:\n      <input value={value} onChange={(e) => onChange(e.target.value)} />\n    </label>\n  );\n}\n\nexport default function Parent() {\n  const [value, setValue] = React.useState('');\n\n  // Data down: value\n  // Events up: onChange -> setValue\n  return <Child value={value} onChange={setValue} />;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>What goes wrong with “two-way” style patterns</strong><br><br>Two-way binding often means multiple places can write to the same piece of data (child + parent, or UI + model). That creates implicit coupling and hidden update loops. In React, it typically shows up as mutating props or sharing mutable objects across components."
        },
        {
          "type": "list",
          "columns": [
            "Anti-pattern",
            "Failure mode",
            "Fix"
          ],
          "rows": [
            [
              "Child mutates a prop object",
              "Parent doesn’t re-render (or re-renders unpredictably); UI becomes inconsistent",
              "Treat props as immutable; update via callbacks and immutable copies"
            ],
            [
              "Shared mutable module-level state",
              "Updates bypass React scheduling; hard-to-trace rerenders",
              "Move into React state/store; update via setState/dispatch"
            ],
            [
              "Child “owns” state but parent also derives from it",
              "Double sources of truth; stale derived UI",
              "Lift state up to the common owner (single source of truth)"
            ]
          ],
          "caption": "The real problem is multiple writers and hidden coupling"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ BAD: mutating a prop object (breaks one-way assumptions)\nfunction Child({ user }) {\n  function rename() {\n    user.name = 'New Name'; // mutation\n  }\n\n  return (\n    <>\n      <div>{user.name}</div>\n      <button onClick={rename}>Rename</button>\n    </>\n  );\n}\n\n// ✅ GOOD: parent owns state; child requests changes\nfunction ChildGood({ user, onRename }) {\n  return (\n    <>\n      <div>{user.name}</div>\n      <button onClick={() => onRename('New Name')}>Rename</button>\n    </>\n  );\n}\n\nfunction ParentGood() {\n  const [user, setUser] = React.useState({ id: 1, name: 'Ada' });\n\n  return (\n    <ChildGood\n      user={user}\n      onRename={(name) => setUser((u) => ({ ...u, name }))}\n    />\n  );\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>React is optimized for predictable updates: inputs flow down, updates happen through explicit events, and renders stay pure. One-way flow prevents multiple sources of truth and makes state changes easy to trace (especially important as React can re-render/retry work in modern rendering)."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React prefers one-way data flow because it gives a single source of truth, explicit update paths, and render safety. That unlocks simpler reasoning, easier debugging, and rendering optimizations (including concurrency-friendly scheduling) that fall apart when components can “push” state into each other implicitly."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-why-props-immutable",
    "title": "Why are props immutable in React, and what breaks if they aren’t?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain why React treats props as read-only inputs (UI = f(props, state, context)). Connect this to predictable rendering, parent ownership, referential equality optimizations (PureComponent/React.memo), and why mutating props can cause missed updates, shared-state bugs, and inconsistent UI—especially under concurrent rendering and StrictMode.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Props are <em>inputs</em> owned by the parent. React’s mental model is: <code>UI = f(props, state, context)</code>. If a child can mutate its inputs, rendering stops being a pure computation and you get hidden side effects and shared mutable state across components."
        },
        {
          "type": "list",
          "columns": [
            "Why props are read-only",
            "What React assumes",
            "What you gain"
          ],
          "rows": [
            [
              "Parent owns the data",
              "Only the parent decides when/why props change",
              "Clear ownership + easier reasoning"
            ],
            [
              "Render should be pure",
              "Same inputs => same output",
              "Safe re-renders, retries, and dev StrictMode stress tests"
            ],
            [
              "Optimizations rely on identity",
              "Shallow comparisons (memo/PureComponent) are meaningful",
              "Skipping work becomes correct and predictable"
            ]
          ],
          "caption": "Immutability is a contract that keeps rendering deterministic and debuggable"
        },
        {
          "type": "text",
          "text": "<strong>What breaks if you mutate props</strong><br><br>JavaScript won’t stop you from mutating objects/arrays passed via props, but React will still treat props as if they were immutable. That mismatch causes bugs."
        },
        {
          "type": "list",
          "columns": [
            "Breakage",
            "What it looks like",
            "Why it happens"
          ],
          "rows": [
            [
              "Missed re-renders / stale UI",
              "You change a field, but UI doesn’t update (or updates inconsistently)",
              "Parent didn’t produce a new reference; memo/shallow compare thinks “nothing changed”"
            ],
            [
              "Shared mutable state bugs",
              "One child “mysteriously” affects another sibling",
              "They both reference the same mutated object/array"
            ],
            [
              "Invalid assumptions in concurrent rendering",
              "Weird flickers, order-dependent bugs, “it depends on timing”",
              "React may render, pause, retry; mutations during render leak across attempts"
            ],
            [
              "Debugging becomes painful",
              "You can’t trace where the data changed",
              "Mutation hides the real source of change (no single writer)"
            ]
          ],
          "caption": "Mutating props breaks the parent->child contract and React’s optimization model"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\n\nconst UserCard = React.memo(function UserCard({ user }) {\n  // ❌ Mutating a prop object\n  user.lastSeenAt = Date.now();\n\n  return (\n    <div>\n      <div>{user.name}</div>\n      <div>lastSeenAt: {user.lastSeenAt}</div>\n    </div>\n  );\n});\n\nexport default function App() {\n  const [user, setUser] = React.useState({ id: 1, name: 'Ada', lastSeenAt: 0 });\n\n  // Parent does NOT create a new object unless setUser is called.\n  // UserCard is memoized; shallow compare sees same `user` reference and may skip re-render.\n  return (\n    <>\n      <UserCard user={user} />\n      <button onClick={() => setUser((u) => ({ ...u, name: u.name + '!' }))}>\n        Update name (new object)\n      </button>\n    </>\n  );\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Another classic footgun: mutating arrays</strong><br><br>Sorting, pushing, splicing, or reversing a prop array mutates in-place and can corrupt parent/sibling views."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function List({ items }) {\n  // ❌ Mutates parent-owned array in-place\n  items.sort((a, b) => a.label.localeCompare(b.label));\n\n  return <ul>{items.map((x) => <li key={x.id}>{x.label}</li>)}</ul>;\n}\n\n// ✅ Make a copy\nfunction ListSafe({ items }) {\n  const sorted = [...items].sort((a, b) => a.label.localeCompare(b.label));\n  return <ul>{sorted.map((x) => <li key={x.id}>{x.label}</li>)}</ul>;\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "If you need to “change props”…",
            "Do this instead"
          ],
          "rows": [
            [
              "Child needs to request an update",
              "Pass a callback prop (events up), parent updates state and passes new props down"
            ],
            [
              "Need derived data",
              "Compute immutably (copy + transform) inside render or memoize with useMemo if expensive"
            ],
            [
              "Need local editable state",
              "Initialize local state from props carefully (and handle updates explicitly)"
            ]
          ],
          "caption": "Props are inputs; changes flow via state updates and callbacks"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Props are immutable because React’s rendering model assumes components are pure functions of their inputs, and because performance optimizations depend on stable identity + parent ownership. If you mutate props, you introduce hidden side effects: missed updates, cross-component contamination, and timing-sensitive bugs—especially with memoization and concurrent rendering."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-usestate-purpose",
    "title": "What is the purpose of useState() in React?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "The useState() Hook in React allows functional components to store and update internal state. It lets you make components dynamic and interactive by re-rendering them whenever the state changes.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>useState()</code> is a built-in React Hook that allows functional components to maintain internal state — data that changes over time and triggers UI updates. Before hooks, only class components could manage state. Now, functional components can handle both logic and state cleanly within the same function."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0); // initialize state\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}"
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Explanation"
          ],
          "rows": [
            [
              "State Variable",
              "The first value (<code>count</code>) holds the current state."
            ],
            [
              "State Setter",
              "The second value (<code>setCount</code>) updates the state."
            ],
            [
              "Initial Value",
              "Passed as an argument to <code>useState()</code> — here, <code>0</code>."
            ],
            [
              "Re-render",
              "Whenever <code>setCount()</code> is called, React re-renders the component with the new value."
            ]
          ],
          "caption": "Core concepts of useState()"
        },
        {
          "type": "text",
          "text": "<strong>Multiple States Example</strong><br>You can use multiple <code>useState()</code> calls in the same component to manage different pieces of data."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Form() {\n  const [name, setName] = useState('');\n  const [age, setAge] = useState(0);\n\n  return (\n    <form>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <input type=\"number\" value={age} onChange={(e) => setAge(e.target.value)} />\n      <p>{name} is {age} years old.</p>\n    </form>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Best Practices</strong><br><ul><li>Group related state in objects for clarity (use <code>useReducer()</code> for complex logic).</li><li>Avoid mutating state directly; always use the setter function.</li><li>Initialize from props or localStorage only when necessary.</li><li>Remember: state updates are asynchronous, so don’t rely on immediate values after calling <code>setState</code>.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>useState()</code> as a variable that ‘remembers’ its value between renders — changing it causes React to rebuild the UI with the new data."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li><code>useState()</code> adds state to functional components.</li><li>It returns a state variable and a setter function.</li><li>Calling the setter triggers a re-render with the new state.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-why-event-delegation",
    "title": "Why does React use event delegation instead of native listeners?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain how React’s event system works (SyntheticEvent + root-level listeners) and why delegation is used: fewer listeners, easier updates for dynamic trees, consistent cross-browser behavior, and better integration with React’s scheduling/batching. Mention the React 17+ change (listeners attached to the root container instead of document) and common trade-offs (native vs synthetic, non-bubbling events).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React usually doesn’t attach a native DOM listener to every element that has <code>onClick</code>/<code>onChange</code>, etc. Instead, it attaches a small set of listeners at the <em>root container</em> and uses <em>event delegation</em>: when the browser event bubbles up, React catches it once and dispatches it to the correct component handler via its internal tree."
        },
        {
          "type": "list",
          "columns": [
            "Why delegation",
            "What it buys React",
            "What breaks with per-node native listeners"
          ],
          "rows": [
            [
              "Fewer listeners (memory + setup cost)",
              "One listener can cover thousands of nodes",
              "Big trees would create many listeners and slow mounts/updates"
            ],
            [
              "Works with dynamic UIs",
              "No attach/detach churn as elements appear/disappear during reconciliation",
              "You’d constantly add/remove listeners on every commit"
            ],
            [
              "Consistent behavior (SyntheticEvent)",
              "Normalizes event quirks across browsers + consistent API",
              "Different native event edge cases leak into app logic"
            ],
            [
              "Tight integration with React scheduling",
              "React can assign event priority (discrete/continuous) and coordinate updates",
              "Harder to keep consistent ordering/priority if every node owns native listeners"
            ],
            [
              "Portals + component tree semantics",
              "Dispatch follows React’s tree (including across portals) rather than only DOM structure",
              "Handlers become harder to reason about when UI spans multiple DOM subtrees"
            ]
          ],
          "caption": "Delegation is about scale + correctness, not just micro-performance"
        },
        {
          "type": "text",
          "text": "<strong>How it works (mental model)</strong><br><br>1) Browser fires a native event on a target node.<br>2) The event bubbles up to the root container.<br>3) React’s root listener runs once, finds the closest React component instance for the target, then runs the matching handler(s) in the right order (capture/bubble)."
        },
        {
          "type": "code",
          "language": "js",
          "code": "// Native DOM event delegation (concept)\nconst root = document.getElementById('root');\n\nroot.addEventListener('click', (e) => {\n  const btn = e.target.closest('button[data-id]');\n  if (!btn) return;\n\n  console.log('Clicked id:', btn.dataset.id);\n});\n\n// React does something similar internally:\n// - one (or few) listeners at the root\n// - map DOM target -> React fiber/component\n// - call the matching onClick handler\n"
        },
        {
          "type": "text",
          "text": "<strong>React 17+ note</strong><br><br>React attaches event listeners to the <em>root container</em> instead of the global <code>document</code>. This avoids interference when multiple React versions/roots coexist and keeps event handling scoped to a root."
        },
        {
          "type": "list",
          "columns": [
            "Trade-off / gotcha",
            "What you’ll notice",
            "What to do"
          ],
          "rows": [
            [
              "Native vs React events",
              "<code>e</code> is a SyntheticEvent wrapper; native event is at <code>e.nativeEvent</code>",
              "Use React handlers for UI updates; use native listeners in <code>useEffect</code> only when needed"
            ],
            [
              "Non-bubbling events",
              "Some events don’t bubble in the DOM (React may emulate via capture or special handling)",
              "Know when to use capture props (e.g., <code>onFocusCapture</code>) or native listeners"
            ],
            [
              "Propagation expectations",
              "React propagation follows React’s tree semantics (including portals), not only DOM nesting",
              "When debugging, think in “React tree”, not just “DOM tree”"
            ]
          ],
          "caption": "Delegation is great, but understand the boundary with native DOM"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>React uses event delegation so it can handle events with a small number of root listeners, keep behavior consistent, avoid listener churn as the UI tree changes, and integrate event handling with React’s scheduling and update model. If it attached native listeners per element, large trees would pay heavy setup/teardown costs and React would lose control over consistent dispatch + prioritization."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-keys-in-lists",
    "title": "What is the significance of keys in lists in React?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Keys in React help identify which list items have changed, been added, or been removed. They make the reconciliation process efficient by allowing React to re-render only the modified elements instead of rebuilding the entire list.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>When rendering lists in React using <code>map()</code>, each item should have a unique <code>key</code> prop. Keys help React track elements between renders, improving performance and preventing bugs during dynamic updates or reordering."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function TodoList({ items }) {\n  return (\n    <ul>\n      {items.map((item) => (\n        <li key={item.id}>{item.text}</li>\n      ))}\n    </ul>\n  );\n}"
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Explanation"
          ],
          "rows": [
            [
              "Uniqueness",
              "Each key must be unique among siblings (but not globally)."
            ],
            [
              "Identity Tracking",
              "Helps React distinguish between elements when data changes."
            ],
            [
              "Reconciliation",
              "Keys optimize the virtual DOM diffing process by mapping elements efficiently."
            ],
            [
              "Dynamic Updates",
              "Prevents unnecessary re-renders or lost input focus when items reorder."
            ]
          ],
          "caption": "How keys influence React's rendering behavior"
        },
        {
          "type": "text",
          "text": "<strong>Example: Without Keys</strong><br>When keys are missing, React may reuse components incorrectly, leading to bugs like mismatched states or input fields swapping values."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "{items.map((item, index) => (\n  <li key={index}>{item.text}</li>\n))}"
        },
        {
          "type": "text",
          "text": "Using array indices as keys works for static lists but can cause issues in lists that reorder or update dynamically."
        },
        {
          "type": "text",
          "text": "<strong>Best Practices</strong><br><ul><li>Use stable and unique identifiers like database IDs for keys.</li><li>Avoid using array indices if the list can change order or length.</li><li>Do not use random or non-deterministic values as keys — React relies on key consistency across renders.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Performance Insight</strong><br>Keys allow React’s diffing algorithm (reconciliation) to skip unchanged elements and efficiently patch only modified nodes, improving render speed and stability."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of keys like labels on moving boxes — without them, React wouldn’t know which box belongs where after reordering."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Keys uniquely identify list items during rendering.</li><li>They improve performance and prevent re-rendering bugs.</li><li>Use stable, unique values like IDs — avoid indices when possible.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-controlled-vs-uncontrolled",
    "title": "What is the difference between controlled and uncontrolled components?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Controlled components in React are those whose form data is managed by React state, while uncontrolled components manage their own state internally through the DOM. Controlled components offer more predictable, testable, and synchronized data flow, whereas uncontrolled components are simpler but less flexible.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>React provides two ways to handle form inputs: <em>controlled</em> and <em>uncontrolled</em> components. Controlled components rely on React state as the single source of truth, while uncontrolled components use the DOM’s internal state via <code>ref</code> to manage data."
        },
        {
          "type": "list",
          "columns": [
            "Type",
            "Description",
            "Data Source"
          ],
          "rows": [
            [
              "Controlled Component",
              "React state controls the input value. Each keystroke triggers a state update.",
              "React state"
            ],
            [
              "Uncontrolled Component",
              "Input value is handled by the DOM itself and accessed via <code>ref</code> when needed.",
              "DOM element"
            ]
          ],
          "caption": "Key differences between controlled and uncontrolled components"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Controlled Component\nfunction ControlledInput() {\n  const [value, setValue] = useState('');\n  return (\n    <input value={value} onChange={(e) => setValue(e.target.value)} />\n  );\n}\n\n// Uncontrolled Component\nfunction UncontrolledInput() {\n  const inputRef = useRef(null);\n  const handleSubmit = () => alert(inputRef.current.value);\n  return (\n    <>\n      <input ref={inputRef} />\n      <button onClick={handleSubmit}>Submit</button>\n    </>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>When to Use Each</strong><br><ul><li><strong>Controlled Components:</strong> When you need form validation, dynamic behavior, or real-time updates (e.g., search inputs, login forms).</li><li><strong>Uncontrolled Components:</strong> When simple or legacy forms are needed, and performance or quick prototyping is prioritized.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Pros and Cons</strong><br><ul><li><strong>Controlled:</strong> Predictable, easier to debug, suitable for complex interactions.</li><li><strong>Uncontrolled:</strong> Simpler, faster for basic use cases, but harder to validate and synchronize with app state.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Controlled components put React in charge of the form state — think of it as React 'holding the pen' while you type."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Controlled components store input values in React state.</li><li>Uncontrolled components rely on DOM references.</li><li>Controlled inputs are ideal for validation, while uncontrolled are simpler but less powerful.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-default-vs-named-exports-runtime-break",
    "title": "How can incorrect default vs named exports break a React application at runtime?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Incorrectly mixing default exports and named exports can cause React to import the wrong thing (often undefined). The app may compile, but crash at runtime when React tries to render a component that isn’t actually a component.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>React doesn’t render “imports” — it renders the <em>value</em> you pass as a component. If you import the wrong symbol, you often end up with <code>undefined</code> (or a plain object). React then throws at runtime when it tries to treat that value like a component."
        },
        {
          "type": "list",
          "columns": [
            "Export style",
            "Import style",
            "Typical runtime result",
            "Fix"
          ],
          "rows": [
            [
              "Default export: <code>export default Button</code>",
              "Wrong: <code>import { Button } from './Button'</code>",
              "Button becomes <code>undefined</code> → React error: <code>Element type is invalid...</code>",
              "Use <code>import Button from './Button'</code>"
            ],
            [
              "Named export: <code>export const Button = ...</code>",
              "Wrong: <code>import Button from './Button'</code>",
              "Button becomes <code>undefined</code> (or a module wrapper) → runtime crash",
              "Use <code>import { Button } from './Button'</code>"
            ],
            [
              "Barrel re-export mistake",
              "Import from <code>index.ts</code> expecting a symbol that isn’t exported",
              "Import resolves but value is missing → <code>undefined</code> at render time",
              "Fix barrel: export the symbol correctly"
            ],
            [
              "Default export renamed during re-export",
              "<code>export { default } from './Button'</code> but you import <code>{ Button }</code>",
              "Named import is missing → <code>undefined</code>",
              "Re-export with a name: <code>export { default as Button } ...</code>"
            ]
          ],
          "caption": "Common export/import mismatches that cause runtime crashes"
        },
        {
          "type": "text",
          "text": "<strong>The classic crash</strong><br><br>When React tries to render <code>undefined</code> as a component, you commonly see:<br><code>Element type is invalid: expected a string (for built-in components) or a class/function but got: undefined</code>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Button.jsx\nexport default function Button() {\n  return <button>OK</button>;\n}\n\n// App.jsx (WRONG)\nimport { Button } from './Button';\n\nexport default function App() {\n  return <Button />; // Button === undefined -> runtime crash\n}\n\n// App.jsx (RIGHT)\nimport Button from './Button';\n"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Button.jsx\nexport function Button() {\n  return <button>OK</button>;\n}\n\n// App.jsx (WRONG)\nimport Button from './Button';\n\nexport default function App() {\n  return <Button />; // Button is not the named export -> undefined -> crash\n}\n\n// App.jsx (RIGHT)\nimport { Button } from './Button';\n"
        },
        {
          "type": "text",
          "text": "<strong>Why it can slip past “build success”</strong><br><br>Depending on tooling (JS vs TS strictness, Babel settings, path aliases, barrel files), the import might not error at compile time. But at runtime, the imported value is still wrong (often <code>undefined</code>), and React only discovers it when rendering."
        },
        {
          "type": "list",
          "columns": [
            "Quick debug step",
            "What you’re checking",
            "What it usually reveals"
          ],
          "rows": [
            [
              "Log the import",
              "<code>console.log(Button)</code> right before rendering",
              "If you see <code>undefined</code> or an object, you imported wrong"
            ],
            [
              "Open the module file",
              "Check the exact export statements",
              "Whether it’s <code>export default</code> or <code>export const</code>"
            ],
            [
              "Check barrel/index files",
              "Is the symbol re-exported correctly?",
              "Missing or incorrectly named re-exports are common"
            ],
            [
              "Search for duplicate files/paths",
              "Same component name in multiple locations",
              "You might be importing a different file than you think"
            ]
          ],
          "caption": "Fast runtime triage checklist"
        },
        {
          "type": "text",
          "text": "<strong>Best practice</strong><br><br>Pick a team convention and enforce it with lint rules. Many teams prefer <em>named exports</em> for components (easier refactors + consistent imports), and reserve <em>default exports</em> for special cases (single main export modules). Consistency reduces these runtime failures."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-conditional-rendering",
    "title": "How do you conditionally render elements in React?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Conditional rendering in React means displaying different components or elements based on certain conditions, such as user actions or application state. It’s typically done using JavaScript operators like if-else, ternary (?:), or logical AND (&&).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Conditional rendering allows React components to decide what to render based on state, props, or logic. Since React is just JavaScript, you can use standard conditional statements to control UI output dynamically."
        },
        {
          "type": "list",
          "columns": [
            "Method",
            "Syntax Example",
            "Use Case"
          ],
          "rows": [
            [
              "if / else",
              "Use normal conditional blocks before return.",
              "When logic is too complex for inline rendering."
            ],
            [
              "Ternary Operator",
              "<code>{isLoggedIn ? <Dashboard /> : <Login />}</code>",
              "Common for inline conditions."
            ],
            [
              "Logical AND (&&)",
              "<code>{messages.length > 0 && <MessageList />}</code>",
              "Render something only when a condition is true."
            ]
          ],
          "caption": "Common conditional rendering techniques in React"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example using if/else\nfunction Greeting({ isLoggedIn }) {\n  if (isLoggedIn) {\n    return <h1>Welcome back!</h1>;\n  }\n  return <h1>Please sign in.</h1>;\n}"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example using ternary operator\nfunction StatusMessage({ status }) {\n  return <p>{status ? 'Online ✅' : 'Offline ❌'}</p>;\n}"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example using && operator\nfunction Notifications({ messages }) {\n  return <>{messages.length > 0 && <p>You have {messages.length} new messages.</p>}</>;\n}"
        },
        {
          "type": "text",
          "text": "<strong>Advanced Example: Rendering Components Conditionally</strong><br>You can also store entire components in variables and conditionally assign them:"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function UserPanel({ user }) {\n  let content;\n  if (user.isAdmin) {\n    content = <AdminPanel />;\n  } else {\n    content = <UserDashboard />;\n  }\n  return <div>{content}</div>;\n}"
        },
        {
          "type": "text",
          "text": "<strong>Best Practices</strong><br><ul><li>Keep conditional logic outside JSX when complex.</li><li>Use fragments (</>) to avoid unnecessary wrappers.</li><li>Combine with hooks (e.g., state from <code>useState()</code> or <code>useContext()</code>) for dynamic rendering.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of conditional rendering like ‘if statements’ inside your UI — React just decides what to show based on the current app state."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Conditional rendering decides what JSX to display based on logic.</li><li>You can use <code>if</code>, ternary (<code>?:</code>), or <code>&&</code> operators.</li><li>Use ternary for short expressions, and <code>if</code> for complex cases.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-useeffect-purpose",
    "title": "What is the purpose of the useEffect() hook in React?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "The useEffect() hook in React manages side effects — operations that occur outside the component’s rendering process, such as fetching data, setting up subscriptions, manipulating the DOM, or running timers.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>useEffect()</code> is one of React’s most powerful hooks. It lets you perform side effects — tasks that affect something outside of React’s pure rendering cycle — like making API calls, listening for window events, or updating the document title. It replaces lifecycle methods such as <code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>componentWillUnmount</code> from class components."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import { useEffect, useState } from 'react';\n\nfunction FetchUser() {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    fetch('https://api.example.com/user')\n      .then((res) => res.json())\n      .then((data) => setUser(data));\n  }, []); // Empty dependency array = runs only once\n\n  return <div>{user ? user.name : 'Loading...'}</div>;\n}"
        },
        {
          "type": "list",
          "columns": [
            "Dependency Pattern",
            "When It Runs",
            "Use Case"
          ],
          "rows": [
            [
              "Empty array (<code>[]</code>)",
              "Once after the first render",
              "Initialization (API calls, subscriptions)"
            ],
            [
              "No array",
              "After every render",
              "When continuous updates are needed"
            ],
            [
              "Specific dependencies",
              "When any listed dependency changes",
              "Reacting to state or prop changes"
            ]
          ],
          "caption": "How dependency arrays control when effects run"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example with cleanup\nuseEffect(() => {\n  const handleResize = () => console.log(window.innerWidth);\n  window.addEventListener('resize', handleResize);\n\n  return () => {\n    window.removeEventListener('resize', handleResize); // cleanup\n  };\n}, []);"
        },
        {
          "type": "text",
          "text": "<strong>Common Use Cases</strong><br><ul><li>Fetching and updating data from APIs</li><li>Subscribing/unsubscribing to events</li><li>Manipulating the DOM (focus, title, scroll)</li><li>Running animations or timers</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Best Practices</strong><br><ul><li>Always clean up event listeners and intervals to prevent memory leaks.</li><li>List all dependencies that your effect uses — React warns about missing ones.</li><li>Avoid unnecessary effects inside the render path; use memoization or derived state when possible.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>useEffect()</code> as a way to ‘sync’ your component with the outside world — it reacts to state changes and performs real-world effects safely."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Manages side effects in React functional components.</li><li>Runs after rendering and optionally cleans up resources.</li><li>Replaces class lifecycle methods for simpler logic organization.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-fragments-dom-and-reconciliation",
    "title": "How do fragments affect the rendered DOM and reconciliation?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what React fragments change in the real DOM (no extra wrapper node) and what they still represent in React’s tree (a Fragment fiber). Connect this to reconciliation: identity/type matching, keys (especially keyed fragments in lists), and common remount/state-loss gotchas when adding/removing a fragment wrapper.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>A fragment (<code>&lt;&gt;...&lt;/&gt;</code> / <code>React.Fragment</code>) is <em>invisible in the browser DOM</em> (no extra element node), but it is <em>still a node in React’s internal tree</em>. That means it affects reconciliation (how React matches old vs new children), even though it doesn’t produce a DOM wrapper."
        },
        {
          "type": "list",
          "columns": [
            "Topic",
            "What happens",
            "Why it matters"
          ],
          "rows": [
            [
              "Rendered DOM",
              "Fragment adds <em>no</em> extra DOM element; only its children are inserted",
              "No accidental wrappers that break CSS layout, semantics (<code>&lt;tr&gt;</code>, <code>&lt;li&gt;</code>), or accessibility structure"
            ],
            [
              "React tree",
              "React still creates a Fragment “fiber” that groups children",
              "Reconciliation can treat “Fragment vs not Fragment” as a type change (can remount)"
            ],
            [
              "Props/attributes",
              "Fragments don’t create a DOM node, so you can’t attach DOM attributes/events/layout hooks to “the fragment itself”",
              "If you need a className, ref to a DOM element, or an event boundary, you need a real element wrapper"
            ]
          ],
          "caption": "Fragments: invisible in DOM, visible to React"
        },
        {
          "type": "text",
          "text": "<strong>How reconciliation sees fragments</strong><br><br>Reconciliation matches elements by <em>type + key + position</em>. A fragment has a distinct element type (<code>Fragment</code>). So introducing/removing a fragment wrapper can change the element type at that position, and React may tear down and recreate that subtree."
        },
        {
          "type": "list",
          "columns": [
            "Scenario",
            "What React compares",
            "Typical result"
          ],
          "rows": [
            [
              "Same fragment, children change",
              "Fragment type stays; React diffs children inside it",
              "Child components can preserve state if their own identity is stable"
            ],
            [
              "Fragment ↔ element wrapper swap (<code>&lt;&gt;</code> vs <code>&lt;div&gt;</code>)",
              "Type changes at that position",
              "Subtree often remounts (state reset) because old fiber is replaced"
            ],
            [
              "Fragment present ↔ fragment removed (wrapping/unwrapping)",
              "Type at the position changes (Fragment vs Child)",
              "Can remount the child even if it “looks like the same UI”"
            ],
            [
              "Fragments in lists with keys",
              "Keyed Fragment gives identity to a <em>group</em> of siblings",
              "Prevents incorrect reuse when returning multiple siblings per list item"
            ]
          ],
          "caption": "What fragments change in reconciliation"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ✅ DOM stays clean (no wrapper)\nfunction Header() {\n  return (\n    <>\n      <h1>Title</h1>\n      <p>Subtitle</p>\n    </>\n  );\n}\n\n// DOM output is roughly:\n// <h1>Title</h1>\n// <p>Subtitle</p>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ✅ Keyed Fragment in a list (group multiple siblings per item)\nfunction DefinitionList({ items }) {\n  return (\n    <dl>\n      {items.map((x) => (\n        <React.Fragment key={x.id}>\n          <dt>{x.term}</dt>\n          <dd>{x.desc}</dd>\n        </React.Fragment>\n      ))}\n    </dl>\n  );\n}\n\n// Without a keyed Fragment, you'd need a wrapper element (often invalid inside <dl>)."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ⚠️ Gotcha: wrapping/unwrapping can remount (state loss)\nfunction Counter() {\n  const [n, setN] = React.useState(0);\n  return <button onClick={() => setN((x) => x + 1)}>{n}</button>;\n}\n\nfunction App({ wrap }) {\n  // If `wrap` toggles, React may replace the subtree because\n  // the element type at this position changes (Fragment vs Counter).\n  return wrap ? (\n    <>\n      <Counter />\n    </>\n  ) : (\n    <Counter />\n  );\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Gotcha",
            "What you see",
            "Fix / rule of thumb"
          ],
          "rows": [
            [
              "Using fragment when you needed a layout hook",
              "You can’t style/measure “the fragment” (no DOM node)",
              "Use a real element when you need className/ref/layout boundary"
            ],
            [
              "Swapping wrappers (Fragment vs <div>)",
              "Unexpected remount / lost local state / lost focus",
              "Keep wrapper type stable; don’t toggle between structurally different roots"
            ],
            [
              "Returning multiple siblings per list item without a keyed Fragment",
              "React warns about keys or reuses siblings incorrectly on reorder",
              "Put the <code>key</code> on <code>React.Fragment</code> (shorthand can’t take a key)"
            ]
          ],
          "caption": "Common fragment pitfalls"
        },
        {
          "type": "text",
          "text": "<strong>Interview framing</strong><br><br>“Fragments don’t create DOM nodes, so they keep markup/semantics clean. But they still exist in React’s tree, so they participate in reconciliation: type + key + position. Keyed fragments are mainly for lists where one item returns multiple siblings. Be careful: adding/removing/swapping the fragment wrapper can change element identity and cause remounts.”"
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><br>Fragments affect the <em>DOM</em> by removing unnecessary wrapper elements. They affect <em>reconciliation</em> because Fragment is still an element type in React’s tree: it can change identity matching (and therefore state preservation), and keyed fragments give stable identity to grouped siblings in lists."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-virtual-dom",
    "title": "What is the virtual DOM and how does React use it?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "The virtual DOM is an in-memory representation of the real DOM used by React to optimize UI rendering. React uses it to determine the minimal set of changes needed to update the UI efficiently.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>The Virtual DOM (VDOM) is a lightweight copy of the browser’s actual DOM stored in memory. React uses it to track changes and update only the parts of the UI that have changed, instead of re-rendering everything. This makes UI updates faster and more efficient."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example of how React uses the virtual DOM\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;\n}\n\n// When state changes:\n// 1. React creates a new virtual DOM tree.\n// 2. It compares it with the previous version (diffing).\n// 3. Only updates the changed parts in the real DOM."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "Description"
          ],
          "rows": [
            [
              "Render Phase",
              "React builds a virtual DOM tree based on component structure."
            ],
            [
              "Diffing",
              "React compares the new VDOM with the previous one to detect changes."
            ],
            [
              "Reconciliation",
              "React efficiently updates only the modified nodes in the real DOM."
            ]
          ],
          "caption": "How React uses the virtual DOM for efficient updates"
        },
        {
          "type": "text",
          "text": "<strong>Why It Matters</strong><br><ul><li>The real DOM is slow to manipulate directly — React minimizes direct DOM access.</li><li>The virtual DOM makes UI updates predictable and performant.</li><li>React batches updates and avoids unnecessary reflows and repaints.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Analogy</strong><br>Imagine the virtual DOM as a 'draft' of your web page — React edits the draft, compares it with the old one, and only rewrites the parts that changed on the final version."
        },
        {
          "type": "text",
          "text": "<strong>Benefits</strong><br><ul><li>Improves performance by reducing DOM manipulation.</li><li>Enables declarative programming — React handles updates automatically.</li><li>Enhances consistency and predictability of UI updates.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> The virtual DOM acts like React’s smart assistant — it figures out what changed and updates the UI for you efficiently."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>The virtual DOM is an in-memory representation of the real DOM.</li><li>React uses it to detect changes and update only affected nodes.</li><li>It enables fast, efficient, and predictable UI rendering.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-component-rerendering",
    "title": "How does React handle component re-rendering?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "React handles component re-rendering efficiently by using its virtual DOM system. When state or props change, React compares the new virtual DOM with the previous one, finds the differences (diffing), and updates only the necessary parts of the real DOM.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>React re-renders components when their <code>state</code> or <code>props</code> change. Instead of directly updating the real DOM, React builds a virtual DOM representation in memory, compares it with the previous version, and then applies only the minimal updates to the browser DOM. This makes UI updates efficient and fast."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "function Counter() {\n  const [count, setCount] = useState(0);\n\n  console.log('Component re-rendered');\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increase</button>\n    </div>\n  );\n}"
        },
        {
          "type": "list",
          "columns": [
            "Trigger",
            "Description"
          ],
          "rows": [
            [
              "State Changes",
              "When you call a setter from <code>useState</code>, React re-renders that component."
            ],
            [
              "Prop Changes",
              "If parent components pass new props, React re-renders the child."
            ],
            [
              "Context Updates",
              "If context values change, all subscribed components re-render."
            ],
            [
              "Force Updates",
              "In rare cases, manual re-renders can be triggered using hooks like <code>useReducer</code> or <code>forceUpdate()</code>."
            ]
          ],
          "caption": "Common triggers for React component re-rendering"
        },
        {
          "type": "text",
          "text": "<strong>Re-rendering Process</strong><br><ul><li>React detects changes in state or props.</li><li>It rebuilds the virtual DOM for that component subtree.</li><li>React compares it to the previous virtual DOM (diffing).</li><li>It applies minimal updates to the real DOM (reconciliation).</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Optimization Techniques</strong><br><ul><li>Use <code>React.memo()</code> to prevent unnecessary re-renders for pure components.</li><li>Use <code>useCallback()</code> and <code>useMemo()</code> to stabilize function and object references.</li><li>Split large components into smaller, reusable ones for fine-grained updates.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> React doesn’t re-render the whole app — only the components whose data changed, thanks to its virtual DOM and reconciliation process."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>React re-renders when state or props change.</li><li>It uses a virtual DOM to minimize direct DOM manipulation.</li><li>Efficient diffing and reconciliation keep performance high.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-mixing-state-and-props-responsibilities",
    "title": "What bugs appear when state and props responsibilities are mixed?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Explain what typically breaks when a component treats the same piece of data as both “props-owned” and “state-owned” (multiple sources of truth). Cover common symptoms (stale UI, input jumps, infinite loops, memo bugs) and the correct patterns (single source of truth, controlled vs uncontrolled, derived state).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Core idea</strong><br><br>Props are <em>inputs</em> owned by the parent. State is <em>local memory</em> owned by the component. When the same value is “owned” by both (prop + local state trying to represent the same truth), you create <em>two sources of truth</em>. React can only re-render correctly if ownership is clear: one writer, one authoritative value."
        },
        {
          "type": "list",
          "columns": [
            "Bug class",
            "What you see",
            "Why it happens"
          ],
          "rows": [
            [
              "Stale UI / missed updates",
              "Parent updates prop, child UI still shows old value",
              "Child copied prop into state once (or with a wrong sync) so it stops reflecting prop changes"
            ],
            [
              "Input “jumps” / cursor issues",
              "User types, then text resets or cursor jumps",
              "Both parent and child write to the input value; updates race and overwrite each other"
            ],
            [
              "Infinite update loops",
              "“Maximum update depth exceeded” or render thrashing",
              "Effect syncs prop → state, state change triggers parent callback, parent changes prop again"
            ],
            [
              "Controlled/uncontrolled warnings",
              "React warning about switching controlled ↔ uncontrolled",
              "Sometimes you pass value, sometimes you don’t; or you mix value + defaultValue"
            ],
            [
              "Memo / shallow-compare lies",
              "React.memo/PureComponent skips re-render when it shouldn’t (or vice versa)",
              "Mutations or identity mismatches: prop reference stays same while internal state changes (or you mutate a prop object)"
            ],
            [
              "Hard-to-debug coupling",
              "“Works sometimes”, order/timing dependent behavior",
              "Two writers + async scheduling = last write wins, but it’s not obvious who wrote last"
            ]
          ],
          "caption": "Typical failures when prop + state compete for the same responsibility"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ Classic bug: copying props to state (stale after parent updates)\nfunction ProfileEditor({ user }) {\n  const [name, setName] = React.useState(user.name); // copied once\n\n  // Later: parent changes user.name (e.g., refetch) but input stays stale\n  return <input value={name} onChange={(e) => setName(e.target.value)} />;\n}\n\n// This component now has two truths:\n// - parent truth: user.name\n// - child truth: name\n"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ❌ Sync effect + callback can create loops / jitter\nfunction Child({ value, onChange }) {\n  const [local, setLocal] = React.useState(value);\n\n  // tries to \"keep in sync\" with prop\n  React.useEffect(() => {\n    setLocal(value);\n  }, [value]);\n\n  // tries to \"keep parent in sync\" with local\n  React.useEffect(() => {\n    onChange(local);\n  }, [local, onChange]);\n\n  return <input value={local} onChange={(e) => setLocal(e.target.value)} />;\n}\n"
        },
        {
          "type": "list",
          "columns": [
            "Correct pattern",
            "When to use",
            "How it prevents bugs"
          ],
          "rows": [
            [
              "Single source of truth (controlled)",
              "Parent owns the value; child just renders + emits events",
              "One writer (parent). No local copy, no drift"
            ],
            [
              "Uncontrolled input + ref",
              "You don’t need every keystroke in React state",
              "DOM owns value; React reads it only when needed (submit, blur)"
            ],
            [
              "Derived data (no state)",
              "Value can be computed from props/state",
              "No syncing needed: compute during render (optionally memoize)"
            ],
            [
              "Intentional “draft state” with explicit reset",
              "You need editable local draft that can be reset by parent",
              "You define a reset rule (key change / reset token) instead of ambiguous syncing"
            ]
          ],
          "caption": "Fix = make ownership explicit (pick one owner per piece of data)"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// ✅ Controlled: parent owns value (single source of truth)\nfunction Child({ value, onChange }) {\n  return <input value={value} onChange={(e) => onChange(e.target.value)} />;\n}\n\nfunction Parent() {\n  const [value, setValue] = React.useState('');\n  return <Child value={value} onChange={setValue} />;\n}\n\n// ✅ Uncontrolled: DOM owns value\nfunction UncontrolledForm() {\n  const ref = React.useRef(null);\n  return (\n    <form\n      onSubmit={(e) => {\n        e.preventDefault();\n        alert(ref.current.value);\n      }}\n    >\n      <input ref={ref} defaultValue=\"\" />\n      <button>Submit</button>\n    </form>\n  );\n}\n\n// ✅ Intentional draft with explicit reset signal\nfunction Editor({ initialName, resetKey }) {\n  const [draft, setDraft] = React.useState(initialName);\n\n  // explicit reset (not \"sync every time\")\n  React.useEffect(() => {\n    setDraft(initialName);\n  }, [resetKey]);\n\n  return <input value={draft} onChange={(e) => setDraft(e.target.value)} />;\n}\n"
        },
        {
          "type": "text",
          "text": "<strong>Rule of thumb</strong><br><br>If two different places can write the “same” value, you will eventually get drift, overwrites, loops, or UI jumps. Decide who owns it (parent via props, or child via local state/DOM), then design the API around that ownership."
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-lifting-state-up",
    "title": "How can you lift state up in React?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 5,
    "description": "Lifting state up in React means moving shared state to the closest common ancestor of the components that need it. This allows multiple components to access and synchronize the same data through props.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In React, when two or more components need to share the same state, it’s best to 'lift the state up' — move it to their nearest common parent. The parent holds the state, and passes it down to children via <code>props</code>. This ensures data consistency and centralized control."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example: Lifting state up\nfunction Parent() {\n  const [value, setValue] = useState('');\n\n  return (\n    <div>\n      <Input value={value} onChange={setValue} />\n      <Display value={value} />\n    </div>\n  );\n}\n\nfunction Input({ value, onChange }) {\n  return <input value={value} onChange={(e) => onChange(e.target.value)} />;\n}\n\nfunction Display({ value }) {\n  return <p>Typed text: {value}</p>;\n}"
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Explanation"
          ],
          "rows": [
            [
              "Centralized State",
              "The parent manages state instead of each child maintaining its own."
            ],
            [
              "Data Flow",
              "State is passed down via props; updates flow upward via callback functions."
            ],
            [
              "Synchronization",
              "Ensures that multiple components always display the same data."
            ]
          ],
          "caption": "Core principles of lifting state up in React"
        },
        {
          "type": "text",
          "text": "<strong>Why Lift State</strong><br><ul><li>To share data between sibling components.</li><li>To prevent duplication of logic or inconsistent state.</li><li>To manage user input that affects multiple components.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Best Practices</strong><br><ul><li>Keep state as high as necessary, but as low as possible — avoid globalizing everything.</li><li>Use callbacks to propagate changes from children to parents.</li><li>Consider using Context API or state management libraries for complex shared state.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of lifting state up as giving one parent the responsibility of tracking data, while children simply read or update it."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Lifting state up moves shared data to a common ancestor.</li><li>Children communicate changes via callbacks.</li><li>It promotes consistency and unidirectional data flow in React.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-higher-order-components",
    "title": "What are higher-order components (HOCs)?",
    "technology": "react",
    "difficulty": "hard",
    "importance": 5,
    "description": "Higher-Order Components (HOCs) are hard React patterns that allow you to reuse component logic by wrapping one component inside another. An HOC takes a component as input and returns an enhanced version of that component with additional functionality or data.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>A Higher-Order Component (HOC) is a function that takes a component as an argument and returns a new component. HOCs enable reusability of logic across multiple components — such as authentication checks, logging, fetching data, or connecting to global state (like Redux)."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Basic HOC pattern\nfunction withLogger(WrappedComponent) {\n  return function EnhancedComponent(props) {\n    console.log('Rendering', WrappedComponent.name);\n    return <WrappedComponent {...props} />;\n  };\n}\n\n// Usage\nfunction Hello({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}\n\nconst HelloWithLogger = withLogger(Hello);"
        },
        {
          "type": "list",
          "columns": [
            "Concept",
            "Explanation"
          ],
          "rows": [
            [
              "Input",
              "A component (the Wrapped Component)."
            ],
            [
              "Output",
              "A new component that wraps the original one."
            ],
            [
              "Purpose",
              "To reuse logic and behavior across multiple components."
            ]
          ],
          "caption": "Core structure of a Higher-Order Component"
        },
        {
          "type": "text",
          "text": "<strong>Common Use Cases</strong><br><ul><li>Injecting props or global data (e.g., authentication, theme).</li><li>Managing subscriptions (like WebSockets or events).</li><li>Logging or performance monitoring.</li><li>Connecting components to global stores (e.g., <code>connect()</code> in Redux).</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Important Notes</strong><br><ul><li>HOCs should be pure — they must not modify the original component.</li><li>Props must always be passed through (<code>{...props}</code>) to ensure component flexibility.</li><li>They can wrap multiple layers deep, so naming and structure should be clear to avoid confusion.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of HOCs like decorators — they wrap a component to give it extra powers without changing its original implementation."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>HOCs are functions that take a component and return a new one.</li><li>Used to share logic across multiple components.</li><li>Follow composition principles and avoid mutating inputs.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-usememo-vs-usecallback",
    "title": "What is the difference between useMemo() and useCallback()?",
    "technology": "react",
    "difficulty": "hard",
    "importance": 5,
    "description": "Both useMemo() and useCallback() are React hooks used for performance optimization. useMemo() memoizes computed values, while useCallback() memoizes functions — preventing unnecessary re-creations during re-renders.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>useMemo()</code> and <code>useCallback()</code> help improve performance by caching results or function references between re-renders. React components re-render when their props or state change, and these hooks prevent expensive re-computations or re-creations that could slow the app down."
        },
        {
          "type": "list",
          "columns": [
            "Hook",
            "Purpose",
            "Returns",
            "Use Case"
          ],
          "rows": [
            [
              "useMemo()",
              "Memoizes a computed value to avoid recalculating it every render.",
              "A cached value.",
              "When you have an expensive calculation that depends on specific values."
            ],
            [
              "useCallback()",
              "Memoizes a function so it retains the same reference between renders.",
              "A memoized function.",
              "When passing callback props to child components to prevent unnecessary re-renders."
            ]
          ],
          "caption": "Key differences between useMemo() and useCallback()"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// useMemo example\nconst total = useMemo(() => {\n  console.log('Calculating total...');\n  return items.reduce((sum, item) => sum + item.price, 0);\n}, [items]);\n\n// useCallback example\nconst handleClick = useCallback(() => {\n  console.log('Button clicked');\n}, []);"
        },
        {
          "type": "text",
          "text": "<strong>Detailed Explanation</strong><br><ul><li><strong>useMemo()</strong> recalculates a value only when dependencies change. It’s ideal for optimizing expensive computations like filtering large datasets or formatting lists.</li><li><strong>useCallback()</strong> returns the same function reference between renders unless its dependencies change. It’s most useful when passing callbacks to memoized child components.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Performance Tip</strong><br>Both hooks should be used selectively. Overusing them can make code complex without significant performance gain. They are primarily helpful in preventing unnecessary renders and optimizing heavy computations."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Combined example\nfunction ProductList({ products }) {\n  const [query, setQuery] = useState('');\n\n  const filteredProducts = useMemo(() => {\n    return products.filter((p) => p.name.toLowerCase().includes(query.toLowerCase()));\n  }, [products, query]);\n\n  const handleChange = useCallback((e) => {\n    setQuery(e.target.value);\n  }, []);\n\n  return (\n    <div>\n      <input value={query} onChange={handleChange} placeholder='Search products' />\n      <ul>{filteredProducts.map((p) => <li key={p.id}>{p.name}</li>)}</ul>\n    </div>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Analogy</strong><br><em>useMemo()</em> is like remembering the result of a long math calculation so you don’t recalculate it unless the inputs change. <em>useCallback()</em> is like remembering the function you used to do the calculation so you don’t create it again each time."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <code>useMemo()</code> optimizes values, <code>useCallback()</code> optimizes functions — both help React skip unnecessary work and maintain stable references."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li><code>useMemo()</code> caches computed values.</li><li><code>useCallback()</code> caches function definitions.</li><li>Both improve performance by avoiding redundant work and reducing re-renders.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-prevent-unnecessary-rerenders",
    "title": "How can you prevent unnecessary re-renders in React?",
    "technology": "react",
    "companies": [
      "netflix"
    ],
    "difficulty": "hard",
    "importance": 5,
    "description": "Preventing unnecessary re-renders in React is crucial for maintaining optimal performance. Re-renders occur when a component's state, props, or context changes, but React provides several techniques and patterns to minimize them — including memoization, pure components, stable references, and smart state management.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>React re-renders components whenever their <code>state</code>, <code>props</code>, or <code>context</code> change. While this ensures UI consistency, unnecessary re-renders can slow down large applications. To optimize performance, React provides techniques like <code>React.memo()</code>, <code>useMemo()</code>, <code>useCallback()</code>, and state hoisting strategies that reduce redundant rendering cycles."
        },
        {
          "type": "list",
          "columns": [
            "Technique",
            "Description",
            "Use Case"
          ],
          "rows": [
            [
              "React.memo()",
              "Prevents re-rendering of a functional component unless its props change.",
              "When a child component receives the same props repeatedly."
            ],
            [
              "useMemo()",
              "Memoizes a computed value and reuses it until its dependencies change.",
              "When performing expensive calculations in render."
            ],
            [
              "useCallback()",
              "Memoizes a function definition so that it doesn’t re-trigger re-renders in memoized children.",
              "When passing callbacks as props."
            ],
            [
              "PureComponent / shallow comparison",
              "Automatically skips re-renders when prop and state values have not changed.",
              "When using class-based components."
            ],
            [
              "Splitting state",
              "Store state closer to the component that actually needs it to avoid global updates.",
              "When managing complex UI with multiple interactive areas."
            ]
          ],
          "caption": "Common strategies to prevent unnecessary re-renders in React"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example using React.memo and useCallback\nconst Button = React.memo(({ onClick, label }) => {\n  console.log('Button rendered');\n  return <button onClick={onClick}>{label}</button>;\n});\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() => {\n    setCount((prev) => prev + 1);\n  }, []);\n\n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <Button onClick={handleClick} label='Increment' />\n    </div>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Detailed Explanation</strong><br><ul><li><strong>Memoization:</strong> By caching values and functions, React avoids re-creating them during re-renders.</li><li><strong>Pure Components:</strong> Class-based components that implement shallow comparison for props and state, ensuring only changed data triggers updates.</li><li><strong>Restructuring State:</strong> Large shared state causes global re-renders; move state down to relevant child components when possible.</li><li><strong>Context Optimization:</strong> Context triggers re-renders in all consumers; use memoized context values or split contexts by responsibility.</li></ul>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example: Context optimization with useMemo\nconst ThemeContext = React.createContext();\n\nfunction App() {\n  const [theme, setTheme] = useState('light');\n  const value = useMemo(() => ({ theme, setTheme }), [theme]);\n\n  return (\n    <ThemeContext.Provider value={value}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Other Optimization Techniques</strong><br><ul><li>Use <code>key</code> attributes wisely — avoid changing keys unnecessarily.</li><li>Batch multiple state updates using <code>ReactDOM.flushSync()</code> or rely on React's automatic batching (React 18+).</li><li>Defer complex calculations or animations using <code>useTransition()</code> or <code>useDeferredValue()</code>.</li><li>Profile performance using React DevTools Profiler to locate render bottlenecks.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Efficient React apps don’t avoid re-renders entirely — they control when and where they happen. The goal is to ensure only components affected by data changes re-render."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>React re-renders components on state, props, or context changes.</li><li>Prevent redundant re-renders with memoization, stable callbacks, and scoped state.</li><li>Proper optimization ensures smooth UI updates without unnecessary computation.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-strictmode-purpose",
    "title": "What is the purpose of the React.StrictMode component?",
    "technology": "react",
    "difficulty": "intermediate",
    "importance": 4,
    "description": "React.StrictMode is a development-only feature that helps identify potential issues in React applications by enabling additional checks, warnings, and highlighting deprecated patterns. It does not affect the production build or app behavior.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br><code>React.StrictMode</code> is a wrapper component provided by React to help developers identify unsafe or deprecated code patterns. It activates additional development checks and warnings to ensure components adhere to modern React practices and will behave correctly in concurrent rendering scenarios."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nReactDOM.createRoot(document.getElementById('root')).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);"
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Behavior"
          ],
          "rows": [
            [
              "Detects Unsafe Lifecycles",
              "Warns when using outdated lifecycle methods like <code>componentWillMount</code> or <code>componentWillReceiveProps</code>."
            ],
            [
              "Detects Side-Effect Issues",
              "Runs certain functions twice (like useEffect callbacks) to ensure side effects are idempotent."
            ],
            [
              "Highlights Deprecated APIs",
              "Warns about legacy string refs, findDOMNode, and legacy context usage."
            ],
            [
              "Identifies Unexpected Behavior",
              "Detects potential issues in asynchronous rendering with React concurrent features."
            ]
          ],
          "caption": "Key development checks enabled by React.StrictMode"
        },
        {
          "type": "text",
          "text": "<strong>Why It Matters</strong><br><ul><li>Encourages developers to write cleaner, future-proof React code.</li><li>Ensures that effects and updates behave consistently in upcoming React features.</li><li>Improves debugging and helps migrate older codebases to modern React hooks and concurrent rendering.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Important Notes</strong><br><ul><li>Only active in development mode; it has no effect in production builds.</li><li>May cause duplicate console logs or API calls in development due to intentional double-invocation of certain functions.</li><li>Does not render any UI or change component behavior; it’s purely diagnostic.</li></ul>"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example of StrictMode highlighting a side-effect\nfunction Example() {\n  useEffect(() => {\n    console.log('Effect triggered');\n    return () => console.log('Cleanup');\n  }, []);\n\n  return <p>Hello World</p>;\n}\n\n// The effect above runs twice in development to test cleanup behavior."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of <code>React.StrictMode</code> as React’s 'training mode' — it helps you find potential bugs early, making your app stronger and more resilient in production."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>StrictMode helps detect side effects, deprecated APIs, and unsafe lifecycles.</li><li>It runs additional checks in development without affecting production.</li><li>Useful for ensuring your React app is ready for future updates and concurrent rendering.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-reconciliation",
    "title": "What is React reconciliation and how does it work?",
    "technology": "react",
    "difficulty": "hard",
    "importance": 5,
    "description": "Reconciliation is the process React uses to compare the current Virtual DOM with the previous one and determine the minimal set of changes needed to update the real DOM. It ensures React applications stay fast and efficient even when rendering complex UI trees.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Reconciliation is the core mechanism that makes React performant. Whenever the state or props of a component change, React generates a new Virtual DOM tree. It then compares this new tree with the previous one to detect differences. This comparison process is called <em>reconciliation</em>, and the optimized algorithm React uses to perform it is known as the <em>diffing algorithm</em>."
        },
        {
          "type": "list",
          "columns": [
            "Step",
            "Description"
          ],
          "rows": [
            [
              "Render Phase",
              "React creates a new Virtual DOM representation of the UI based on the latest component state and props."
            ],
            [
              "Diffing Phase",
              "React compares the new Virtual DOM with the old one to detect what has changed."
            ],
            [
              "Commit Phase",
              "React updates only the changed elements in the real DOM, leaving the rest untouched."
            ]
          ],
          "caption": "Main phases of React’s reconciliation process"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example: Reconciliation in action\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <h2>Count: {count}</h2>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// Only <h2> changes when count updates; React reuses <div> and <button>."
        },
        {
          "type": "text",
          "text": "<strong>Why It Matters</strong><br>Direct manipulation of the DOM is expensive. React’s reconciliation process ensures that only necessary updates happen, minimizing reflows and improving performance. This approach makes React declarative — you describe the UI, and React efficiently figures out how to update it."
        },
        {
          "type": "text",
          "text": "<strong>Rules of Reconciliation</strong><br><ul><li>Elements of the same type are compared recursively.</li><li>If an element type changes (e.g., <code>&lt;div&gt;</code> → <code>&lt;span&gt;</code>), React destroys and rebuilds that node.</li><li>Keys help React identify elements across renders, especially in lists, ensuring stable updates instead of re-creating entire subtrees.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Reconciliation and Keys</strong><br><ul><li>Keys allow React to match old and new elements efficiently.</li><li>When keys are missing or inconsistent, React may re-render entire lists instead of updating only changed items.</li><li>Stable, unique keys (like IDs) help React maintain state between renders.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Example</strong><br>If you render a list and change one item’s position, React uses the <code>key</code> attribute to identify which element moved instead of destroying and re-creating all items."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "{items.map(item => (\n  <li key={item.id}>{item.name}</li>\n))}"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Reconciliation is React’s secret engine — it ensures your UI stays fast by updating only what’s necessary, not everything that changed."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Reconciliation is React’s process for updating the DOM efficiently.</li><li>It compares old and new Virtual DOM trees using the diffing algorithm.</li><li>Only changed parts of the real DOM are updated, ensuring optimal performance.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-diffing-algorithm",
    "title": "Explain how React’s diffing algorithm determines which parts of the DOM to update.",
    "technology": "react",
    "difficulty": "hard",
    "importance": 5,
    "description": "React’s diffing algorithm efficiently compares two Virtual DOM trees to find the minimal number of operations needed to synchronize the real DOM with the new state. It uses intelligent heuristics that make the process nearly O(n) instead of O(n³).",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>The diffing algorithm is the heart of React’s Virtual DOM system. Whenever a component’s state or props change, React constructs a new Virtual DOM and compares it to the previous one. Instead of checking every possible change (which would be computationally expensive), React uses smart assumptions to identify the minimal changes required."
        },
        {
          "type": "list",
          "columns": [
            "Rule",
            "Explanation"
          ],
          "rows": [
            [
              "1. Element Type Comparison",
              "If two elements have the same type (e.g., both are <code>&lt;div&gt;</code>), React assumes their structure is similar and performs a deep comparison of their attributes and children."
            ],
            [
              "2. Replacement on Type Change",
              "If the element type differs (e.g., <code>&lt;div&gt;</code> → <code>&lt;span&gt;</code>), React removes the old node and creates a new one."
            ],
            [
              "3. Key-Based List Comparison",
              "When diffing lists, React uses keys to track which items changed, were added, or removed. Keys ensure minimal reordering and preserve component state."
            ]
          ],
          "caption": "Simplified rules of React’s diffing algorithm"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example: Efficient list diffing using keys\nconst fruits = ['Apple', 'Banana', 'Cherry'];\n\n// When re-rendered with a new list:\nconst updatedFruits = ['Banana', 'Cherry', 'Apple'];\n\n// React uses 'key' to determine what moved instead of re-rendering everything.\n{updatedFruits.map(fruit => (\n  <li key={fruit}>{fruit}</li>\n))}"
        },
        {
          "type": "text",
          "text": "<strong>How the Algorithm Works</strong><br><ul><li><strong>Step 1:</strong> React starts from the root of the tree and compares each Virtual DOM node with its previous version.</li><li><strong>Step 2:</strong> If nodes are identical, React skips them.</li><li><strong>Step 3:</strong> If attributes differ (e.g., <code>className</code>), React updates only those attributes in the real DOM.</li><li><strong>Step 4:</strong> When lists change, React uses keys to identify additions, deletions, and reorderings efficiently.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Example of Attribute Update</strong><br>React updates only what changes — not the entire node."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Old Virtual DOM\n<div className='red'>Hello</div>\n\n// New Virtual DOM\n<div className='blue'>Hello</div>\n\n// React result:\n// Only updates the className from 'red' to 'blue', not the entire <div>."
        },
        {
          "type": "text",
          "text": "<strong>Performance Advantage</strong><br>The traditional approach to comparing trees is O(n³), but React’s diffing algorithm achieves near O(n) by making these assumptions:<ul><li>Different element types produce different trees.</li><li>Stable keys indicate the same components across renders.</li></ul>This efficiency makes React suitable for large-scale dynamic UIs."
        },
        {
          "type": "text",
          "text": "<strong>When Keys Are Misused</strong><br>Incorrect or missing keys can cause React to discard and re-create DOM nodes unnecessarily, resulting in performance issues and lost component state. Always use unique and stable keys (like database IDs)."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> The diffing algorithm is React’s performance superpower — it ensures your UI updates surgically instead of rebuilding the whole DOM every time something changes."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>React’s diffing algorithm compares Virtual DOM trees efficiently.</li><li>It updates only changed attributes or elements using heuristic assumptions.</li><li>Keys play a critical role in optimizing list updates and preserving state.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-render-props-vs-hocs",
    "title": "What are render props and how do they differ from HOCs?",
    "technology": "react",
    "difficulty": "hard",
    "importance": 5,
    "description": "Render props and higher-order components (HOCs) are both React patterns used for code reuse. Render props use a function passed as a prop to control what to render, while HOCs wrap components to inject additional logic or data.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>In React, both <em>Render Props</em> and <em>Higher-Order Components (HOCs)</em> aim to share logic between components. However, they differ in implementation: HOCs wrap components and return enhanced ones, whereas Render Props use a function as a prop to dynamically render UI with shared functionality."
        },
        {
          "type": "text",
          "text": "<strong>Render Props Pattern</strong><br>Render props is a pattern where a component receives a function as a prop and uses it to determine what to render. This function receives shared data or behavior as arguments, enabling reusable and flexible composition."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example of Render Props\nfunction DataProvider({ render }) {\n  const [data, setData] = useState('Hello Render Props!');\n  return render(data);\n}\n\nfunction App() {\n  return (\n    <DataProvider render={(data) => <h1>{data}</h1>} />\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>Higher-Order Components (HOCs)</strong><br>HOCs are functions that take a component as input and return an enhanced version of it. They are often used to inject props or logic into wrapped components, such as authentication, logging, or global data handling."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example of HOC\nfunction withLogger(WrappedComponent) {\n  return function EnhancedComponent(props) {\n    console.log('Rendering', WrappedComponent.name);\n    return <WrappedComponent {...props} />;\n  };\n}\n\nconst Hello = (props) => <h2>Hello, {props.name}</h2>;\nconst HelloWithLogger = withLogger(Hello);"
        },
        {
          "type": "list",
          "columns": [
            "Pattern",
            "Implementation",
            "Rendering Control",
            "Common Use Cases"
          ],
          "rows": [
            [
              "Render Props",
              "Passes a function prop to control rendering.",
              "Parent component controls rendering output.",
              "Reusable behavior without inheritance or wrapping."
            ],
            [
              "HOC",
              "Wraps a component and returns an enhanced version.",
              "Wrapped component renders normally.",
              "Injecting data or functionality (e.g., Redux connect)."
            ]
          ],
          "caption": "Key differences between Render Props and HOCs"
        },
        {
          "type": "text",
          "text": "<strong>When to Use Each</strong><br><ul><li><strong>Render Props:</strong> When you want full control over rendering and flexible composition.</li><li><strong>HOCs:</strong> When you want to extend or modify components’ behavior in a reusable, declarative way.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Best Practices</strong><br><ul><li>Avoid using both patterns simultaneously in the same component — it increases complexity.</li><li>Prefer hooks in modern React for sharing logic (e.g., <code>useCustomHook()</code>).</li><li>Render props are more explicit and composable, whereas HOCs abstract logic more deeply.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Think of render props as 'passing a render recipe' and HOCs as 'wrapping an object with a new layer of behavior.' Both achieve reusability, but through different philosophies."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Render Props share logic through function props.</li><li>HOCs wrap and enhance components.</li><li>Modern React often replaces both patterns with custom hooks for cleaner and simpler reusability.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-portals",
    "title": "What are React portals and when would you use them?",
    "technology": "react",
    "difficulty": "hard",
    "importance": 5,
    "description": "React Portals allow components to render children into a DOM node that exists outside the main React component hierarchy, without losing context. They are commonly used for modals, tooltips, popovers, and overlays.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>By default, components in React render into a specific section of the DOM tree — typically inside a root element. However, there are cases where you need to render an element outside of this hierarchy (like a modal that overlays the entire page). React Portals make this possible while preserving the component’s state and event bubbling behavior."
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example: Creating a Portal\nimport { createPortal } from 'react-dom';\n\nfunction Modal({ children }) {\n  const modalRoot = document.getElementById('modal-root');\n  return createPortal(\n    <div className='modal-overlay'>\n      <div className='modal-content'>{children}</div>\n    </div>,\n    modalRoot\n  );\n}\n\n// Usage\nfunction App() {\n  return (\n    <>\n      <h1>Main App</h1>\n      <Modal>\n        <p>This modal is rendered outside the main DOM hierarchy!</p>\n      </Modal>\n    </>\n  );\n}"
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Description"
          ],
          "rows": [
            [
              "DOM Separation",
              "Renders children into a different part of the DOM while still being part of the same React component tree."
            ],
            [
              "Event Propagation",
              "Events (like clicks) still bubble up through the React tree even if rendered elsewhere."
            ],
            [
              "Reusability",
              "Useful for rendering overlays, tooltips, dropdowns, and notifications without CSS positioning issues."
            ]
          ],
          "caption": "Key characteristics of React Portals"
        },
        {
          "type": "text",
          "text": "<strong>When to Use React Portals</strong><br><ul><li><strong>Modals and Dialogs:</strong> To overlay content on top of the entire app while avoiding nested CSS stacking contexts.</li><li><strong>Tooltips and Popovers:</strong> To position elements outside of overflow or clipping containers.</li><li><strong>Floating UI Elements:</strong> For global notifications, menus, or context-sensitive actions.</li></ul>"
        },
        {
          "type": "code",
          "language": "html",
          "code": "<!-- Typical setup in index.html -->\n<body>\n  <div id='root'></div>\n  <div id='modal-root'></div>\n</body>"
        },
        {
          "type": "text",
          "text": "<strong>How It Works Internally</strong><br>React’s <code>createPortal()</code> function takes two arguments: a React child (JSX element) and a DOM node. It attaches the child to the specified DOM node, but keeps it part of the React component hierarchy — meaning it still shares state, context, and event propagation with its parent."
        },
        {
          "type": "text",
          "text": "<strong>Advantages of Using Portals</strong><br><ul><li>Solves z-index and overflow issues by detaching UI from parent containers.</li><li>Keeps React’s declarative structure intact.</li><li>Maintains event propagation and context links even when rendered outside the normal DOM flow.</li></ul>"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Portals act like ‘wormholes’ in React — they render elements somewhere else in the DOM while keeping them connected to their original logic and context."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>React Portals render children outside the parent DOM hierarchy.</li><li>Used for modals, overlays, and tooltips to avoid CSS stacking issues.</li><li>They preserve React context and event bubbling despite DOM separation.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  },
  {
    "id": "react-concurrent-rendering",
    "title": "How does React’s concurrent rendering improve performance?",
    "technology": "react",
    "difficulty": "hard",
    "importance": 5,
    "description": "Concurrent rendering is a feature introduced in React 18 that allows React to prepare multiple versions of the UI simultaneously, improving responsiveness and user experience. It makes rendering interruptible, enabling React to prioritize urgent updates and avoid UI blocking during heavy computations.",
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<strong>Overview</strong><br><br>Traditional rendering in React was synchronous — once React started rendering a component tree, it had to finish before handling new updates. Concurrent rendering changes that behavior. It allows React to work on multiple UI updates at the same time, pause work when necessary, and prioritize more important updates (like user interactions) over less critical ones."
        },
        {
          "type": "text",
          "text": "<strong>Key Concept</strong><br><em>Concurrent rendering</em> doesn’t mean React renders components in parallel; rather, it can interrupt and resume work intelligently. This leads to smoother UIs, especially in complex applications where large updates could otherwise block input or animations."
        },
        {
          "type": "list",
          "columns": [
            "Feature",
            "Explanation"
          ],
          "rows": [
            [
              "Interruptible Rendering",
              "React can pause an ongoing render to handle higher-priority tasks, like responding to a user click."
            ],
            [
              "Prioritized Updates",
              "Updates are assigned priorities — urgent ones (like typing) are handled first, while non-urgent ones (like data loading) can be delayed."
            ],
            [
              "Concurrent Preparation",
              "React can prepare multiple versions of the UI in memory and commit the best one when ready."
            ],
            [
              "Non-blocking Rendering",
              "Rendering no longer freezes the main thread, keeping the app responsive even under heavy load."
            ]
          ],
          "caption": "Core principles of concurrent rendering"
        },
        {
          "type": "code",
          "language": "jsx",
          "code": "// Example using useTransition\nimport { useState, useTransition } from 'react';\n\nfunction SearchList({ items }) {\n  const [query, setQuery] = useState('');\n  const [filtered, setFiltered] = useState(items);\n  const [isPending, startTransition] = useTransition();\n\n  const handleChange = (e) => {\n    const value = e.target.value;\n    setQuery(value);\n    startTransition(() => {\n      const results = items.filter(item => item.includes(value));\n      setFiltered(results);\n    });\n  };\n\n  return (\n    <div>\n      <input value={query} onChange={handleChange} placeholder='Search...' />\n      {isPending && <p>Loading...</p>}\n      <ul>{filtered.map((item, i) => <li key={i}>{item}</li>)}</ul>\n    </div>\n  );\n}"
        },
        {
          "type": "text",
          "text": "<strong>How This Improves Performance</strong><br><ul><li>By marking some updates as ‘transitions’, React knows they are not urgent and can delay them to keep the UI responsive.</li><li>React can interrupt rendering mid-way to handle urgent updates first, then continue rendering where it left off.</li><li>This prevents input lag and stuttering during large data updates or re-renders.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Key APIs Enabling Concurrent Rendering</strong><br><ul><li><code>useTransition()</code>: Defers expensive updates to improve responsiveness.</li><li><code>useDeferredValue()</code>: Allows a value to ‘lag behind’ to avoid blocking fast updates.</li><li><code>startTransition()</code>: Marks non-urgent updates to be scheduled with lower priority.</li><li><code>Suspense</code>: Works with concurrent rendering to pause UI updates until asynchronous data is ready.</li></ul>"
        },
        {
          "type": "text",
          "text": "<strong>Under the Hood</strong><br><br>React’s concurrent renderer is built on a new architecture called the <em>Fiber Reconciler</em>. Each component update is split into small units of work (called fibers). This lets React work on these pieces incrementally and yield control back to the browser between frames, ensuring smooth rendering without blocking the main thread."
        },
        {
          "type": "text",
          "text": "<strong>Example of Prioritization</strong><br>Imagine typing into a search box that filters a large list. With concurrent rendering:<ul><li>Your keystrokes (high priority) update the input immediately.</li><li>The filtering logic (low priority) runs in the background without freezing the input field.</li></ul>This creates a seamless, lag-free user experience."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> Concurrent rendering isn’t about parallelism — it’s about <em>cooperative scheduling</em>. React breaks large tasks into smaller chunks and works on them over time, making your app feel faster without actually increasing raw performance."
        },
        {
          "type": "text",
          "text": "<strong>Summary</strong><br><ul><li>Concurrent rendering lets React pause, resume, and prioritize rendering tasks.</li><li>It improves responsiveness by keeping the UI interactive during long updates.</li><li>Enabled through APIs like <code>useTransition</code>, <code>useDeferredValue</code>, and the Fiber architecture.</li><li>Especially useful for search filtering, data fetching, and large list rendering scenarios.</li></ul>"
        }
      ]
    },
    "access": "free",
    "type": "trivia"
  }
]