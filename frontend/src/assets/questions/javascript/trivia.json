[
  {
    "id": "js-event-loop",
    "title": "Explain the JavaScript Event Loop",
    "description": "JavaScript runs on a single thread. Each cycle: it executes synchronous code, drains all microtasks (e.g., Promise callbacks), then runs one macrotask (e.g., setTimeout) before repeating. This is why Promises run before timers and why long microtask chains can block rendering.",
    "type": "trivia",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "event-loop",
      "async",
      "microtasks"
    ],
    "importance": 5,
    "companies": [
      "google",
      "meta",
      "microsoft",
      "uber",
      "netflix"
    ],
    "answer": {
      "blocks": [
        {
          "type": "text",
          "text": "<i class='fa-solid fa-brain'></i> <strong>The Big Picture</strong>\n\nJavaScript runs <strong>on a single thread</strong>, meaning it can only do <strong>one thing at a time</strong>. So how does it handle things like <code>setTimeout</code>, <code>fetch</code>, or <code>Promise.then</code> without freezing? That’s where the <strong>event loop</strong> comes in.\n\nThink of it like a manager that decides <em>what piece of code runs next</em> among all waiting tasks."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-gears'></i> <strong>The Three Main Parts</strong>\n\nThe JavaScript runtime manages execution using three core parts: the <strong>Call Stack</strong>, <strong>Task Queues</strong>, and the <strong>Event Loop</strong>."
        },
        {
          "type": "list",
          "columns": [
            "Component",
            "Purpose",
            "Examples / Details"
          ],
          "rows": [
            [
              "<strong>Call Stack</strong>",
              "Where synchronous code runs, line by line. If a function takes too long here, everything else waits (blocking).",
              "<code>console.log</code>, loops, math operations, synchronous functions"
            ],
            [
              "<strong>Task Queues (two types)</strong>",
              "Where async tasks wait until the stack is clear — split into Microtask and Macrotask queues.",
              "Async callbacks, Promises, timers, I/O events"
            ],
            [
              "<strong>Microtask Queue</strong>",
              "Smaller, high-priority tasks that run immediately after the stack is clear.",
              "<code>Promise.then</code>, <code>queueMicrotask</code>, <code>process.nextTick</code>"
            ],
            [
              "<strong>Macrotask Queue</strong>",
              "Larger, lower-priority tasks that can yield to the browser for rendering between runs.",
              "<code>setTimeout</code>, DOM events, I/O, <code>setInterval</code>"
            ]
          ],
          "caption": "Call Stack and Task Queues at a glance."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-repeat'></i> <strong>The Event Loop</strong>\n\nThe event loop constantly checks:\n1. Is the call stack empty?  \n2. Any microtasks waiting? → Run all of them.  \n3. Take one macrotask and run it.  \nThen the cycle repeats forever."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "console.log('A');\n\nsetTimeout(() => console.log('B (macrotask)'));\n\nPromise.resolve()\n  .then(() => console.log('C (microtask)'))\n  .then(() => console.log('D (microtask)'));\n\nconsole.log('E');\n\n// Output:\n// A\n// E\n// C\n// D\n// B"
        },
        {
          "type": "text",
          "text": "<strong>Why this order?</strong>\n- <code>A</code> and <code>E</code> → run first (synchronous stack).  \n- Then the event loop runs <strong>all microtasks</strong> → <code>C</code>, <code>D</code>.  \n- Finally, the next macrotask runs → <code>B</code>.  \n\nThat’s why <strong>Promises always run before timers</strong>, even when scheduled “at the same time.”"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-layer-group'></i> <strong>Microtasks vs. Macrotasks (Summary)</strong>"
        },
        {
          "type": "list",
          "columns": [
            "Type",
            "Examples",
            "Runs When",
            "Priority"
          ],
          "rows": [
            [
              "<strong>Microtask</strong>",
              "<code>Promise.then</code>, <code>queueMicrotask</code>",
              "After the current call stack, before rendering",
              "High"
            ],
            [
              "<strong>Macrotask</strong>",
              "<code>setTimeout</code>, <code>setInterval</code>, DOM events",
              "After microtasks, allows rendering",
              "Normal"
            ]
          ],
          "caption": "Microtasks run before macrotasks within each event loop cycle."
        },
        {
          "type": "text",
          "text": "After each macrotask, <strong>all microtasks</strong> are drained before the next one starts. That’s why too many microtasks (like recursive Promises) can block rendering."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "function loop() {\n  Promise.resolve().then(loop); // microtask recursion\n}\nloop(); // browser freezes — it never yields control back"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-server'></i> <strong>In Node.js</strong>\n\nThe event loop runs through several <strong>phases</strong>:\n<pre class='md-pre'>timers → pending callbacks → poll → check → close callbacks</pre>\nMicrotasks (<code>Promise.then</code>, <code>process.nextTick</code>) run <strong>after each phase</strong>, unlike browsers where they run once per loop."
        },
        {
          "type": "code",
          "language": "javascript",
          "code": "setTimeout(() => console.log('timer'));\nsetImmediate(() => console.log('immediate'));\nPromise.resolve().then(() => console.log('microtask'));\n\n// Common order:\n// microtask → timer → immediate"
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-circle-check'></i> <strong>Summary</strong>\n\n- JavaScript executes <strong>synchronously</strong> on a single thread.  \n- The <strong>event loop</strong> coordinates between the stack and queues.  \n- <strong>Microtasks</strong> (Promises) always run before <strong>macrotasks</strong> (timers).  \n- Too many microtasks can freeze rendering.  \n- Use macrotasks for deferred work and microtasks for quick follow-ups."
        },
        {
          "type": "text",
          "text": "<i class='fa-solid fa-lightbulb'></i> <strong>Still so complicated?</strong>\n\nImagine you’re the only cashier at a store. You serve one customer at a time (the call stack). When a customer needs to grab something, you tell them to step aside (macrotask). But before you call the next one, you handle quick questions like ‘Can I get a receipt?’ (microtasks). You repeat this all day — that’s the event loop!"
        }
      ]
    }
  }
]