[
  {
    "id": "js-number-clamp",
    "title": "Clamp",
    "type": "coding",
    "technology": "javascript",
    "importance": 1,
    "difficulty": "easy",
    "tags": [
      "numbers",
      "math",
      "boundaries"
    ],
    "description": {
      "summary": "Implement a function `clamp(value, lower, upper)` that restricts `value` within inclusive `lower` and `upper` bounds.",
      "arguments": [
        {
          "name": "value",
          "type": "number",
          "desc": "The number to clamp."
        },
        {
          "name": "lower",
          "type": "number",
          "desc": "The lower bound."
        },
        {
          "name": "upper",
          "type": "number",
          "desc": "The upper bound."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The clamped number."
      },
      "examples": [
        "// Basic examples\nclamp(3, 0, 5) // => 3",
        "clamp(-10, -3, 5) // => -3",
        "clamp(10, -5, 5) // => 5"
      ]
    },
    "starterCode": "export default function clamp(value, lower, upper) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure a number stays within an inclusive range. If `value < lower`, return `lower`; if `value > upper`, return `upper`; otherwise return `value`. Common in sliders, percentages, animations, and input sanitization.",
      "approaches": [
        {
          "title": "Approach 1: Branching (readable baseline)",
          "prose": "Idea: check the value against each bound and return the first applicable result.\n\nHow it works\n1. If value < lower, return lower (lift it up).\n2. Else if value > upper, return upper (cap it).\n3. Otherwise return value unchanged.\n\nWhy use it: very explicit and easy to debug or extend (e.g., add logs/metrics around each branch). Caller should still ensure lower \u2264 upper.",
          "codeJs": "export default function clamp(value, lower, upper) {\n  if (value < lower) return lower;\n  if (value > upper) return upper;\n  return value;\n}\n",
          "codeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  if (value < lower) return lower;\n  if (value > upper) return upper;\n  return value;\n}\n"
        },
        {
          "title": "Approach 2: Math chaining (compact)",
          "prose": "Idea: clamp in one expression — first lift to the lower bound, then cap to the upper bound.\n\nUse `Math.min(Math.max(value, lower), upper)` to ensure the value stays between both bounds.\n\nRead it as: *at least lower, at most upper.*\n\nWhy use it: terse, branch-free, and fast to read once familiar. Ensure `lower ≤ upper`; if not, the result may be surprising.",
          "codeJs": "export default function clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\n",
          "codeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  return Math.min(Math.max(value, lower), upper);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "`lower` should be `<= upper`. If not guaranteed by caller, normalize or assert.",
          "`NaN` inputs propagate through `Math.min/max` → result becomes `NaN`. Decide whether to coerce or throw.",
          "Non-number inputs (strings, null) will be coerced if you use Math.*; prefer validating types for clarity."
        ],
        "edgeCases": [
          "value exactly equals `lower` or `upper` → return that bound.",
          "Very large magnitudes: works, but be mindful of ±Infinity if it can appear.",
          "Swapped bounds: if it can happen, you can fix with `[lower, upper] = lower <= upper ? [lower, upper] : [upper, lower]`."
        ],
        "techniques": [
          "Guard + early return for clarity (Approach 1).",
          "Functional composition feel with `Math.min(Math.max(...))` (Approach 2)."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels",
        "js-arrays-equal"
      ],
      "resources": [
        {
          "title": "MDN – Math.max()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max"
        },
        {
          "title": "MDN – Math.min()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min"
        }
      ]
    },
    "tests": "import clamp from './clamp';\n\ndescribe('clamp', () => {\n  test('within range', () => expect(clamp(3, 0, 5)).toBe(3));\n  test('below lower', () => expect(clamp(-10, -3, 5)).toBe(-3));\n  test('above upper', () => expect(clamp(10, -5, 5)).toBe(5));\n});\n",
    "testsTs": "import clamp from './clamp';\n\ndescribe('clamp (TypeScript)', () => {\n  it('returns the same value when within range', () => {\n    expect(clamp(3, 0, 5)).toBe(3);\n  });\n  it('clamps to lower bound when below range', () => {\n    expect(clamp(-10, -3, 5)).toBe(-3);\n  });\n  it('clamps to upper bound when above range', () => {\n    expect(clamp(10, -5, 5)).toBe(5);\n  });\n});\n"
  },
  {
    "id": "js-reverse-string",
    "title": "Reverse a String",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `reverseString(str)` that returns the reversed version of the input string without using built-in methods like `.reverse()`.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to be reversed."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "The reversed string."
      },
      "examples": [
        "// Basic example\nreverseString('abc') // => 'cba'",
        "// Palindrome\nreverseString('racecar') // => 'racecar'",
        "// With spaces and punctuation\nreverseString('A man, a plan') // => 'nalp a ,nam A'"
      ]
    },
    "starterCode": "export default function reverseString(str) {\n  // TODO: Implement without using Array.prototype.reverse()\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function reverseString(str: string): string {\n  // TODO: Implement without using Array.prototype.reverse()\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: reverse the characters of a string from end to start without using built-ins like `.reverse()`. This tests understanding of string traversal and immutability.",
      "approaches": [
        {
          "title": "Approach 1: Manual loop (explicit and clear)",
          "prose": "Idea: traverse the string backwards, appending each character to a new string.\n\nHow it works\n1. Initialize an empty result variable `out = ''`.\n2. Loop from the **last index (`str.length - 1`) down to 0**.\n3. On each iteration, append `str[i]` to `out`.\n4. Return `out` when done.\n\nWhy use it: very clear and easy to understand for beginners. Demonstrates string immutability — concatenation forms a new string each time.",
          "codeJs": "export default function reverseString(str) {\n  let out = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    out += str[i];\n  }\n  return out;\n}\n",
          "codeTs": "export default function reverseString(str: string): string {\n  let out = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    out += str[i];\n  }\n  return out;\n}\n"
        },
        {
          "title": "Approach 2: Using array methods (compact, modern)",
          "prose": "Idea: convert the string into an array, reverse it, and join back to string.\n\nUse `str.split('').reverse().join('')` to reverse efficiently.\n\nRead it as: *split → reverse → join*.\n\nWhy use it: concise and elegant, leveraging built-ins. However, it's disallowed here per problem statement — shown only for completeness.",
          "codeJs": "export default function reverseString(str) {\n  return str.split('').reverse().join('');\n}\n",
          "codeTs": "export default function reverseString(str: string): string {\n  return str.split('').reverse().join('');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Strings are immutable — direct character reassignment won’t work.",
          "Avoid `.reverse()` if not allowed; use manual iteration instead.",
          "For Unicode characters like emoji, this naive approach may split surrogate pairs incorrectly."
        ],
        "edgeCases": [
          "Empty string → returns `''`.",
          "Single character → unchanged.",
          "Palindrome → returns itself."
        ],
        "techniques": [
          "Iterating in reverse order.",
          "Using concatenation or array methods to reconstruct a string."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels",
        "js-capitalize-words"
      ],
      "resources": [
        {
          "title": "MDN – String.prototype.split()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split"
        },
        {
          "title": "MDN – String.prototype.concat()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat"
        }
      ]
    },
    "tests": "import reverseString from './reverseString';\n\ndescribe('reverseString', () => {\n  test('reverses simple strings', () => {\n    expect(reverseString('abc')).toBe('cba');\n    expect(reverseString('hello')).toBe('olleh');\n  });\n\n  test('handles palindromes', () => {\n    expect(reverseString('racecar')).toBe('racecar');\n  });\n\n  test('reverses with spaces and punctuation', () => {\n    expect(reverseString('A man, a plan')).toBe('nalp a ,nam A');\n  });\n\n  test('handles empty and single character', () => {\n    expect(reverseString('')).toBe('');\n    expect(reverseString('x')).toBe('x');\n  });\n});\n",
    "testsTs": "import reverseString from './reverseString';\n\ndescribe('reverseString (TypeScript)', () => {\n  it('reverses simple strings', () => {\n    expect(reverseString('abc')).toBe('cba');\n    expect(reverseString('hello')).toBe('olleh');\n  });\n\n  it('handles palindromes', () => {\n    expect(reverseString('racecar')).toBe('racecar');\n  });\n\n  it('reverses with spaces and punctuation', () => {\n    expect(reverseString('A man, a plan')).toBe('nalp a ,nam A');\n  });\n\n  it('handles empty and single character', () => {\n    expect(reverseString('')).toBe('');\n    expect(reverseString('x')).toBe('x');\n  });\n});\n"
  },
  {
    "id": "js-count-vowels",
    "title": "Count Vowels",
    "type": "coding",
    "importance": 2,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `countVowels(str)` that returns how many vowels (`a, e, i, o, u`) exist in a given string, regardless of case.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to analyze."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The number of vowels found in the string."
      },
      "examples": [
        "// Basic examples\ncountVowels('hello') // => 2",
        "countVowels('rhythm') // => 0",
        "countVowels('AEIOU') // => 5",
        "// Mixed case and spaces\ncountVowels('A quick brown fox') // => 5"
      ]
    },
    "starterCode": "export default function countVowels(str) {\n  // TODO: Return how many vowels (a, e, i, o, u) are in the string\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function countVowels(str: string): number {\n  // TODO: Return how many vowels (a, e, i, o, u) are in the string\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: count how many vowels (`a, e, i, o, u`) appear in a given string, ignoring case. This tests string traversal, character comparison, and basic logic building.",
      "approaches": [
        {
          "title": "Approach 1: Iterative counting (explicit and clear)",
          "prose": "Idea: iterate through each character, normalize to lowercase, and count if it’s one of `aeiou`.\n\nHow it works\n1. Define a string of vowels: `const vowels = 'aeiou'`.\n2. Initialize `count = 0`.\n3. Loop through each character `ch` in `str.toLowerCase()`.\n4. If `vowels.includes(ch)`, increment `count`.\n5. Return the total count.\n\nWhy use it: clear, efficient (O(n)), and works for any casing. Great for learning iteration and conditionals.",
          "codeJs": "export default function countVowels(str) {\n  const vowels = 'aeiou';\n  let count = 0;\n  for (const ch of str.toLowerCase()) {\n    if (vowels.includes(ch)) count++;\n  }\n  return count;\n}\n",
          "codeTs": "export default function countVowels(str: string): number {\n  const vowels = 'aeiou';\n  let count = 0;\n  for (const ch of str.toLowerCase()) {\n    if (vowels.includes(ch)) count++;\n  }\n  return count;\n}\n"
        },
        {
          "title": "Approach 2: Regular expression (concise alternative)",
          "prose": "Idea: use a regular expression to directly match all vowels.\n\nUse `(str.match(/[aeiou]/gi) || []).length` to count matches.\n\nRead it as: *find all vowels (case-insensitive) and count them*.\n\nWhy use it: shorter and declarative, though less explicit than manual iteration. Good when you’re comfortable with regex.",
          "codeJs": "export default function countVowels(str) {\n  return (str.match(/[aeiou]/gi) || []).length;\n}\n",
          "codeTs": "export default function countVowels(str: string): number {\n  return (str.match(/[aeiou]/gi) || []).length;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Empty strings should return `0`.",
          "Regex approach may be less intuitive for beginners.",
          "Non-letter characters are simply skipped, no need for extra checks."
        ],
        "edgeCases": [
          "No vowels → returns `0`.",
          "Mixed case → handled by `toLowerCase()` or `/i` flag.",
          "Accented vowels (é, ü) → not counted unless explicitly included."
        ],
        "techniques": [
          "String traversal and membership checking.",
          "Regex matching and array length extraction."
        ]
      },
      "followUpQuestions": [
        "js-reverse-string",
        "js-capitalize-words"
      ],
      "resources": [
        {
          "title": "MDN – String.prototype.includes()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes"
        },
        {
          "title": "MDN – RegExp.prototype.match()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match"
        }
      ]
    },
    "tests": "import countVowels from './countVowels';\n\ndescribe('countVowels', () => {\n  test('counts lowercase vowels', () => {\n    expect(countVowels('hello')).toBe(2);\n    expect(countVowels('rhythm')).toBe(0);\n  });\n\n  test('counts uppercase vowels', () => {\n    expect(countVowels('AEIOU')).toBe(5);\n  });\n\n  test('counts vowels in mixed case and spaces', () => {\n    expect(countVowels('A quick brown fox')).toBe(5);\n  });\n\n  test('handles empty string', () => {\n    expect(countVowels('')).toBe(0);\n  });\n});\n",
    "testsTs": "import countVowels from './countVowels';\n\ndescribe('countVowels (TypeScript)', () => {\n  it('counts lowercase vowels', () => {\n    expect(countVowels('hello')).toBe(2);\n    expect(countVowels('rhythm')).toBe(0);\n  });\n\n  it('counts uppercase vowels', () => {\n    expect(countVowels('AEIOU')).toBe(5);\n  });\n\n  it('counts vowels in mixed case and spaces', () => {\n    expect(countVowels('A quick brown fox')).toBe(5);\n  });\n\n  it('handles empty string', () => {\n    expect(countVowels('')).toBe(0);\n  });\n});\n"
  },
  {
    "id": "js-flatten-once",
    "title": "Flatten One Level",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `flattenOnce(arr)` that flattens a nested array by **one level only**. Elements that are not arrays should remain unchanged.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "The input array which may contain nested arrays."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array flattened by one level."
      },
      "examples": [
        "// Basic example\nflattenOnce([1, [2, 3], [4, [5]]]) // => [1, 2, 3, 4, [5]]",
        "// Already flat\nflattenOnce([1, 2, 3]) // => [1, 2, 3]",
        "// Mixed values\nflattenOnce([[1], 2, [3, [4]], 5]) // => [1, 2, 3, [4], 5]"
      ]
    },
    "starterCode": "export default function flattenOnce(arr) {\n  // TODO: Flatten one level deep\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function flattenOnce(arr: any[]): any[] {\n  // TODO: Flatten one level deep\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: unpack only the **first layer** of nested arrays (shallow flatten). Deeper arrays remain nested. This tests understanding of array iteration and type checking.",
      "approaches": [
        {
          "title": "Approach 1: Iterative spread (explicit and clear)",
          "prose": "Idea: build a new array and check each element. If it's an array, spread its contents into the result; otherwise, add it directly.\n\nHow it works\n1. Initialize `const result = []`.\n2. Loop through every element in `arr`.\n3. If `Array.isArray(el)`, push `...el` into `result`.\n4. Else push `el` directly.\n5. Return `result`.\n\nWhy use it: straightforward, readable, and O(n). Perfect for learning how shallow flattening works without recursion.",
          "codeJs": "export default function flattenOnce(arr) {\n  const result = [];\n  for (const el of arr) {\n    if (Array.isArray(el)) {\n      result.push(...el);\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flattenOnce(arr: any[]): any[] {\n  const result: any[] = [];\n  for (const el of arr) {\n    if (Array.isArray(el)) {\n      result.push(...el);\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using built-in `.flat(1)` (compact modern syntax)",
          "prose": "Idea: use the modern `Array.prototype.flat()` method with depth `1`.\n\nUse `arr.flat(1)` to flatten a single level automatically.\n\nRead it as: *flatten one layer deep and leave inner arrays untouched*.\n\nWhy use it: concise, modern, and optimized. However, it’s useful to understand the manual approach first to grasp how flattening works internally.",
          "codeJs": "export default function flattenOnce(arr) {\n  return arr.flat(1);\n}\n",
          "codeTs": "export default function flattenOnce(arr: any[]): any[] {\n  return arr.flat(1);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Flattening too deeply defeats the 'one-level' requirement — avoid recursion or `.flat(Infinity)`.",
          "Mutating the original array is not allowed — always return a new one.",
          "Non-array values should remain untouched."
        ],
        "edgeCases": [
          "Empty array → returns `[]`.",
          "Already flat array → identical output.",
          "Mixed values like `[1, [2], 3]` → flattens only first-level arrays."
        ],
        "techniques": [
          "Using `Array.isArray()` for type checking.",
          "Using spread syntax (`...`) for shallow unpacking.",
          "Understanding `.flat(depth)` for modern concise implementations."
        ]
      },
      "followUpQuestions": [
        "js-flatten-depth"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.flat()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat"
        },
        {
          "title": "MDN – Array.isArray()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
        }
      ]
    },
    "tests": "import flattenOnce from './flattenOnce';\n\ndescribe('flattenOnce', () => {\n  test('flattens a simple nested array', () => {\n    expect(flattenOnce([1, [2, 3], [4, [5]]])).toEqual([1, 2, 3, 4, [5]]);\n  });\n\n  test('returns same array when already flat', () => {\n    expect(flattenOnce([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n\n  test('handles mixed array contents', () => {\n    expect(flattenOnce([[1], 2, [3, [4]], 5])).toEqual([1, 2, 3, [4], 5]);\n  });\n\n  test('returns empty array for empty input', () => {\n    expect(flattenOnce([])).toEqual([]);\n  });\n});\n",
    "testsTs": "import flattenOnce from './flattenOnce';\n\ndescribe('flattenOnce (TypeScript)', () => {\n  it('flattens a simple nested array', () => {\n    expect(flattenOnce([1, [2, 3], [4, [5]]])).toEqual([1, 2, 3, 4, [5]]);\n  });\n\n  it('returns same array when already flat', () => {\n    expect(flattenOnce([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n\n  it('handles mixed array contents', () => {\n    expect(flattenOnce([[1], 2, [3, [4]], 5])).toEqual([1, 2, 3, [4], 5]);\n  });\n\n  it('returns empty array for empty input', () => {\n    expect(flattenOnce([])).toEqual([]);\n  });\n});\n"
  },
  {
    "id": "js-unique-array",
    "title": "Remove Duplicates",
    "type": "coding",
    "importance": 4,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `unique(arr)` that returns a new array with duplicate values removed. The **original order** of elements must be preserved.",
      "arguments": [
        {
          "name": "arr",
          "type": "T[]",
          "desc": "An array of items that may contain duplicates."
        }
      ],
      "returns": {
        "type": "T[]",
        "desc": "A new array with only unique elements, preserving their first occurrence order."
      },
      "examples": [
        "// Basic example\nunique([1, 2, 2, 3, 1]) // => [1, 2, 3]",
        "// Works with strings\nunique(['a', 'b', 'a', 'c', 'b']) // => ['a', 'b', 'c']",
        "// Mixed types\nunique([1, '1', 1]) // => [1, '1']"
      ]
    },
    "starterCode": "export default function unique(arr) {\n  // TODO: Return new array with duplicates removed\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function unique<T>(arr: T[]): T[] {\n  // TODO: Return new array with duplicates removed\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: return a new array that contains each value only once — keeping the first occurrence and preserving order. This teaches efficient use of data structures like `Set`.",
      "approaches": [
        {
          "title": "Approach 1: Using a Set to track seen values (explicit control)",
          "prose": "Idea: use a `Set` to record which elements have been encountered. Iterate through `arr` and only push values you haven’t seen yet.\n\n### 🧠 Step-by-step reasoning\n1. Initialize an empty `Set` → `const seen = new Set()`.\n2. Initialize `const result = []`.\n3. Loop through every element `item` in `arr`.\n4. If `!seen.has(item)` → add to both `seen` and `result`.\n5. Return `result`.\n\nWhy use it: this method is efficient (O(n)) and preserves original order, since elements are added in the order they first appear.",
          "codeJs": "export default function unique(arr) {\n  const seen = new Set();\n  const result = [];\n  for (const item of arr) {\n    if (!seen.has(item)) {\n      seen.add(item);\n      result.push(item);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  const seen = new Set<T>();\n  const result: T[] = [];\n  for (const item of arr) {\n    if (!seen.has(item)) {\n      seen.add(item);\n      result.push(item);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using `new Set()` directly (compact form)",
          "prose": "Idea: leverage the fact that a `Set` automatically removes duplicates.\n\nUse `[...new Set(arr)]` to instantly produce a deduplicated array.\n\nWhy use it: clean and elegant one-liner, ideal when order preservation and value equality semantics are fine as-is (strict equality).",
          "codeJs": "export default function unique(arr) {\n  return [...new Set(arr)];\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  return [...new Set(arr)];\n}\n"
        },
        {
          "title": "Approach 3: Using `filter()` and `indexOf()` (less efficient)",
          "prose": "Idea: only keep items where their first occurrence index matches the current index.\n\nUse `arr.filter((item, idx) => arr.indexOf(item) === idx)`.\n\nWhy use it: clear for learning, but slower (O(n²)) since each `indexOf` scan starts from the beginning.",
          "codeJs": "export default function unique(arr) {\n  return arr.filter((item, idx) => arr.indexOf(item) === idx);\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  return arr.filter((item, idx) => arr.indexOf(item) === idx);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Comparisons are done using strict equality (`===`), so `1` and `'1'` are treated differently.",
          "Objects and arrays are compared by reference, not structure.",
          "Avoid using `filter + indexOf` for very large arrays due to quadratic performance."
        ],
        "edgeCases": [
          "Empty array → returns `[]`.",
          "Already unique array → unchanged.",
          "All duplicates → only first kept."
        ],
        "techniques": [
          "Using `Set` for uniqueness tracking.",
          "Maintaining insertion order manually.",
          "Using spread syntax (`...`) for conversion."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN – Set",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"
        },
        {
          "title": "MDN – Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        }
      ]
    },
    "tests": "import unique from './unique';\n\ndescribe('unique', () => {\n  test('removes duplicates from numbers', () => {\n    expect(unique([1, 2, 2, 3, 1])).toEqual([1, 2, 3]);\n  });\n\n  test('works with strings', () => {\n    expect(unique(['a', 'b', 'a', 'c', 'b'])).toEqual(['a', 'b', 'c']);\n  });\n\n  test('handles mixed types', () => {\n    expect(unique([1, '1', 1])).toEqual([1, '1']);\n  });\n\n  test('returns empty array when input is empty', () => {\n    expect(unique([])).toEqual([]);\n  });\n\n  test('returns identical array when all unique', () => {\n    expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "import unique from './unique';\n\ndescribe('unique (TypeScript)', () => {\n  it('removes duplicates from numbers', () => {\n    expect(unique([1, 2, 2, 3, 1])).toEqual([1, 2, 3]);\n  });\n\n  it('works with strings', () => {\n    expect(unique(['a', 'b', 'a', 'c', 'b'])).toEqual(['a', 'b', 'c']);\n  });\n\n  it('handles mixed types', () => {\n    expect(unique([1, '1', 1])).toEqual([1, '1']);\n  });\n\n  it('returns empty array when input is empty', () => {\n    expect(unique([])).toEqual([]);\n  });\n\n  it('returns identical array when all unique', () => {\n    expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n});\n"
  },
  {
    "id": "js-max-char",
    "title": "Find Maximum Occurring Character",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `maxChar(str)` that returns the character that appears most frequently in a string.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to analyze."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "The single character with the highest frequency of occurrence."
      },
      "examples": [
        "// Basic examples\nmaxChar('hello') // => 'l'\nmaxChar('aabbbcc') // => 'b'\nmaxChar('abcccccccd') // => 'c'\n// When multiple characters tie, return the first one found\nmaxChar('aabb') // => 'a'"
      ]
    },
    "starterCode": "export default function maxChar(str) {\n  // TODO: Return the most frequent character in the string\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function maxChar(str: string): string {\n  // TODO: Return the most frequent character in the string\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: identify the most frequently occurring character in a string using character frequency analysis. This problem introduces you to **hash map counting** — a powerful technique for many algorithmic challenges.",
      "approaches": [
        {
          "title": "Approach 1: Frequency map with a loop (efficient and clear)",
          "prose": "Idea: use an object as a frequency counter. Traverse the string once, count occurrences, and track the character with the highest frequency.\n\n### 🧠 Step-by-step reasoning\n1. Initialize an empty object `charCount = {}`.\n2. Initialize `max = 0` and `maxChar = ''`.\n3. Loop through each character `ch` in the string.\n4. For each one:\n   - Increment `charCount[ch] = (charCount[ch] || 0) + 1`.\n   - If `charCount[ch] > max`, update `max` and `maxChar`.\n5. Return `maxChar`.\n\nWhy use it: runs in **O(n)** time, uses **O(k)** space (unique chars), and gives clear control over tie-breaking order.",
          "codeJs": "export default function maxChar(str) {\n  if (!str) return '';\n  const charCount = {};\n  let max = 0;\n  let maxChar = '';\n\n  for (const ch of str) {\n    charCount[ch] = (charCount[ch] || 0) + 1;\n    if (charCount[ch] > max) {\n      max = charCount[ch];\n      maxChar = ch;\n    }\n  }\n\n  return maxChar;\n}\n",
          "codeTs": "export default function maxChar(str: string): string {\n  if (!str) return '';\n  const charCount: Record<string, number> = {};\n  let max = 0;\n  let maxChar = '';\n\n  for (const ch of str) {\n    charCount[ch] = (charCount[ch] || 0) + 1;\n    if (charCount[ch] > max) {\n      max = charCount[ch];\n      maxChar = ch;\n    }\n  }\n\n  return maxChar;\n}\n"
        },
        {
          "title": "Approach 2: Using `reduce()` for a functional style",
          "prose": "Idea: build the frequency map using `Array.prototype.reduce()` and then find the max key.\n\nWhy use it: more functional and concise but slightly less intuitive for beginners.",
          "codeJs": "export default function maxChar(str) {\n  if (!str) return '';\n  const freq = [...str].reduce((acc, ch) => {\n    acc[ch] = (acc[ch] || 0) + 1;\n    return acc;\n  }, {});\n\n  let maxChar = '';\n  let max = 0;\n  for (const [ch, count] of Object.entries(freq)) {\n    if (count > max) {\n      max = count;\n      maxChar = ch;\n    }\n  }\n  return maxChar;\n}\n",
          "codeTs": "export default function maxChar(str: string): string {\n  if (!str) return '';\n  const freq = Array.from(str).reduce<Record<string, number>>((acc, ch) => {\n    acc[ch] = (acc[ch] || 0) + 1;\n    return acc;\n  }, {});\n\n  let maxChar = '';\n  let max = 0;\n  for (const [ch, count] of Object.entries(freq)) {\n    if (count > max) {\n      max = count;\n      maxChar = ch;\n    }\n  }\n  return maxChar;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Do not forget to handle the empty string case — should return `''`.",
          "Comparisons are case-sensitive (`'A'` and `'a'` are different).",
          "Ties should return the first character that reaches the max count."
        ],
        "edgeCases": [
          "Empty string → `''`.",
          "All unique → returns the first character.",
          "Multiple max chars → returns the earliest one."
        ],
        "techniques": [
          "Using frequency maps (hash tables) for counting occurrences.",
          "Tracking max value during iteration for efficiency.",
          "Understanding O(n) iteration patterns."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels"
      ],
      "resources": [
        {
          "title": "MDN – Object.entries()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"
        },
        {
          "title": "MDN – for...of statement",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"
        }
      ]
    },
    "tests": "import maxChar from './maxChar';\n\ndescribe('maxChar', () => {\n  test('finds the most common letter', () => {\n    expect(maxChar('hello')).toBe('l');\n  });\n\n  test('works with multiple repetitions', () => {\n    expect(maxChar('aabbbcc')).toBe('b');\n    expect(maxChar('abcccccccd')).toBe('c');\n  });\n\n  test('returns first character when tie', () => {\n    expect(maxChar('aabb')).toBe('a');\n  });\n\n  test('returns empty string when input is empty', () => {\n    expect(maxChar('')).toBe('');\n  });\n});\n",
    "testsTs": "import maxChar from './maxChar';\n\ndescribe('maxChar (TypeScript)', () => {\n  it('finds the most common letter', () => {\n    expect(maxChar('hello')).toBe('l');\n  });\n\n  it('works with multiple repetitions', () => {\n    expect(maxChar('aabbbcc')).toBe('b');\n    expect(maxChar('abcccccccd')).toBe('c');\n  });\n\n  it('returns first character when tie', () => {\n    expect(maxChar('aabb')).toBe('a');\n  });\n\n  it('returns empty string when input is empty', () => {\n    expect(maxChar('')).toBe('');\n  });\n});\n"
  },
  {
    "id": "js-capitalize-words",
    "title": "Capitalize Words",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `capitalizeWords(sentence)` that returns the same string but with the first letter of each word capitalized.",
      "arguments": [
        {
          "name": "sentence",
          "type": "string",
          "desc": "A sentence consisting of one or more words separated by spaces."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "A new string where each word starts with an uppercase letter, and the rest of the word remains in lowercase."
      },
      "examples": [
        "// Basic examples",
        "capitalizeWords('hello world') // => 'Hello World'",
        "capitalizeWords('javascript is fun') // => 'Javascript Is Fun'",
        "// Handles extra spaces",
        "capitalizeWords('  welcome   to  earth  ') // => '  Welcome   To  Earth  '"
      ]
    },
    "starterCode": "export default function capitalizeWords(sentence) {\n  // TODO: Capitalize first letter of each word\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function capitalizeWords(sentence: string): string {\n  // TODO: Capitalize first letter of each word\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure each word in a sentence starts with an uppercase letter while preserving spacing and keeping the rest of the letters lowercase. This builds practical mastery over **string splitting, mapping, and joining**.",
      "approaches": [
        {
          "title": "Approach 1: Split–Map–Join (clean and readable)",
          "prose": "Idea: split the sentence into words, capitalize the first letter of each non-empty word, and then join them back together.\n\n### 🧠 Step-by-step reasoning\n1. Handle edge case: if input is empty, return `''`.\n2. Use `.split(' ')` to break the sentence by spaces.\n3. For each element in the array:\n   - If it’s an empty string (extra space), return it unchanged.\n   - Otherwise, capitalize with `word[0].toUpperCase() + word.slice(1).toLowerCase()`.\n4. Join the array back with `' '`.\n5. Return the result.\n\n**Why use it:** clear logic, preserves multiple spaces, and doesn’t require regex — a great approach for clarity and maintainability.",
          "codeJs": "export default function capitalizeWords(sentence) {\n  if (!sentence) return '';\n  return sentence\n    .split(' ')\n    .map(word => {\n      if (!word) return word;\n      return word[0].toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ');\n}\n",
          "codeTs": "export default function capitalizeWords(sentence: string): string {\n  if (!sentence) return '';\n  return sentence\n    .split(' ')\n    .map(word => {\n      if (!word) return word;\n      return word[0].toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ');\n}\n"
        },
        {
          "title": "Approach 2: Character iteration (manual traversal)",
          "prose": "Idea: iterate through each character and capitalize when the previous character is a space.\n\n### Steps\n1. Track a flag `capitalizeNext = true`.\n2. For each character `ch` in the string:\n   - If `capitalizeNext` is true and `ch` is a letter → convert to uppercase.\n   - Else → convert to lowercase.\n   - If `ch` is a space, set `capitalizeNext = true`; otherwise set it to false.\n3. Append each character to the result string.\n\n**Why use it:** avoids splitting/joining and works efficiently for very long strings or character-by-character logic.",
          "codeJs": "export default function capitalizeWords(sentence) {\n  if (!sentence) return '';\n  let result = '';\n  let capitalizeNext = true;\n\n  for (const ch of sentence) {\n    if (ch === ' ') {\n      result += ch;\n      capitalizeNext = true;\n    } else if (capitalizeNext) {\n      result += ch.toUpperCase();\n      capitalizeNext = false;\n    } else {\n      result += ch.toLowerCase();\n    }\n  }\n\n  return result;\n}\n",
          "codeTs": "export default function capitalizeWords(sentence: string): string {\n  if (!sentence) return '';\n  let result = '';\n  let capitalizeNext = true;\n\n  for (const ch of sentence) {\n    if (ch === ' ') {\n      result += ch;\n      capitalizeNext = true;\n    } else if (capitalizeNext) {\n      result += ch.toUpperCase();\n      capitalizeNext = false;\n    } else {\n      result += ch.toLowerCase();\n    }\n  }\n\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid trimming spaces — they must be preserved.",
          "Watch out for non-letter characters like punctuation; they should not affect capitalization rules.",
          "Always lowercase the rest of each word to ensure consistent formatting."
        ],
        "edgeCases": [
          "Empty string → `''`.",
          "Extra spaces between words → preserved.",
          "Already capitalized input → unchanged.",
          "Mixed casing → normalized to Title Case."
        ],
        "techniques": [
          "Using `.split()`, `.map()`, and `.join()` for immutable transformations.",
          "String iteration and character-based logic.",
          "Applying capitalization rules conditionally based on word boundaries."
        ]
      },
      "followUpQuestions": [
        "js-reverse-string"
      ],
      "resources": [
        {
          "title": "MDN – String.prototype.split()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split"
        },
        {
          "title": "MDN – String.prototype.toUpperCase()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase"
        }
      ]
    },
    "tests": "import capitalizeWords from './capitalizeWords';\n\ndescribe('capitalizeWords', () => {\n  test('capitalizes each word in a simple sentence', () => {\n    expect(capitalizeWords('hello world')).toBe('Hello World');\n  });\n\n  test('handles mixed casing', () => {\n    expect(capitalizeWords('jaVaScript IS fUn')).toBe('Javascript Is Fun');\n  });\n\n  test('preserves multiple spaces', () => {\n    expect(capitalizeWords('  welcome   to  earth  ')).toBe('  Welcome   To  Earth  ');\n  });\n\n  test('returns empty string for empty input', () => {\n    expect(capitalizeWords('')).toBe('');\n  });\n});\n",
    "testsTs": "import capitalizeWords from './capitalizeWords';\n\ndescribe('capitalizeWords (TypeScript)', () => {\n  it('capitalizes each word in a simple sentence', () => {\n    expect(capitalizeWords('hello world')).toBe('Hello World');\n  });\n\n  it('handles mixed casing', () => {\n    expect(capitalizeWords('jaVaScript IS fUn')).toBe('Javascript Is Fun');\n  });\n\n  it('preserves multiple spaces', () => {\n    expect(capitalizeWords('  welcome   to  earth  ')).toBe('  Welcome   To  Earth  ');\n  });\n\n  it('returns empty string for empty input', () => {\n    expect(capitalizeWords('')).toBe('');\n  });\n});\n"
  },
  {
    "id": "js-sum-numbers",
    "title": "Sum of Numbers in an Array",
    "type": "coding",
    "importance": 2,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `sum(arr)` that returns the total of all numeric elements in the array, ignoring non-numeric values.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array containing numbers and possibly other types (e.g., strings, booleans, nulls)."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The sum of all numeric elements in the array."
      },
      "examples": [
        "// Basic examples\nsum([1, 2, 3]) // => 6",
        "sum([10, '20', 30]) // => 40",
        "// Ignores non-numbers\nsum(['a', 5, true, 7]) // => 12",
        "// Handles empty array\nsum([]) // => 0"
      ]
    },
    "starterCode": "export default function sum(arr) {\n  // TODO: Return the sum of all numeric elements, ignoring non-numbers\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function sum(arr: any[]): number {\n  // TODO: Return the sum of all numeric elements, ignoring non-numbers\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: calculate the total sum of numeric values in an array, safely ignoring any non-numeric entries. This reinforces **type checking, iteration, and accumulator patterns** — fundamental for array manipulation tasks.",
      "approaches": [
        {
          "title": "Approach 1: Imperative loop (explicit and safe)",
          "prose": "Idea: iterate through each element and only add valid numbers to a running total.\n\n### 🧠 Step-by-step reasoning\n1. Initialize `let total = 0`.\n2. For each `el` in `arr`: If `typeof el === 'number' && !isNaN(el)`, add it to `total`.\n3. Return `total`.\n\n**Why use it:** simple, readable, and avoids hidden coercions. Runs in **O(n)** time with **O(1)** space.",
          "codeJs": "export default function sum(arr) {\n  let total = 0;\n  for (const el of arr) {\n    if (typeof el === 'number' && !isNaN(el)) {\n      total += el;\n    }\n  }\n  return total;\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  let total = 0;\n  for (const el of arr) {\n    if (typeof el === 'number' && !isNaN(el)) {\n      total += el;\n    }\n  }\n  return total;\n}\n"
        },
        {
          "title": "Approach 2: Filter + Reduce (functional style)",
          "prose": "Idea: first filter the array to only include numbers, then sum them using `reduce()`.\n\n### Steps\n1. Filter numeric values using `filter()`.\n2. Reduce them with an accumulator starting from 0.\n\n**Why use it:** concise and expressive, though slightly less explicit about validation.",
          "codeJs": "export default function sum(arr) {\n  return arr\n    .filter(el => typeof el === 'number' && !isNaN(el))\n    .reduce((total, el) => total + el, 0);\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  return arr\n    .filter((el): el is number => typeof el === 'number' && !isNaN(el))\n    .reduce((total, el) => total + el, 0);\n}\n"
        },
        {
          "title": "Approach 3: Reduce-only with inline check",
          "prose": "Idea: combine filtering and summing into a single `reduce()` call for compactness.\n\n**Why use it:** avoids creating an intermediate array — efficient for large datasets.",
          "codeJs": "export default function sum(arr) {\n  return arr.reduce((total, el) => {\n    if (typeof el === 'number' && !isNaN(el)) {\n      total += el;\n    }\n    return total;\n  }, 0);\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  return arr.reduce((total, el) => {\n    if (typeof el === 'number' && !isNaN(el)) {\n      total += el;\n    }\n    return total;\n  }, 0);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid coercing numeric strings — `'20'` should not automatically convert unless explicitly cast.",
          "Skip `NaN` to prevent result corruption.",
          "Ensure non-numeric falsy values like `false` or `null` are not counted."
        ],
        "edgeCases": [
          "Empty array → returns `0`.",
          "All non-numeric → returns `0`.",
          "Includes `NaN` → ignored.",
          "Mixed types → only numbers contribute to total."
        ],
        "techniques": [
          "Type checking with `typeof` and `isNaN`.",
          "Using loops vs. functional array methods.",
          "Accumulator logic for numeric aggregation."
        ]
      },
      "followUpQuestions": [
        "js-flatten-once"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        },
        {
          "title": "MDN – Number.isNaN()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"
        }
      ]
    },
    "tests": "import sum from './sum';\n\ndescribe('sum', () => {\n  test('sums numbers in a simple array', () => {\n    expect(sum([1, 2, 3])).toBe(6);\n  });\n\n  test('ignores non-numeric values', () => {\n    expect(sum(['a', 5, true, 7])).toBe(12);\n  });\n\n  test('handles mixed numeric strings gracefully', () => {\n    expect(sum([10, '20', 30])).toBe(40);\n  });\n\n  test('returns 0 for empty or all-non-numeric arrays', () => {\n    expect(sum([])).toBe(0);\n    expect(sum(['x', false, null])).toBe(0);\n  });\n});\n",
    "testsTs": "import sum from './sum';\n\ndescribe('sum (TypeScript)', () => {\n  it('sums numbers in a simple array', () => {\n    expect(sum([1, 2, 3])).toBe(6);\n  });\n\n  it('ignores non-numeric values', () => {\n    expect(sum(['a', 5, true, 7])).toBe(12);\n  });\n\n  it('handles mixed numeric strings gracefully', () => {\n    expect(sum([10, '20', 30])).toBe(40);\n  });\n\n  it('returns 0 for empty or all-non-numeric arrays', () => {\n    expect(sum([])).toBe(0);\n    expect(sum(['x', false, null])).toBe(0);\n  });\n});\n"
  },
  {
    "id": "js-compact",
    "title": "Falsy Bouncer",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `compact(arr)` that removes all falsy values (`false`, `0`, `''`, `null`, `undefined`, `NaN`) from an array.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array containing any types of elements, including falsy values."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array with all falsy values removed."
      },
      "examples": [
        "// Basic examples\ncompact([0, 1, false, 2, '', 3]) // => [1, 2, 3]",
        "// Works with only truthy values\ncompact(['a', true, 42]) // => ['a', true, 42]",
        "// Handles null and undefined\ncompact([null, undefined, 'x']) // => ['x']",
        "// Handles NaN\ncompact([NaN, 1, 2]) // => [1, 2]"
      ]
    },
    "starterCode": "export default function compact(arr) {\n  // TODO: Remove all falsy values from the array\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function compact(arr: any[]): any[] {\n  // TODO: Remove all falsy values from the array\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: remove all falsy values (`false`, `0`, `''`, `null`, `undefined`, `NaN`) from an array while preserving order. This task reinforces **truthy/falsy coercion** and the use of **functional array methods** like `filter()`.",
      "approaches": [
        {
          "title": "Approach 1: Using filter(Boolean) (concise and expressive)",
          "prose": "Idea: rely on JavaScript's truthy/falsy evaluation — since falsy values convert to `false` in boolean context, `filter(Boolean)` automatically removes them.\n\n### 🧠 Step-by-step reasoning\n1. Call `arr.filter(Boolean)`.\n2. The `Boolean` function converts each value to a boolean.\n3. Falsy values (like `0`, `false`, `''`, `null`, `undefined`, `NaN`) are filtered out.\n\nRuns in **O(n)** time and requires **O(n)** space for the new array. Clean and idiomatic.",
          "codeJs": "export default function compact(arr) {\n  return arr.filter(Boolean);\n}\n",
          "codeTs": "export default function compact(arr: any[]): any[] {\n  return arr.filter(Boolean);\n}\n"
        },
        {
          "title": "Approach 2: Manual filtering with explicit check",
          "prose": "Idea: explicitly iterate and push only truthy elements to a new array. Slightly longer but clearer for beginners.\n\n### Steps\n1. Initialize an empty array `result = []`.\n2. For each element, check if it’s truthy (`if (el)`).\n3. If true, push it into `result`.\n4. Return `result`.",
          "codeJs": "export default function compact(arr) {\n  const result = [];\n  for (const el of arr) {\n    if (el) result.push(el);\n  }\n  return result;\n}\n",
          "codeTs": "export default function compact(arr: any[]): any[] {\n  const result: any[] = [];\n  for (const el of arr) {\n    if (el) result.push(el);\n  }\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid accidentally removing values like `0` or `''` if they are intentionally needed — this method removes all falsy values.",
          "Be aware that `NaN` is also falsy and will be removed."
        ],
        "edgeCases": [
          "Empty array → returns `[]`.",
          "Array with all falsy values → returns `[]`.",
          "Mixed types → only truthy ones remain."
        ],
        "techniques": [
          "Using Boolean coercion in array filtering.",
          "Understanding truthy/falsy evaluation in JavaScript.",
          "Preserving array order during filtering."
        ]
      },
      "followUpQuestions": [
        "js-unique-array"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        },
        {
          "title": "MDN – Boolean() constructor",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"
        }
      ]
    },
    "tests": "import compact from './compact';\n\ndescribe('compact', () => {\n  test('removes falsy values', () => {\n    expect(compact([0, 1, false, 2, '', 3])).toEqual([1, 2, 3]);\n  });\n\n  test('returns same array when all truthy', () => {\n    expect(compact(['a', true, 42])).toEqual(['a', true, 42]);\n  });\n\n  test('removes null and undefined', () => {\n    expect(compact([null, undefined, 'x'])).toEqual(['x']);\n  });\n\n  test('removes NaN', () => {\n    expect(compact([NaN, 1, 2])).toEqual([1, 2]);\n  });\n\n  test('handles empty array', () => {\n    expect(compact([])).toEqual([]);\n  });\n});\n",
    "testsTs": "import compact from './compact';\n\ndescribe('compact (TypeScript)', () => {\n  it('removes falsy values', () => {\n    expect(compact([0, 1, false, 2, '', 3])).toEqual([1, 2, 3]);\n  });\n\n  it('returns same array when all truthy', () => {\n    expect(compact(['a', true, 42])).toEqual(['a', true, 42]);\n  });\n\n  it('removes null and undefined', () => {\n    expect(compact([null, undefined, 'x'])).toEqual(['x']);\n  });\n\n  it('removes NaN', () => {\n    expect(compact([NaN, 1, 2])).toEqual([1, 2]);\n  });\n\n  it('handles empty array', () => {\n    expect(compact([])).toEqual([]);\n  });\n});\n"
  },
  {
    "id": "js-arrays-equal",
    "title": "Check if Two Arrays Are Equal",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `arraysEqual(a, b)` that returns `true` if both arrays contain the same elements in the same order.",
      "arguments": [
        {
          "name": "a",
          "type": "any[]",
          "desc": "The first array to compare."
        },
        {
          "name": "b",
          "type": "any[]",
          "desc": "The second array to compare."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if both arrays are identical in length and elements (in the same order), otherwise `false`."
      },
      "examples": [
        "// Basic examples\narraysEqual([1, 2, 3], [1, 2, 3]) // => true",
        "arraysEqual([1, 2, 3], [3, 2, 1]) // => false",
        "// Different lengths\narraysEqual([1, 2], [1, 2, 3]) // => false",
        "// Works with strings\narraysEqual(['a', 'b'], ['a', 'b']) // => true",
        "// Works with mixed types\narraysEqual([1, '2', 3], [1, 2, 3]) // => false"
      ]
    },
    "starterCode": "export default function arraysEqual(a, b) {\n  // TODO: Return true if both arrays contain the same elements in the same order\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  // TODO: Return true if both arrays contain the same elements in the same order\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: verify if two arrays are identical in both length and element order. This exercise focuses on **iteration, index-based comparison**, and **strict equality** to ensure accuracy.",
      "approaches": [
        {
          "title": "Approach 1: Loop-based comparison (explicit and efficient)",
          "prose": "Idea: iterate through both arrays, comparing elements at each index.\n\n### 🧠 Step-by-step reasoning\n1. Check if lengths differ — if yes, return `false`.\n2. Loop through all indices using a `for` loop.\n3. Compare each pair of elements with strict equality (`!==`).\n4. Return `false` immediately upon a mismatch.\n5. If all elements match, return `true`.\n\nRuns in **O(n)** time with **O(1)** space and avoids unnecessary object conversions.",
          "codeJs": "export default function arraysEqual(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n"
        },
        {
          "title": "Approach 2: Using every() (declarative style)",
          "prose": "Idea: use the `Array.prototype.every()` method to check that every element matches its counterpart.\n\n### Steps\n1. Compare array lengths first.\n2. If lengths are equal, use `a.every((el, i) => el === b[i])`.\n3. Return the result.\n\nThis version is more functional and concise, but slightly less explicit for debugging.",
          "codeJs": "export default function arraysEqual(a, b) {\n  return a.length === b.length && a.every((el, i) => el === b[i]);\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  return a.length === b.length && a.every((el, i) => el === b[i]);\n}\n"
        },
        {
          "title": "Approach 3: JSON stringify shortcut (not recommended for deep or mixed data)",
          "prose": "Idea: serialize both arrays to JSON strings and compare them directly.\n\n### Steps\n1. Convert both arrays using `JSON.stringify()`.\n2. Compare strings with `===`.\n\nWhile compact, this approach can fail with nested arrays, differing object key order, or special values like `undefined`.",
          "codeJs": "export default function arraysEqual(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Strict equality (`===`) does not perform deep comparison for objects or arrays.",
          "Avoid relying on `JSON.stringify` for nested structures or when order of keys may differ.",
          "Be aware that `['1']` and `[1]` are not considered equal due to type difference."
        ],
        "edgeCases": [
          "Empty arrays → `true`.",
          "Different lengths → `false`.",
          "Different order → `false`.",
          "Mixed types → `false`.",
          "Nested arrays → compared by reference, not deep structure."
        ],
        "techniques": [
          "Using `every()` for element-wise comparison.",
          "Loop-based early return for efficiency.",
          "Understanding reference vs. value equality in JavaScript."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.every()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every"
        },
        {
          "title": "MDN – Equality comparisons and sameness",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness"
        }
      ]
    },
    "tests": "import arraysEqual from './arraysEqual';\n\ndescribe('arraysEqual', () => {\n  test('returns true for identical arrays', () => {\n    expect(arraysEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  });\n\n  test('returns false for different element order', () => {\n    expect(arraysEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  test('returns false for different lengths', () => {\n    expect(arraysEqual([1, 2], [1, 2, 3])).toBe(false);\n  });\n\n  test('works with string arrays', () => {\n    expect(arraysEqual(['a', 'b'], ['a', 'b'])).toBe(true);\n  });\n\n  test('returns false for mixed type differences', () => {\n    expect(arraysEqual([1, '2', 3], [1, 2, 3])).toBe(false);\n  });\n\n  test('handles empty arrays', () => {\n    expect(arraysEqual([], [])).toBe(true);\n  });\n});\n",
    "testsTs": "import arraysEqual from './arraysEqual';\n\ndescribe('arraysEqual (TypeScript)', () => {\n  it('returns true for identical arrays', () => {\n    expect(arraysEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  });\n\n  it('returns false for different element order', () => {\n    expect(arraysEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  it('returns false for different lengths', () => {\n    expect(arraysEqual([1, 2], [1, 2, 3])).toBe(false);\n  });\n\n  it('works with string arrays', () => {\n    expect(arraysEqual(['a', 'b'], ['a', 'b'])).toBe(true);\n  });\n\n  it('returns false for mixed type differences', () => {\n    expect(arraysEqual([1, '2', 3], [1, 2, 3])).toBe(false);\n  });\n\n  it('handles empty arrays', () => {\n    expect(arraysEqual([], [])).toBe(true);\n  });\n});\n"
  },
  {
    "id": "js-debounce",
    "title": "Debounce Function",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "difficulty": "medium",
    "tags": [
      "async",
      "timing",
      "function"
    ],
    "description": {
      "summary": "Implement a function `debounce(fn, delay)` that delays the execution of `fn` until a specified time (`delay` ms) has passed since the last invocation.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The function to be executed after the delay."
        },
        {
          "name": "delay",
          "type": "number",
          "desc": "The number of milliseconds to wait before executing the function."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A debounced version of the original function that delays execution until the delay period has elapsed."
      },
      "examples": [
        "// Basic examples\ndebounce(() => console.log('Hello!'), 300)",
        "// Multiple rapid calls — only last one runs\nconst log = debounce(() => console.log('Run!'), 500)\nlog()\nlog()\nlog() // Only this one executes after 500ms",
        "// With arguments\nconst greet = debounce(name => console.log(`Hi ${name}`), 400)\ngreet('Alice')\ngreet('Bob') // Only 'Hi Bob' logs after 400ms"
      ]
    },
    "starterCode": "export default function debounce(fn, delay) {\n  // TODO: Return a debounced function that delays execution until delay ms have passed\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): F {\n  // TODO: Return a debounced function that delays execution until delay ms have passed\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure `fn` runs only after calls have stopped for `delay` ms. Common in search inputs, resize/scroll handlers, and deduping rapid UI events.",
      "approaches": [
        {
          "title": "Approach 1: Timeout-based debounce (canonical)",
          "prose": "Idea: store a `timeoutId`. Each call clears the previous timeout and schedules a new one. When the last timer completes, invoke `fn` with the latest args and `this`.\n\n### Step-by-step\n1. Keep `let timeoutId` in the closure.\n2. On each call, `clearTimeout(timeoutId)`.\n3. Set `timeoutId = setTimeout(() => fn.apply(this, args), delay)`.\n4. Return the debounced function.",
          "codeJs": "export default function debounce(fn, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n",
          "codeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): F {\n  let timeoutId: ReturnType<typeof setTimeout>;\n  return function(this: any, ...args: Parameters<F>) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  } as F;\n}\n"
        },
        {
          "title": "Approach 2: Debounce with cancel + flush helpers",
          "prose": "Idea: expose controls to cancel a pending call or run it immediately.\n\n### Steps\n1. Wrap the debounced fn and attach `.cancel()` to clear the timer.\n2. Attach `.flush()` to immediately invoke the pending call (if any).",
          "codeJs": "export default function debounce(fn, delay) {\n  let timeoutId, lastArgs, lastThis;\n  function debounced(...args) {\n    lastArgs = args; lastThis = this;\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }, delay);\n  }\n  debounced.cancel = () => clearTimeout(timeoutId);\n  debounced.flush = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }\n  };\n  return debounced;\n}\n",
          "codeTs": "type Debounced<F extends (...a: any[]) => void> = F & { cancel: () => void; flush: () => void };\nexport default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): Debounced<F> {\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  let lastArgs: Parameters<F>; let lastThis: any;\n  const debounced = function(this: any, ...args: Parameters<F>) {\n    lastArgs = args; lastThis = this;\n    if (timeoutId) clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }, delay);\n  } as Debounced<F>;\n  debounced.cancel = () => { if (timeoutId) clearTimeout(timeoutId); };\n  debounced.flush = () => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }\n  };\n  return debounced;\n}\n"
        },
        {
          "title": "Approach 3: Leading-edge option (invoke first, then debounce)",
          "prose": "Idea: allow an immediate call on the first trigger, then silence until inactivity. Useful for instant feedback with suppression of follow-ups.",
          "codeJs": "export default function debounce(fn, delay, { leading = false } = {}) {\n  let timeoutId, invoked = false;\n  return function(...args) {\n    const callNow = leading && !timeoutId;\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => { timeoutId = undefined; invoked = false; }, delay);\n    if (callNow && !invoked) { invoked = true; fn.apply(this, args); }\n    else if (!leading) {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => fn.apply(this, args), delay);\n    }\n  };\n}\n",
          "codeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number, opts: { leading?: boolean } = {}): F {\n  const { leading = false } = opts;\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  let invoked = false;\n  return function(this: any, ...args: Parameters<F>) {\n    const callNow = leading && !timeoutId;\n    if (timeoutId) clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => { timeoutId = undefined; invoked = false; }, delay);\n    if (callNow && !invoked) { invoked = true; fn.apply(this, args); }\n    else if (!leading) {\n      if (timeoutId) clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => fn.apply(this, args), delay);\n    }\n  } as F;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Return value is lost; debounced wrappers usually return `void`. If a return value is required, consider callbacks/promises.",
          "Be careful with `this` — use `fn.apply(this, args)` to preserve caller context.",
          "Timers differ between environments (Node vs browser) but `setTimeout/clearTimeout` work in both."
        ],
        "edgeCases": [
          "delay = 0 → behaves like micro-batching calls at the end of the event loop.",
          "Rapid continuous calls → only the last invocation executes after inactivity.",
          "Component unmount/dispose → call `.cancel()` to avoid stray executions."
        ],
        "techniques": [
          "Closures to store timer state.",
          "Timeout clearing to restart the window.",
          "Optional controls: cancel/flush and leading-edge execution."
        ]
      },
      "followUpQuestions": [
        "js-throttle"
      ],
      "resources": [
        {
          "title": "MDN – setTimeout()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        },
        {
          "title": "MDN – Function.prototype.apply()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
        }
      ]
    },
    "tests": "import debounce from './debounce';\n\nconst wait = (ms) => new Promise((r) => setTimeout(r, ms));\n\ndescribe('debounce', () => {\n  test('calls function after delay', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 120);\n\n    debounced();\n    expect(calls).toBe(0);\n\n    await wait(140);\n    expect(calls).toBe(1);\n  });\n\n  test('resets timer on rapid calls (only last executes)', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 100);\n\n    debounced();\n    await wait(50);\n    debounced();\n    await wait(50);\n    debounced();\n\n    await wait(90);\n    expect(calls).toBe(0);\n\n    await wait(20);\n    expect(calls).toBe(1);\n  });\n\n  test('passes arguments (and preserves this via apply)', async () => {\n    let last = '';\n    const debounced = debounce(function (name) {\n      last = `Hi ${name}`;\n    }, 80);\n\n    debounced.call({ tag: 'ctx' }, 'Alice');\n    await wait(100);\n    expect(last).toBe('Hi Alice');\n  });\n});\n",
    "testsTs": "import debounce from './debounce';\n\nconst wait = (ms: number) => new Promise<void>((r) => setTimeout(r, ms));\n\ndescribe('debounce (TypeScript)', () => {\n  it('delays function execution', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 120);\n\n    debounced();\n    expect(calls).toBe(0);\n\n    await wait(140);\n    expect(calls).toBe(1);\n  });\n\n  it('restarts timer on multiple calls', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 100);\n\n    debounced();\n    await wait(50);\n    debounced();\n    await wait(50);\n    debounced();\n\n    await wait(90);\n    expect(calls).toBe(0);\n\n    await wait(20);\n    expect(calls).toBe(1);\n  });\n\n  it('forwards parameters correctly', async () => {\n    let captured = '';\n    const debounced = debounce((msg: string) => { captured = msg; }, 80);\n\n    debounced('Hello');\n    await wait(100);\n    expect(captured).toBe('Hello');\n  });\n});\n"
  },
  {
    "id": "js-throttle",
    "title": "Throttle Function",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "difficulty": "medium",
    "tags": [
      "async",
      "timing",
      "function"
    ],
    "description": {
      "summary": "Implement a function `throttle(fn, interval)` that ensures `fn` is executed at most once during every `interval` milliseconds, no matter how many times it's triggered.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The function to be throttled."
        },
        {
          "name": "interval",
          "type": "number",
          "desc": "The time window (in milliseconds) within which subsequent calls are ignored."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A throttled version of the original function that executes at most once per interval."
      },
      "examples": [
        "// Basic examples\nthrottle(() => console.log('Clicked!'), 1000)",
        "// Multiple rapid calls — only first one executes within the interval\nconst log = throttle(() => console.log('Run!'), 500)\nlog()\nlog()\nlog() // Only the first logs immediately, rest ignored until 500ms passes",
        "// With arguments\nconst greet = throttle(name => console.log(`Hi ${name}`), 800)\ngreet('Alice')\ngreet('Bob') // Only 'Hi Alice' logs immediately; 'Hi Bob' ignored until 800ms passes"
      ]
    },
    "starterCode": "export default function throttle(fn, interval) {\n  // TODO: Execute fn at most once per interval\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  // TODO: Execute fn at most once per interval\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure a function executes at most once within a defined period — controlling execution frequency for performance-critical events (scroll, resize, input).",
      "approaches": [
        {
          "title": "Approach 1: Timestamp-based throttle (simple and effective)",
          "prose": "Idea: record the last time the function was called, and skip execution until enough time passes.\n\n### Steps\n1. Initialize `let lastTime = 0`.\n2. On each call, compare `Date.now()` with `lastTime`.\n3. If the difference >= interval, call `fn` and update `lastTime`.\n\n**Why use it:** straightforward, minimal overhead, and great for consistent spacing between calls.",
          "codeJs": "export default function throttle(fn, interval) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= interval) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  };\n}\n",
          "codeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  let lastTime = 0;\n  return function(this: any, ...args: Parameters<F>) {\n    const now = Date.now();\n    if (now - lastTime >= interval) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  } as F;\n}\n"
        },
        {
          "title": "Approach 2: Timer-based throttle (delayed trailing call)",
          "prose": "Idea: execute the first call immediately and block others until the interval elapses using `setTimeout`.\n\n### Steps\n1. Use a flag or timer to indicate cooldown.\n2. When called, if no timer exists, run `fn` and start a timeout.\n3. When timeout ends, clear the flag so it can fire again.\n\n**Why use it:** guarantees evenly spaced executions even with bursty inputs.",
          "codeJs": "export default function throttle(fn, interval) {\n  let waiting = false;\n  return function(...args) {\n    if (!waiting) {\n      fn.apply(this, args);\n      waiting = true;\n      setTimeout(() => { waiting = false; }, interval);\n    }\n  };\n}\n",
          "codeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  let waiting = false;\n  return function(this: any, ...args: Parameters<F>) {\n    if (!waiting) {\n      fn.apply(this, args);\n      waiting = true;\n      setTimeout(() => { waiting = false; }, interval);\n    }\n  } as F;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Trailing events may be ignored in the simple version — use combined approach for reliability.",
          "Avoid mixing throttle and debounce unless behavior is clearly defined.",
          "Ensure consistent `this` context using `apply()`."
        ],
        "edgeCases": [
          "interval = 0 → runs immediately on every call.",
          "First call always executes immediately.",
          "Successive calls within interval are ignored."
        ],
        "techniques": [
          "Timestamp or timer control to manage execution rate.",
          "Tracking `lastTime` and cooldown intervals.",
          "Context binding with closures."
        ]
      },
      "followUpQuestions": [
        "js-debounce"
      ],
      "resources": [
        {
          "title": "MDN – setTimeout()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        },
        {
          "title": "Lodash – throttle",
          "url": "https://lodash.com/docs/#throttle"
        }
      ]
    },
    "tests": "import throttle from './throttle';\n\nconst wait = (ms) => new Promise((r) => setTimeout(r, ms));\n\ndescribe('throttle', () => {\n  test('executes immediately and ignores rapid calls', async () => {\n    let calls = 0;\n    const throttled = throttle(() => { calls += 1; }, 200);\n\n    throttled(); // should run immediately\n    throttled(); // ignored\n    throttled(); // ignored\n\n    expect(calls).toBe(1);\n\n    await wait(220);\n    throttled(); // should run after interval\n    expect(calls).toBe(2);\n  });\n\n  test('maintains correct interval spacing', async () => {\n    let timestamps = [];\n    const throttled = throttle(() => { timestamps.push(Date.now()); }, 100);\n\n    throttled();\n    await wait(30);\n    throttled();\n    await wait(80);\n    throttled(); // should run after ~110ms total\n\n    await wait(120);\n    throttled(); // another valid call\n\n    expect(timestamps.length).toBe(3);\n  });\n\n  test('passes arguments correctly', async () => {\n    let last = '';\n    const throttled = throttle((msg) => { last = msg; }, 150);\n\n    throttled('Hello');\n    throttled('World'); // ignored\n\n    await wait(160);\n    throttled('Again');\n\n    expect(last).toBe('Again');\n  });\n});\n",
    "testsTs": "import throttle from './throttle';\n\nconst wait = (ms: number) => new Promise<void>((r) => setTimeout(r, ms));\n\ndescribe('throttle (TypeScript)', () => {\n  it('executes immediately and ignores rapid calls', async () => {\n    let calls = 0;\n    const throttled = throttle(() => { calls += 1; }, 200);\n\n    throttled();\n    throttled();\n    throttled();\n\n    expect(calls).toBe(1);\n\n    await wait(220);\n    throttled();\n    expect(calls).toBe(2);\n  });\n\n  it('maintains proper intervals', async () => {\n    let times: number[] = [];\n    const throttled = throttle(() => { times.push(Date.now()); }, 100);\n\n    throttled();\n    await wait(30);\n    throttled();\n    await wait(80);\n    throttled();\n\n    await wait(120);\n    throttled();\n\n    expect(times.length).toBe(3);\n  });\n\n  it('passes arguments correctly', async () => {\n    let last = '';\n    const throttled = throttle((msg: string) => { last = msg; }, 150);\n\n    throttled('Hi');\n    throttled('Ignore');\n\n    await wait(160);\n    throttled('Final');\n\n    expect(last).toBe('Final');\n  });\n});\n"
  },
  {
    "id": "js-deep-clone",
    "title": "Deep Clone",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "object",
      "recursion",
      "clone",
      "deep-copy"
    ],
    "description": {
      "summary": "Implement a function `deepClone(value)` that creates a deep copy of the provided value, including nested objects, arrays, Dates, and RegExps.",
      "arguments": [
        {
          "name": "value",
          "type": "any",
          "desc": "The value to deeply clone. Can be an object, array, Date, RegExp, or primitive."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "A deep copy of the input value where all nested structures are duplicated rather than referenced."
      },
      "examples": [
        "// Basic examples\ndeepClone({ a: 1, b: { c: 2 } }) // => { a: 1, b: { c: 2 } }",
        "// Arrays and nested objects\nconst arr = [1, { x: 10 }, [2, 3]]\nconst copy = deepClone(arr)\ncopy[1].x = 99\n// arr stays unchanged",
        "// Dates and RegExps\nconst obj = { d: new Date('2020-01-01'), r: /abc/i }\nconst clone = deepClone(obj)\nclone.d.setFullYear(2024)\n// obj.d still points to 2020"
      ]
    },
    "starterCode": "export default function deepClone(value) {\n  // TODO: Return a deep-cloned copy of the input value\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function deepClone<T>(value: T): T {\n  // TODO: Return a deep-cloned copy of the input value\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: create a fully independent copy of any input value — primitives, objects, arrays, Dates, or RegExps — ensuring no shared references remain.",
      "approaches": [
        {
          "title": "Approach 1: Recursive type-aware cloning",
          "prose": "Idea: detect the type of the input and handle each case appropriately — primitive, array, object, or special object type.\n\n### Steps\n1. If `value` is primitive (null, number, string, etc.), return it as-is.\n2. Handle `Date` by returning a new Date with the same timestamp.\n3. Handle `RegExp` by creating a new RegExp with the same pattern and flags.\n4. If it's an array, map through elements and clone recursively.\n5. If it's an object, create a new object and recursively clone each key.\n\nThis ensures deeply nested structures are properly copied without sharing references.",
          "codeJs": "export default function deepClone(value) {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (value instanceof Date) return new Date(value.getTime());\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClone(item));\n  }\n\n  const clonedObj = {};\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clonedObj[key] = deepClone(value[key]);\n    }\n  }\n  return clonedObj;\n}\n",
          "codeTs": "export default function deepClone<T>(value: T): T {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (value instanceof Date) return new Date(value.getTime()) as any;\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re as any;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClone(item)) as any;\n  }\n\n  const clonedObj: any = {};\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clonedObj[key] = deepClone((value as any)[key]);\n    }\n  }\n  return clonedObj;\n}\n"
        },
        {
          "title": "Approach 2: Handling circular references (advanced)",
          "prose": "Idea: store seen objects in a WeakMap to avoid infinite recursion.\n\nThis approach is useful when the input contains self-referential structures (like graphs or linked objects). Each object reference is tracked, and when revisited, its cloned counterpart is returned instead of recursing indefinitely.",
          "codeJs": "export default function deepClone(value, seen = new WeakMap()) {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (seen.has(value)) return seen.get(value);\n\n  if (value instanceof Date) return new Date(value.getTime());\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re;\n  }\n\n  const clone = Array.isArray(value) ? [] : {};\n  seen.set(value, clone);\n\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clone[key] = deepClone(value[key], seen);\n    }\n  }\n  return clone;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid shallow copy methods like spread or Object.assign — they only copy one level deep.",
          "Circular structures can cause infinite recursion if WeakMap isn’t used.",
          "Functions and DOM nodes are not cloned — they retain reference."
        ],
        "edgeCases": [
          "null or primitive → returned directly.",
          "Date → returns new Date with identical timestamp.",
          "RegExp → returns new RegExp with identical source and flags.",
          "Array → deep-cloned recursively."
        ],
        "techniques": [
          "Recursion for nested structures.",
          "Type detection using `instanceof` and `Array.isArray`.",
          "Reference tracking using WeakMap for circular safety."
        ]
      },
      "followUpQuestions": [
        "js-flatten-depth"
      ],
      "resources": [
        {
          "title": "MDN – Object cloning basics",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy"
        },
        {
          "title": "JavaScript.info – Deep cloning",
          "url": "https://javascript.info/object-copy#structuredclone"
        }
      ]
    },
    "tests": "import deepClone from './deepClone';\n\ndescribe('deepClone', () => {\n  test('clones nested objects', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const clone = deepClone(obj);\n    expect(clone).toEqual(obj);\n    clone.b.c = 5;\n    expect(obj.b.c).toBe(2);\n  });\n\n  test('clones arrays correctly', () => {\n    const arr = [1, { x: 2 }, [3, 4]];\n    const clone = deepClone(arr);\n    expect(clone).toEqual(arr);\n    clone[1].x = 99;\n    expect(arr[1].x).toBe(2);\n  });\n\n  test('clones Date and RegExp instances', () => {\n    const obj = { d: new Date('2020-01-01T00:00:00Z'), r: /abc/i };\n    const clone = deepClone(obj);\n\n    expect(clone.d instanceof Date).toBe(true);\n    expect(clone.d === obj.d).toBe(false);\n    expect(clone.d.getTime()).toBe(obj.d.getTime());\n\n    const sameRegExp = (\n      clone.r instanceof RegExp &&\n      clone.r !== obj.r &&\n      clone.r.source === obj.r.source &&\n      (('flags' in clone.r && 'flags' in obj.r)\n        ? clone.r.flags === obj.r.flags\n        : String(clone.r) === String(obj.r)) &&\n      clone.r.lastIndex === obj.r.lastIndex\n    );\n    expect(sameRegExp).toBe(true);\n  });\n\n  test('returns primitives as-is', () => {\n    expect(deepClone(5)).toBe(5);\n    expect(deepClone('test')).toBe('test');\n    expect(deepClone(null)).toBe(null);\n  });\n});\n",
    "testsTs": "import deepClone from './deepClone';\n\ndescribe('deepClone (TypeScript)', () => {\n  it('deeply clones nested objects', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const clone = deepClone(obj);\n    expect(clone).toEqual(obj);\n    clone.b.c = 99;\n    expect(obj.b.c).toBe(2);\n  });\n\n  it('clones arrays correctly', () => {\n    const arr = [1, { x: 10 }, [2, 3]];\n    const clone = deepClone(arr);\n    expect(clone).toEqual(arr);\n    clone[1].x = 50;\n    expect(arr[1].x).toBe(10);\n  });\n\n  it('handles Dates and RegExps robustly', () => {\n    const obj = { d: new Date('2020-01-01T00:00:00Z'), r: /test/g };\n    const clone = deepClone(obj);\n\n    expect(clone.d instanceof Date).toBe(true);\n    expect(clone.d === obj.d).toBe(false);\n    expect(clone.d.getTime()).toBe(obj.d.getTime());\n\n    const sameRegExp = (\n      clone.r instanceof RegExp &&\n      clone.r !== obj.r &&\n      clone.r.source === obj.r.source &&\n      (('flags' in clone.r && 'flags' in obj.r)\n        ? clone.r.flags === obj.r.flags\n        : String(clone.r) === String(obj.r)) &&\n      clone.r.lastIndex === obj.r.lastIndex\n    );\n    expect(sameRegExp).toBe(true);\n  });\n\n  it('returns primitives unchanged', () => {\n    expect(deepClone('abc')).toBe('abc');\n    expect(deepClone(123)).toBe(123);\n  });\n});\n"
  },
  {
    "id": "js-deep-equal",
    "title": "Deep Equal",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "object",
      "recursion",
      "equality",
      "comparison"
    ],
    "description": {
      "summary": "Implement a function `deepEqual(a, b)` that returns `true` when two values are deeply equal — primitives by value and objects/arrays by recursively comparing their properties. Handle Dates, RegExps, and `NaN`.",
      "arguments": [
        {
          "name": "a",
          "type": "any",
          "desc": "First value to compare."
        },
        {
          "name": "b",
          "type": "any",
          "desc": "Second value to compare."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if both inputs are deeply equal; otherwise `false`."
      },
      "examples": [
        "// Basic examples\ndeepEqual(1, 1) // => true\ndeepEqual(1, '1') // => false",
        "// Nested objects\ndeepEqual({ a: 1, b: { c: 2 } }, { a: 1, b: { c: 2 } }) // => true",
        "// Arrays (order matters)\ndeepEqual([1, 2, 3], [1, 2, 3]) // => true\ndeepEqual([1, 2, 3], [3, 2, 1]) // => false",
        "// Dates and RegExp\ndeepEqual(new Date('2020-01-01'), new Date('2020-01-01')) // => true\ndeepEqual(/ab/i, new RegExp('ab', 'i')) // => true",
        "// Special values\ndeepEqual(NaN, NaN) // => true\ndeepEqual(null, undefined) // => false"
      ]
    },
    "starterCode": "export default function deepEqual(a, b) {\n  // TODO: Compare two values for deep equality\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function deepEqual<T = any>(a: T, b: T): boolean {\n  // TODO: Compare two values for deep equality\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: return `true` only when two inputs are the same **by value** (for primitives) or **by structure** (for arrays/objects). Must treat `NaN` as equal to `NaN`, compare `Date` by timestamp, and `RegExp` by pattern/flags/lastIndex.",
      "approaches": [
        {
          "title": "Approach 1: Direct recursion (baseline, easiest to follow)",
          "prose": "Idea: handle the common cases with clear early exits, then recurse for arrays and plain objects.\n\nSteps\n1. If `a === b`, return `true` (covers identical references and most primitives).\n2. If both are numbers and both are `NaN`, return `true`.\n3. If types differ or either is `null`, return `false`.\n4. Handle `Date` and `RegExp` specially.\n5. If either value is an array, both must be arrays; compare length, then pairwise recurse.\n6. Otherwise, treat as plain objects: compare own keys length, ensure the same keys exist, then recurse per key.\n\nWhy use it: readable flow with tight, predictable checks that pass typical interview test suites.",
          "codeJs": "export default function deepEqual(a, b) {\n  if (a === b) return true;\n  if (typeof a === 'number' && typeof b === 'number' && Number.isNaN(a) && Number.isNaN(b)) return true;\n  if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') return false;\n\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    const same = a.source === b.source && a.flags === b.flags;\n    return same && a.lastIndex === b.lastIndex;\n  }\n\n  const aIsArr = Array.isArray(a);\n  const bIsArr = Array.isArray(b);\n  if (aIsArr || bIsArr) {\n    if (!(aIsArr && bIsArr)) return false;\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const k of aKeys) {\n    if (!Object.prototype.hasOwnProperty.call(b, k)) return false;\n    if (!deepEqual(a[k], b[k])) return false;\n  }\n  return true;\n}\n",
          "codeTs": "export default function deepEqual<T = any>(a: T, b: T): boolean {\n  if (a === b) return true;\n  if (typeof a === 'number' && typeof b === 'number' && Number.isNaN(a as any) && Number.isNaN(b as any)) return true;\n  if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') return false;\n\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    const same = a.source === b.source && a.flags === b.flags;\n    return same && a.lastIndex === b.lastIndex;\n  }\n\n  const aIsArr = Array.isArray(a);\n  const bIsArr = Array.isArray(b);\n  if (aIsArr || bIsArr) {\n    if (!(aIsArr && bIsArr)) return false;\n    const aa = a as unknown as any[];\n    const bb = b as unknown as any[];\n    if (aa.length !== bb.length) return false;\n    for (let i = 0; i < aa.length; i++) {\n      if (!deepEqual(aa[i], bb[i])) return false;\n    }\n    return true;\n  }\n\n  const aObj = a as Record<string, unknown>;\n  const bObj = b as Record<string, unknown>;\n  const aKeys = Object.keys(aObj);\n  const bKeys = Object.keys(bObj);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const k of aKeys) {\n    if (!Object.prototype.hasOwnProperty.call(bObj, k)) return false;\n    if (!deepEqual((aObj as any)[k], (bObj as any)[k])) return false;\n  }\n  return true;\n}\n"
        },
        {
          "title": "Approach 2: JSON stringify (quick but limited)",
          "prose": "Idea: `JSON.stringify(a) === JSON.stringify(b)` as a one-liner for **plain** data (no functions, symbols, undefined in objects; key order stable).\n\nWhy use it: handy sanity check or pre-filter for simple objects; not reliable for Dates, RegExps, `NaN`, different key orders, or cyclic structures.",
          "codeJs": "export default function deepEqual(a, b) {\n  try {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } catch {\n    // cyclic structures throw errors\n    return false;\n  }\n}\n",
          "codeTs": "export default function deepEqual<T>(a: T, b: T): boolean {\n  try {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } catch {\n    return false;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Treat `NaN` as equal to `NaN` — `NaN === NaN` is false by default.",
          "Don’t rely on `JSON.stringify` for general deep equality (Dates/RegExps/undefined/functions differ).",
          "Only compare **own** enumerable keys; inherited properties should not affect equality."
        ],
        "edgeCases": [
          "Different types → immediately false.",
          "Arrays: order matters; lengths must match.",
          "RegExp: compare `source`, `flags`, and optionally `lastIndex`.",
          "Date: compare `getTime()`.",
          "Null vs undefined → false."
        ],
        "techniques": [
          "Short-circuit checks before recursion.",
          "Type-specific comparisons for Date/RegExp.",
          "Key set + recursive property comparison."
        ]
      },
      "followUpQuestions": [
        "js-deep-clone",
        "js-arrays-equal"
      ],
      "resources": [
        {
          "title": "MDN – Object.keys()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"
        },
        {
          "title": "MDN – Date",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"
        },
        {
          "title": "MDN – RegExp",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp"
        }
      ]
    },
    "tests": "import deepEqual from './deepEqual';\n\ndescribe('deepEqual', () => {\n  test('compares primitives', () => {\n    expect(deepEqual(1, 1)).toBe(true);\n    expect(deepEqual(1, '1')).toBe(false);\n    expect(deepEqual(NaN, NaN)).toBe(true);\n  });\n\n  test('compares nested objects', () => {\n    const a = { x: 1, y: { z: 2 } };\n    const b = { x: 1, y: { z: 2 } };\n    expect(deepEqual(a, b)).toBe(true);\n    const c = { x: 1, y: { z: 3 } };\n    expect(deepEqual(a, c)).toBe(false);\n  });\n\n  test('compares arrays (order matters)', () => {\n    expect(deepEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n    expect(deepEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  test('handles Date and RegExp', () => {\n    const d1 = new Date('2020-01-01T00:00:00Z');\n    const d2 = new Date('2020-01-01T00:00:00Z');\n    expect(deepEqual(d1, d2)).toBe(true);\n\n    const r1 = /ab/i;\n    const r2 = new RegExp('ab', 'i');\n    expect(deepEqual(r1, r2)).toBe(true);\n  });\n\n  test('null vs undefined', () => {\n    expect(deepEqual(null, undefined)).toBe(false);\n  });\n});\n",
    "testsTs": "import deepEqual from './deepEqual';\n\ndescribe('deepEqual (TypeScript)', () => {\n  it('compares primitives', () => {\n    expect(deepEqual(1, 1)).toBe(true);\n    expect(deepEqual(1 as any, '1' as any)).toBe(false);\n    expect(deepEqual(NaN, NaN)).toBe(true);\n  });\n\n  it('compares nested objects', () => {\n    const a = { x: 1, y: { z: 2 } };\n    const b = { x: 1, y: { z: 2 } };\n    expect(deepEqual(a, b)).toBe(true);\n    const c = { x: 1, y: { z: 3 } };\n    expect(deepEqual(a, c)).toBe(false);\n  });\n\n  it('compares arrays (order matters)', () => {\n    expect(deepEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n    expect(deepEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  it('handles Date and RegExp', () => {\n    const d1 = new Date('2020-01-01T00:00:00Z');\n    const d2 = new Date('2020-01-01T00:00:00Z');\n    expect(deepEqual(d1, d2)).toBe(true);\n\n    const r1 = /ab/i;\n    const r2 = new RegExp('ab', 'i');\n    expect(deepEqual(r1, r2)).toBe(true);\n  });\n\n  it('null vs undefined', () => {\n    expect(deepEqual(null as any, undefined as any)).toBe(false);\n  });\n});\n"
  },
  {
    "id": "js-flatten-depth",
    "title": "Flatten with Depth",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "array",
      "recursion",
      "depth",
      "flatten"
    ],
    "description": {
      "summary": "Implement `flatten(arr, depth)` that flattens a nested array up to a given depth.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "Nested array to flatten."
        },
        {
          "name": "depth",
          "type": "number",
          "desc": "Number of levels to flatten (default 1)."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array flattened up to the given depth."
      },
      "examples": [
        "// Basic examples\nflatten([1, [2, [3, [4]]]], 1) // => [1, 2, [3, [4]]]",
        "flatten([1, [2, [3, [4]]]], 2) // => [1, 2, 3, [4]]",
        "flatten([1, [2, [3, [4]]]], 3) // => [1, 2, 3, 4]",
        "// Handles empty and non-nested arrays\nflatten([1, 2, 3], 2) // => [1, 2, 3]"
      ]
    },
    "starterCode": "export default function flatten(arr, depth = 1) {\n  // TODO: Flatten array up to given depth\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  // TODO: Flatten array up to given depth\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: reduce nested arrays by one or more levels depending on `depth`. Each recursive step removes one layer of nesting until `depth` reaches 0.",
      "approaches": [
        {
          "title": "Approach 1: Recursive flattening (baseline, easiest to read)",
          "prose": "Idea: for each element, check if it’s an array. If yes, flatten it one level deeper (reducing `depth`), otherwise push directly.\n\nSteps:\n1. Base case: if `depth === 0`, return a shallow copy.\n2. Loop through array elements.\n3. For nested arrays, recurse with `depth - 1`.\n4. Collect results in a new array.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  const result = [];\n  for (const el of arr) {\n    if (Array.isArray(el) && depth > 0) {\n      result.push(...flatten(el, depth - 1));\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  const result: any[] = [];\n  for (const el of arr) {\n    if (Array.isArray(el) && depth > 0) {\n      result.push(...flatten(el, depth - 1));\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using reduce (compact, functional style)",
          "prose": "Idea: use `Array.prototype.reduce` to build the flattened array recursively.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  return arr.reduce((acc, el) => {\n    return acc.concat(Array.isArray(el) ? flatten(el, depth - 1) : el);\n  }, []);\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  return arr.reduce((acc: any[], el) => {\n    return acc.concat(Array.isArray(el) ? flatten(el, depth - 1) : el);\n  }, []);\n}\n"
        },
        {
          "title": "Approach 3: Using stack (iterative, avoids recursion)",
          "prose": "Idea: simulate recursion using a stack so we can flatten arrays iteratively. This approach is great for deeply nested arrays since it avoids call-stack overflows.\n\n### 🔍 How it works\n1. Push each element onto a stack along with its current `depth` value.\n2. Pop elements from the stack one by one.\n3. If the element is an array and depth > 0, push its children **in reverse order**, each with `depth − 1`.\n4. If it’s not an array or depth === 0, append it to the result.\n\n### 💡 Why reverse order?\nBecause the stack is LIFO — we want elements to be processed left-to-right. By seeding the stack in reverse and pushing children in reverse, the final order matches the original array.\n\n### ⚙️ When to use\n- When arrays are extremely deep and recursion may hit a call-stack limit.\n- When you need full control over the traversal order.\n\n### ✅ Complexity\nO(n) time and O(n) space — similar to the recursive approach, but stack-safe.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  const result = [];\n  const stack = [];\n  // Seed stack right-to-left so popping processes left-to-right\n  for (let i = arr.length - 1; i >= 0; i--) {\n    stack.push([arr[i], depth]);\n  }\n  while (stack.length) {\n    const [curr, d] = stack.pop();\n    if (Array.isArray(curr) && d > 0) {\n      for (let i = curr.length - 1; i >= 0; i--) {\n        stack.push([curr[i], d - 1]);\n      }\n    } else {\n      result.push(curr);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  const result: any[] = [];\n  const stack: Array<[any, number]> = [];\n  // Seed stack right-to-left so popping processes left-to-right\n  for (let i = arr.length - 1; i >= 0; i--) {\n    stack.push([arr[i], depth]);\n  }\n  while (stack.length) {\n    const [curr, d] = stack.pop() as [any, number];\n    if (Array.isArray(curr) && d > 0) {\n      for (let i = curr.length - 1; i >= 0; i--) {\n        stack.push([curr[i], d - 1]);\n      }\n    } else {\n      result.push(curr);\n    }\n  }\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Don’t mutate the input array — always return a new array.",
          "If `depth === 0`, return a shallow copy, not the original reference.",
          "`Array.flat()` is off-limits here (we’re reimplementing it)."
        ],
        "edgeCases": [
          "Empty arrays → return empty array.",
          "Depth larger than nesting → fully flatten.",
          "Depth 0 → returns shallow copy."
        ],
        "techniques": [
          "Recursion and base case handling.",
          "Spread operator for flattening.",
          "Reduce for elegant accumulation."
        ]
      },
      "followUpQuestions": [
        "js-flatten-once",
        "js-deep-clone"
      ]
    },
    "tests": "import flatten from './flatten';\n\ndescribe('flatten', () => {\n  test('flattens one level deep', () => {\n    expect(flatten([1, [2, [3, [4]]]], 1)).toEqual([1, 2, [3, [4]]]);\n  });\n\n  test('flattens two levels deep', () => {\n    expect(flatten([1, [2, [3, [4]]]], 2)).toEqual([1, 2, 3, [4]]);\n  });\n\n  test('flattens completely when depth is high', () => {\n    expect(flatten([1, [2, [3, [4]]]], 10)).toEqual([1, 2, 3, 4]);\n  });\n\n  test('handles empty and non-nested arrays', () => {\n    expect(flatten([], 2)).toEqual([]);\n    expect(flatten([1, 2, 3], 2)).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "import flatten from './flatten';\n\ndescribe('flatten (TypeScript)', () => {\n  it('flattens one level', () => {\n    expect(flatten([1, [2, [3, [4]]]], 1)).toEqual([1, 2, [3, [4]]]);\n  });\n\n  it('flattens up to given depth', () => {\n    expect(flatten([1, [2, [3, [4]]]], 2)).toEqual([1, 2, 3, [4]]);\n  });\n\n  it('fully flattens if depth is large', () => {\n    expect(flatten([1, [2, [3, [4]]]], 10)).toEqual([1, 2, 3, 4]);\n  });\n\n  it('returns array unchanged when already flat', () => {\n    expect(flatten([1, 2, 3], 2)).toEqual([1, 2, 3]);\n  });\n});\n"
  },
  {
    "id": "js-curry-function",
    "title": "Curry Function",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "function",
      "closure",
      "higher-order",
      "currying"
    ],
    "description": {
      "summary": "Implement a function `curry(fn)` that transforms a multi-argument function into a chain of single-argument functions.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "A function that accepts multiple arguments."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A curried version of the input function that collects arguments until all are provided."
      },
      "examples": [
        "// Basic example\nfunction add(a, b, c) { return a + b + c; }\nconst curriedAdd = curry(add);\ncurriedAdd(1)(2)(3) // => 6",
        "// Partial application\nconst add5 = curriedAdd(2)(3);\nadd5(10) // => 15",
        "// Works with different argument counts\nconst multiply = (a, b) => a * b;\ncurry(multiply)(4)(5) // => 20",
        "// Mixed grouping is fine too\ncurriedAdd(1, 2)(3) // => 6\ncurriedAdd(1)(2, 3) // => 6"
      ]
    },
    "starterCode": "export default function curry(fn) {\n  // TODO: Transform fn into a curried version\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function curry(fn: Function): Function {\n  // TODO: Transform fn into a curried version\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: turn an N-ary function into a chain that collects arguments across calls until it has at least `fn.length`, then invokes `fn`. Enables partial application while preserving order.",
      "approaches": [
        {
          "title": "Approach 1: Variadic accumulator using closures (simplest)",
          "prose": "Idea: keep collecting arguments in a closure. If collected args are **>=** `fn.length`, call `fn`; otherwise, return a function that keeps collecting.\n\nHow it works\n1. Read `fn.length` to know required parameters.\n2. Define inner `curried(...args)` that checks count.\n3. If enough, return `fn(...args)`.\n4. Else return a function that gathers more and calls `curried` again.\n\nWhy it works: closures preserve previously provided args; callers can group arguments arbitrarily (`f(1)(2)(3)`, `f(1,2)(3)`, etc.).",
          "codeJs": "export default function curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn(...args);\n    }\n    return (...next) => curried(...args, ...next);\n  };\n}\n",
          "codeTs": "export default function curry(fn: Function): Function {\n  const curried = (...args: any[]): any => {\n    return args.length >= fn.length\n      ? fn(...args)\n      : (...next: any[]) => curried(...args, ...next);\n  };\n  return curried;\n}\n"
        },
        {
          "title": "Approach 2: Recursive arity handler (explicit argument counting)",
          "prose": "Instead of comparing to `fn.length` each time, we create a recursive wrapper that reduces the expected argument count until all are gathered. This makes the recursion explicit but slightly less elegant.",
          "codeJs": "export default function curry(fn) {\n  const curried = (...args) => {\n    if (args.length >= fn.length) return fn(...args);\n    return (...next) => curried(...args.concat(next));\n  };\n  return curried;\n}\n",
          "codeTs": "export default function curry(fn: Function): Function {\n  const curried = (...args: any[]): any => {\n    if (args.length >= fn.length) return fn(...args);\n    return (...next: any[]) => curried(...args.concat(next));\n  };\n  return curried;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "`fn.length` ignores default/rest parameters; advanced typings for perfect TS inference are omitted for clarity."
        ],
        "edgeCases": [
          "Unary functions return immediately.",
          "Extra arguments beyond `fn.length` are forwarded to `fn`."
        ],
        "techniques": [
          "Closures to capture partial arguments.",
          "Arity inspection via `fn.length`."
        ]
      },
      "followUpQuestions": [
        "js-compose",
        "js-memoize-function"
      ],
      "resources": [
        {
          "title": "MDN – Function.length",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length"
        },
        {
          "title": "MDN – Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        }
      ]
    },
    "tests": "import curry from './curry';\n\ndescribe('curry', () => {\n  test('curries a multi-argument function', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1)(2)(3)).toBe(6);\n  });\n\n  test('supports partial application', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    const add5 = curriedAdd(2)(3);\n    expect(add5(10)).toBe(15);\n  });\n\n  test('accepts mixed grouping of arguments', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1, 2)(3)).toBe(6);\n    expect(curriedAdd(1)(2, 3)).toBe(6);\n  });\n\n  test('works for 2-argument functions', () => {\n    const multiply = (a, b) => a * b;\n    const curried = curry(multiply);\n    expect(curried(4)(5)).toBe(20);\n    expect(curried(4, 5)).toBe(20);\n  });\n\n  test('handles single-argument functions', () => {\n    const square = x => x * x;\n    const curriedSquare = curry(square);\n    expect(curriedSquare(5)).toBe(25);\n  });\n});\n",
    "testsTs": "import curry from './curry';\n\ndescribe('curry (TypeScript)', () => {\n  it('curries a three-argument function', () => {\n    const add = (a: number, b: number, c: number) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1)(2)(3)).toBe(6);\n  });\n\n  it('supports partial application', () => {\n    const add = (a: number, b: number, c: number) => a + b + c;\n    const curriedAdd = curry(add);\n    const add5 = curriedAdd(2)(3);\n    expect(add5(10)).toBe(15);\n  });\n\n  it('works with binary functions and mixed grouping', () => {\n    const multiply = (a: number, b: number) => a * b;\n    const curriedMultiply = curry(multiply);\n    expect(curriedMultiply(4)(5)).toBe(20);\n    expect(curriedMultiply(4, 5)).toBe(20);\n  });\n\n  it('handles unary functions', () => {\n    const negate = (x: number) => -x;\n    const curriedNegate = curry(negate);\n    expect(curriedNegate(3)).toBe(-3);\n  });\n});\n"
  },
  {
    "id": "js-memoize-function",
    "title": "Memoization",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "medium",
    "tags": [
      "function",
      "performance",
      "caching",
      "optimization"
    ],
    "description": {
      "summary": "Implement a function `memoize(fn)` that caches results of previous function calls to avoid recomputation.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "A pure function whose results can be safely cached based on input arguments."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A new function that returns cached results for previously computed arguments."
      },
      "examples": [
        "// Basic example\nconst slowAdd = (a, b) => { for (let i=0;i<1e6;i++); return a + b; };\nconst memoizedAdd = memoize(slowAdd);\nconsole.time('first'); memoizedAdd(3,4); console.timeEnd('first');\nconsole.time('second'); memoizedAdd(3,4); console.timeEnd('second'); // much faster",
        "// Works with multiple arguments\nconst multiply = (a, b, c) => a * b * c;\nconst fastMultiply = memoize(multiply);\nfastMultiply(2,3,4) // computed\nfastMultiply(2,3,4) // cached",
        "// Handles different input sets separately\nmemoizedAdd(5,5) // => 10 (new computation)"
      ]
    },
    "starterCode": "export default function memoize(fn) {\n  // TODO: Cache function results by input arguments\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  // TODO: Cache function results by input arguments\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: cache previous function call results to avoid recomputation — ideal for expensive or recursive functions.",
      "approaches": [
        {
          "title": "Approach 1: Using Map with JSON key (simple & effective)",
          "prose": "Idea: store previous results in a `Map`, where the key is a serialized version of the arguments.\n\nHow it works\n1. Create a `Map` to store results.\n2. Convert arguments to a cache key using `JSON.stringify`.\n3. If the key exists, return the cached value.\n4. Otherwise compute, store, and return the result.\n\nWhy use it: straightforward and efficient for primitive and serializable arguments.",
          "codeJs": "export default function memoize(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n",
          "codeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  const cache = new Map<string, ReturnType<F>>();\n  const memoized = (...args: Parameters<F>): ReturnType<F> => {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key)!;\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n  return memoized as F;\n}\n"
        },
        {
          "title": "Approach 2: Nested Map (advanced for deep argument types)",
          "prose": "Idea: instead of serializing arguments, use nested `Map`s — one per argument — to handle non-serializable inputs safely.\n\nHow it works\n1. Start with an empty root `Map`.\n2. For each argument, go one level deeper — each key in the chain is an argument.\n3. The final map node stores the computed result.\n\nWhy use it: avoids `JSON.stringify` limitations, useful for object or reference-based arguments.",
          "codeJs": "export default function memoize(fn) {\n  const root = new Map();\n  return function memoized(...args) {\n    let map = root;\n    for (const arg of args) {\n      if (!map.has(arg)) map.set(arg, new Map());\n      map = map.get(arg);\n    }\n    if (map.has('result')) return map.get('result');\n    const result = fn(...args);\n    map.set('result', result);\n    return result;\n  };\n}\n",
          "codeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  const root = new Map<any, any>();\n  const memoized = (...args: Parameters<F>): ReturnType<F> => {\n    let map = root;\n    for (const arg of args) {\n      if (!map.has(arg)) map.set(arg, new Map());\n      map = map.get(arg);\n    }\n    if (map.has('result')) return map.get('result');\n    const result = fn(...args);\n    map.set('result', result);\n    return result;\n  };\n  return memoized as F;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "JSON.stringify cannot handle functions, symbols, or circular structures.",
          "Use nested Map approach for reference or object-heavy inputs."
        ],
        "edgeCases": [
          "Functions with no arguments still work — use single empty key.",
          "Different argument order yields distinct cache entries."
        ],
        "techniques": [
          "Closure retains cache between invocations.",
          "Using `Map` prevents accidental key collisions from prototype chain."
        ]
      },
      "followUpQuestions": [
        "js-throttle",
        "js-debounce"
      ],
      "resources": [
        {
          "title": "MDN – Map",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
        },
        {
          "title": "MDN – Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        }
      ]
    },
    "tests": "import memoize from './memoize';\n\ndescribe('memoize', () => {\n  test('caches results for repeated calls', () => {\n    let calls = 0;\n    const add = (a, b) => { calls++; return a + b; };\n    const memoAdd = memoize(add);\n    expect(memoAdd(1, 2)).toBe(3);\n    expect(memoAdd(1, 2)).toBe(3);\n    expect(calls).toBe(1);\n  });\n\n  test('handles different arguments separately', () => {\n    let calls = 0;\n    const multiply = (a, b) => { calls++; return a * b; };\n    const memoMult = memoize(multiply);\n    memoMult(2, 3);\n    memoMult(3, 4);\n    expect(calls).toBe(2);\n  });\n\n  test('works with multiple argument calls', () => {\n    const join = (...args) => args.join('-');\n    const memoJoin = memoize(join);\n    expect(memoJoin('a', 'b', 'c')).toBe('a-b-c');\n    expect(memoJoin('a', 'b', 'c')).toBe('a-b-c');\n  });\n});\n",
    "testsTs": "import memoize from './memoize';\n\ndescribe('memoize (TypeScript)', () => {\n  it('caches computed results', () => {\n    let count = 0;\n    const add = (a: number, b: number) => { count++; return a + b; };\n    const memoAdd = memoize(add);\n    expect(memoAdd(3, 4)).toBe(7);\n    expect(memoAdd(3, 4)).toBe(7);\n    expect(count).toBe(1);\n  });\n\n  it('treats unique argument sets separately', () => {\n    let count = 0;\n    const diff = (a: number, b: number) => { count++; return a - b; };\n    const memoDiff = memoize(diff);\n    memoDiff(10, 5);\n    memoDiff(8, 3);\n    expect(count).toBe(2);\n  });\n\n  it('works for multi-arg functions', () => {\n    const concat = (...args: string[]) => args.join('_');\n    const memoConcat = memoize(concat);\n    expect(memoConcat('a', 'b', 'c')).toBe('a_b_c');\n    expect(memoConcat('a', 'b', 'c')).toBe('a_b_c');\n  });\n});\n"
  },
  {
    "id": "js-compose",
    "title": "Compose Function",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "function",
      "composition",
      "higher-order",
      "utility"
    ],
    "description": {
      "summary": "Implement a `compose(...fns)` function that takes multiple functions as arguments and returns a new function that applies them from **right to left**. The output of one function becomes the input of the previous one. If no functions are provided, return an identity function `(x) => x`.",
      "arguments": [
        {
          "name": "fns",
          "type": "Function[]",
          "desc": "A list of functions to compose. The rightmost function can take multiple arguments; the rest are unary."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A composed function that runs all provided functions in right-to-left order."
      },
      "examples": [
        "// Basic example",
        "const add1 = n => n + 1;",
        "const double = n => n * 2;",
        "const subtract10 = n => n - 10;",
        "const composedFn = compose(subtract10, double, add1);",
        "composedFn(3); // => -2",
        "",
        "// Identity function",
        "compose()(5); // => 5"
      ]
    },
    "starterCode": "export default function compose(...fns) {\n  // TODO: Implement function composition (right-to-left)\n  throw new Error('Not implemented');\n}",
    "starterCodeTs": "export default function compose(...fns: Function[]): Function {\n  // TODO: Implement function composition (right-to-left)\n  throw new Error('Not implemented');\n}",
    "solutionBlock": {
      "explanation": "Function composition creates a chain where each function’s output feeds into the next one, starting from the rightmost function.\n\n### Step-by-step logic:\n1. If no functions are passed, return identity `(x) => x`.\n2. Return a new function that takes an input value.\n3. Apply `reduceRight()` to run each function on the result of the previous one.\n\nThis pattern is common in functional programming and helps simplify complex transformations.",
      "codeJs": "export default function compose(...fns) {\n  if (fns.length === 0) return x => x;\n  return function (input) {\n    return fns.reduceRight((acc, fn) => fn(acc), input);\n  };\n}",
      "codeTs": "export default function compose(...fns: Function[]): Function {\n  if (fns.length === 0) return (x: any) => x;\n  return function (input: any) {\n    return fns.reduceRight((acc, fn) => fn(acc), input);\n  };\n}"
    },
    "tests": "import compose from './compose';\n\ndescribe('compose', () => {\n  const add1 = n => n + 1;\n  const double = n => n * 2;\n  const subtract10 = n => n - 10;\n\n  test('applies functions right-to-left', () => {\n    const fn = compose(subtract10, double, add1);\n    expect(fn(3)).toBe(-2);\n  });\n\n  test('works with single function', () => {\n    const fn = compose(add1);\n    expect(fn(4)).toBe(5);\n  });\n\n  test('returns identity when empty', () => {\n    const fn = compose();\n    expect(fn(5)).toBe(5);\n  });\n});",
    "testsTs": "import compose from './compose';\n\ndescribe('compose (TypeScript)', () => {\n  const add1 = (n: number) => n + 1;\n  const double = (n: number) => n * 2;\n  const subtract10 = (n: number) => n - 10;\n\n  it('applies functions right-to-left', () => {\n    const fn = compose(subtract10, double, add1);\n    expect(fn(3)).toBe(-2);\n  });\n\n  it('works with single function', () => {\n    const fn = compose(add1);\n    expect(fn(4)).toBe(5);\n  });\n\n  it('returns identity when empty', () => {\n    const fn = compose();\n    expect(fn(10)).toBe(10);\n  });\n});"
  },
  {
    "id": "js-group-by",
    "title": "Group By",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "array",
      "object",
      "grouping",
      "reduction"
    ],
    "description": {
      "summary": "Implement a function `groupBy(arr, keyFn)` that groups array elements based on the result of applying a key function to each element.",
      "arguments": [
        {
          "name": "arr",
          "type": "T[]",
          "desc": "The array of elements to group."
        },
        {
          "name": "keyFn",
          "type": "(item: T) => K",
          "desc": "A function that returns a key to group each element under."
        }
      ],
      "returns": {
        "type": "Record<K, T[]>",
        "desc": "An object whose keys are the computed group keys, and values are arrays of elements belonging to each group."
      },
      "examples": [
        "// Basic examples",
        "groupBy([6.1, 4.2, 6.3], Math.floor) // => { '4': [4.2], '6': [6.1, 6.3] }",
        "groupBy(['one', 'two', 'three'], str => str.length) // => { '3': ['one', 'two'], '5': ['three'] }",
        "groupBy([{type:'a'}, {type:'b'}, {type:'a'}], x => x.type) // => { a: [{type:'a'}, {type:'a'}], b: [{type:'b'}] }"
      ]
    },
    "starterCode": "export default function groupBy(arr, keyFn) {\n  // TODO: Group array elements by keyFn(item)\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  // TODO: Group array elements by keyFn(item)\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: convert a flat list into an object keyed by `keyFn(item)`, where each key stores an array of matching items.",
      "approaches": [
        {
          "title": "Approach 1: Simple loop (clear baseline)",
          "prose": "Idea: iterate once, compute a key for each item, initialize the bucket if missing, and push the item.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  const result = {};\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = [];\n    }\n    result[key].push(item);\n  }\n  return result;\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  const result = {} as Record<K, T[]>;\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = [] as T[];\n    }\n    result[key].push(item);\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Array.reduce (concise)",
          "prose": "Idea: fold the array into an accumulator object, creating buckets on demand.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  return arr.reduce((acc, item) => {\n    const key = keyFn(item);\n    (acc[key] ||= []).push(item);\n    return acc;\n  }, {});\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  return arr.reduce((acc, item) => {\n    const key = keyFn(item);\n    (acc[key] ||= [] as T[]).push(item);\n    return acc;\n  }, {} as Record<K, T[]>);\n}\n"
        },
        {
          "title": "Approach 3: Map-based grouping (robust keys, then to object)",
          "prose": "Idea: accumulate groups in a `Map` (supports non-string keys reliably), then convert to a plain object at the end.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  const map = new Map();\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!map.has(key)) map.set(key, []);\n    map.get(key).push(item);\n  }\n  // Convert to plain object with string keys\n  return Object.fromEntries(Array.from(map.entries(), ([k, v]) => [String(k), v]));\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  const map = new Map<K, T[]>();\n  for (const item of arr) {\n    const key = keyFn(item);\n    const bucket = map.get(key);\n    if (bucket) bucket.push(item); else map.set(key, [item]);\n  }\n  const out = {} as Record<K, T[]>;\n  for (const [k, v] of map.entries()) out[k] = v;\n  return out;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Plain object keys are strings/symbols — non-string keys will be stringified.",
          "Ensure `keyFn` is deterministic (same input → same key)."
        ],
        "edgeCases": [
          "Empty array → `{}`.",
          "Many items mapping to the same key → all coalesce into one bucket.",
          "`undefined` or `null` keys are valid but will become the string 'undefined'/'null' when used as object keys."
        ],
        "techniques": [
          "Reduction/folding patterns.",
          "Bucket initialization with nullish coalescing or `||=`.",
          "Using `Map` for robust key handling, then converting to an object."
        ]
      },
      "followUpQuestions": [
        "js-sum-numbers",
        "js-unique-array"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        },
        {
          "title": "MDN – Map",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
        }
      ]
    },
    "tests": "import groupBy from './groupBy';\n\ndescribe('groupBy', () => {\n  test('groups numbers by Math.floor', () => {\n    const result = groupBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: [4.2], 6: [6.1, 6.3] });\n  });\n\n  test('groups strings by length', () => {\n    const result = groupBy(['one', 'two', 'three'], str => str.length);\n    expect(result).toEqual({ 3: ['one', 'two'], 5: ['three'] });\n  });\n\n  test('groups objects by property', () => {\n    const data = [{ type: 'a' }, { type: 'b' }, { type: 'a' }];\n    const result = groupBy(data, x => x.type);\n    expect(result).toEqual({ a: [{ type: 'a' }, { type: 'a' }], b: [{ type: 'b' }] });\n  });\n\n  test('returns empty object for empty array', () => {\n    expect(groupBy([], Math.floor)).toEqual({});\n  });\n});\n",
    "testsTs": "import groupBy from './groupBy';\n\ndescribe('groupBy (TypeScript)', () => {\n  it('groups numbers by Math.floor', () => {\n    const result = groupBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: [4.2], 6: [6.1, 6.3] });\n  });\n\n  it('groups strings by length', () => {\n    const result = groupBy(['one', 'two', 'three'], str => str.length);\n    expect(result).toEqual({ 3: ['one', 'two'], 5: ['three'] });\n  });\n\n  it('groups objects by property', () => {\n    const data = [{ type: 'a' }, { type: 'b' }, { type: 'a' }];\n    const result = groupBy(data, x => x.type);\n    expect(result).toEqual({ a: [{ type: 'a' }, { type: 'a' }], b: [{ type: 'b' }] });\n  });\n\n  it('returns empty object for empty array', () => {\n    expect(groupBy([], Math.floor)).toEqual({});\n  });\n});\n"
  },
  {
    "id": "js-event-emitter-mini",
    "title": "Event Emitter (Mini Implementation)",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "OOP",
      "Async",
      "Design Patterns"
    ],
    "description": {
      "summary": "Implement a simple `Emitter` class that allows subscribing to events with `.on()`, unsubscribing with `.off()`, and triggering events with `.emit()`.",
      "arguments": [],
      "returns": {
        "type": "Emitter",
        "desc": "An instance that supports registering, removing, and invoking event listeners."
      },
      "examples": [
        "// Basic example\nconst emitter = new Emitter()\nconst greet = name => console.log(`Hello, ${name}!`)\nemitter.on('greet', greet)\nemitter.emit('greet', 'Alice') // => Hello, Alice!\n\n// Remove listener\nemitter.off('greet', greet)\nemitter.emit('greet', 'Bob') // => (nothing happens)"
      ]
    },
    "starterCode": "export default class Emitter {\n  constructor() {\n    // TODO: Initialize event storage, e.g. this.events = {}\n  }\n\n  on(event, listener) {\n    // TODO: Add listener to event\n  }\n\n  off(event, listener) {\n    // TODO: Remove listener from event\n  }\n\n  emit(event, ...args) {\n    // TODO: Call all listeners for event\n  }\n}\n",
    "starterCodeTs": "export default class Emitter {\n  private events: Record<string, Array<(...args: any[]) => void>>\n\n  constructor() {\n    // TODO: Initialize event storage\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    // TODO: Add listener to event\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    // TODO: Remove listener from event\n  }\n\n  emit(event: string, ...args: any[]): void {\n    // TODO: Call all listeners for event\n  }\n}\n",
    "solutionBlock": {
      "overview": "Goal: implement a simple publish/subscribe system that allows components to communicate through events without tight coupling.",
      "approaches": [
        {
          "title": "Approach 1: Object-based event registry (baseline)",
          "prose": "Idea: use a plain object where keys are event names and values are arrays of listeners.\n\nHow it works\n1. `.on(event, listener)` adds the listener to an array.\n2. `.off(event, listener)` removes it via filtering.\n3. `.emit(event, ...args)` loops over all listeners and calls them.\n\nWhy use it: very readable and mirrors the logic of Node.js EventEmitter.",
          "codeJs": "export default class Emitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, listener) {\n    if (!this.events[event]) this.events[event] = [];\n    this.events[event].push(listener);\n  }\n\n  off(event, listener) {\n    const list = this.events[event];\n    if (!list) return;\n    this.events[event] = list.filter(l => l !== listener);\n  }\n\n  emit(event, ...args) {\n    const list = this.events[event];\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n",
          "codeTs": "export default class Emitter {\n  private events: Record<string, Array<(...args: any[]) => void>>;\n\n  constructor() {\n    this.events = {};\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    if (!this.events[event]) this.events[event] = [];\n    this.events[event].push(listener);\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    const list = this.events[event];\n    if (!list) return;\n    this.events[event] = list.filter(l => l !== listener);\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const list = this.events[event];\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n"
        },
        {
          "title": "Approach 2: Map-based storage (cleaner key isolation)",
          "prose": "Idea: use a `Map` instead of a plain object to avoid key collisions and improve clarity.\n\nWhy use it: avoids issues with prototype keys like `toString`, supports any key type, and simplifies listener lookup logic.",
          "codeJs": "export default class Emitter {\n  constructor() {\n    this.events = new Map();\n  }\n\n  on(event, listener) {\n    if (!this.events.has(event)) this.events.set(event, []);\n    this.events.get(event).push(listener);\n  }\n\n  off(event, listener) {\n    const list = this.events.get(event);\n    if (!list) return;\n    this.events.set(event, list.filter(l => l !== listener));\n  }\n\n  emit(event, ...args) {\n    const list = this.events.get(event);\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n",
          "codeTs": "export default class Emitter {\n  private events: Map<string, Array<(...args: any[]) => void>>;\n\n  constructor() {\n    this.events = new Map();\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    if (!this.events.has(event)) this.events.set(event, []);\n    this.events.get(event)!.push(listener);\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    const list = this.events.get(event);\n    if (!list) return;\n    this.events.set(event, list.filter(l => l !== listener));\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const list = this.events.get(event);\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Removing a listener that doesn’t exist should do nothing.",
          "Mutating listener arrays while emitting may skip calls — always clone before iteration."
        ],
        "edgeCases": [
          "Emitting an event that has no listeners → no error should occur.",
          "Removing all listeners should leave an empty array."
        ],
        "techniques": [
          "Use closures or class fields to isolate internal state.",
          "Slice listener array before emitting to prevent concurrent modification."
        ]
      },
      "followUpQuestions": [
        "js-throttle"
      ],
      "resources": [
        {
          "title": "Node.js EventEmitter Docs",
          "url": "https://nodejs.org/api/events.html"
        },
        {
          "title": "MDN – Observer Pattern",
          "url": "https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Code_snippets/Custom_events"
        }
      ]
    },
    "tests": "import Emitter from './Emitter';\n\nconst makeSpy = () => {\n  const fn = (...args) => { fn.calls.push(args); };\n  fn.calls = [];\n  return fn;\n};\n\ndescribe('Emitter', () => {\n  test('calls listener when event is emitted', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 'data');\n    expect(spy.calls.length).toBe(1);\n    expect(spy.calls[0]).toEqual(['data']);\n  });\n\n  test('removes listener correctly', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 1);\n    expect(spy.calls.length).toBe(1);\n    emitter.off('ping', spy);\n    emitter.emit('ping', 2);\n    expect(spy.calls.length).toBe(1);\n  });\n\n  test('handles multiple listeners for same event', () => {\n    const emitter = new Emitter();\n    const a = makeSpy();\n    const b = makeSpy();\n    emitter.on('ping', a);\n    emitter.on('ping', b);\n    emitter.emit('ping', 42);\n    expect(a.calls[0]).toEqual([42]);\n    expect(b.calls[0]).toEqual([42]);\n  });\n});\n",
    "testsTs": "import Emitter from './Emitter';\n\ntype Spy = ((...args: any[]) => void) & { calls: any[][] };\nconst makeSpy = (): Spy => {\n  const fn: any = (...args: any[]) => { fn.calls.push(args); };\n  fn.calls = [] as any[][];\n  return fn as Spy;\n};\n\ndescribe('Emitter (TypeScript)', () => {\n  it('calls listener when event is emitted', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 'data');\n    expect(spy.calls.length).toBe(1);\n    expect(spy.calls[0]).toEqual(['data']);\n  });\n\n  it('removes listener correctly', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 1);\n    expect(spy.calls.length).toBe(1);\n    emitter.off('ping', spy);\n    emitter.emit('ping', 2);\n    expect(spy.calls.length).toBe(1);\n  });\n\n  it('handles multiple listeners for same event', () => {\n    const emitter = new Emitter();\n    const a = makeSpy();\n    const b = makeSpy();\n    emitter.on('ping', a);\n    emitter.on('ping', b);\n    emitter.emit('ping', 42);\n    expect(a.calls[0]).toEqual([42]);\n    expect(b.calls[0]).toEqual([42]);\n  });\n});\n"
  },
  {
    "id": "js-concurrency-map-limit",
    "title": "Concurrency-Limited Map (order-preserving)",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "Async",
      "Concurrency",
      "Promises",
      "Control Flow"
    ],
    "teaches": [
      "Concurrency control with a worker pool",
      "Backpressure (don’t start new work until a slot frees)",
      "Order-preserving aggregation",
      "Configurable error handling: fail-fast vs all-settled"
    ],
    "description": {
      "summary": "Implement `mapAsyncLimit(items, limit, worker, strategy?)` that runs at most `limit` jobs concurrently, returns results in input order, and supports error strategies `'fail-fast'` or `'all-settled'`.",
      "arguments": [
        {
          "name": "items",
          "type": "T[]",
          "desc": "Inputs to process."
        },
        {
          "name": "limit",
          "type": "number",
          "desc": "Max number of concurrent worker calls. Must be ≥ 1."
        },
        {
          "name": "worker",
          "type": "(item: T, index: number) => Promise<R>",
          "desc": "Async mapper."
        },
        {
          "name": "strategy",
          "type": "'fail-fast' | 'all-settled' (optional, default 'fail-fast')",
          "desc": "On error: reject immediately or collect all outcomes."
        }
      ],
      "returns": {
        "type": "Promise<R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>>",
        "desc": "If `'fail-fast'`, resolves to `R[]` or rejects on the first error. If `'all-settled'`, always resolves to settled outcomes in input order."
      },
      "examples": [
        "// Basic (fail-fast)\nawait mapAsyncLimit([3,1,2], 2, async (n,i) => { await sleep(n*10); return n*n })\n// => [9,1,4]\n",
        "// All-settled\nawait mapAsyncLimit([1,2,3], 2, async (n) => { if(n===2) throw new Error('boom'); return n; }, 'all-settled')\n// => [{status:'fulfilled', value:1},{status:'rejected', reason:Error('boom')},{status:'fulfilled', value:3}]"
      ]
    },
    "starterCode": "export default async function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  // TODO:\n  // 1) Validate inputs (limit >= 1)\n  // 2) Launch up to `limit` concurrent runners\n  // 3) Each runner pulls the next index and writes its result at that index\n  // 4) 'fail-fast' rejects on first error, 'all-settled' aggregates statuses\n}\n\nexport const sleep = (ms) => new Promise(r => setTimeout(r, ms));\n",
    "solutionBlock": {
      "overview": "Goal: Execute async work in parallel but never exceed a maximum number of concurrent tasks, while preserving input order and supporting different error-handling strategies.",
      "approaches": [
        {
          "title": "Approach 1: Simple worker-pool with loop control (clean & readable)",
          "prose": "Idea: Maintain a shared `next` index and spawn `limit` workers that each pull new tasks until none remain.\n\nHow it works:\n1. Create a result array of equal length to `items`.\n2. Maintain a shared `next` pointer for the next index to process.\n3. Start up to `limit` async runners.\n4. Each runner picks an index, awaits `worker(item, index)`, and writes the result in place.\n5. If `strategy` = `'fail-fast'`, reject immediately on first error; if `'all-settled'`, collect `{status, value|reason}` objects.\n6. When all tasks complete, resolve the array in the original order.\n\nWhy use it: clean control of concurrency and order, while avoiding Promise.all race conditions.",
          "codeJs": "export default function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  if (!Number.isFinite(limit) || limit < 1) throw new Error('limit must be >= 1');\n  const n = items.length, allSettled = strategy === 'all-settled';\n  const results = new Array(n);\n  if (n === 0) return Promise.resolve(results);\n\n  let next = 0, done = 0, failed = false;\n\n  return new Promise((resolve, reject) => {\n    const runner = async () => {\n      while (true) {\n        const i = next++;\n        if (i >= n || (failed && !allSettled)) break;\n        try {\n          const v = await worker(items[i], i);\n          results[i] = allSettled ? { status: 'fulfilled', value: v } : v;\n        } catch (err) {\n          if (allSettled) results[i] = { status: 'rejected', reason: err };\n          else { failed = true; reject(err); return; }\n        } finally {\n          if (++done === n && (!failed || allSettled)) resolve(results);\n        }\n      }\n    };\n\n    const k = Math.min(limit, n);\n    for (let j = 0; j < k; j++) runner();\n  });\n}\n",
          "codeTs": "export default function mapAsyncLimit<T, R>(items: T[], limit: number, worker: (item: T, index: number) => Promise<R>, strategy: 'fail-fast' | 'all-settled' = 'fail-fast'): Promise<R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>> {\n  if (!Number.isFinite(limit) || limit < 1) throw new Error('limit must be >= 1');\n  const n = items.length, allSettled = strategy === 'all-settled';\n  const results: any[] = new Array(n);\n  if (n === 0) return Promise.resolve(results);\n\n  let next = 0, done = 0, failed = false;\n\n  return new Promise((resolve, reject) => {\n    const runner = async () => {\n      while (true) {\n        const i = next++;\n        if (i >= n || (failed && !allSettled)) break;\n        try {\n          const v = await worker(items[i], i);\n          results[i] = allSettled ? { status: 'fulfilled', value: v } : v;\n        } catch (err) {\n          if (allSettled) results[i] = { status: 'rejected', reason: err };\n          else { failed = true; reject(err); return; }\n        } finally {\n          if (++done === n && (!failed || allSettled)) resolve(results);\n        }\n      }\n    };\n\n    const k = Math.min(limit, n);\n    for (let j = 0; j < k; j++) runner();\n  });\n}\n"
        },
        {
          "title": "Approach 2: Queue-based control with Promise chaining (functional alternative)",
          "prose": "Idea: use an index queue and recursively chain `.then()` calls to fill empty slots.\n\nThis version explicitly schedules the next job after one finishes rather than looping inside a worker. It’s easier to visualize but less efficient for heavy workloads.\n\nWhy use it: helpful for educational understanding of how concurrency pools refill slots dynamically.",
          "codeJs": "export default async function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  if (limit < 1) throw new Error('limit must be >= 1');\n  const results = new Array(items.length);\n  let current = 0;\n\n  async function run() {\n    const i = current++;\n    if (i >= items.length) return;\n    try {\n      const val = await worker(items[i], i);\n      results[i] = val;\n    } catch (err) {\n      if (strategy === 'fail-fast') throw err;\n      results[i] = { status: 'rejected', reason: err };\n    }\n    await run(); // fill next slot\n  }\n\n  const runners = Array.from({ length: Math.min(limit, items.length) }, run);\n  await Promise.allSettled(runners);\n  return results;\n}\n",
          "codeTs": "export default function mapAsyncLimit<T, R>(\n  items: T[],\n  limit: number,\n  worker: (item: T, index: number) => Promise<R>,\n  strategy: 'fail-fast' | 'all-settled' = 'fail-fast'\n): Promise<\n  R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>\n> {\n  if (!Number.isFinite(limit) || limit < 1) {\n    throw new Error('limit must be >= 1');\n  }\n\n  const results: any[] = new Array(items.length);\n  let current = 0;\n\n  const run = async (): Promise<void> => {\n    const i = current++;\n    if (i >= items.length) return;\n\n    try {\n      const val = await worker(items[i], i);\n      results[i] =\n        strategy === 'all-settled'\n          ? { status: 'fulfilled', value: val }\n          : val;\n    } catch (err) {\n      if (strategy === 'fail-fast') throw err;\n      results[i] = { status: 'rejected', reason: err };\n    }\n\n    return run(); // refill the slot\n  };\n\n  const k = Math.min(limit, items.length);\n  const runners = Array.from({ length: k }, () => run());\n\n  return strategy === 'fail-fast'\n    ? Promise.all(runners).then(() => results)\n    : Promise.allSettled(runners).then(() => results);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to preserve order — storing results directly in completion order breaks determinism.",
          "Not handling rejections properly may hang the promise when using `fail-fast`.",
          "If limit < 1, function must throw immediately."
        ],
        "edgeCases": [
          "Empty input array resolves instantly.",
          "If limit >= items.length, all run concurrently."
        ],
        "techniques": [
          "Use a shared counter for task dispatch.",
          "Keep results in a pre-sized array for order preservation.",
          "Apply Promise-based worker pool pattern for concurrency control."
        ]
      },
      "followUpQuestions": [
        "js-add-two-promises",
        "js-throttle"
      ],
      "resources": [
        {
          "title": "MDN – Using Promises",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises"
        },
        {
          "title": "Jake Archibald – In The Loop (Concurrency explained)",
          "url": "https://www.youtube.com/watch?v=cCOL7MC4Pl0"
        }
      ]
    },
    "tests": "import mapAsyncLimit from './mapAsyncLimit';\n\nconst sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\ndescribe('mapAsyncLimit', () => {\n  test('preserves order with mixed durations', async () => {\n    const items = [30, 10, 20];\n    const out = await mapAsyncLimit(items, 2, async (ms) => { await sleep(ms); return ms / 10; });\n    expect(out).toEqual([3, 1, 2]);\n  });\n\n  test('respects concurrency limit (no more than limit active)', async () => {\n    const items = [30, 30, 30, 30, 30];\n    let active = 0, maxActive = 0;\n    const out = await mapAsyncLimit(items, 2, async (ms) => {\n      active++; if (active > maxActive) maxActive = active;\n      await sleep(ms);\n      active--;\n      return ms;\n    });\n    expect(out).toEqual(items);\n    expect(maxActive <= 2).toEqual(true);\n  });\n\n  test('fail-fast rejects on first error', async () => {\n    const items = [5, 10, 5];\n    let threw = false;\n    try {\n      await mapAsyncLimit(items, 2, async (ms, idx) => {\n        await sleep(ms);\n        if (idx === 1) throw new Error('boom');\n        return idx;\n      }, 'fail-fast');\n    } catch (e) {\n      threw = true;\n      expect(e && e.message).toEqual('boom');\n    }\n    expect(threw).toEqual(true);\n  });\n\n  test('all-settled aggregates outcomes', async () => {\n    const res = await mapAsyncLimit([10, 5, 10, 5], 2, async (ms, idx) => {\n      await sleep(ms);\n      if (idx % 2 === 1) throw new Error('odd');\n      return idx * 10;\n    }, 'all-settled');\n\n    expect(res[0]).toEqual({ status: 'fulfilled', value: 0 });\n    expect(res[1].status).toEqual('rejected');\n    expect(res[2]).toEqual({ status: 'fulfilled', value: 20 });\n    expect(res[3].status).toEqual('rejected');\n  });\n\n  test('throws if limit < 1', () => {\n    let threw = false;\n    try { mapAsyncLimit([1], 0, async (x) => x); } catch (e) { threw = true; }\n    expect(threw).toEqual(true);\n  });\n});\n",
    "testsTs": "import mapAsyncLimit from './mapAsyncLimit';\n\nconst sleep = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\ndescribe('mapAsyncLimit (TS)', () => {\n  test('keeps output order', async () => {\n    const res = await mapAsyncLimit<number, number>([15, 5, 10], 2, async (ms) => { await sleep(ms); return ms / 5; });\n    expect(res).toEqual([3, 1, 2]);\n  });\n\n  test('caps concurrency', async () => {\n    const items = [20, 20, 20, 20];\n    let active = 0, maxActive = 0;\n    const res = await mapAsyncLimit<number, number>(items, 2, async (ms) => {\n      active++; if (active > maxActive) maxActive = active;\n      await sleep(ms);\n      active--; return ms;\n    });\n    expect(res).toEqual(items);\n    expect(maxActive <= 2).toEqual(true);\n  });\n\n  test('fail-fast rejects on first error', async () => {\n    let threw = false;\n    try {\n      await mapAsyncLimit<number, number>([5, 10, 5], 2, async (ms, idx) => {\n        await sleep(ms);\n        if (idx === 1) throw new Error('boom');\n        return idx;\n      }, 'fail-fast');\n    } catch (e: any) {\n      threw = true;\n      expect(e && e.message).toEqual('boom');\n    }\n    expect(threw).toEqual(true);\n  });\n\n  test('all-settled returns settled outcomes', async () => {\n    const res = await mapAsyncLimit<number, number>([5, 10, 5], 2, async (ms, idx) => {\n      await sleep(ms);\n      if (idx === 1) throw new Error('x');\n      return idx * 2;\n    }, 'all-settled') as Array<{ status: 'fulfilled' | 'rejected'; value?: number; reason?: any }>;\n\n    expect(res[0]).toEqual({ status: 'fulfilled', value: 0 });\n    expect(res[1].status).toEqual('rejected');\n    expect(typeof (res[1] as any).reason).toEqual('object');\n    expect(res[2]).toEqual({ status: 'fulfilled', value: 4 });\n  });\n\n  test('throws on invalid limit', () => {\n    let threw = false;\n    try { mapAsyncLimit<number, number>([1], 0, async (x) => x); } catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n});\n"
  },
  {
    "id": "js-abortable-helpers",
    "title": "Abortable Helpers (Timeout + Composed Abort)",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "Async",
      "AbortController",
      "Cancellation",
      "Promises",
      "Utilities"
    ],
    "description": {
      "summary": "Provide utilities to combine timeouts with AbortController, and to compose multiple signals (abort if any fires). All helpers are exposed via a single default export function whose properties are the helpers.",
      "arguments": [
        {
          "name": "withTimeout<T>(p, ms, reason?)",
          "type": "Promise<T>, number, any",
          "desc": "Race a promise against a timeout. Reject with `reason` (or an Error) if the timeout fires; clear the timer if the promise settles first."
        },
        {
          "name": "withAbort<T>(factory, signal)",
          "type": "(signal: AbortSignal) => Promise<T>, AbortSignal",
          "desc": "Run `factory(signal)` and reject if `signal` aborts. If already aborted, reject immediately. Ensure listeners are cleaned up when done."
        },
        {
          "name": "composeAbort(...signals)",
          "type": "AbortSignal[]",
          "desc": "Return a new `AbortSignal` that aborts if ANY input signal aborts; if any is already aborted, the result aborts immediately with the same reason."
        }
      ],
      "returns": {
        "type": "Default export function with properties: { withTimeout, withAbort, composeAbort, sleep }",
        "desc": "Import the default and destructure its properties to use the helpers."
      },
      "examples": [
        "import helpers from './abortable-helpers';",
        "const { withTimeout, withAbort, composeAbort } = helpers;",
        "",
        "await withTimeout(fetch(url), 2000, new Error('Timeout'));",
        "const ac = new AbortController();",
        "await withAbort(doWork, ac.signal);",
        "const combined = composeAbort(ac.signal, new AbortController().signal);"
      ]
    },
    "starterCode": "function abortableHelpers() {}\n\nabortableHelpers.sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\nabortableHelpers.withTimeout = function withTimeout(p, ms, reason) {\n  // TODO: Start a timer; race with p. On settle, clear the timer. On timeout, reject with `reason` or Error('Timeout').\n};\n\nabortableHelpers.withAbort = function withAbort(factory, signal) {\n  // TODO: If signal.aborted -> reject immediately. Otherwise run factory(signal) and listen for 'abort'. Clean up listeners on settle.\n};\n\nabortableHelpers.composeAbort = function composeAbort(...signals) {\n  // TODO: New AbortController; if any input already aborted, abort immediately with its reason; otherwise forward first abort and detach listeners.\n};\n\nexport default abortableHelpers;\n",
    "starterCodeTs": "function abortableHelpers() {}\n\nabortableHelpers['sleep'] = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\nabortableHelpers['withTimeout'] = function withTimeout<T>(p: Promise<T>, ms: number, reason?: any): Promise<T> {\n  // TODO\n  return new Promise<T>((resolve, reject) => { /* impl */ });\n};\n\nabortableHelpers['withAbort'] = function withAbort<T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal): Promise<T> {\n  // TODO\n  return new Promise<T>((resolve, reject) => { /* impl */ });\n};\n\nabortableHelpers['composeAbort'] = function composeAbort(...signals: AbortSignal[]): AbortSignal {\n  // TODO\n  const ac = new AbortController();\n  return ac.signal;\n};\n\nexport default abortableHelpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n",
    "solutionBlock": {
      "overview": "Goal: enable cooperative cancellation and safe async composition using `AbortController`. Helpers simplify racing timeouts, making async functions abortable, and merging multiple signals cleanly.",
      "approaches": [
        {
          "title": "Core idea and cleanup discipline",
          "prose": "We implement a single export `abortableHelpers` object with methods `withTimeout`, `withAbort`, `composeAbort`, and `sleep`.\n\n- **withTimeout(p, ms, reason)**: Races a promise with a timeout.\n- **withAbort(factory, signal)**: Runs cancellable async work.\n- **composeAbort(...signals)**: Merges signals into one — aborts when any does.\n\nEach helper ensures proper cleanup of timers or listeners to prevent leaks.",
          "codeJs": "function abortableHelpers() {}\n\nabortableHelpers.sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\nabortableHelpers.withTimeout = function withTimeout(p, ms, reason) {\n  return new Promise((resolve, reject) => {\n    let settled = false;\n    const id = setTimeout(() => {\n      if (settled) return;\n      settled = true;\n      reject(reason ?? new Error('Timeout'));\n    }, ms);\n\n    Promise.resolve(p).then(\n      v => { if (!settled) { settled = true; clearTimeout(id); resolve(v); } },\n      e => { if (!settled) { settled = true; clearTimeout(id); reject(e); } }\n    );\n  });\n};\n\nabortableHelpers.withAbort = function withAbort(factory, signal) {\n  return new Promise((resolve, reject) => {\n    if (signal?.aborted) { reject(signal.reason ?? new Error('Aborted')); return; }\n\n    let finished = false;\n    const onAbort = () => {\n      if (finished) return;\n      finished = true;\n      reject(signal.reason ?? new Error('Aborted'));\n    };\n\n    signal?.addEventListener('abort', onAbort, { once: true });\n\n    Promise.resolve()\n      .then(() => factory(signal))\n      .then(v => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); resolve(v); } })\n      .catch(e => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); reject(e); } });\n  });\n};\n\nabortableHelpers.composeAbort = function composeAbort(...signals) {\n  const ac = new AbortController();\n  if (!signals || signals.length === 0) return ac.signal;\n\n  const already = signals.find(s => s?.aborted);\n  if (already) { ac.abort(already.reason); return ac.signal; }\n\n  const listeners = [];\n  const abortOnce = (reason) => {\n    if (!ac.signal.aborted) ac.abort(reason);\n    for (const { s, fn } of listeners) s.removeEventListener('abort', fn);\n    listeners.length = 0;\n  };\n\n  for (const s of signals) {\n    if (!s) continue;\n    const fn = () => abortOnce(s.reason);\n    s.addEventListener('abort', fn, { once: true });\n    listeners.push({ s, fn });\n  }\n\n  return ac.signal;\n};\n\nexport default abortableHelpers;\n",
          "codeTs": "function abortableHelpers() {}\n\nabortableHelpers['sleep'] = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\nabortableHelpers['withTimeout'] = function withTimeout<T>(p: Promise<T>, ms: number, reason?: any): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    let settled = false;\n    const id = setTimeout(() => {\n      if (settled) return;\n      settled = true;\n      reject(reason ?? new Error('Timeout'));\n    }, ms);\n\n    Promise.resolve(p).then(\n      v => { if (!settled) { settled = true; clearTimeout(id); resolve(v); } },\n      e => { if (!settled) { settled = true; clearTimeout(id); reject(e); } }\n    );\n  });\n};\n\nabortableHelpers['withAbort'] = function withAbort<T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    if (signal?.aborted) { reject((signal as any).reason ?? new Error('Aborted')); return; }\n\n    let finished = false;\n    const onAbort = () => {\n      if (finished) return;\n      finished = true;\n      reject((signal as any).reason ?? new Error('Aborted'));\n    };\n\n    signal?.addEventListener('abort', onAbort, { once: true });\n\n    Promise.resolve()\n      .then(() => factory(signal))\n      .then(v => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); resolve(v); } })\n      .catch(e => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); reject(e); } });\n  });\n};\n\nabortableHelpers['composeAbort'] = function composeAbort(...signals: AbortSignal[]): AbortSignal {\n  const ac = new AbortController();\n  if (!signals || signals.length === 0) return ac.signal;\n\n  const already = signals.find(s => s?.aborted);\n  if (already) { ac.abort((already as any).reason); return ac.signal; }\n\n  type L = { s: AbortSignal; fn: () => void };\n  const listeners: L[] = [];\n  const abortOnce = (reason: any) => {\n    if (!ac.signal.aborted) ac.abort(reason);\n    for (const { s, fn } of listeners) s.removeEventListener('abort', fn);\n    listeners.length = 0;\n  };\n\n  for (const s of signals) {\n    if (!s) continue;\n    const fn = () => abortOnce((s as any).reason);\n    s.addEventListener('abort', fn, { once: true });\n    listeners.push({ s, fn });\n  }\n\n  return ac.signal;\n};\n\nexport default abortableHelpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Always remove abort listeners and clear timers to avoid leaks.",
          "Avoid double resolution; track state with a `settled` flag.",
          "If a signal is already aborted, reject immediately without side effects."
        ],
        "edgeCases": [
          "Zero-timeout case (ms = 0) → rejects immediately.",
          "Aborted signal passed to `withAbort` → immediate rejection.",
          "Composed signal with any already-aborted input → aborts instantly."
        ],
        "techniques": [
          "Use AbortController to coordinate cancellations.",
          "Use Promise.race-style logic for timeouts.",
          "Clean up listeners and timers explicitly."
        ]
      },
      "followUpQuestions": [
        "js-add-two-promises"
      ],
      "resources": [
        {
          "title": "MDN – AbortController",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController"
        },
        {
          "title": "MDN – Promise.race()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"
        }
      ]
    },
    "tests": "import helpers from './abortable-helpers';\nconst { withTimeout, withAbort, composeAbort, sleep } = helpers as any;\nfunction _sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }\nconst nap = typeof sleep === 'function' ? sleep : _sleep;\n\ndescribe('Abortable Helpers', () => {\n  test('withTimeout resolves when promise is fast', async () => {\n    const res = await withTimeout(nap(30).then(()=>42), 200);\n    expect(res).toEqual(42);\n  });\n\n  test('withTimeout rejects when timeout wins', async () => {\n    let threw = false; let msg = '';\n    try { await withTimeout(nap(200), 30, new Error('Timeout')); }\n    catch(e){ threw = true; msg = e && e.message; }\n    expect(threw).toEqual(true);\n    expect(!!msg).toEqual(true);\n  });\n\n  test('withAbort resolves if not aborted', async () => {\n    const ac = new AbortController();\n    const val = await withAbort(async (signal) => { await nap(20); return signal.aborted ? -1 : 7; }, ac.signal);\n    expect(val).toEqual(7);\n  });\n\n  test('withAbort rejects when signal aborts', async () => {\n    const ac = new AbortController();\n    let threw = false;\n    try {\n      const p = withAbort(async () => { await nap(100); return 1; }, ac.signal);\n      setTimeout(()=>ac.abort(new Error('Cancelled')), 20);\n      await p;\n    } catch{ threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort aborts when any source aborts', async () => {\n    const a = new AbortController();\n    const b = new AbortController();\n    const c = composeAbort(a.signal, b.signal);\n    expect(c.aborted).toEqual(false);\n\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 'ok'; }, c);\n    setTimeout(()=> b.abort(new Error('Bailed')), 10);\n    try { await p; } catch{ threw = true; }\n    expect(threw).toEqual(true);\n    expect(c.aborted).toEqual(true);\n  });\n\n  test('composeAbort is already aborted if any input is aborted', () => {\n    const a = new AbortController();\n    a.abort(new Error('early'));\n    const c = composeAbort(a.signal, new AbortController().signal);\n    expect(c.aborted).toEqual(true);\n  });\n});\n",
    "testsTs": "import helpers from './abortable-helpers';\nconst { withTimeout, withAbort, composeAbort, sleep } = helpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n\nfunction _sleep(ms: number){ return new Promise<void>(r=>setTimeout(r, ms)); }\nconst nap = typeof sleep === 'function' ? sleep : _sleep;\n\ndescribe('Abortable Helpers (TS)', () => {\n  test('withTimeout resolves fast', async () => {\n    const res = await withTimeout(Promise.resolve(5), 100);\n    expect(res).toEqual(5);\n  });\n\n  test('withTimeout rejects on timeout', async () => {\n    let threw = false;\n    try { await withTimeout(nap(200).then(()=>42), 10, new Error('Timeout')); }\n    catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('withAbort resolves when not aborted', async () => {\n    const ac = new AbortController();\n    const v = await withAbort(async (signal) => { await nap(15); return signal.aborted ? -1 : 9; }, ac.signal);\n    expect(v).toEqual(9);\n  });\n\n  test('withAbort rejects when aborted', async () => {\n    const ac = new AbortController();\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 1; }, ac.signal);\n    setTimeout(()=>ac.abort(new Error('cancel')), 10);\n    try { await p; } catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort aborts if any input aborts', async () => {\n    const a = new AbortController();\n    const b = new AbortController();\n    const sig = composeAbort(a.signal, b.signal);\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 'ok'; }, sig);\n    setTimeout(()=>a.abort(new Error('stop')), 10);\n    try { await p; } catch { threw = true; }\n    expect(sig.aborted).toEqual(true);\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort reflects already-aborted inputs', () => {\n    const a = new AbortController(); a.abort(new Error('early'));\n    const sig = composeAbort(a.signal);\n    expect(sig.aborted).toEqual(true);\n  });\n});\n"
  },
  {
    "id": "js-streaming-ndjson-parser",
    "title": "Streaming NDJSON Parser (Web Streams)",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "Streams",
      "Web Streams API",
      "TextDecoder",
      "Backpressure",
      "Parsing",
      "NDJSON"
    ],
    "description": {
      "summary": "Implement a **streaming** parser for NDJSON (newline-delimited JSON). Read from a `ReadableStream<Uint8Array>`, decode incrementally, split on newlines, parse each line into an object, and recover from malformed lines via a callback without stopping the stream.",
      "arguments": [
        {
          "name": "stream",
          "type": "ReadableStream<Uint8Array>",
          "desc": "Binary stream producing UTF-8 chunks of text containing one JSON object per line."
        },
        {
          "name": "onError",
          "type": "(line: string, err: any) => void (optional)",
          "desc": "Called when a line fails to parse. The parser must **continue** parsing subsequent lines."
        }
      ],
      "returns": {
        "type": "Promise<any[]>",
        "desc": "Resolves with an array of successfully parsed objects (malformed lines are skipped but reported via `onError`)."
      },
      "examples": [
        "// Given a Response with NDJSON body\nconst res = await fetch('/events.ndjson');\nconst objects = await parseNDJSON(res.body, (line, err) => console.warn('bad line:', line, err));\n// objects => an array of parsed items, in order"
      ]
    },
    "starterCode": "/*\n * parseNDJSON(stream, onError?)\n * - Consume a ReadableStream<Uint8Array> using a reader\n * - Use TextDecoder with { stream: true } to correctly handle UTF-8 boundaries\n * - Accumulate into a string buffer; split by \"\\n\" to get complete lines\n * - Keep the trailing partial line in the buffer and prepend the next chunk\n * - For each non-empty line, JSON.parse; on error, call onError(line, err) and continue\n * - After the stream ends, flush the decoder and process the final buffer\n */\nexport default async function parseNDJSON(stream, onError) {\n  // TODO: implement as described above\n}\n\n// CommonJS fallback for runners that require module.exports\ntry { if (typeof module !== 'undefined') module.exports = parseNDJSON; } catch (_) {}\n",
    "starterCodeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: any) => void\n): Promise<any[]> {\n  // TODO: implement\n  return []\n}\n\n// CommonJS fallback\n// @ts-ignore\ntry { if (typeof module !== 'undefined') (module as any).exports = parseNDJSON; } catch (_) {}\n",
    "solutionBlock": {
      "overview": "Goal: build a robust streaming NDJSON parser that respects backpressure, decodes UTF-8 across chunk boundaries, preserves order, and isolates per-line JSON errors so parsing continues.",
      "approaches": [
        {
          "title": "Approach 1: Built-ins pipeline (easiest)",
          "prose": "Use `TextDecoderStream` to handle UTF-8 boundaries and a tiny `TransformStream` to split lines. Minimal state, readable code.",
          "codeJs": "export default async function parseNDJSON(stream, onError){\n  if (!stream?.pipeThrough) throw new Error('ReadableStream expected');\n  const lineSplitter = new TransformStream({\n    start(){ this.buf = ''; },\n    transform(chunk, controller){\n      this.buf += chunk; const parts = this.buf.split('\\n');\n      this.buf = parts.pop() ?? '';\n      for (const line of parts){ const t=line.trim(); if (t) controller.enqueue(t); }\n    },\n    flush(controller){ const t = this.buf.trim(); if (t) controller.enqueue(t); }\n  });\n\n  const out = [];\n  const reader = stream\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(lineSplitter)\n    .getReader();\n\n  while (true){\n    const { value, done } = await reader.read(); if (done) break;\n    try { out.push(JSON.parse(value)); } catch (e){ onError?.(value, e); }\n  }\n  try{ reader.releaseLock(); }catch{}\n  return out;\n}",
          "codeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: unknown) => void\n): Promise<any[]> {\n  if (!('pipeThrough' in stream)) throw new Error('ReadableStream expected');\n\n  const lineSplitter = new TransformStream<string, string>({\n    start() { (this as any).buf = ''; },\n    transform(chunk, controller) {\n      (this as any).buf += chunk;\n      const parts = (this as any).buf.split('\\n');\n      (this as any).buf = parts.pop() ?? '';\n      for (const line of parts) {\n        const t = line.trim();\n        if (t) controller.enqueue(t);\n      }\n    },\n    flush(controller) {\n      const t = ((this as any).buf as string).trim();\n      if (t) controller.enqueue(t);\n    }\n  });\n\n  const out: any[] = [];\n  const reader = stream\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(lineSplitter)\n    .getReader();\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    try { out.push(JSON.parse(value)); } catch (e) { onError?.(value, e); }\n  }\n  try { reader.releaseLock(); } catch {}\n  return out;\n}"
        },
        {
          "title": "Approach 2: Async iterator style (clean & concise)",
          "prose": "Consume bytes with a reader and keep a tiny string buffer. Less plumbing than a pipeline; still clear and efficient.",
          "codeJs": "export default async function parseNDJSON(stream, onError){\n  const reader = stream.getReader(); const dec = new TextDecoder();\n  let buf = '', out = [];\n  const drain = () => { const parts = buf.split('\\n'); buf = parts.pop() ?? '';\n    for (let l of parts){ l = l.trim(); if(!l) continue; try{ out.push(JSON.parse(l)); }catch(e){ onError?.(l,e); } }\n  };\n  while(true){ const {value,done}=await reader.read(); if(done) break;\n    buf += dec.decode(value,{stream:true}); drain(); }\n  buf += dec.decode(); drain(); const tail=buf.trim();\n  if(tail){ try{ out.push(JSON.parse(tail)); }catch(e){ onError?.(tail,e); } }\n  try{ reader.releaseLock(); }catch{}\n  return out;\n}",
          "codeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: unknown) => void\n): Promise<any[]> {\n  const reader = stream.getReader();\n  const dec = new TextDecoder();\n  let buf = '';\n  const out: any[] = [];\n\n  const drain = () => {\n    const parts = buf.split('\\n');\n    buf = parts.pop() ?? '';\n    for (let l of parts) {\n      const t = l.trim();\n      if (!t) continue;\n      try { out.push(JSON.parse(t)); }\n      catch (e) { onError?.(t, e); }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buf += dec.decode(value, { stream: true });\n    drain();\n  }\n\n  buf += dec.decode();\n  drain();\n  const tail = buf.trim();\n  if (tail) {\n    try { out.push(JSON.parse(tail)); }\n    catch (e) { onError?.(tail, e); }\n  }\n\n  try { reader.releaseLock(); } catch {}\n  return out;\n}"
        },
        {
          "title": "Approach 3: Backpressure-focused reader loop (most control)",
          "prose": "The robust, production-ready variant you already have: explicit reader loop, `{ stream: true }` decoding, careful cleanup. Best when you need tight control over resource management or metrics.",
          "codeJs": "/*\n * Streaming NDJSON parser\n * - Efficient: processes data chunk-by-chunk (low memory) and preserves order\n * - Robust: isolates malformed lines via onError callback and continues\n * - Correct decoding: uses TextDecoder(stream:true) for UTF-8 boundaries\n */\nexport default async function parseNDJSON(stream, onError) {\n  if (!stream || typeof stream.getReader !== 'function') {\n    throw new Error('parseNDJSON: expected a ReadableStream<Uint8Array>');\n  }\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n  const out = [];\n\n  const drainLines = () => {\n    const parts = buffer.split('\\n');\n    buffer = parts.pop() ?? '';\n    for (let line of parts) {\n      line = line.trim();\n      if (line === '') continue;\n      try {\n        out.push(JSON.parse(line));\n      } catch (err) {\n        if (typeof onError === 'function') onError(line, err);\n      }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, { stream: true });\n    drainLines();\n  }\n\n  buffer += decoder.decode();\n  drainLines();\n  const tail = buffer.trim();\n  if (tail !== '') {\n    try { out.push(JSON.parse(tail)); }\n    catch (err) { if (typeof onError === 'function') onError(tail, err); }\n  }\n\n  try { reader.releaseLock(); } catch (_) {}\n  return out;\n}\n\ntry { if (typeof module !== 'undefined') module.exports = parseNDJSON; } catch (_) {}\n",
          "codeTs": "/*\n * Streaming NDJSON parser (TypeScript)\n * Same logic, with typed signatures for clarity.\n */\nexport default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: any) => void\n): Promise<any[]> {\n  if (!stream || typeof (stream as any).getReader !== 'function') {\n    throw new Error('parseNDJSON: expected a ReadableStream<Uint8Array>');\n  }\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n  const out: any[] = [];\n\n  const drainLines = () => {\n    const parts = buffer.split('\\n');\n    buffer = parts.pop() ?? '';\n    for (let raw of parts) {\n      const line = raw.trim();\n      if (line === '') continue;\n      try { out.push(JSON.parse(line)); }\n      catch (err) { if (onError) onError(line, err); }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, { stream: true });\n    drainLines();\n  }\n\n  buffer += decoder.decode();\n  drainLines();\n  const tail = buffer.trim();\n  if (tail !== '') {\n    try { out.push(JSON.parse(tail)); }\n    catch (err) { if (onError) onError(tail, err); }\n  }\n\n  try { reader.releaseLock(); } catch {}\n  return out;\n}\n\n// CommonJS fallback\n// @ts-ignore\ntry { if (typeof module !== 'undefined') (module as any).exports = parseNDJSON; } catch {}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting `{ stream: true }` on `TextDecoder.decode` can corrupt multi-byte characters split across chunks.",
          "Dropping the trailing partial line between chunks leads to truncated/invalid JSON.",
          "Throwing on a single bad line halts the entire parse — prefer `onError` and continue."
        ],
        "edgeCases": [
          "CRLF endings: `\\r\\n` — use `trim()` before parsing to remove stray `\\r`.",
          "Empty lines: skip safely.",
          "Final line without trailing `\\n`: parse it after flushing the decoder."
        ],
        "techniques": [
          "Respect backpressure with `getReader()` and `await reader.read()`.",
          "Incremental decode using `TextDecoder` with stream mode.",
          "Carry-over buffer + split-on-newline to align record boundaries."
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "MDN – Streams API",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Streams_API"
        },
        {
          "title": "MDN – TextDecoder",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder"
        }
      ]
    },
    "tests": "import parseNDJSON from './ndjson-parser';\n\n// Helper: build a ReadableStream<Uint8Array> that emits given string chunks\nconst te = new TextEncoder();\nfunction streamFromStrings(chunks) {\n  return new ReadableStream({\n    start(controller) {\n      let i = 0;\n      const pump = () => {\n        if (i >= chunks.length) { controller.close(); return; }\n        controller.enqueue(te.encode(chunks[i++]));\n        setTimeout(pump, 0); // async to exercise the reader loop\n      };\n      pump();\n    }\n  });\n}\n\nfunction expectEqual(a, b){ expect(JSON.stringify(a)).toEqual(JSON.stringify(b)); }\n\ndescribe('Streaming NDJSON Parser', () => {\n  test('parses lines across arbitrary chunk boundaries', async () => {\n    const chunks = [\n      '{\"a\":1}\\n{\"b\"',\n      ':2}\\n{\"c\":3}\\n',\n    ];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{a:1},{b:2},{c:3}]);\n  });\n\n  test('handles last line without trailing newline', async () => {\n    const chunks = ['{\"x\":1}\\n{\"y\":2}'];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{x:1},{y:2}]);\n  });\n\n  test('skips blank lines and trims CRLF', async () => {\n    const chunks = ['\\r\\n', '{\"n\":1}\\r\\n', '\\n', '{\"m\":2}\\n'];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{n:1},{m:2}]);\n  });\n\n  test('reports malformed lines via onError and continues', async () => {\n    const bad = []; // collect bad lines\n    const chunks = ['{\"ok\":1}\\n', '{bad json}\\n', '{\"ok\":2}\\n'];\n    const res = await parseNDJSON(streamFromStrings(chunks), (line, err) => { bad.push(line); });\n    expectEqual(res, [{ok:1},{ok:2}]);\n    expectEqual(bad, ['{bad json}']);\n  });\n});\n",
    "testsTs": "import parseNDJSON from './ndjson-parser';\n\nconst te = new TextEncoder();\nfunction streamFromStrings(chunks: string[]): ReadableStream<Uint8Array> {\n  return new ReadableStream<Uint8Array>({\n    start(controller) {\n      let i = 0;\n      const pump = () => {\n        if (i >= chunks.length) { controller.close(); return; }\n        controller.enqueue(te.encode(chunks[i++]));\n        setTimeout(pump, 0);\n      };\n      pump();\n    }\n  });\n}\n\nfunction expectEqual(a: any, b: any){ expect(JSON.stringify(a)).toEqual(JSON.stringify(b)); }\n\ndescribe('Streaming NDJSON Parser (TS)', () => {\n  test('parses across chunk boundaries', async () => {\n    const res = await parseNDJSON(streamFromStrings(['{\"a\":1}\\n{\"b\"', ':2}\\n']));\n    expectEqual(res, [{a:1},{b:2}]);\n  });\n\n  test('no trailing newline', async () => {\n    const res = await parseNDJSON(streamFromStrings(['{\"x\":1}\\n{\"y\":2}']));\n    expectEqual(res, [{x:1},{y:2}]);\n  });\n\n  test('error isolation', async () => {\n    const errors: string[] = [];\n    const res = await parseNDJSON(streamFromStrings(['{\"ok\":1}\\n','{oops}\\n','{\"ok\":2}\\n']), (line) => errors.push(line));\n    expectEqual(res, [{ok:1},{ok:2}]);\n    expectEqual(errors, ['{oops}']);\n  });\n});\n"
  },
  {
    "id": "js-array-prototype-map",
    "title": "Implement Array.prototype.map",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "Arrays",
      "Callbacks",
      "Iteration",
      "Polyfills"
    ],
    "teaches": [
      "How built-in array iteration works under the hood",
      "Correct callback invocation and thisArg binding",
      "Handling sparse arrays (holes) correctly",
      "Spec-aware details: boxing, length coercion, property checks"
    ],
    "description": {
      "summary": "Recreate the native `.map()` method **without using it**. Your `myMap` must call the callback for each existing index, pass `(value, index, array)`, respect `thisArg`, and return a new array with the mapped values. It must **skip holes** (no callback for missing indices) and preserve array length.",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "(currentValue: any, index: number, array: any[]) => any",
          "desc": "Function to execute on each existing element."
        },
        {
          "name": "thisArg",
          "type": "any (optional)",
          "desc": "Value to use as `this` when executing callback."
        }
      ],
      "returns": {
        "type": "Array",
        "desc": "A new array with the results of calling `callbackFn` on every existing element."
      },
      "examples": [
        "[1, 2, 3].myMap(x => x * 2) // => [2, 4, 6]",
        "[, 10, , 30].myMap((v,i) => i) // => [ , 1, , 3 ] (holes preserved)",
        "[1].myMap(function(x){ return this.add + x }, { add: 5 }) // => [6]"
      ]
    },
    "starterCode": "/* Boilerplate — replace the throw with a correct implementation */\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};\n",
    "starterCodeTs": "declare global {\n  interface Array<T> {\n    myMap<U>(\n      callbackFn: (value: T, index: number, array: Array<T>) => U,\n      thisArg?: any\n    ): Array<U>;\n  }\n}\n\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};\n",
    "solutionBlock": {
      "overview": "Goal: implement a `.map()`-like method that iterates indices 0..length−1, calls the callback with `(value, index, array)`, respects `thisArg`, **skips holes**, and returns a new array with the same length. Approach 1 is the simplest practical variant; Approach 2 is closer to the spec.",
      "approaches": [
        {
          "title": "Approach 1: Simple for-loop (practical baseline)",
          "prose": "Idea: create an output array of the same length and fill it as we go. Only call the callback for **real** elements (skip holes) and write each result at the same index.\n\nHow it works\n1) Read the length once: `len = this.length`.\n2) Pre-create the result array: `out = new Array(len)` (so length/holes are preserved).\n3) Loop `k = 0 → len − 1`.\n4) If `Object.hasOwn(this, k)` is true, the slot exists → call the callback with context: `callbackFn.call(thisArg, this[k], k, this)`.\n5) Put the returned value at `out[k]`.\n6) Return `out`.\n\nWhy it works\n- `Object.hasOwn` skips missing indices (holes), matching how native `map` behaves on sparse arrays.\n- Writing results by index keeps output length and hole positions identical to the input.\n\nComplexity\n- Time: O(n) (single pass).  Space: O(n) for the output array.",
          "codeJs": "Array.prototype.myMap = function (callbackFn, thisArg) {\n  const len = this.length;\n  const out = new Array(len);\n  for (let k = 0; k < len; k++) {\n    if (Object.hasOwn(this, k)) {\n      out[k] = callbackFn.call(thisArg, this[k], k, this);\n    }\n  }\n  return out;\n};\n",
          "codeTs": "interface Array<T> {\n  myMap<U>(\n    callbackFn: (value: T, index: number, array: Array<T>) => U,\n    thisArg?: any\n  ): Array<U>;\n}\n\nArray.prototype.myMap = function <T, U>(this: T[], callbackFn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[] {\n  const len: number = this.length;\n  const out = new Array<U>(len);\n  for (let k = 0; k < len; k++) {\n    if (Object.hasOwn(this, k)) {\n      out[k] = callbackFn.call(thisArg, (this as T[])[k], k, this as T[]);\n    }\n  }\n  return out;\n};\n"
        },
        {
          "title": "Approach 2: Spec-leaning (ToObject + length coercion + `k in O`)",
          "prose": "Idea: mirror native semantics more closely. Convert `this` to an object, coerce `length` safely, and use `k in O` so inherited numeric properties count as elements (like the real `.map()`).\n\nHow it works\n1) Box the receiver: `const O = Object(this)`.\n2) Coerce length: `len = Math.max(0, Math.floor(Number(O.length) || 0))`.\n3) Create `out = new Array(len)`.\n4) Loop `k = 0 → len − 1`.\n5) If `(k in O)` is true, call `callbackFn.call(thisArg, O[k], k, O)` and assign to `out[k]`.\n6) Return `out`.\n\nWhy it works\n- `k in O` matches the spec’s property lookup rules (own or inherited).\n- Pre-sized array keeps indices aligned with the original.\n\nComplexity\n- Time: O(n).  Space: O(n) for the output array.",
          "codeJs": "Array.prototype.myMap = function (callbackFn, thisArg) {\n  const O = Object(this);\n  const len = Math.max(0, Math.floor(Number(O.length) || 0));\n  const out = new Array(len);\n  for (let k = 0; k < len; k++) {\n    if (k in O) {\n      out[k] = callbackFn.call(thisArg, O[k], k, O);\n    }\n  }\n  return out;\n};\n",
          "codeTs": "Array.prototype.myMap = function <T, U>(this: T[], callbackFn: (value: T, index: number, array: Array<T>) => U, thisArg?: any): U[] {\n  const O = Object(this) as Record<string | number, T> & { length: number };\n  const len: number = Math.max(0, Math.floor(Number(O.length) || 0));\n  const out = new Array<U>(len);\n  for (let k = 0; k < len; k++) {\n    if (k in O) {\n      out[k] = callbackFn.call(thisArg, O[k] as T, k, O as unknown as T[]);\n    }\n  }\n  return out;\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Calling the callback for holes: use `Object.hasOwn(this, k)` or be intentional with `k in O`.",
          "`thisArg` is ignored by arrow functions by design—use a normal function if you need `this`.",
          "Forgetting to preserve length/holes (e.g., using `push`) changes the array shape."
        ],
        "edgeCases": [
          "Sparse arrays like `[,10,,30]` → callbacks should run only for existing indices.",
          "Inherited numeric keys: Approach 2 includes them; Approach 1 does not.",
          "Mutations during mapping can affect later iterations (same as native)."
        ],
        "techniques": [
          "Coerce the receiver with `Object(this)` when you want spec-accurate behavior.",
          "Coerce length safely with `Math.floor(Number(len) || 0)` (or `>>> 0` if allowed).",
          "Use `.call(thisArg, value, index, array)` to bind callback context.",
          "Preallocate the output array to keep indices aligned."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-filter",
        "js-array-prototype-reduce",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.map()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"
        },
        {
          "title": "ECMAScript Spec – Array.prototype.map",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.map"
        }
      ]
    },
    "tests": "const identity = (x) => x;\nconst square = (n) => n * n;\n\ndescribe('Array.prototype.myMap', () => {\n  test('identity', () => {\n    expect([10].myMap(identity)).toEqual([10]);\n    expect([10, 20].myMap(identity)).toEqual([10, 20]);\n  });\n\n  test('square', () => {\n    expect([-4].myMap(square)).toEqual([16]);\n    expect([5].myMap(square)).toEqual([25]);\n  });\n\n  test('skips holes and preserves length', () => {\n    const a = [, 10, , 30];\n    const r = a.myMap((v, i) => i);\n    expect(r.length).toBe(4);\n    expect(0 in r).toBe(false);\n    expect(1 in r).toBe(true);\n    expect(2 in r).toBe(false);\n    expect(3 in r).toBe(true);\n  });\n\n  test('binds thisArg', () => {\n    const ctx = { add: 5 };\n    const out = [1].myMap(function (x) { return this.add + x; }, ctx);\n    expect(out).toEqual([6]);\n  });\n});\n",
    "testsTs": "// @ts-nocheck\nconst _shimMap = (arr, cb, thisArg) => {\n  const O = Object(arr);\n  let len = Math.max(0, Math.floor(Number(O.length) || 0));\n  const A = new Array(len);\n  for (let k = 0; k < len; k++) {\n    if (k in O) A[k] = cb.call(thisArg, O[k], k, O);\n  }\n  return A;\n};\n\nconst callMap = (arr, cb, thisArg) =>\n  typeof arr.myMap === 'function' ? arr.myMap(cb, thisArg) : _shimMap(arr, cb, thisArg);\n\nconst identity = (element) => element;\nconst square = (element) => element * element;\n\ndescribe('Array.prototype.myMap', () => {\n  test('identity', () => {\n    expect(callMap([10], identity)).toEqual([10]);\n    expect(callMap([10, 20], identity)).toEqual([10, 20]);\n  });\n\n  test('square', () => {\n    expect(callMap([-4], square)).toEqual([16]);\n    expect(callMap([5], square)).toEqual([25]);\n  });\n});\n"
  },
  {
    "id": "js-array-prototype-reduce",
    "title": "Implement Array.prototype.reduce",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "medium",
    "tags": [
      "Arrays",
      "Callbacks",
      "Iteration",
      "Polyfills",
      "Accumulators"
    ],
    "teaches": [
      "How array reduction works under the hood",
      "Accumulator initialization with or without an initial value",
      "Handling sparse arrays (holes) correctly",
      "Throwing on empty arrays without an initial value"
    ],
    "description": {
      "summary": "Recreate the native `.reduce()` method **without using it**. Your `myReduce` must call the reducer with `(accumulator, currentValue, index, array)` only for existing indices, handle an optional `initialValue`, and return the final accumulator. If no `initialValue` is provided, use the **first existing element** as the initial accumulator. If there is **no existing element** and no `initialValue`, throw a `TypeError`.",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "(accumulator: any, currentValue: any, index: number, array: any[]) => any",
          "desc": "Reducer function applied to each existing element."
        },
        {
          "name": "initialValue",
          "type": "any (optional)",
          "desc": "Value to use as the first accumulator. If omitted, the first existing element is used."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "The final accumulated value after iterating through the array."
      },
      "examples": [
        "[1, 2, 3].myReduce((acc, x) => acc + x, 0) // => 6",
        "[, 1, , 3].myReduce((acc, x) => acc + x)   // => 4 (skips holes; starts at 1)",
        "[].myReduce((a, x) => a + x, 10)           // => 10"
      ]
    },
    "starterCode": "/* Boilerplate — replace the throw with a correct implementation */\nArray.prototype.myReduce = function (callbackFn, initialValue) {\n  throw 'Not implemented!';\n};\n",
    "starterCodeTs": "declare global {\n  interface Array<T> {\n    myReduce<U>(\n      callbackFn: (accumulator: U, currentValue: T, index: number, array: Array<T>) => U,\n      initialValue: U\n    ): U;\n    myReduce(\n      callbackFn: (accumulator: T, currentValue: T, index: number, array: Array<T>) => T\n    ): T;\n  }\n}\n\nArray.prototype.myReduce = function (callbackFn: any, initialValue?: any) {\n  throw 'Not implemented!';\n};\n",
    "solutionBlock": {
      "overview": "What a correct `.reduce()` must do: (1) Work on the receiver and read its `length` directly. (2) If `initialValue` is provided, start with it; otherwise find the first existing element as the initial accumulator (skip holes) or throw on empty. (3) For each existing index, call `callbackFn(acc, value, index, array)` and store back to `acc`. (4) Skip holes using an own-property check. (5) Return the final `acc`.",
      "approaches": [
        {
          "title": "Approach 1: Simple for-loop (practical baseline)",
          "prose": "Iterate 0..length-1, seed the accumulator from `initialValue` or the first present element, and skip holes with an own-property check. Clear, fast, and mirrors everyday expectations.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = O.length >>> 0; // coerce to uint32 without changing semantics\n  let k = 0;\n  let acc;\n  if (arguments.length > 1) {\n    acc = initialValue;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(O, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      acc = callbackFn(acc, O[k], k, O);\n    }\n  }\n  return acc;\n};\n",
          "codeTs": "declare global {\n  interface Array<T> {\n    myReduce<U>(cb: (acc: U, cur: T, idx: number, arr: T[]) => U, initialValue: U): U;\n    myReduce(cb: (acc: T, cur: T, idx: number, arr: T[]) => T): T;\n  }\n}\n\nArray.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as T[] & { length: number };\n  const len: number = (O.length >>> 0);\n  let k = 0;\n  let acc: any;\n  if (arguments.length > 2 || (arguments.length === 2 && initialValue !== undefined)) {\n    acc = initialValue as U;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(O, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = (O as any)[k++];\n  }\n  for (; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      acc = (callbackFn as any)(acc, (O as any)[k], k, O);\n    }\n  }\n  return acc as any;\n};\n"
        },
        {
          "title": "Approach 2: Spec-leaning (`ToObject`, length coercion, `k in O`)",
          "prose": "Closer to native semantics: coerce `this` with `Object(this)`, coerce length with `Math.floor(Number(...))`, and use `k in O` to honor inherited index accessors (native does). Still skips actual holes when nothing is inherited at that index.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = Math.max(0, Math.floor(Number(O.length) || 0));\n  let k = 0;\n  let acc;\n  if (arguments.length > 1) {\n    acc = initialValue;\n  } else {\n    while (k < len && !(k in O)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) {\n    if (k in O) acc = callbackFn(acc, O[k], k, O);\n  }\n  return acc;\n};\n",
          "codeTs": "Array.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as Record<number, T> & { length: number };\n  const len: number = Math.max(0, Math.floor(Number(O.length) || 0));\n  let k = 0;\n  let acc: any;\n  if (arguments.length > 2 || (arguments.length === 2 && initialValue !== undefined)) {\n    acc = initialValue as U;\n  } else {\n    while (k < len && !(k in O)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) if (k in O) acc = (callbackFn as any)(acc, O[k], k, O as any);\n  return acc as any;\n};\n"
        },
        {
          "title": "Approach 3: Helper-driven (readability: `nextPresentIndex`)",
          "prose": "Extract the ‘find next present element’ logic into a tiny helper. This makes the seeding + iteration steps very explicit and easy to reason about for sparse arrays.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = O.length >>> 0;\n  const nextPresentIndex = (start) => {\n    let i = start; while (i < len && !Object.prototype.hasOwnProperty.call(O, i)) i++; return i;\n  };\n  let k = 0;\n  let acc;\n  if (arguments.length > 1) {\n    acc = initialValue; k = nextPresentIndex(0);\n  } else {\n    k = nextPresentIndex(0);\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (k = nextPresentIndex(k); k < len; k = nextPresentIndex(k + 1)) {\n    acc = callbackFn(acc, O[k], k, O);\n  }\n  return acc;\n};\n",
          "codeTs": "Array.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as T[] & { length: number };\n  const len: number = (O.length >>> 0);\n  const hasOwn = Object.prototype.hasOwnProperty;\n  const nextPresentIndex = (start: number): number => {\n    let i = start; while (i < len && !hasOwn.call(O, i)) i++; return i;\n  };\n  let k = 0;\n  let acc: any;\n  if (arguments.length > 2 || (arguments.length === 2 && initialValue !== undefined)) {\n    acc = initialValue as U; k = nextPresentIndex(0);\n  } else {\n    k = nextPresentIndex(0);\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = (O as any)[k++];\n  }\n  for (k = nextPresentIndex(k); k < len; k = nextPresentIndex(k + 1)) {\n    acc = (callbackFn as any)(acc, (O as any)[k], k, O);\n  }\n  return acc as any;\n};\n"
        }
      ]
    },
    "notes": {
      "pitfalls": [
        "Using `this[0]` as the seed even when index 0 is a hole — must scan for the **first present** element.",
        "Forgetting to skip holes (use own-property checks or `k in O` as appropriate).",
        "Not throwing on an empty array when `initialValue` is omitted."
      ],
      "edgeCases": [
        "All holes (e.g., `[,,,]`) with no `initialValue` → throw `TypeError`.",
        "Arrays with leading holes (e.g., `[,1,,3]`) → seed from `1` when `initialValue` is omitted.",
        "Arrays with getters on inherited indices: if you use `k in O`, inherited accessors may participate."
      ],
      "techniques": [
        "Coerce the receiver with `Object(this)` before reading `length`.",
        "Seed from `initialValue` when provided; otherwise scan for the first present element.",
        "Use `hasOwnProperty.call(O, k)` to skip holes consistently."
      ]
    },
    "followUpQuestions": [
      "js-array-prototype-map",
      "js-array-prototype-filter",
      "js-array-prototype-some"
    ],
    "resources": [
      {
        "title": "MDN – Array.prototype.reduce()",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
      },
      {
        "title": "ECMAScript Spec (Reduce)",
        "url": "https://tc39.es/ecma262/#sec-array.prototype.reduce"
      }
    ],
    "tests": "const sum = (a, x) => a + x;\nconst pair = (a, x, i) => a.concat([[i, x]]);\n\n// helper for throw assertions (no toThrow in this runner)\nconst expectThrowsTypeError = (fn) => {\n  let ok = false;\n  try { fn(); } catch (e) { ok = e instanceof TypeError; }\n  expect(ok).toBe(true);\n};\n\ndescribe('Array.prototype.myReduce', () => {\n  test('with initialValue on dense arrays', () => {\n    expect([1, 2, 3].myReduce(sum, 0)).toBe(6);\n    expect([5].myReduce(sum, 10)).toBe(15);\n  });\n\n  test('without initialValue uses first existing element (handles leading holes)', () => {\n    const a = [, 1, , 3];\n    expect(a.myReduce(sum)).toBe(4);\n  });\n\n  test('skips holes (sparse arrays) with initialValue', () => {\n    const a = [, 1, , 3];\n    expect(a.myReduce(sum, 0)).toBe(4);\n  });\n\n  test('passes index and array correctly', () => {\n    const out = [10, 20].myReduce(pair, []);\n    expect(out).toEqual([[0, 10], [1, 20]]);\n  });\n\n  test('empty array with initialValue returns initialValue', () => {\n    expect([].myReduce(sum, 42)).toBe(42);\n  });\n\n  test('empty array without initialValue throws TypeError', () => {\n    expectThrowsTypeError(() => [].myReduce(sum));\n  });\n});\n",
    "testsTs": "// @ts-nocheck\nconst _shimReduce = (arr, cb, initProvided, initVal) => {\n  const len = arr.length;\n  let k = 0;\n  let acc;\n  if (initProvided) {\n    acc = initVal;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(arr, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = arr[k++];\n  }\n  for (; k < len; k++) if (Object.prototype.hasOwnProperty.call(arr, k)) acc = cb(acc, arr[k], k, arr);\n  return acc;\n};\n\nconst callReduce = (arr, cb, ...rest) =>\n  typeof arr.myReduce === 'function'\n    ? arr.myReduce(cb, ...rest)\n    : _shimReduce(arr, cb, rest.length > 0, rest[0]);\n\nconst sum = (a, x) => a + x;\n\nconst expectThrowsTypeError = (fn) => {\n  let ok = false; try { fn(); } catch (e) { ok = e instanceof TypeError; } expect(ok).toBe(true);\n};\n\ndescribe('Array.prototype.myReduce (TS)', () => {\n  test('sum with initialValue', () => {\n    expect(callReduce([1, 2, 3], sum, 0)).toBe(6);\n  });\n  test('sum without initialValue (holes at start)', () => {\n    expect(callReduce([,1,,3], sum)).toBe(4);\n  });\n  test('sparse array skipping with initialValue', () => {\n    expect(callReduce([,1,,3], sum, 0)).toBe(4);\n  });\n  test('empty + initial returns initial', () => {\n    expect(callReduce([], sum, 7)).toBe(7);\n  });\n  test('empty without initial throws', () => {\n    expectThrowsTypeError(() => callReduce([], sum));\n  });\n});\n"
  },
  {
    "id": "js-array-prototype-filter",
    "title": "Implement Array.prototype.filter",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "callbacks",
      "iteration",
      "polyfills",
      "core-js"
    ],
    "description": {
      "summary": "Recreate the native `Array.prototype.filter()` method as `myFilter`. It should call a provided callback once for each element in the array, include the element in the new array if the callback returns a truthy value, skip holes in sparse arrays, and support an optional `thisArg` for context.",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "function",
          "desc": "Function to test each element. It receives (element, index, array) as arguments."
        },
        {
          "name": "thisArg",
          "type": "any",
          "desc": "Value to use as `this` when executing `callbackFn`."
        }
      ],
      "returns": {
        "type": "Array",
        "desc": "A new array with elements that passed the test implemented by `callbackFn`."
      },
      "examples": [
        "// Filter even numbers\n[1, 2, 3, 4, 5].myFilter(n => n % 2 === 0) // => [2, 4]",
        "// Filter by context\n[1, 2, 3, 4, 5].myFilter(function(n) { return n > this.min; }, { min: 3 }) // => [4, 5]"
      ]
    },
    "starterCode": "Array.prototype.myFilter = function(callbackFn, thisArg) {\n  throw new Error('Not implemented');\n};\n",
    "starterCodeTs": "interface Array<T> {\n  myFilter<U extends T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];\n}\n\nArray.prototype.myFilter = function<T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[] {\n  throw new Error('Not implemented');\n};\n",
    "solutionBlock": {
      "overview": "Goal: implement a `.filter()`-like method that iterates indices 0..length-1, calls the predicate with `(value, index, array)`, **skips holes**, respects `thisArg`, and returns a **new** array of values for which the predicate is truthy.",
      "approaches": [
        {
          "title": "Approach 1: Variadic for-loop using own-property check (simplest)",
          "prose": "Idea: build a new array while looping once. Only call the predicate for **real** elements (skip holes), bind `thisArg`, and push when the predicate is truthy.\n\nHow it works\n1) Guardrails: throw if called on null/undefined or if `callbackFn` isn’t a function.\n2) Coerce the receiver: `const arr = Object(this)` so we can safely read `length`.\n3) Snapshot `length` once: `len = arr.length >>> 0`.\n4) Create an empty result array: `const result = []`.\n5) Loop `i = 0 → len - 1`:\n   • If `Object.hasOwn(arr, i)` is **true**, the slot exists (not a hole).\n   • Read `val = arr[i]`.\n   • Run predicate with context: `callbackFn.call(thisArg, val, i, arr)`.\n   • If truthy, `result.push(val)`.\n6) Return `result`.\n\nWhy it works\n- `Object.hasOwn` skips missing indices → no predicate calls for holes.\n- Using `.call(thisArg, ...)` mirrors native `filter`’s `this` handling.\n- We only scan once and push in order → same output order as the input.\n\nComplexity\n- Time: O(n) — one pass.\n- Space: O(k) — number of kept items.",
          "codeJs": "Array.prototype.myFilter = function(callbackFn, thisArg) {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(callbackFn + ' is not a function');\n  const arr = Object(this);\n  const len = arr.length >>> 0;\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    if (Object.hasOwn(arr, i)) {\n      const val = arr[i];\n      if (callbackFn.call(thisArg, val, i, arr)) result.push(val);\n    }\n  }\n  return result;\n};\n",
          "codeTs": "interface Array<T> {\n  myFilter<U extends T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];\n}\n\nArray.prototype.myFilter = function<T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[] {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n  const arr = Object(this) as { [k: number]: T; length: number };\n  const len = arr.length >>> 0;\n  const result: T[] = [];\n  for (let i = 0; i < len; i++) {\n    if (Object.hasOwn(arr, i)) {\n      const val = arr[i];\n      if (callbackFn.call(thisArg, val, i, arr)) result.push(val);\n    }\n  }\n  return result;\n};\n"
        },
        {
          "title": "Approach 2: Spec-leaning — include inherited numeric keys with `k in O`",
          "prose": "Idea: behave closer to the spec by considering numeric keys that come from the prototype chain (`k in O`). That allows inherited getters at numeric indices to participate.\n\nHow it works\n1) Validate inputs (same as Approach 1).\n2) Coerce the receiver: `const O = Object(this)`.\n3) Coerce length once: `len = Math.max(0, Math.floor(Number(O.length) || 0))`.\n4) Prepare `out = []`.\n5) Loop `k = 0 → len - 1`:\n   • If `(k in O)` is **true**, treat it as an element (own or inherited).\n   • Get `v = O[k]` (may trigger an inherited getter).\n   • If `callbackFn.call(thisArg, v, k, O)` is truthy → `out.push(v)`.\n6) Return `out`.\n\nWhy it works\n- `k in O` mirrors ECMAScript iteration semantics for array methods that consult the prototype chain.\n- Still returns a dense array of matches in the original order.\n\nComplexity\n- Time: O(n).\n- Space: O(k).",
          "codeJs": "Array.prototype.myFilter = function(callbackFn, thisArg) {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(callbackFn + ' is not a function');\n  const O = Object(this);\n  const len = Math.max(0, Math.floor(Number(O.length) || 0));\n  const out = [];\n  for (let k = 0; k < len; k++) {\n    if (k in O) {\n      const v = O[k];\n      if (callbackFn.call(thisArg, v, k, O)) out.push(v);\n    }\n  }\n  return out;\n};\n",
          "codeTs": "Array.prototype.myFilter = function<T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[] {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n  const O = Object(this) as Record<number, T> & { length: number };\n  const len: number = Math.max(0, Math.floor(Number(O.length) || 0));\n  const out: T[] = [];\n  for (let k = 0; k < len; k++) {\n    if (k in O) {\n      const v = O[k];\n      if (callbackFn.call(thisArg, v, k, O as any)) out.push(v);\n    }\n  }\n  return out;\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Calling the predicate for holes — use `Object.hasOwn` or `k in O` depending on whether you want to include inherited indices.",
          "Mutating the array while filtering can affect subsequent iterations (same as native).",
          "Forgetting to validate `callbackFn` and `this` can cause confusing errors."
        ],
        "edgeCases": [
          "Sparse arrays: `[1, , 3]` → predicate is not called for the missing index when using own-property checks.",
          "Inherited getters at numeric keys: with `k in O`, those can be considered elements.",
          "`thisArg` binding: arrow functions ignore `thisArg` by design."
        ],
        "techniques": [
          "Coerce the receiver with `Object(this)` and read `length` once.",
          "Prefer `>>> 0` or `Math.floor(Number(...))` to safely coerce `length`.",
          "Use `.call(thisArg, value, index, array)` to pass context."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-map",
        "js-array-prototype-reduce",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        },
        {
          "title": "ECMAScript Spec (Filter)",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.filter"
        }
      ]
    },
    "tests": "describe('Array.prototype.myFilter', () => {\n  test('filters even numbers', () => {\n    const res = [1, 2, 3, 4, 5].myFilter(x => x % 2 === 0);\n    expect(res).toEqual([2, 4]);\n  });\n\n  test('returns empty array when nothing matches', () => {\n    const res = [1, 3, 5].myFilter(x => x % 2 === 0);\n    expect(res).toEqual([]);\n  });\n\n  test('does not mutate original array', () => {\n    const arr = [1, 2, 3];\n    arr.myFilter(x => x > 1);\n    expect(arr).toEqual([1, 2, 3]);\n  });\n\n  test('uses thisArg correctly', () => {\n    const ctx = { min: 3 };\n    const res = [1, 2, 3, 4, 5].myFilter(function(x) { return x > this.min; }, ctx);\n    expect(res).toEqual([4, 5]);\n  });\n\n  test('skips holes in sparse arrays', () => {\n    const arr = [1, , 3];\n    const res = arr.myFilter(x => true);\n    expect(res).toEqual([1, 3]);\n  });\n});\n",
    "testsTs": "describe('Array.prototype.myFilter (TypeScript)', () => {\n  it('should filter even numbers', () => {\n    const result = [1, 2, 3, 4, 5].myFilter(n => n % 2 === 0);\n    expect(result).toEqual([2, 4]);\n  });\n\n  it('should handle empty results correctly', () => {\n    const result = [1, 3, 5].myFilter(n => n % 2 === 0);\n    expect(result).toEqual([]);\n  });\n\n  it('should use thisArg for context', () => {\n    const ctx = { min: 3 };\n    const result = [1, 2, 3, 4, 5].myFilter(function(x) { return x > this.min; }, ctx);\n    expect(result).toEqual([4, 5]);\n  });\n});\n"
  },
  {
    "id": "js-array-foreach",
    "title": "Implement Array.forEach (no prototype mutation)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "iteration",
      "callbacks",
      "edge-cases"
    ],
    "description": {
      "summary": "Write a `forEach` helper that invokes a callback for each existing element in an array, in order, without mutating prototypes. Tests sparse arrays, callback binding, and mutation during iteration.",
      "arguments": [
        {
          "name": "arr",
          "type": "Array<any>",
          "desc": "Source array to iterate. Sparse slots must be skipped."
        },
        {
          "name": "callbackFn",
          "type": "(value:any, index:number, array:any[]) => void",
          "desc": "Function to invoke for each present element."
        },
        {
          "name": "thisArg",
          "type": "any (optional)",
          "desc": "Value of `this` inside `callbackFn`."
        }
      ],
      "returns": {
        "type": "void",
        "desc": "No return value (returns `undefined`)."
      },
      "examples": [
        "// Sum values\nlet sum = 0; arrayForEach([1,2,3], v => { sum += v; }); // sum = 6",
        "// Respect thisArg\nconst ctx = { seen: [] }; arrayForEach(['a','b'], function (v) { this.seen.push(v); }, ctx); // ctx.seen = ['a','b']",
        "// Skip holes\nconst a = [1, , 3]; arrayForEach(a, (v, i) => { /* called for i=0 and i=2 only */ });"
      ]
    },
    "starterCode": "export default function arrayForEach(arr, callbackFn, thisArg) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function arrayForEach<T>(\n  arr: (T | undefined)[],\n  callbackFn: (value: T, index: number, array: (T | undefined)[]) => void,\n  thisArg?: any,\n): void {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Behave like native `Array.prototype.forEach` without touching prototypes: walk left→right over **existing** indices, call the callback with `(value, index, array)` bound to `thisArg`, **skip holes**, snapshot `length` once, and return `undefined`.",
      "approaches": [
        {
          "title": "Approach 1: Snapshot length + own-property check (recommended)",
          "prose": "1. Validate inputs (`Array.isArray` + function check).\n2. Snapshot `len = arr.length` so appends aren’t visited.\n3. Loop `i = 0..len-1` and call callback only if `hasOwn.call(arr, i)`.\n4. Bind `thisArg` with `.call` and return `undefined`.\n\n✅ Skips holes, ignores new elements, matches spec behavior.",
          "codeJs": "export default function arrayForEach(arr, callbackFn, thisArg) {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n  const len = arr.length;\n  const hasOwn = Object.prototype.hasOwnProperty;\n  for (let i = 0; i < len; i++) {\n    if (hasOwn.call(arr, i)) {\n      callbackFn.call(thisArg, arr[i], i, arr);\n    }\n  }\n  return undefined;\n}\n",
          "codeTs": "export default function arrayForEach<T>(\n  arr: (T | undefined)[],\n  callbackFn: (value: T, index: number, array: (T | undefined)[]) => void,\n  thisArg?: any,\n): void {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n  const len = arr.length;\n  const hasOwn = Object.prototype.hasOwnProperty;\n  for (let i = 0; i < len; i++) {\n    if (hasOwn.call(arr, i)) {\n      callbackFn.call(thisArg, arr[i] as T, i, arr);\n    }\n  }\n}\n"
        },
        {
          "title": "Approach 2: Spec-leaning — ToObject + `k in O` (includes inherited numeric keys)",
          "prose": "1. Convert to object: `const O = Object(arr)` and coerce `len` safely.\n2. Loop `k = 0..len-1` and check `(k in O)` to include inherited indices.\n3. Call `callbackFn.call(thisArg, O[k], k, O)` and return `undefined`.\n\n✅ Mirrors spec property access and includes inherited numeric keys.",
          "codeJs": "export default function arrayForEach(arr, callbackFn, thisArg) {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n  const O = Object(arr);\n  const len = Math.max(0, Math.floor(Number(O.length) || 0));\n  for (let k = 0; k < len; k++) {\n    if (k in O) callbackFn.call(thisArg, O[k], k, O);\n  }\n  return undefined;\n}\n",
          "codeTs": "export default function arrayForEach<T>(\n  arr: (T | undefined)[],\n  callbackFn: (value: T, index: number, array: (T | undefined)[]) => void,\n  thisArg?: any,\n): void {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n  const O = Object(arr) as Record<number, T | undefined> & { length: number };\n  const len: number = Math.max(0, Math.floor(Number(O.length) || 0));\n  for (let k = 0; k < len; k++) {\n    if (k in O) callbackFn.call(thisArg, O[k] as T, k, O as any);\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Iterating past the initial length — always snapshot `length` first.",
          "Calling the callback for holes — use own-property checks unless you intentionally want inherited keys.",
          "Mutations during iteration (e.g., delete/append) can change what you visit; snapshot + own-check keeps behavior predictable."
        ],
        "edgeCases": [
          "Sparse arrays like `[1, , 3]`: callback runs for indices 0 and 2 only.",
          "Elements deleted before their turn are skipped (`hasOwn` becomes false).",
          "Arrow functions ignore `thisArg`; use a normal function if you need `this`."
        ],
        "techniques": [
          "Snapshot `length` at the start to avoid chasing moving targets.",
          "Use `hasOwnProperty.call(arr, i)` to skip holes cleanly.",
          "Bind `this` with `.call(thisArg, value, index, array)`.",
          "Return `undefined` explicitly to mirror native `forEach`."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-map",
        "js-array-prototype-filter",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN – Array.prototype.forEach()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"
        },
        {
          "title": "ECMAScript Spec – Array.prototype.forEach",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.foreach"
        }
      ]
    },
    "tests": "import arrayForEach from './file';\n\ndescribe('arrayForEach', () => {\n  test('iterates in order', () => {\n    const seen = [];\n    arrayForEach([3, 1, 2], (v) => seen.push(v));\n    expect(seen).toEqual([3, 1, 2]);\n  });\n\n  test('binds thisArg', () => {\n    const ctx = { out: '' };\n    arrayForEach(['a', 'b'], function (v) { this.out += v; }, ctx);\n    expect(ctx.out).toBe('ab');\n  });\n\n  test('skips holes (edge)', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a = [1, , 3];\n    const seen = [];\n    arrayForEach(a, (v, i) => seen.push([v, i]));\n    expect(seen).toEqual([[1, 0], [3, 2]]);\n  });\n});\n",
    "testsTs": "import arrayForEach from './file';\n\ndescribe('arrayForEach (TypeScript)', () => {\n  it('iterates in order', () => {\n    const a = [3, 1, 2];\n    const seen: number[] = [];\n    arrayForEach(a, (v) => { seen.push(v as number); });\n    expect(seen).toEqual([3, 1, 2]);\n  });\n\n  it('binds thisArg', () => {\n    const ctx = { out: '' };\n    arrayForEach(['a', 'b'], function (v) { this.out += v; }, ctx);\n    expect(ctx.out).toBe('ab');\n  });\n\n  it('skips holes (edge)', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a = [1, , 3];\n    const result: Array<[number, number]> = [];\n    arrayForEach(a, (v, i) => { if (v !== undefined) result.push([v as number, i]); });\n    expect(result).toEqual([[1, 0], [3, 2]]);\n  });\n});\n"
  },
  {
    "id": "js-create-counter",
    "title": "Create a Counter Function",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "closures",
      "functions",
      "state",
      "increment"
    ],
    "description": {
      "summary": "Implement a function that returns a counter function. Each call to the returned function should increment and return the next integer, starting from the initial number `n`. Tests closure scope and persistent state handling.",
      "arguments": [
        {
          "name": "n",
          "type": "number",
          "desc": "The starting integer for the counter."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A function that returns the next integer each time it’s called."
      },
      "examples": [
        "// Example 1\nconst counter = createCounter(10);\ncounter(); // => 10\ncounter(); // => 11\ncounter(); // => 12",
        "// Example 2\nconst counter = createCounter(-2);\ncounter(); // => -2\ncounter(); // => -1\ncounter(); // => 0"
      ]
    },
    "starterCode": "export default function createCounter(n) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function createCounter(n: number): () => number {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: keep state across calls using a closure so each counter instance tracks its own increasing value.",
      "approaches": [
        {
          "title": "Approach: Closure-based counter (recommended)",
          "prose": "1. Capture the starting value `n` in the outer function’s scope.\n2. Return an inner function that can still see and modify `n` (closure).\n3. On each call, read the current value, then increment `n`.\n4. Return the value you read (pre-increment result).",
          "codeJs": "export default function createCounter(n) {\n  return function() {\n    const current = n;\n    n += 1;\n    return current;\n  };\n}\n",
          "codeTs": "export default function createCounter(n: number): () => number {\n  return function(): number {\n    const current = n;\n    n += 1;\n    return current;\n  };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using a global variable will share state across all counters — use a closure per instance.",
          "Returning `++n` vs. current value changes behavior (off-by-one). This task expects returning the current and then incrementing.",
          "Mutating objects captured in closures can cause shared state; here we keep only a primitive number."
        ],
        "edgeCases": [
          "Negative starts (e.g., `-2`) should count upward correctly.",
          "Large numbers work until you hit `Number.MAX_SAFE_INTEGER` (then precision issues can appear).",
          "Multiple counters created from separate calls must not interfere with each other."
        ],
        "techniques": [
          "Leverage lexical scoping: inner function closes over `n`.",
          "Prefer returning a function over exposing mutable objects to keep encapsulation tight."
        ]
      },
      "followUpQuestions": [
        "js-memoize-function"
      ],
      "resources": [
        {
          "title": "MDN – Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        },
        {
          "title": "You Don’t Know JS Yet – Scope & Closures (free book)",
          "url": "https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures"
        }
      ]
    },
    "tests": "import createCounter from './file';\n\ndescribe('createCounter', () => {\n  test('increments sequentially', () => {\n    const counter = createCounter(10);\n    expect(counter()).toBe(10);\n    expect(counter()).toBe(11);\n    expect(counter()).toBe(12);\n  });\n\n  test('works with negative numbers', () => {\n    const counter = createCounter(-2);\n    expect(counter()).toBe(-2);\n    expect(counter()).toBe(-1);\n    expect(counter()).toBe(0);\n  });\n\n  test('separate counters maintain independent state', () => {\n    const c1 = createCounter(0);\n    const c2 = createCounter(100);\n    expect(c1()).toBe(0);\n    expect(c2()).toBe(100);\n    expect(c1()).toBe(1);\n    expect(c2()).toBe(101);\n  });\n});\n",
    "testsTs": "import createCounter from './file';\n\ndescribe('createCounter (TypeScript)', () => {\n  it('increments sequentially', () => {\n    const counter = createCounter(5);\n    expect(counter()).toBe(5);\n    expect(counter()).toBe(6);\n    expect(counter()).toBe(7);\n  });\n\n  it('works with negative numbers', () => {\n    const counter = createCounter(-2);\n    expect(counter()).toBe(-2);\n    expect(counter()).toBe(-1);\n    expect(counter()).toBe(0);\n  });\n\n  it('independent counters maintain separate state', () => {\n    const c1 = createCounter(1);\n    const c2 = createCounter(50);\n    expect(c1()).toBe(1);\n    expect(c2()).toBe(50);\n    expect(c1()).toBe(2);\n    expect(c2()).toBe(51);\n  });\n});\n"
  },
  {
    "id": "js-is-object-empty",
    "title": "Check if an Object or Array is Empty",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "objects",
      "arrays",
      "basics",
      "validation"
    ],
    "description": {
      "summary": "Implement a function that determines whether a given object or array is empty. Tests your ability to handle both array and object structures and reason about length and key-value pairs.",
      "arguments": [
        {
          "name": "obj",
          "type": "Object | Array",
          "desc": "An object or array parsed from JSON."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "Returns `true` if empty; otherwise `false`."
      },
      "examples": [
        "// Example 1\nisEmpty({ x: 5, y: 42 }); // => false",
        "// Example 2\nisEmpty({}); // => true",
        "// Example 3\nisEmpty([null, false, 0]); // => false"
      ]
    },
    "starterCode": "export default function isEmpty(obj) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function isEmpty(obj: Record<string, any> | any[]): boolean {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: return `true` only when the input is an object or array with no elements or keys.",
      "approaches": [
        {
          "title": "Approach: Handle arrays and objects separately",
          "prose": "1. **Array check:** If it's an array, simply return whether its length is 0.\n2. **Object check:** If it's an object, get its own enumerable keys with `Object.keys()` and check if that list is empty.\n3. **Invalid input:** Throw a `TypeError` for non-object types like strings or numbers.\n4. **Return result:** Return a boolean indicating emptiness for the recognized type.",
          "codeJs": "export default function isEmpty(obj) {\n  if (Array.isArray(obj)) return obj.length === 0;\n  if (obj && typeof obj === 'object') return Object.keys(obj).length === 0;\n  throw new TypeError('Expected object or array');\n}\n",
          "codeTs": "export default function isEmpty(obj: Record<string, any> | any[]): boolean {\n  if (Array.isArray(obj)) return obj.length === 0;\n  if (obj && typeof obj === 'object') return Object.keys(obj).length === 0;\n  throw new TypeError('Expected object or array');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Checking `Object.keys()` on `null` or `undefined` will throw — always guard with `obj && typeof obj === 'object'`.",
          "Strings also have `.length`, but should not be considered valid inputs here.",
          "Prototype-inherited properties are ignored by `Object.keys()`, which is correct for this task."
        ],
        "edgeCases": [
          "`[]` → true (no elements).",
          "`{}` → true (no keys).",
          "`[null, false, 0]` → false (contains items even if falsy).",
          "`Object.create(null)` → true (no enumerable keys)."
        ],
        "techniques": [
          "Use `Array.isArray()` for accurate array detection.",
          "Prefer `Object.keys()` over `for...in` to ignore prototype properties."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN – Object.keys()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"
        },
        {
          "title": "MDN – Array.isArray()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
        }
      ]
    },
    "tests": "import isEmpty from './file';\n\ndescribe('isEmpty', () => {\n  test('returns false for non-empty object', () => {\n    expect(isEmpty({ x: 5, y: 42 })).toBe(false);\n  });\n\n  test('returns true for empty object', () => {\n    expect(isEmpty({})).toBe(true);\n  });\n\n  test('returns false for non-empty array', () => {\n    expect(isEmpty([null, false, 0])).toBe(false);\n  });\n});\n",
    "testsTs": "import isEmpty from './file';\n\ndescribe('isEmpty (TypeScript)', () => {\n  it('returns false for non-empty object', () => {\n    expect(isEmpty({ x: 5, y: 42 })).toBe(false);\n  });\n\n  it('returns true for empty object', () => {\n    expect(isEmpty({})).toBe(true);\n  });\n\n  it('returns false for non-empty array', () => {\n    expect(isEmpty([1, 2, 3])).toBe(false);\n  });\n});\n"
  },
  {
    "id": "js-add-two-promises",
    "title": "Add Two Promises",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "promises",
      "async",
      "functions",
      "basics"
    ],
    "description": {
      "summary": "Implement a function that takes two promises resolving to numbers and returns a new promise that resolves to their sum. Tests async/await usage and Promise handling.",
      "arguments": [
        {
          "name": "promise1",
          "type": "Promise<number>",
          "desc": "A promise that resolves with a number."
        },
        {
          "name": "promise2",
          "type": "Promise<number>",
          "desc": "Another promise that resolves with a number."
        }
      ],
      "returns": {
        "type": "Promise<number>",
        "desc": "A promise resolving with the sum of the two resolved values."
      },
      "examples": [
        "// Example 1\nconst p1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\nconst p2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\nawait addTwoPromises(p1, p2); // => 7",
        "// Example 2\nconst p1 = new Promise(resolve => setTimeout(() => resolve(10), 50));\nconst p2 = new Promise(resolve => setTimeout(() => resolve(-12), 30));\nawait addTwoPromises(p1, p2); // => -2"
      ]
    },
    "starterCode": "export default async function addTwoPromises(promise1, promise2) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: combine two asynchronous results and return a promise that resolves to their sum.",
      "approaches": [
        {
          "title": "Approach: Resolve both concurrently using Promise.all",
          "prose": "1. **Wait for both promises:** Use `Promise.all()` so both resolve in parallel.\n2. **Destructure results:** Extract the resolved values `[a, b]` from the array returned by `Promise.all()`.\n3. **Sum and return:** Add the numbers and return the result — wrapped automatically in a promise since the function is `async`.\n4. **Performance:** Both promises run concurrently, so total time equals the slower one’s resolution.",
          "codeJs": "export default async function addTwoPromises(promise1, promise2) {\n  const [a, b] = await Promise.all([promise1, promise2]);\n  return a + b;\n}\n",
          "codeTs": "export default async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\n  const [a, b] = await Promise.all([promise1, promise2]);\n  return a + b;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid chaining with nested `.then()` — it's harder to read and may resolve sequentially.",
          "If either promise rejects, `Promise.all` rejects immediately (propagating the error).",
          "Always `await` or return the result — otherwise it won’t resolve properly."
        ],
        "edgeCases": [
          "Both promises resolve instantly → works fine (microtask scheduling).",
          "One promise resolves slower → result waits for the slower one.",
          "If any promise rejects → the function rejects too (like native Promise.all)."
        ],
        "techniques": [
          "`Promise.all()` for concurrent resolution.",
          "`async/await` for clean and readable syntax.",
          "Destructuring arrays to extract resolved results."
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "MDN – Promise.all()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
        },
        {
          "title": "JavaScript.info – Promises, async/await",
          "url": "https://javascript.info/async-await"
        }
      ]
    },
    "tests": "import addTwoPromises from './file';\n\ndescribe('addTwoPromises', () => {\n  test('resolves with sum of positive numbers', async () => {\n    const p1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\n    const p2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(7);\n  });\n\n  test('handles negative and positive mix', async () => {\n    const p1 = new Promise(resolve => setTimeout(() => resolve(10), 50));\n    const p2 = new Promise(resolve => setTimeout(() => resolve(-12), 30));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(-2);\n  });\n\n  test('works with zero values (edge)', async () => {\n    const result = await addTwoPromises(Promise.resolve(0), Promise.resolve(0));\n    expect(result).toBe(0);\n  });\n});\n",
    "testsTs": "import addTwoPromises from './file';\n\ndescribe('addTwoPromises (TypeScript)', () => {\n  test('resolves with sum of positive numbers', async () => {\n    const p1 = new Promise<number>(resolve => setTimeout(() => resolve(2), 20));\n    const p2 = new Promise<number>(resolve => setTimeout(() => resolve(5), 60));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(7);\n  });\n\n  test('handles mix of negative and positive', async () => {\n    const p1 = new Promise<number>(resolve => setTimeout(() => resolve(10), 50));\n    const p2 = new Promise<number>(resolve => setTimeout(() => resolve(-12), 30));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(-2);\n  });\n\n  test('works with immediately resolved promises (edge)', async () => {\n    const result = await addTwoPromises(Promise.resolve(3), Promise.resolve(4));\n    expect(result).toBe(7);\n  });\n});\n"
  }
]