[
  {
    "id": "js-number-clamp",
    "title": "Clamp",
    "type": "coding",
    "technology": "javascript",
    "importance": 1,
    "difficulty": "easy",
    "tags": [
      "numbers",
      "math",
      "boundaries"
    ],
    "description": {
      "summary": "Implement a function `clamp(value, lower, upper)` that restricts `value` within inclusive `lower` and `upper` bounds.",
      "arguments": [
        {
          "name": "value",
          "type": "number",
          "desc": "The number to clamp."
        },
        {
          "name": "lower",
          "type": "number",
          "desc": "The lower bound."
        },
        {
          "name": "upper",
          "type": "number",
          "desc": "The upper bound."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The clamped number."
      },
      "examples": [
        "// Basic examples\nclamp(3, 0, 5) // => 3",
        "clamp(-10, -3, 5) // => -3",
        "clamp(10, -5, 5) // => 5"
      ]
    },
    "starterCode": "export default function clamp(value, lower, upper) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "The purpose of `clamp()` is to ensure a number stays within a specific range. Think of it as a limit gate: if the value falls below `lower`, we pull it up; if it exceeds `upper`, we bring it down. This pattern is often used in animation limits, slider inputs, or percentage caps.\n\nAlgorithm:\n1. If `value < lower`, return `lower`.\n2. Else if `value > upper`, return `upper`.\n3. Otherwise, return `value`.\n\nThis keeps outputs predictable and avoids overflow or underflow issues.",
      "codeJs": "export default function clamp(value, lower, upper) {\n  if (value < lower) return lower;\n  if (value > upper) return upper;\n  return value;\n}\n",
      "codeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  if (value < lower) return lower;\n  if (value > upper) return upper;\n  return value;\n}\n"
    },
    "tests": "import clamp from './clamp';\n\ndescribe('clamp', () => {\n  test('within range', () => expect(clamp(3, 0, 5)).toBe(3));\n  test('below lower', () => expect(clamp(-10, -3, 5)).toBe(-3));\n  test('above upper', () => expect(clamp(10, -5, 5)).toBe(5));\n});\n",
    "testsTs": "import clamp from './clamp';\n\ndescribe('clamp (TypeScript)', () => {\n  it('should return the same value when within range', () => {\n    expect(clamp(3, 0, 5)).toBe(3);\n  });\n  it('should clamp to lower bound when below range', () => {\n    expect(clamp(-10, -3, 5)).toBe(-3);\n  });\n  it('should clamp to upper bound when above range', () => {\n    expect(clamp(10, -5, 5)).toBe(5);\n  });\n});\n"
  },
  {
    "id": "js-reverse-string",
    "title": "Reverse a String",
    "type": "coding",
    "importance": 4,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `reverseString(str)` that returns the reversed version of the input string without using built-in methods like `.reverse()`.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to be reversed."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "The reversed string."
      },
      "examples": [
        "// Basic example\nreverseString('abc') // => 'cba'",
        "// Palindrome\nreverseString('racecar') // => 'racecar'",
        "// With spaces and punctuation\nreverseString('A man, a plan') // => 'nalp a ,nam A'"
      ]
    },
    "starterCode": "export default function reverseString(str) {\n  // TODO: Implement without using Array.prototype.reverse()\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function reverseString(str: string): string {\n  // TODO: Implement without using Array.prototype.reverse()\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "Reversing a string means flipping its characters from end to start. Since the challenge restricts using built-ins like `.reverse()`, we can manually rebuild the string.\n\n### 🧠 Step-by-step reasoning:\n1. Start with an empty result string `out = ''`.\n2. Loop from the **last index (`str.length - 1`) down to 0**.\n3. On each step, append the current character to `out`.\n4. When the loop ends, `out` holds the reversed result.\n\n### ⚙️ Why this works\nStrings are immutable in JavaScript, so each concatenation forms a new string. That’s fine for small or medium inputs — O(n) time and O(n) space overall.\n\n### ⚠️ Edge cases\n- **Empty string:** returns `''`.\n- **Single character:** returns itself.\n- **Palindromes:** look identical when reversed.\n- **Unicode:** this basic version flips code units, which is fine for normal text but not grapheme clusters (like emoji combinations).\n\nThis simple loop is easy to read, performs well, and helps you understand string traversal from end to start.",
      "codeJs": "export default function reverseString(str) {\n  let out = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    out += str[i];\n  }\n  return out;\n}\n",
      "codeTs": "export default function reverseString(str: string): string {\n  let out = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    out += str[i];\n  }\n  return out;\n}\n"
    },
    "tests": "import reverseString from './reverseString';\n\ndescribe('reverseString', () => {\n  test('reverses simple strings', () => {\n    expect(reverseString('abc')).toBe('cba');\n    expect(reverseString('hello')).toBe('olleh');\n  });\n\n  test('handles palindromes', () => {\n    expect(reverseString('racecar')).toBe('racecar');\n  });\n\n  test('reverses with spaces and punctuation', () => {\n    expect(reverseString('A man, a plan')).toBe('nalp a ,nam A');\n  });\n\n  test('handles empty and single character', () => {\n    expect(reverseString('')).toBe('');\n    expect(reverseString('x')).toBe('x');\n  });\n});\n",
    "testsTs": "import reverseString from './reverseString';\n\ndescribe('reverseString (TypeScript)', () => {\n  it('reverses simple strings', () => {\n    expect(reverseString('abc')).toBe('cba');\n    expect(reverseString('hello')).toBe('olleh');\n  });\n\n  it('handles palindromes', () => {\n    expect(reverseString('racecar')).toBe('racecar');\n  });\n\n  it('reverses with spaces and punctuation', () => {\n    expect(reverseString('A man, a plan')).toBe('nalp a ,nam A');\n  });\n\n  it('handles empty and single character', () => {\n    expect(reverseString('')).toBe('');\n    expect(reverseString('x')).toBe('x');\n  });\n});\n"
  },
  {
    "id": "js-count-vowels",
    "title": "Count Vowels",
    "type": "coding",
    "importance": 2,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `countVowels(str)` that returns how many vowels (a, e, i, o, u) exist in a given string, regardless of case.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to analyze."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The number of vowels found in the string."
      },
      "examples": [
        "// Basic examples\ncountVowels('hello') // => 2",
        "countVowels('rhythm') // => 0",
        "countVowels('AEIOU') // => 5",
        "// Mixed case and spaces\ncountVowels('A quick brown fox') // => 5"
      ]
    },
    "starterCode": "export default function countVowels(str) {\n  // TODO: Return how many vowels (a, e, i, o, u) are in the string\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function countVowels(str: string): number {\n  // TODO: Return how many vowels (a, e, i, o, u) are in the string\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "We need to count how many vowels appear in the string. A **vowel** is one of `'a', 'e', 'i', 'o', 'u'`, and both uppercase and lowercase should count.\n\n### 🧠 Step-by-step reasoning:\n1. Convert the string to lowercase so we don’t have to check for both cases.\n2. Loop through each character.\n3. For each one, check if it’s in the set `'aeiou'`.\n4. If it is, increment a counter.\n5. Return the total count.\n\n### ⚙️ Why this works\nThe lowercase conversion normalizes input. Checking membership with `includes()` makes the logic clear and readable. It runs in O(n) time and O(1) space.\n\n### ⚡ Alternative approach\nYou could also use a regular expression: `(str.match(/[aeiou]/gi) || []).length`. It’s concise but less explicit for beginners.\n\n### ⚠️ Edge cases\n- Empty string → `0`\n- No vowels → `0`\n- Case-insensitive (handles 'A' and 'a' equally)\n\nThis question checks basic string traversal and condition checking — a great warm-up before moving to regex or frequency-count problems.",
      "codeJs": "export default function countVowels(str) {\n  const vowels = 'aeiou';\n  let count = 0;\n  for (const ch of str.toLowerCase()) {\n    if (vowels.includes(ch)) count++;\n  }\n  return count;\n}\n",
      "codeTs": "export default function countVowels(str: string): number {\n  const vowels = 'aeiou';\n  let count = 0;\n  for (const ch of str.toLowerCase()) {\n    if (vowels.includes(ch)) count++;\n  }\n  return count;\n}\n"
    },
    "tests": "import countVowels from './countVowels';\n\ndescribe('countVowels', () => {\n  test('counts lowercase vowels', () => {\n    expect(countVowels('hello')).toBe(2);\n    expect(countVowels('rhythm')).toBe(0);\n  });\n\n  test('counts uppercase vowels', () => {\n    expect(countVowels('AEIOU')).toBe(5);\n  });\n\n  test('counts vowels in mixed case and spaces', () => {\n    expect(countVowels('A quick brown fox')).toBe(5);\n  });\n\n  test('handles empty string', () => {\n    expect(countVowels('')).toBe(0);\n  });\n});\n",
    "testsTs": "import countVowels from './countVowels';\n\ndescribe('countVowels (TypeScript)', () => {\n  it('counts lowercase vowels', () => {\n    expect(countVowels('hello')).toBe(2);\n    expect(countVowels('rhythm')).toBe(0);\n  });\n\n  it('counts uppercase vowels', () => {\n    expect(countVowels('AEIOU')).toBe(5);\n  });\n\n  it('counts vowels in mixed case and spaces', () => {\n    expect(countVowels('A quick brown fox')).toBe(5);\n  });\n\n  it('handles empty string', () => {\n    expect(countVowels('')).toBe(0);\n  });\n});\n"
  },
  {
    "id": "js-flatten-once",
    "title": "Flatten One Level",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `flattenOnce(arr)` that flattens a nested array by **one level only**. Elements that are not arrays should remain unchanged.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "The input array which may contain nested arrays."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array flattened by one level."
      },
      "examples": [
        "// Basic example\nflattenOnce([1, [2, 3], [4, [5]]]) // => [1, 2, 3, 4, [5]]",
        "// Already flat\nflattenOnce([1, 2, 3]) // => [1, 2, 3]",
        "// Mixed values\nflattenOnce([[1], 2, [3, [4]], 5]) // => [1, 2, 3, [4], 5]"
      ]
    },
    "starterCode": "export default function flattenOnce(arr) {\n  // TODO: Flatten one level deep\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function flattenOnce(arr: any[]): any[] {\n  // TODO: Flatten one level deep\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "Flattening by **one level** means unpacking only the first layer of nested arrays — not performing a deep recursion.\n\n### 🧠 Step-by-step reasoning:\n1. Create an empty array `result = []`.\n2. Loop through each element in `arr`.\n3. If an element is an array (`Array.isArray(el)`), spread its elements into `result`.\n4. Otherwise, push the element directly.\n5. Return the `result`.\n\n### ⚙️ Why this works\nThis approach uses a single pass (O(n)) and respects the rule of flattening just one level. It avoids recursion — deeper arrays remain nested.\n\n### ⚡ Alternative approach\nYou could use the built-in `.flat(1)` (modern JS) but implementing it manually builds stronger understanding.\n\n### ⚠️ Edge cases\n- Empty input → returns `[]`\n- Already flat → unchanged\n- Mixed array contents (numbers, objects, nested arrays) → only one layer unpacked\n\nThis problem is a great warm-up before writing a recursive `flatten()` that handles arbitrary depths.",
      "codeJs": "export default function flattenOnce(arr) {\n  const result = [];\n  for (const el of arr) {\n    if (Array.isArray(el)) {\n      result.push(...el);\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n",
      "codeTs": "export default function flattenOnce(arr: any[]): any[] {\n  const result: any[] = [];\n  for (const el of arr) {\n    if (Array.isArray(el)) {\n      result.push(...el);\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n"
    },
    "tests": "import flattenOnce from './flattenOnce';\n\ndescribe('flattenOnce', () => {\n  test('flattens a simple nested array', () => {\n    expect(flattenOnce([1, [2, 3], [4, [5]]])).toEqual([1, 2, 3, 4, [5]]);\n  });\n\n  test('returns same array when already flat', () => {\n    expect(flattenOnce([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n\n  test('handles mixed array contents', () => {\n    expect(flattenOnce([[1], 2, [3, [4]], 5])).toEqual([1, 2, 3, [4], 5]);\n  });\n\n  test('returns empty array for empty input', () => {\n    expect(flattenOnce([])).toEqual([]);\n  });\n});\n",
    "testsTs": "import flattenOnce from './flattenOnce';\n\ndescribe('flattenOnce (TypeScript)', () => {\n  it('flattens a simple nested array', () => {\n    expect(flattenOnce([1, [2, 3], [4, [5]]])).toEqual([1, 2, 3, 4, [5]]);\n  });\n\n  it('returns same array when already flat', () => {\n    expect(flattenOnce([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n\n  it('handles mixed array contents', () => {\n    expect(flattenOnce([[1], 2, [3, [4]], 5])).toEqual([1, 2, 3, [4], 5]);\n  });\n\n  it('returns empty array for empty input', () => {\n    expect(flattenOnce([])).toEqual([]);\n  });\n});\n"
  },
  {
    "id": "js-unique-array",
    "title": "Remove Duplicates",
    "type": "coding",
    "importance": 4,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `unique(arr)` that returns a new array with duplicate values removed. The **original order** of elements must be preserved.",
      "arguments": [
        {
          "name": "arr",
          "type": "T[]",
          "desc": "An array of items that may contain duplicates."
        }
      ],
      "returns": {
        "type": "T[]",
        "desc": "A new array with only unique elements, preserving their first occurrence order."
      },
      "examples": [
        "// Basic example\nunique([1, 2, 2, 3, 1]) // => [1, 2, 3]",
        "// Works with strings\nunique(['a', 'b', 'a', 'c', 'b']) // => ['a', 'b', 'c']",
        "// Mixed types\nunique([1, '1', 1]) // => [1, '1']"
      ]
    },
    "starterCode": "export default function unique(arr) {\n  // TODO: Return new array with duplicates removed\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function unique<T>(arr: T[]): T[] {\n  // TODO: Return new array with duplicates removed\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "Removing duplicates means ensuring each element appears only once in the output array.\n\n### 🧠 Step-by-step reasoning:\n1. Create a `Set` to keep track of elements we've already seen.\n2. Create an empty result array `result = []`.\n3. Loop through the input array.\n4. For each element:\n   - If it’s **not** in the `Set`, add it to both `Set` and `result`.\n   - If it’s already in the `Set`, skip it.\n5. Return `result`.\n\n### ⚙️ Why this works\n`Set` automatically ignores duplicates, and by adding elements only when we first see them, we preserve the original order. Time complexity is **O(n)**, and space complexity is **O(n)**.\n\n### ⚡ Alternative approaches\n- **Using spread syntax:** `return [...new Set(arr)]` (fast but doesn’t teach algorithmic thinking).\n- **Using `filter` and `indexOf`:** works but has O(n²) complexity — not ideal for large arrays.\n\n### ⚠️ Edge cases\n- Empty array → returns `[]`\n- All unique → unchanged\n- All duplicates → only one element kept\n\nThis is a fundamental problem that tests your understanding of iteration, data structures, and algorithmic efficiency.",
      "codeJs": "export default function unique(arr) {\n  const seen = new Set();\n  const result = [];\n  for (const item of arr) {\n    if (!seen.has(item)) {\n      seen.add(item);\n      result.push(item);\n    }\n  }\n  return result;\n}\n",
      "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  const seen = new Set<T>();\n  const result: T[] = [];\n  for (const item of arr) {\n    if (!seen.has(item)) {\n      seen.add(item);\n      result.push(item);\n    }\n  }\n  return result;\n}\n"
    },
    "tests": "import unique from './unique';\n\ndescribe('unique', () => {\n  test('removes duplicates from numbers', () => {\n    expect(unique([1, 2, 2, 3, 1])).toEqual([1, 2, 3]);\n  });\n\n  test('works with strings', () => {\n    expect(unique(['a', 'b', 'a', 'c', 'b'])).toEqual(['a', 'b', 'c']);\n  });\n\n  test('handles mixed types', () => {\n    expect(unique([1, '1', 1])).toEqual([1, '1']);\n  });\n\n  test('returns empty array when input is empty', () => {\n    expect(unique([])).toEqual([]);\n  });\n\n  test('returns identical array when all unique', () => {\n    expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "import unique from './unique';\n\ndescribe('unique (TypeScript)', () => {\n  it('removes duplicates from numbers', () => {\n    expect(unique([1, 2, 2, 3, 1])).toEqual([1, 2, 3]);\n  });\n\n  it('works with strings', () => {\n    expect(unique(['a', 'b', 'a', 'c', 'b'])).toEqual(['a', 'b', 'c']);\n  });\n\n  it('handles mixed types', () => {\n    expect(unique([1, '1', 1])).toEqual([1, '1']);\n  });\n\n  it('returns empty array when input is empty', () => {\n    expect(unique([])).toEqual([]);\n  });\n\n  it('returns identical array when all unique', () => {\n    expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n});\n"
  },
  {
    "id": "js-max-char",
    "title": "Find Maximum Occurring Character",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `maxChar(str)` that returns the character that appears most frequently in a string.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to analyze."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "The single character with the highest frequency of occurrence."
      },
      "examples": [
        "// Basic examples\nmaxChar('hello') // => 'l'\nmaxChar('aabbbcc') // => 'b'\nmaxChar('abcccccccd') // => 'c'\n// When multiple characters tie, return the first one found\nmaxChar('aabb') // => 'a'"
      ]
    },
    "starterCode": "export default function maxChar(str) {\n  // TODO: Return the most frequent character in the string\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function maxChar(str: string): string {\n  // TODO: Return the most frequent character in the string\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "To find the character that appears most often, we can count how many times each character appears and then pick the one with the largest count.\n\n### 🧠 Step-by-step reasoning:\n1. Create an empty object `charCount` to store frequencies.\n2. Loop through each character in the string.\n3. For each one, increment its count in `charCount`.\n4. After counting, loop through the keys of `charCount` to find the one with the highest value.\n5. Return that character.\n\n### ⚙️ Why this works\nWe’re using a **hash map** (plain JS object) to efficiently count occurrences — each lookup and increment is O(1), giving us an overall O(n) time complexity.\n\n### ⚡ Alternative approach\n- You can also use `Array.prototype.reduce()` or `Map` for a more functional or explicit style.\n- If Unicode or emoji handling is needed, `Array.from(str)` is safer than splitting by character.\n\n### ⚠️ Edge cases\n- Empty string → return an empty string `''`\n- All characters appear once → return the first character\n- Case-sensitive: `'A'` and `'a'` are different\n\nThis question teaches how to use **frequency maps**, a pattern that appears in many algorithm problems (anagrams, histogram comparisons, etc.).",
      "codeJs": "export default function maxChar(str) {\n  if (!str) return '';\n  const charCount = {};\n  let max = 0;\n  let maxChar = '';\n\n  for (const ch of str) {\n    charCount[ch] = (charCount[ch] || 0) + 1;\n    if (charCount[ch] > max) {\n      max = charCount[ch];\n      maxChar = ch;\n    }\n  }\n\n  return maxChar;\n}\n",
      "codeTs": "export default function maxChar(str: string): string {\n  if (!str) return '';\n  const charCount: Record<string, number> = {};\n  let max = 0;\n  let maxChar = '';\n\n  for (const ch of str) {\n    charCount[ch] = (charCount[ch] || 0) + 1;\n    if (charCount[ch] > max) {\n      max = charCount[ch];\n      maxChar = ch;\n    }\n  }\n\n  return maxChar;\n}\n"
    },
    "tests": "import maxChar from './maxChar';\n\ndescribe('maxChar', () => {\n  test('finds the most common letter', () => {\n    expect(maxChar('hello')).toBe('l');\n  });\n\n  test('works with multiple repetitions', () => {\n    expect(maxChar('aabbbcc')).toBe('b');\n    expect(maxChar('abcccccccd')).toBe('c');\n  });\n\n  test('returns first character when tie', () => {\n    expect(maxChar('aabb')).toBe('a');\n  });\n\n  test('returns empty string when input is empty', () => {\n    expect(maxChar('')).toBe('');\n  });\n});\n",
    "testsTs": "import maxChar from './maxChar';\n\ndescribe('maxChar (TypeScript)', () => {\n  it('finds the most common letter', () => {\n    expect(maxChar('hello')).toBe('l');\n  });\n\n  it('works with multiple repetitions', () => {\n    expect(maxChar('aabbbcc')).toBe('b');\n    expect(maxChar('abcccccccd')).toBe('c');\n  });\n\n  it('returns first character when tie', () => {\n    expect(maxChar('aabb')).toBe('a');\n  });\n\n  it('returns empty string when input is empty', () => {\n    expect(maxChar('')).toBe('');\n  });\n});\n"
  },
  {
    "id": "js-capitalize-words",
    "title": "Capitalize Words",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `capitalizeWords(sentence)` that returns the same string but with the first letter of each word capitalized.",
      "arguments": [
        {
          "name": "sentence",
          "type": "string",
          "desc": "A sentence consisting of one or more words separated by spaces."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "A new string where each word starts with an uppercase letter, and the rest of the word remains in lowercase."
      },
      "examples": [
        "// Basic examples",
        "capitalizeWords('hello world') // => 'Hello World'",
        "capitalizeWords('javascript is fun') // => 'Javascript Is Fun'",
        "// Handles extra spaces",
        "capitalizeWords('  welcome   to  earth  ') // => '  Welcome   To  Earth  '"
      ]
    },
    "starterCode": "export default function capitalizeWords(sentence) {\n  // TODO: Capitalize first letter of each word\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function capitalizeWords(sentence: string): string {\n  // TODO: Capitalize first letter of each word\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "Capitalizing each word means transforming only the **first character** of every word to uppercase while leaving the rest in lowercase.\n\n### 🧠 Step-by-step reasoning:\n1. Split the sentence into words using `.split(' ')`.\n2. Map through each word and:\n   - If the word is empty (from extra spaces), leave it unchanged.\n   - Otherwise, take `word[0].toUpperCase()` and append `word.slice(1).toLowerCase()`.\n3. Join all the words back together with spaces.\n4. Return the result.\n\n### ⚙️ Why this works\nThis method preserves multiple spaces, handles mixed-case inputs, and efficiently reconstructs the string with correct capitalization.\n\n### ⚡ Alternative approach\nYou could also iterate through the string directly, capitalizing after every space. That approach avoids splitting but is less readable for beginners.\n\n### ⚠️ Edge cases\n- Empty string → returns `''`\n- Multiple consecutive spaces → preserved\n- Already capitalized words → unchanged\n- Mixed case input → normalized to proper capitalization\n\nThis problem strengthens your understanding of **string iteration** and **immutable transformations**, core skills for interview challenges.",
      "codeJs": "export default function capitalizeWords(sentence) {\n  if (!sentence) return '';\n  return sentence\n    .split(' ')\n    .map(word => {\n      if (!word) return word;\n      return word[0].toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ');\n}\n",
      "codeTs": "export default function capitalizeWords(sentence: string): string {\n  if (!sentence) return '';\n  return sentence\n    .split(' ')\n    .map(word => {\n      if (!word) return word;\n      return word[0].toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ');\n}\n"
    },
    "tests": "import capitalizeWords from './capitalizeWords';\n\ndescribe('capitalizeWords', () => {\n  test('capitalizes each word in a simple sentence', () => {\n    expect(capitalizeWords('hello world')).toBe('Hello World');\n  });\n\n  test('handles mixed casing', () => {\n    expect(capitalizeWords('jaVaScript IS fUn')).toBe('Javascript Is Fun');\n  });\n\n  test('preserves multiple spaces', () => {\n    expect(capitalizeWords('  welcome   to  earth  ')).toBe('  Welcome   To  Earth  ');\n  });\n\n  test('returns empty string for empty input', () => {\n    expect(capitalizeWords('')).toBe('');\n  });\n});\n",
    "testsTs": "import capitalizeWords from './capitalizeWords';\n\ndescribe('capitalizeWords (TypeScript)', () => {\n  it('capitalizes each word in a simple sentence', () => {\n    expect(capitalizeWords('hello world')).toBe('Hello World');\n  });\n\n  it('handles mixed casing', () => {\n    expect(capitalizeWords('jaVaScript IS fUn')).toBe('Javascript Is Fun');\n  });\n\n  it('preserves multiple spaces', () => {\n    expect(capitalizeWords('  welcome   to  earth  ')).toBe('  Welcome   To  Earth  ');\n  });\n\n  it('returns empty string for empty input', () => {\n    expect(capitalizeWords('')).toBe('');\n  });\n});\n"
  },
  {
    "id": "js-sum-numbers",
    "title": "Sum of Numbers in an Array",
    "type": "coding",
    "importance": 2,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `sum(arr)` that returns the total of all numeric elements in the array, ignoring non-numeric values.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array containing numbers and possibly other types (e.g., strings, booleans, nulls)."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The sum of all numeric elements in the array."
      },
      "examples": [
        "// Basic examples\nsum([1, 2, 3]) // => 6",
        "sum([10, '20', 30]) // => 40",
        "// Ignores non-numbers\nsum(['a', 5, true, 7]) // => 12",
        "// Handles empty array\nsum([]) // => 0"
      ]
    },
    "starterCode": "export default function sum(arr) {\n  // TODO: Return the sum of all numeric elements, ignoring non-numbers\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function sum(arr: any[]): number {\n  // TODO: Return the sum of all numeric elements, ignoring non-numbers\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "To find the sum of numbers while ignoring non-numeric values, we can loop through the array and only add valid numbers.\n\n### 🧠 Step-by-step reasoning:\n1. Initialize a running total: `let total = 0`.\n2. Loop through each element in `arr`.\n3. Check if it's a number using `typeof x === 'number'` and `!isNaN(x)`.\n4. If valid, add it to `total`.\n5. Return the final total.\n\n### ⚙️ Why this works\nBy filtering out non-numeric types, we prevent errors or unintended additions. The logic runs in O(n) and works even with mixed data arrays.\n\n### ⚡ Alternative approach\nYou could use `arr.filter(Number.isFinite).reduce((a,b)=>a+b,0)`, but that’s less explicit for beginners and may coerce strings.\n\n### ⚠️ Edge cases\n- Empty array → returns 0\n- All non-numbers → returns 0\n- Includes NaN → ignored\n\nThis task reinforces your understanding of iteration, type checking, and numeric operations in JavaScript.",
      "codeJs": "export default function sum(arr) {\n  let total = 0;\n  for (const el of arr) {\n    if (typeof el === 'number' && !isNaN(el)) {\n      total += el;\n    }\n  }\n  return total;\n}\n",
      "codeTs": "export default function sum(arr: any[]): number {\n  let total = 0;\n  for (const el of arr) {\n    if (typeof el === 'number' && !isNaN(el)) {\n      total += el;\n    }\n  }\n  return total;\n}\n"
    },
    "tests": "import sum from './sum';\n\ndescribe('sum', () => {\n  test('sums numbers in a simple array', () => {\n    expect(sum([1, 2, 3])).toBe(6);\n  });\n\n  test('ignores non-numeric values', () => {\n    expect(sum(['a', 5, true, 7])).toBe(12);\n  });\n\n  test('handles mixed numeric strings gracefully', () => {\n    expect(sum([10, '20', 30])).toBe(40);\n  });\n\n  test('returns 0 for empty or all-non-numeric arrays', () => {\n    expect(sum([])).toBe(0);\n    expect(sum(['x', false, null])).toBe(0);\n  });\n});\n",
    "testsTs": "import sum from './sum';\n\ndescribe('sum (TypeScript)', () => {\n  it('sums numbers in a simple array', () => {\n    expect(sum([1, 2, 3])).toBe(6);\n  });\n\n  it('ignores non-numeric values', () => {\n    expect(sum(['a', 5, true, 7])).toBe(12);\n  });\n\n  it('handles mixed numeric strings gracefully', () => {\n    expect(sum([10, '20', 30])).toBe(40);\n  });\n\n  it('returns 0 for empty or all-non-numeric arrays', () => {\n    expect(sum([])).toBe(0);\n    expect(sum(['x', false, null])).toBe(0);\n  });\n});\n"
  },
  {
    "id": "js-compact",
    "title": "Falsy Bouncer",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `compact(arr)` that removes all falsy values (`false`, `0`, `''`, `null`, `undefined`, `NaN`) from an array.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array containing any types of elements, including falsy values."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array with all falsy values removed."
      },
      "examples": [
        "// Basic examples\ncompact([0, 1, false, 2, '', 3]) // => [1, 2, 3]",
        "// Works with only truthy values\ncompact(['a', true, 42]) // => ['a', true, 42]",
        "// Handles null and undefined\ncompact([null, undefined, 'x']) // => ['x']",
        "// Handles NaN\ncompact([NaN, 1, 2]) // => [1, 2]"
      ]
    },
    "starterCode": "export default function compact(arr) {\n  // TODO: Remove all falsy values from the array\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function compact(arr: any[]): any[] {\n  // TODO: Remove all falsy values from the array\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "Falsy values in JavaScript include `false`, `0`, `''`, `null`, `undefined`, and `NaN`. Removing them is a classic filter problem.\n\n### 🧠 Step-by-step reasoning:\n1. Use the `Array.prototype.filter()` method.\n2. Inside the filter callback, simply return the element itself (`el => el`).\n3. JavaScript will treat falsy values as `false`, so they’re automatically excluded.\n\n### ⚙️ Why this works\nEach element is evaluated in a boolean context — only truthy values pass. This is a neat one-liner that elegantly cleans arrays.\n\n### ⚡ Alternative approach\nYou could use a manual loop and push truthy elements to a new array, but `filter(Boolean)` is both shorter and faster.\n\n### ⚠️ Edge cases\n- Empty array → returns `[]`\n- Array with all falsy values → returns `[]`\n- Mixed values → only truthy ones remain\n\nThis question is a favorite in interviews to test understanding of **truthy/falsy coercion** and functional array methods.",
      "codeJs": "export default function compact(arr) {\n  return arr.filter(Boolean);\n}\n",
      "codeTs": "export default function compact(arr: any[]): any[] {\n  return arr.filter(Boolean);\n}\n"
    },
    "tests": "import compact from './compact';\n\ndescribe('compact', () => {\n  test('removes falsy values', () => {\n    expect(compact([0, 1, false, 2, '', 3])).toEqual([1, 2, 3]);\n  });\n\n  test('returns same array when all truthy', () => {\n    expect(compact(['a', true, 42])).toEqual(['a', true, 42]);\n  });\n\n  test('removes null and undefined', () => {\n    expect(compact([null, undefined, 'x'])).toEqual(['x']);\n  });\n\n  test('removes NaN', () => {\n    expect(compact([NaN, 1, 2])).toEqual([1, 2]);\n  });\n\n  test('handles empty array', () => {\n    expect(compact([])).toEqual([]);\n  });\n});\n",
    "testsTs": "import compact from './compact';\n\ndescribe('compact (TypeScript)', () => {\n  it('removes falsy values', () => {\n    expect(compact([0, 1, false, 2, '', 3])).toEqual([1, 2, 3]);\n  });\n\n  it('returns same array when all truthy', () => {\n    expect(compact(['a', true, 42])).toEqual(['a', true, 42]);\n  });\n\n  it('removes null and undefined', () => {\n    expect(compact([null, undefined, 'x'])).toEqual(['x']);\n  });\n\n  it('removes NaN', () => {\n    expect(compact([NaN, 1, 2])).toEqual([1, 2]);\n  });\n\n  it('handles empty array', () => {\n    expect(compact([])).toEqual([]);\n  });\n});\n"
  },
  {
    "id": "js-arrays-equal",
    "title": "Check if Two Arrays Are Equal",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `arraysEqual(a, b)` that returns `true` if both arrays contain the same elements in the same order.",
      "arguments": [
        {
          "name": "a",
          "type": "any[]",
          "desc": "The first array to compare."
        },
        {
          "name": "b",
          "type": "any[]",
          "desc": "The second array to compare."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if both arrays are identical in length and elements (in the same order), otherwise `false`."
      },
      "examples": [
        "// Basic examples\narraysEqual([1, 2, 3], [1, 2, 3]) // => true",
        "arraysEqual([1, 2, 3], [3, 2, 1]) // => false",
        "// Different lengths\narraysEqual([1, 2], [1, 2, 3]) // => false",
        "// Works with strings\narraysEqual(['a', 'b'], ['a', 'b']) // => true",
        "// Works with mixed types\narraysEqual([1, '2', 3], [1, 2, 3]) // => false"
      ]
    },
    "starterCode": "export default function arraysEqual(a, b) {\n  // TODO: Return true if both arrays contain the same elements in the same order\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  // TODO: Return true if both arrays contain the same elements in the same order\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "To check if two arrays are equal, we must ensure both:\n1. Have the same **length**.\n2. Have **identical elements** at each index.\n\n### 🧠 Step-by-step reasoning:\n1. Compare lengths — if they differ, immediately return `false`.\n2. Loop through each index.\n3. At every position, compare values with strict equality (`!==`).\n4. If any mismatch occurs, return `false`.\n5. If the loop completes without mismatches, return `true`.\n\n### ⚙️ Why this works\nBy using strict equality and order-based comparison, we ensure both content and sequence match exactly. This avoids the pitfalls of `JSON.stringify()` (which may fail with nested references or different object key order).\n\n### ⚡ Alternative approach\nYou could use `return JSON.stringify(a) === JSON.stringify(b);` for quick checks on flat arrays, but it’s less explicit and not recommended in production.\n\n### ⚠️ Edge cases\n- Empty arrays → `true`\n- Different lengths → `false`\n- Arrays with mixed types (e.g. `'2'` vs `2`) → `false`\n- Nested arrays → compares references, not deep equality\n\nThis exercise reinforces careful iteration and comparison logic — one of the most essential building blocks for interview coding questions.",
      "codeJs": "export default function arraysEqual(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n",
      "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n"
    },
    "tests": "import arraysEqual from './arraysEqual';\n\ndescribe('arraysEqual', () => {\n  test('returns true for identical arrays', () => {\n    expect(arraysEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  });\n\n  test('returns false for different element order', () => {\n    expect(arraysEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  test('returns false for different lengths', () => {\n    expect(arraysEqual([1, 2], [1, 2, 3])).toBe(false);\n  });\n\n  test('works with string arrays', () => {\n    expect(arraysEqual(['a', 'b'], ['a', 'b'])).toBe(true);\n  });\n\n  test('returns false for mixed type differences', () => {\n    expect(arraysEqual([1, '2', 3], [1, 2, 3])).toBe(false);\n  });\n\n  test('handles empty arrays', () => {\n    expect(arraysEqual([], [])).toBe(true);\n  });\n});\n",
    "testsTs": "import arraysEqual from './arraysEqual';\n\ndescribe('arraysEqual (TypeScript)', () => {\n  it('returns true for identical arrays', () => {\n    expect(arraysEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  });\n\n  it('returns false for different element order', () => {\n    expect(arraysEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  it('returns false for different lengths', () => {\n    expect(arraysEqual([1, 2], [1, 2, 3])).toBe(false);\n  });\n\n  it('works with string arrays', () => {\n    expect(arraysEqual(['a', 'b'], ['a', 'b'])).toBe(true);\n  });\n\n  it('returns false for mixed type differences', () => {\n    expect(arraysEqual([1, '2', 3], [1, 2, 3])).toBe(false);\n  });\n\n  it('handles empty arrays', () => {\n    expect(arraysEqual([], [])).toBe(true);\n  });\n});\n"
  },
  {
    "id": "js-debounce",
    "title": "Debounce Function",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "tags": [
      "async",
      "timing",
      "function"
    ],
    "importance": 5,
    "description": {
      "summary": "Implement a function `debounce(fn, delay)` that delays the execution of `fn` until a specified time (`delay` ms) has passed since the last invocation.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The function to be executed after the delay."
        },
        {
          "name": "delay",
          "type": "number",
          "desc": "The number of milliseconds to wait before executing the function."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A debounced version of the original function that delays execution until the delay period has elapsed."
      },
      "examples": [
        "// Basic examples\ndebounce(() => console.log('Hello!'), 300)",
        "// Multiple rapid calls — only last one runs\nconst log = debounce(() => console.log('Run!'), 500)\nlog()\nlog()\nlog() // Only this one executes after 500ms",
        "// With arguments\nconst greet = debounce(name => console.log(`Hi ${name}`), 400)\ngreet('Alice')\ngreet('Bob') // Only 'Hi Bob' logs after 400ms"
      ]
    },
    "starterCode": "export default function debounce(fn, delay) {\n  // TODO: Return a debounced function that delays execution until delay ms have passed\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): F {\n  // TODO: Return a debounced function that delays execution until delay ms have passed\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "A **debounced function** ensures that a function (`fn`) runs **only after** a pause in calls for a given time (`delay`). It’s heavily used in UI patterns like search boxes, resize handlers, or API calls that shouldn’t fire too often.\n\n### 🧠 Step-by-step reasoning:\n1. Keep track of a `timeoutId` outside the returned function.\n2. When the returned function is called:\n   - Clear any existing timeout using `clearTimeout(timeoutId)`.\n   - Start a new one with `setTimeout(fn, delay)`.\n3. Only when the delay passes without another call will `fn` execute.\n\n### ⚙️ Why this works\nEach call resets the timer, so the function only executes after the last event in a burst — reducing redundant executions.\n\n### ⚡ Example use cases\n- Prevent firing an API request while typing.\n- Optimize scroll/resize events.\n- Avoid multiple button clicks triggering the same action.\n\n### ⚠️ Edge cases\n- Works best with non-returning (void) functions.\n- If immediate execution is needed, you can extend it with an `immediate` flag.\n\nMastering debounce is key for performance optimization and clean async UI logic — a recurring concept in frontend interviews.",
      "codeJs": "export default function debounce(fn, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n",
      "codeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): F {\n  let timeoutId: ReturnType<typeof setTimeout>;\n  return function(this: any, ...args: Parameters<F>) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  } as F;\n}\n"
    },
    "tests": "import debounce from './debounce';\n\nconst wait = (ms) => new Promise((r) => setTimeout(r, ms));\n\ndescribe('debounce', () => {\n  test('calls function after delay', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 120);\n\n    debounced();\n    expect(calls).toBe(0);\n\n    await wait(140);\n    expect(calls).toBe(1);\n  });\n\n  test('resets timer on rapid calls (only last executes)', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 100);\n\n    debounced();\n    await wait(50);\n    debounced();\n    await wait(50);\n    debounced();\n\n    await wait(90);\n    expect(calls).toBe(0);\n\n    await wait(20);\n    expect(calls).toBe(1);\n  });\n\n  test('passes arguments (and preserves this via apply)', async () => {\n    let last = '';\n    const debounced = debounce(function (name) {\n      last = `Hi ${name}`;\n    }, 80);\n\n    debounced.call({ tag: 'ctx' }, 'Alice');\n    await wait(100);\n    expect(last).toBe('Hi Alice');\n  });\n});\n",
    "testsTs": "import debounce from './debounce';\n\nconst wait = (ms: number) => new Promise<void>((r) => setTimeout(r, ms));\n\ndescribe('debounce (TypeScript)', () => {\n  it('delays function execution', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 120);\n\n    debounced();\n    expect(calls).toBe(0);\n\n    await wait(140);\n    expect(calls).toBe(1);\n  });\n\n  it('restarts timer on multiple calls', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 100);\n\n    debounced();\n    await wait(50);\n    debounced();\n    await wait(50);\n    debounced();\n\n    await wait(90);\n    expect(calls).toBe(0);\n\n    await wait(20);\n    expect(calls).toBe(1);\n  });\n\n  it('forwards parameters correctly', async () => {\n    let captured = '';\n    const debounced = debounce((msg: string) => { captured = msg; }, 80);\n\n    debounced('Hello');\n    await wait(100);\n    expect(captured).toBe('Hello');\n  });\n});\n"
  },
  {
    "id": "js-throttle",
    "title": "Throttle Function",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "tags": [
      "async",
      "timing",
      "function"
    ],
    "importance": 5,
    "description": {
      "summary": "Implement a function `throttle(fn, interval)` that ensures `fn` is executed at most once during every `interval` milliseconds, no matter how many times it's triggered.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The function to be throttled."
        },
        {
          "name": "interval",
          "type": "number",
          "desc": "The time window (in milliseconds) within which subsequent calls are ignored."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A throttled version of the original function that executes at most once per interval."
      },
      "examples": [
        "// Basic examples\nthrottle(() => console.log('Clicked!'), 1000)",
        "// Multiple rapid calls — only first one executes within the interval\nconst log = throttle(() => console.log('Run!'), 500)\nlog()\nlog()\nlog() // Only the first logs immediately, rest ignored until 500ms passes",
        "// With arguments\nconst greet = throttle(name => console.log(`Hi ${name}`), 800)\ngreet('Alice')\ngreet('Bob') // Only 'Hi Alice' logs immediately; 'Hi Bob' ignored until 800ms passes"
      ]
    },
    "starterCode": "export default function throttle(fn, interval) {\n  // TODO: Execute fn at most once per interval\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  // TODO: Execute fn at most once per interval\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "A **throttled function** ensures that a function (`fn`) executes **at most once per given interval**, even if it's called multiple times. It’s commonly used in performance-sensitive event handlers like scroll, resize, and mousemove.\n\n### 🧠 Step-by-step reasoning:\n1. Track the **last execution time** using a variable (e.g. `lastTime`).\n2. When the returned function is called:\n   - Capture the **current time**.\n   - If the time since `lastTime` is greater than or equal to `interval`, execute `fn` and update `lastTime`.\n   - Otherwise, ignore the call.\n\n### ⚙️ Why this works\nThrottle enforces a cooldown period. Once `fn` runs, it won’t run again until the specified time passes.\n\n### ⚡ Example use cases\n- Limit scroll or resize event triggers.\n- Prevent rapid button spam.\n- Optimize continuous data fetch or DOM updates.\n\n### ⚠️ Edge cases\n- First call always fires immediately.\n- Works best for continuous triggers where you want consistent spacing.\n\nThrottle is an essential partner to Debounce — both manage **rate control** of function execution, a vital skill for performance optimization in frontend interviews.",
      "codeJs": "export default function throttle(fn, interval) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= interval) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  };\n}\n",
      "codeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  let lastTime = 0;\n  return function(this: any, ...args: Parameters<F>) {\n    const now = Date.now();\n    if (now - lastTime >= interval) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  } as F;\n}\n"
    },
    "tests": "import throttle from './throttle';\n\nconst wait = (ms) => new Promise((r) => setTimeout(r, ms));\n\ndescribe('throttle', () => {\n  test('executes immediately and ignores rapid calls', async () => {\n    let calls = 0;\n    const throttled = throttle(() => { calls += 1; }, 200);\n\n    throttled(); // should run immediately\n    throttled(); // ignored\n    throttled(); // ignored\n\n    expect(calls).toBe(1);\n\n    await wait(220);\n    throttled(); // should run after interval\n    expect(calls).toBe(2);\n  });\n\n  test('maintains correct interval spacing', async () => {\n    let timestamps = [];\n    const throttled = throttle(() => { timestamps.push(Date.now()); }, 100);\n\n    throttled();\n    await wait(30);\n    throttled();\n    await wait(80);\n    throttled(); // should run after ~110ms total\n\n    await wait(120);\n    throttled(); // another valid call\n\n    expect(timestamps.length).toBe(3);\n  });\n\n  test('passes arguments correctly', async () => {\n    let last = '';\n    const throttled = throttle((msg) => { last = msg; }, 150);\n\n    throttled('Hello');\n    throttled('World'); // ignored\n\n    await wait(160);\n    throttled('Again');\n\n    expect(last).toBe('Again');\n  });\n});\n",
    "testsTs": "import throttle from './throttle';\n\nconst wait = (ms: number) => new Promise<void>((r) => setTimeout(r, ms));\n\ndescribe('throttle (TypeScript)', () => {\n  it('executes immediately and ignores rapid calls', async () => {\n    let calls = 0;\n    const throttled = throttle(() => { calls += 1; }, 200);\n\n    throttled();\n    throttled();\n    throttled();\n\n    expect(calls).toBe(1);\n\n    await wait(220);\n    throttled();\n    expect(calls).toBe(2);\n  });\n\n  it('maintains proper intervals', async () => {\n    let times: number[] = [];\n    const throttled = throttle(() => { times.push(Date.now()); }, 100);\n\n    throttled();\n    await wait(30);\n    throttled();\n    await wait(80);\n    throttled();\n\n    await wait(120);\n    throttled();\n\n    expect(times.length).toBe(3);\n  });\n\n  it('passes arguments correctly', async () => {\n    let last = '';\n    const throttled = throttle((msg: string) => { last = msg; }, 150);\n\n    throttled('Hi');\n    throttled('Ignore');\n\n    await wait(160);\n    throttled('Final');\n\n    expect(last).toBe('Final');\n  });\n});\n"
  },
  {
    "id": "js-deep-clone",
    "title": "Deep Clone",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "object",
      "recursion",
      "clone",
      "deep-copy"
    ],
    "importance": 5,
    "description": {
      "summary": "Implement a function `deepClone(value)` that creates a deep copy of the provided value, including nested objects, arrays, Dates, and RegExps.",
      "arguments": [
        {
          "name": "value",
          "type": "any",
          "desc": "The value to deeply clone. Can be an object, array, Date, RegExp, or primitive."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "A deep copy of the input value where all nested structures are duplicated rather than referenced."
      },
      "examples": [
        "// Basic examples\ndeepClone({ a: 1, b: { c: 2 } }) // => { a: 1, b: { c: 2 } }",
        "// Arrays and nested objects\nconst arr = [1, { x: 10 }, [2, 3]]\nconst copy = deepClone(arr)\ncopy[1].x = 99\n// arr stays unchanged",
        "// Dates and RegExps\nconst obj = { d: new Date('2020-01-01'), r: /abc/i }\nconst clone = deepClone(obj)\nclone.d.setFullYear(2024)\n// obj.d still points to 2020"
      ]
    },
    "starterCode": "export default function deepClone(value) {\n  // TODO: Return a deep-cloned copy of the input value\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function deepClone<T>(value: T): T {\n  // TODO: Return a deep-cloned copy of the input value\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "Deep cloning means creating a **fully independent copy** of an object, including all its nested structures. Unlike shallow copies (`Object.assign`, spread syntax), a deep clone ensures modifying the clone doesn’t affect the original.\n\n### 🧠 Step-by-step reasoning:\n1. **Handle primitives** (numbers, strings, booleans, null, undefined): return as-is.\n2. **Handle special types**:\n   - `Date`: return a new Date with the same timestamp.\n   - `RegExp`: create a new RegExp with the same pattern and flags.\n3. **Handle arrays and objects**:\n   - Create a new array/object.\n   - Recursively deepClone each property or element.\n4. **Handle circular references** (optional, advanced): store references in a WeakMap to avoid infinite loops.\n\n### ⚙️ Why this works\nBy handling each data type explicitly and recursing through nested structures, we ensure no shared references remain between the original and the clone.\n\n### ⚡ Use cases\n- Copying nested state trees in Redux-like systems.\n- Serializing and restoring large data objects safely.\n- Avoiding accidental mutation in immutability-focused architectures.\n\n### ⚠️ Edge cases\n- Functions and DOM nodes aren’t cloned (should return same reference or be ignored).\n- Symbol keys and non-enumerable properties can be cloned if needed (beyond basic version).\n\nMastering deep cloning builds strong understanding of **recursion**, **reference vs value**, and **data structure traversal**, all key areas in frontend interviews.",
      "codeJs": "export default function deepClone(value) {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (value instanceof Date) return new Date(value.getTime());\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClone(item));\n  }\n\n  const clonedObj = {};\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clonedObj[key] = deepClone(value[key]);\n    }\n  }\n  return clonedObj;\n}\n",
      "codeTs": "export default function deepClone<T>(value: T): T {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (value instanceof Date) return new Date(value.getTime()) as any;\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re as any;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClone(item)) as any;\n  }\n\n  const clonedObj: any = {};\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clonedObj[key] = deepClone((value as any)[key]);\n    }\n  }\n  return clonedObj;\n}\n"
    },
    "tests": "import deepClone from './deepClone';\n\ndescribe('deepClone', () => {\n  test('clones nested objects', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const clone = deepClone(obj);\n    expect(clone).toEqual(obj);\n    clone.b.c = 5;\n    expect(obj.b.c).toBe(2);\n  });\n\n  test('clones arrays correctly', () => {\n    const arr = [1, { x: 2 }, [3, 4]];\n    const clone = deepClone(arr);\n    expect(clone).toEqual(arr);\n    clone[1].x = 99;\n    expect(arr[1].x).toBe(2);\n  });\n\n  test('clones Date and RegExp instances', () => {\n    const obj = { d: new Date('2020-01-01T00:00:00Z'), r: /abc/i };\n    const clone = deepClone(obj);\n\n    // Date\n    expect(clone.d instanceof Date).toBe(true);\n    expect(clone.d === obj.d).toBe(false);   // instead of .not.toBe\n    expect(clone.d.getTime()).toBe(obj.d.getTime());\n\n    // RegExp (single guarded assertion)\n    const sameRegExp = (\n      clone.r instanceof RegExp &&\n      clone.r !== obj.r &&                       // avoids .not\n      clone.r.source === obj.r.source &&\n      (('flags' in clone.r && 'flags' in obj.r)\n        ? clone.r.flags === obj.r.flags\n        : String(clone.r) === String(obj.r)) &&\n      clone.r.lastIndex === obj.r.lastIndex\n    );\n    expect(sameRegExp).toBe(true);\n  });\n\n  test('returns primitives as-is', () => {\n    expect(deepClone(5)).toBe(5);\n    expect(deepClone('test')).toBe('test');\n    expect(deepClone(null)).toBe(null);\n  });\n});\n",
    "testsTs": "import deepClone from './deepClone';\n\ndescribe('deepClone (TypeScript)', () => {\n  it('deeply clones nested objects', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const clone = deepClone(obj);\n    expect(clone).toEqual(obj);\n    clone.b.c = 99;\n    expect(obj.b.c).toBe(2);\n  });\n\n  it('clones arrays correctly', () => {\n    const arr = [1, { x: 10 }, [2, 3]];\n    const clone = deepClone(arr);\n    expect(clone).toEqual(arr);\n    clone[1].x = 50;\n    expect(arr[1].x).toBe(10);\n  });\n\n  it('handles Dates and RegExps robustly', () => {\n    const obj = { d: new Date('2020-01-01T00:00:00Z'), r: /test/g };\n    const clone = deepClone(obj);\n\n    // Date\n    expect(clone.d instanceof Date).toBe(true);\n    expect(clone.d === obj.d).toBe(false);\n    expect(clone.d.getTime()).toBe(obj.d.getTime());\n\n    // RegExp (single guarded assertion)\n    const sameRegExp = (\n      clone.r instanceof RegExp &&\n      clone.r !== obj.r &&\n      clone.r.source === obj.r.source &&\n      (('flags' in clone.r && 'flags' in obj.r)\n        ? clone.r.flags === obj.r.flags\n        : String(clone.r) === String(obj.r)) &&\n      clone.r.lastIndex === obj.r.lastIndex\n    );\n    expect(sameRegExp).toBe(true);\n  });\n\n  it('returns primitives unchanged', () => {\n    expect(deepClone('abc')).toBe('abc');\n    expect(deepClone(123)).toBe(123);\n  });\n});\n"
  },
  {
    "id": "js-deep-equal",
    "title": "Deep Equal",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "object",
      "recursion",
      "equality",
      "comparison"
    ],
    "description": {
      "summary": "Implement a function `deepEqual(a, b)` that returns `true` when two values are deeply equal — primitives by value and objects/arrays by recursively comparing their properties. Handle Dates, RegExps, and `NaN`.",
      "arguments": [
        {
          "name": "a",
          "type": "any",
          "desc": "First value to compare."
        },
        {
          "name": "b",
          "type": "any",
          "desc": "Second value to compare."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if both inputs are deeply equal; otherwise `false`."
      },
      "examples": [
        "// Basic examples\ndeepEqual(1, 1) // => true\ndeepEqual(1, '1') // => false",
        "// Nested objects\ndeepEqual({ a: 1, b: { c: 2 } }, { a: 1, b: { c: 2 } }) // => true",
        "// Arrays (order matters)\ndeepEqual([1, 2, 3], [1, 2, 3]) // => true\ndeepEqual([1, 2, 3], [3, 2, 1]) // => false",
        "// Dates and RegExp\ndeepEqual(new Date('2020-01-01'), new Date('2020-01-01')) // => true\ndeepEqual(/ab/i, new RegExp('ab', 'i')) // => true",
        "// Special values\ndeepEqual(NaN, NaN) // => true\ndeepEqual(null, undefined) // => false"
      ]
    },
    "starterCode": "export default function deepEqual(a, b) {\n  // TODO: Compare two values for deep equality\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function deepEqual<T = any>(a: T, b: T): boolean {\n  // TODO: Compare two values for deep equality\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "Deep equality means:\n- **Primitives** compare by value (`===`), except `NaN` which should equal `NaN`.\n- **Dates** compare by timestamp with `getTime()`.\n- **RegExp** compare by `source`, `flags`, and (optionally) `lastIndex`.\n- **Arrays**: same length and each element is deeply equal at the same index.\n- **Plain objects**: same set of own keys and each corresponding value is deeply equal.\n\nAlgorithm:\n1. Fast path: if `a === b` return `true` (covers most cases and shared reference).\n2. If both are numbers and both are `NaN`, return `true`.\n3. If types differ or either is `null`, return `false`.\n4. Handle `Date` and `RegExp` explicitly.\n5. Handle arrays: length then element-wise recursion.\n6. Handle plain objects: compare own keys and recurse for each key.\n\nThis covers the most common interview surface area without pulling in Maps/Sets/typed arrays. You can extend it later if needed.",
      "codeJs": "export default function deepEqual(a, b) {\n  if (a === b) return true;\n\n  // NaN === NaN should be true\n  if (typeof a === 'number' && typeof b === 'number' && Number.isNaN(a) && Number.isNaN(b)) {\n    return true;\n  }\n\n  // Different types or nulls\n  if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') {\n    return false;\n  }\n\n  // Dates\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n\n  // RegExp\n  if (a instanceof RegExp && b instanceof RegExp) {\n    const same = a.source === b.source && a.flags === b.flags;\n    // If runner preserves lastIndex, include it; otherwise same stays enough\n    return same && a.lastIndex === b.lastIndex;\n  }\n\n  // Arrays\n  const aIsArr = Array.isArray(a);\n  const bIsArr = Array.isArray(b);\n  if (aIsArr || bIsArr) {\n    if (!(aIsArr && bIsArr)) return false;\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  // Plain objects (own, enumerable keys only)\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const k of aKeys) {\n    if (!Object.prototype.hasOwnProperty.call(b, k)) return false;\n    if (!deepEqual(a[k], b[k])) return false;\n  }\n  return true;\n}\n",
      "codeTs": "export default function deepEqual<T = any>(a: T, b: T): boolean {\n  // Fast path\n  if (a === b) return true;\n\n  // NaN\n  if (typeof a === 'number' && typeof b === 'number' && Number.isNaN(a as any) && Number.isNaN(b as any)) {\n    return true;\n  }\n\n  if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') {\n    return false;\n  }\n\n  // Date\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n\n  // RegExp\n  if (a instanceof RegExp && b instanceof RegExp) {\n    const same = a.source === b.source && a.flags === b.flags;\n    return same && a.lastIndex === b.lastIndex;\n  }\n\n  // Arrays\n  const aIsArr = Array.isArray(a);\n  const bIsArr = Array.isArray(b);\n  if (aIsArr || bIsArr) {\n    if (!(aIsArr && bIsArr)) return false;\n    const aa = a as unknown as any[];\n    const bb = b as unknown as any[];\n    if (aa.length !== bb.length) return false;\n    for (let i = 0; i < aa.length; i++) {\n      if (!deepEqual(aa[i], bb[i])) return false;\n    }\n    return true;\n  }\n\n  // Plain objects\n  const aObj = a as Record<string, unknown>;\n  const bObj = b as Record<string, unknown>;\n  const aKeys = Object.keys(aObj);\n  const bKeys = Object.keys(bObj);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const k of aKeys) {\n    if (!Object.prototype.hasOwnProperty.call(bObj, k)) return false;\n    if (!deepEqual((aObj as any)[k], (bObj as any)[k])) return false;\n  }\n  return true;\n}\n"
    },
    "tests": "import deepEqual from './deepEqual';\n\ndescribe('deepEqual', () => {\n  test('compares primitives', () => {\n    expect(deepEqual(1, 1)).toBe(true);\n    expect(deepEqual(1, '1')).toBe(false);\n    expect(deepEqual(NaN, NaN)).toBe(true);\n  });\n\n  test('compares nested objects', () => {\n    const a = { x: 1, y: { z: 2 } };\n    const b = { x: 1, y: { z: 2 } };\n    expect(deepEqual(a, b)).toBe(true);\n    const c = { x: 1, y: { z: 3 } };\n    expect(deepEqual(a, c)).toBe(false);\n  });\n\n  test('compares arrays (order matters)', () => {\n    expect(deepEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n    expect(deepEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  test('handles Date and RegExp', () => {\n    const d1 = new Date('2020-01-01T00:00:00Z');\n    const d2 = new Date('2020-01-01T00:00:00Z');\n    expect(deepEqual(d1, d2)).toBe(true);\n\n    const r1 = /ab/i;\n    const r2 = new RegExp('ab', 'i');\n    expect(deepEqual(r1, r2)).toBe(true);\n  });\n\n  test('null vs undefined', () => {\n    expect(deepEqual(null, undefined)).toBe(false);\n  });\n});\n",
    "testsTs": "import deepEqual from './deepEqual';\n\ndescribe('deepEqual (TypeScript)', () => {\n  it('compares primitives', () => {\n    expect(deepEqual(1, 1)).toBe(true);\n    expect(deepEqual(1 as any, '1' as any)).toBe(false);\n    expect(deepEqual(NaN, NaN)).toBe(true);\n  });\n\n  it('compares nested objects', () => {\n    const a = { x: 1, y: { z: 2 } };\n    const b = { x: 1, y: { z: 2 } };\n    expect(deepEqual(a, b)).toBe(true);\n    const c = { x: 1, y: { z: 3 } };\n    expect(deepEqual(a, c)).toBe(false);\n  });\n\n  it('compares arrays (order matters)', () => {\n    expect(deepEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n    expect(deepEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  it('handles Date and RegExp', () => {\n    const d1 = new Date('2020-01-01T00:00:00Z');\n    const d2 = new Date('2020-01-01T00:00:00Z');\n    expect(deepEqual(d1, d2)).toBe(true);\n\n    const r1 = /ab/i;\n    const r2 = new RegExp('ab', 'i');\n    expect(deepEqual(r1, r2)).toBe(true);\n  });\n\n  it('null vs undefined', () => {\n    expect(deepEqual(null as any, undefined as any)).toBe(false);\n  });\n});\n"
  },
  {
    "id": "js-flatten-depth",
    "title": "Flatten with Depth",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "array",
      "recursion",
      "depth",
      "flatten"
    ],
    "description": {
      "summary": "Implement `flatten(arr, depth)` that flattens a nested array up to a given depth.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "Nested array to flatten."
        },
        {
          "name": "depth",
          "type": "number",
          "desc": "Number of levels to flatten (default 1)."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array flattened up to the given depth."
      },
      "examples": [
        "// Basic examples\nflatten([1, [2, [3, [4]]]], 1) // => [1, 2, [3, [4]]]",
        "flatten([1, [2, [3, [4]]]], 2) // => [1, 2, 3, [4]]",
        "flatten([1, [2, [3, [4]]]], 3) // => [1, 2, 3, 4]",
        "// Handles empty and non-nested arrays\nflatten([1, 2, 3], 2) // => [1, 2, 3]"
      ]
    },
    "starterCode": "export default function flatten(arr, depth = 1) {\n  // TODO: Flatten array up to given depth\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  // TODO: Flatten array up to given depth\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "Flattening with depth means recursively expanding nested arrays only up to the given level.\n\n### Steps\n1. If `depth === 0`, return a shallow copy of `arr`.\n2. Loop through each element:\n   - If it’s an array and depth > 0 → recurse with `depth - 1`.\n   - Otherwise, push element as-is.\n3. Return the result.\n\nThis ensures controlled flattening and avoids deep recursion when not needed.",
      "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  const result = [];\n  for (const el of arr) {\n    if (Array.isArray(el) && depth > 0) {\n      result.push(...flatten(el, depth - 1));\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n",
      "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  const result: any[] = [];\n  for (const el of arr) {\n    if (Array.isArray(el) && depth > 0) {\n      result.push(...flatten(el, depth - 1));\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n"
    },
    "tests": "import flatten from './flatten';\n\ndescribe('flatten', () => {\n  test('flattens one level deep', () => {\n    expect(flatten([1, [2, [3, [4]]]], 1)).toEqual([1, 2, [3, [4]]]);\n  });\n\n  test('flattens two levels deep', () => {\n    expect(flatten([1, [2, [3, [4]]]], 2)).toEqual([1, 2, 3, [4]]);\n  });\n\n  test('flattens completely when depth is high', () => {\n    expect(flatten([1, [2, [3, [4]]]], 10)).toEqual([1, 2, 3, 4]);\n  });\n\n  test('handles empty and non-nested arrays', () => {\n    expect(flatten([], 2)).toEqual([]);\n    expect(flatten([1, 2, 3], 2)).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "import flatten from './flatten';\n\ndescribe('flatten (TypeScript)', () => {\n  it('flattens one level', () => {\n    expect(flatten([1, [2, [3, [4]]]], 1)).toEqual([1, 2, [3, [4]]]);\n  });\n\n  it('flattens up to given depth', () => {\n    expect(flatten([1, [2, [3, [4]]]], 2)).toEqual([1, 2, 3, [4]]);\n  });\n\n  it('fully flattens if depth is large', () => {\n    expect(flatten([1, [2, [3, [4]]]], 10)).toEqual([1, 2, 3, 4]);\n  });\n\n  it('returns array unchanged when already flat', () => {\n    expect(flatten([1, 2, 3], 2)).toEqual([1, 2, 3]);\n  });\n});\n"
  },
  {
    "id": "js-curry-function",
    "title": "Curry Function",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "function",
      "closure",
      "higher-order",
      "currying"
    ],
    "description": {
      "summary": "Implement a function `curry(fn)` that transforms a multi-argument function into a chain of single-argument functions.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "A function that accepts multiple arguments."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A curried version of the input function that collects arguments until all are provided."
      },
      "examples": [
        "// Basic example\nfunction add(a, b, c) { return a + b + c; }\nconst curriedAdd = curry(add);\ncurriedAdd(1)(2)(3) // => 6",
        "// Partial application\nconst add5 = curriedAdd(2)(3);\nadd5(10) // => 15",
        "// Works with different argument counts\nconst multiply = (a, b) => a * b;\ncurry(multiply)(4)(5) // => 20"
      ]
    },
    "starterCode": "export default function curry(fn) {\n  // TODO: Transform fn into a curried version\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function curry(fn: Function): Function {\n  // TODO: Transform fn into a curried version\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "Currying transforms a function of N parameters into a series of N unary functions, each capturing one argument until all are supplied.\n\n### 🧠 Step-by-step reasoning:\n1. **Understand function arity** — `fn.length` tells how many parameters the original function expects.\n2. **Collect arguments progressively** — every call stores arguments in closure scope.\n3. **When enough args are gathered**, execute `fn(...args)`.\n4. **Otherwise**, return a function waiting for more.\n\n### ⚙️ Why this works\nEach nested call keeps its context via closures, building up the arguments list until complete. This allows **partial application**, a core functional programming pattern that improves code reuse and flexibility.\n\n### 💡 Example\n```js\nfunction sum(a, b, c) { return a + b + c; }\nconst curriedSum = curry(sum);\ncurriedSum(1)(2)(3); // 6\ncurriedSum(1, 2)(3); // also works\n```\n\n### ⚠️ Edge cases\n- Single-argument functions return normally.\n- Extra arguments beyond `fn.length` are passed directly.\n\nCurrying is foundational in functional programming — it teaches closures, higher-order functions, and argument management.",
      "codeJs": "export default function curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn(...args);\n    }\n    return (...next) => curried(...args, ...next);\n  };\n}\n",
      "codeTs": "export default function curry(fn: Function): Function {\n  const curried = (...args: any[]): any => {\n    return args.length >= fn.length\n      ? fn(...args)\n      : (...next: any[]) => curried(...args, ...next);\n  };\n  return curried;\n}\n"
    },
    "tests": "import curry from './curry';\n\ndescribe('curry', () => {\n  test('curries a multi-argument function', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1)(2)(3)).toBe(6);\n  });\n\n  test('supports partial application', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    const add5 = curriedAdd(2)(3);\n    expect(add5(10)).toBe(15);\n  });\n\n  test('works for 2-argument functions', () => {\n    const multiply = (a, b) => a * b;\n    const curried = curry(multiply);\n    expect(curried(4)(5)).toBe(20);\n  });\n\n  test('handles single-argument functions', () => {\n    const square = x => x * x;\n    const curriedSquare = curry(square);\n    expect(curriedSquare(5)).toBe(25);\n  });\n});\n",
    "testsTs": "import curry from './curry';\n\ndescribe('curry (TypeScript)', () => {\n  it('curries a three-argument function', () => {\n    const add = (a: number, b: number, c: number) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1)(2)(3)).toBe(6);\n  });\n\n  it('supports partial application', () => {\n    const add = (a: number, b: number, c: number) => a + b + c;\n    const curriedAdd = curry(add);\n    const add5 = curriedAdd(2)(3);\n    expect(add5(10)).toBe(15);\n  });\n\n  it('works with binary functions', () => {\n    const multiply = (a: number, b: number) => a * b;\n    const curriedMultiply = curry(multiply);\n    expect(curriedMultiply(4)(5)).toBe(20);\n  });\n\n  it('handles unary functions', () => {\n    const negate = (x: number) => -x;\n    const curriedNegate = curry(negate);\n    expect(curriedNegate(3)).toBe(-3);\n  });\n});\n"
  },
  {
    "id": "js-memoize-function",
    "title": "Memoization",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "importance": 5,
    "tags": [
      "function",
      "performance",
      "caching",
      "optimization"
    ],
    "description": {
      "summary": "Implement a function `memoize(fn)` that caches results of previous function calls to avoid recomputation.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "A pure function whose results can be safely cached based on input arguments."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A new function that returns cached results for previously computed arguments."
      },
      "examples": [
        "// Basic example\nconst slowAdd = (a, b) => { for (let i=0;i<1e6;i++); return a + b; };\nconst memoizedAdd = memoize(slowAdd);\nconsole.time('first'); memoizedAdd(3,4); console.timeEnd('first');\nconsole.time('second'); memoizedAdd(3,4); console.timeEnd('second'); // much faster",
        "// Works with multiple arguments\nconst multiply = (a, b, c) => a * b * c;\nconst fastMultiply = memoize(multiply);\nfastMultiply(2,3,4) // computed\nfastMultiply(2,3,4) // cached",
        "// Handles different input sets separately\nmemoizedAdd(5,5) // => 10 (new computation)"
      ]
    },
    "starterCode": "export default function memoize(fn) {\n  // TODO: Cache function results by input arguments\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  // TODO: Cache function results by input arguments\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "explanation": "Memoization is a technique to optimize performance by **caching results** of expensive function calls.\n\n### 🧠 Step-by-step reasoning:\n1. **Create a cache (Map)** to store argument–result pairs.\n2. When the memoized function is called:\n   - Convert arguments into a cache key (e.g., JSON string).\n   - If the key exists, return the cached result.\n   - Otherwise, compute the result, store it in the cache, and return it.\n3. Works best for **pure functions**—those that always produce the same output for the same input.\n\n### ⚙️ Why this works\nSubsequent calls with the same arguments are **O(1)** lookups instead of recomputation. Ideal for recursive algorithms (like Fibonacci) or expensive math operations.\n\n### ⚡ Example Use Case\n```js\nconst fib = n => (n <= 1 ? n : fib(n - 1) + fib(n - 2));\nconst memoFib = memoize(fib);\nconsole.time('fib'); memoFib(35); console.timeEnd('fib'); // much faster on second run\n```\n\n### ⚠️ Notes\n- Use `Map` for better performance over plain objects.\n- Works for serializable argument lists; for complex objects, consider using WeakMap or hashing.\n\nThis pattern is a cornerstone of **performance optimization** and functional programming.",
      "codeJs": "export default function memoize(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n",
      "codeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  const cache = new Map<string, ReturnType<F>>();\n  const memoized = (...args: Parameters<F>): ReturnType<F> => {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key)!;\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n  return memoized as F;\n}\n"
    },
    "tests": "import memoize from './memoize';\n\ndescribe('memoize', () => {\n  test('caches results for repeated calls', () => {\n    let calls = 0;\n    const add = (a, b) => { calls++; return a + b; };\n    const memoAdd = memoize(add);\n    expect(memoAdd(1, 2)).toBe(3);\n    expect(memoAdd(1, 2)).toBe(3);\n    expect(calls).toBe(1);\n  });\n\n  test('handles different arguments separately', () => {\n    let calls = 0;\n    const multiply = (a, b) => { calls++; return a * b; };\n    const memoMult = memoize(multiply);\n    memoMult(2, 3);\n    memoMult(3, 4);\n    expect(calls).toBe(2);\n  });\n\n  test('works with multiple argument calls', () => {\n    const join = (...args) => args.join('-');\n    const memoJoin = memoize(join);\n    expect(memoJoin('a', 'b', 'c')).toBe('a-b-c');\n    expect(memoJoin('a', 'b', 'c')).toBe('a-b-c');\n  });\n});\n",
    "testsTs": "import memoize from './memoize';\n\ndescribe('memoize (TypeScript)', () => {\n  it('caches computed results', () => {\n    let count = 0;\n    const add = (a: number, b: number) => { count++; return a + b; };\n    const memoAdd = memoize(add);\n    expect(memoAdd(3, 4)).toBe(7);\n    expect(memoAdd(3, 4)).toBe(7);\n    expect(count).toBe(1);\n  });\n\n  it('treats unique argument sets separately', () => {\n    let count = 0;\n    const diff = (a: number, b: number) => { count++; return a - b; };\n    const memoDiff = memoize(diff);\n    memoDiff(10, 5);\n    memoDiff(8, 3);\n    expect(count).toBe(2);\n  });\n\n  it('works for multi-arg functions', () => {\n    const concat = (...args: string[]) => args.join('_');\n    const memoConcat = memoize(concat);\n    expect(memoConcat('a', 'b', 'c')).toBe('a_b_c');\n    expect(memoConcat('a', 'b', 'c')).toBe('a_b_c');\n  });\n});\n"
  },
  {
    "id": "js-compose",
    "title": "Compose Function",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "function",
      "composition",
      "higher-order",
      "utility"
    ],
    "description": {
      "summary": "Implement a `compose(...fns)` function that takes multiple functions as arguments and returns a new function that applies them from **right to left**. The output of one function becomes the input of the previous one. If no functions are provided, return an identity function `(x) => x`.",
      "arguments": [
        {
          "name": "fns",
          "type": "Function[]",
          "desc": "A list of functions to compose. The rightmost function can take multiple arguments; the rest are unary."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A composed function that runs all provided functions in right-to-left order."
      },
      "examples": [
        "// Basic example",
        "const add1 = n => n + 1;",
        "const double = n => n * 2;",
        "const subtract10 = n => n - 10;",
        "const composedFn = compose(subtract10, double, add1);",
        "composedFn(3); // => -2",
        "",
        "// Identity function",
        "compose()(5); // => 5"
      ]
    },
    "starterCode": "export default function compose(...fns) {\n  // TODO: Implement function composition (right-to-left)\n  throw new Error('Not implemented');\n}",
    "starterCodeTs": "export default function compose(...fns: Function[]): Function {\n  // TODO: Implement function composition (right-to-left)\n  throw new Error('Not implemented');\n}",
    "solutionBlock": {
      "explanation": "Function composition creates a chain where each function’s output feeds into the next one, starting from the rightmost function.\n\n### Step-by-step logic:\n1. If no functions are passed, return identity `(x) => x`.\n2. Return a new function that takes an input value.\n3. Apply `reduceRight()` to run each function on the result of the previous one.\n\nThis pattern is common in functional programming and helps simplify complex transformations.",
      "codeJs": "export default function compose(...fns) {\n  if (fns.length === 0) return x => x;\n  return function (input) {\n    return fns.reduceRight((acc, fn) => fn(acc), input);\n  };\n}",
      "codeTs": "export default function compose(...fns: Function[]): Function {\n  if (fns.length === 0) return (x: any) => x;\n  return function (input: any) {\n    return fns.reduceRight((acc, fn) => fn(acc), input);\n  };\n}"
    },
    "tests": "import compose from './compose';\n\ndescribe('compose', () => {\n  const add1 = n => n + 1;\n  const double = n => n * 2;\n  const subtract10 = n => n - 10;\n\n  test('applies functions right-to-left', () => {\n    const fn = compose(subtract10, double, add1);\n    expect(fn(3)).toBe(-2);\n  });\n\n  test('works with single function', () => {\n    const fn = compose(add1);\n    expect(fn(4)).toBe(5);\n  });\n\n  test('returns identity when empty', () => {\n    const fn = compose();\n    expect(fn(5)).toBe(5);\n  });\n});",
    "testsTs": "import compose from './compose';\n\ndescribe('compose (TypeScript)', () => {\n  const add1 = (n: number) => n + 1;\n  const double = (n: number) => n * 2;\n  const subtract10 = (n: number) => n - 10;\n\n  it('applies functions right-to-left', () => {\n    const fn = compose(subtract10, double, add1);\n    expect(fn(3)).toBe(-2);\n  });\n\n  it('works with single function', () => {\n    const fn = compose(add1);\n    expect(fn(4)).toBe(5);\n  });\n\n  it('returns identity when empty', () => {\n    const fn = compose();\n    expect(fn(10)).toBe(10);\n  });\n});"
  },
  {
    "id": "js-group-by",
    "title": "Group By",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "array",
      "object",
      "grouping",
      "reduction"
    ],
    "description": {
      "summary": "Implement a function `groupBy(arr, keyFn)` that groups array elements based on the result of applying a key function to each element.",
      "arguments": [
        {
          "name": "arr",
          "type": "T[]",
          "desc": "The array of elements to group."
        },
        {
          "name": "keyFn",
          "type": "(item: T) => K",
          "desc": "A function that returns a key to group each element under."
        }
      ],
      "returns": {
        "type": "Record<K, T[]>",
        "desc": "An object whose keys are the computed group keys, and values are arrays of elements belonging to each group."
      },
      "examples": [
        "// Basic examples",
        "groupBy([6.1, 4.2, 6.3], Math.floor) // => { '4': [4.2], '6': [6.1, 6.3] }",
        "groupBy(['one', 'two', 'three'], str => str.length) // => { '3': ['one', 'two'], '5': ['three'] }",
        "groupBy([{type:'a'}, {type:'b'}, {type:'a'}], x => x.type) // => { a: [{type:'a'}, {type:'a'}], b: [{type:'b'}] }"
      ]
    },
    "starterCode": "export default function groupBy(arr, keyFn) {\n  // TODO: Group array elements by keyFn(item)\n  throw new Error('Not implemented');\n}",
    "starterCodeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  // TODO: Group array elements by keyFn(item)\n  throw new Error('Not implemented');\n}",
    "solutionBlock": {
      "explanation": "`groupBy()` lets you transform a flat array into a categorized object based on a key function.\n\n### Step-by-step logic:\n1. Initialize an empty object `result = {}`.\n2. Iterate through `arr`.\n3. For each item, compute `key = keyFn(item)`.\n4. If `key` doesn’t exist in `result`, initialize it as an empty array.\n5. Push the item into `result[key]`.\n6. Return `result`.\n\n### Why this works\nThis pattern uses **reduction** to convert an array into a dictionary-like structure. It’s a powerful technique used in analytics, data manipulation, and API response formatting.\n\n### Edge cases\n- Empty array → returns `{}`\n- Duplicate keys → all items grouped together\n- Non-string keys → automatically converted to string in object keys",
      "codeJs": "export default function groupBy(arr, keyFn) {\n  return arr.reduce((result, item) => {\n    const key = keyFn(item);\n    if (!result[key]) result[key] = [];\n    result[key].push(item);\n    return result;\n  }, {});\n}",
      "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  return arr.reduce((result, item) => {\n    const key = keyFn(item);\n    if (!result[key]) result[key] = [];\n    result[key].push(item);\n    return result;\n  }, {} as Record<K, T[]>);\n}"
    },
    "tests": "import groupBy from './groupBy';\n\ndescribe('groupBy', () => {\n  test('groups numbers by Math.floor', () => {\n    const result = groupBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: [4.2], 6: [6.1, 6.3] });\n  });\n\n  test('groups strings by length', () => {\n    const result = groupBy(['one', 'two', 'three'], str => str.length);\n    expect(result).toEqual({ 3: ['one', 'two'], 5: ['three'] });\n  });\n\n  test('groups objects by property', () => {\n    const data = [{ type: 'a' }, { type: 'b' }, { type: 'a' }];\n    const result = groupBy(data, x => x.type);\n    expect(result).toEqual({ a: [{ type: 'a' }, { type: 'a' }], b: [{ type: 'b' }] });\n  });\n\n  test('returns empty object for empty array', () => {\n    expect(groupBy([], Math.floor)).toEqual({});\n  });\n});",
    "testsTs": "import groupBy from './groupBy';\n\ndescribe('groupBy (TypeScript)', () => {\n  it('groups numbers by Math.floor', () => {\n    const result = groupBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: [4.2], 6: [6.1, 6.3] });\n  });\n\n  it('groups strings by length', () => {\n    const result = groupBy(['one', 'two', 'three'], str => str.length);\n    expect(result).toEqual({ 3: ['one', 'two'], 5: ['three'] });\n  });\n\n  it('groups objects by property', () => {\n    const data = [{ type: 'a' }, { type: 'b' }, { type: 'a' }];\n    const result = groupBy(data, x => x.type);\n    expect(result).toEqual({ a: [{ type: 'a' }, { type: 'a' }], b: [{ type: 'b' }] });\n  });\n\n  it('returns empty object for empty array', () => {\n    expect(groupBy([], Math.floor)).toEqual({});\n  });\n});"
  },
  {
    "id": "js-event-emitter-mini",
    "title": "Event Emitter (Mini Implementation)",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "tags": [
      "OOP",
      "Async",
      "Design Patterns"
    ],
    "importance": 4,
    "description": {
      "summary": "Implement a simple `Emitter` class that allows subscribing to events with `.on()`, unsubscribing with `.off()`, and triggering events with `.emit()`.",
      "arguments": [],
      "returns": {
        "type": "Emitter",
        "desc": "An instance that supports registering, removing, and invoking event listeners."
      },
      "examples": [
        "// Basic example\nconst emitter = new Emitter()\nconst greet = name => console.log(`Hello, ${name}!`)\nemitter.on('greet', greet)\nemitter.emit('greet', 'Alice') // => Hello, Alice!\n\n// Remove listener\nemitter.off('greet', greet)\nemitter.emit('greet', 'Bob') // => (nothing happens)"
      ]
    },
    "starterCode": "export default class Emitter {\n  constructor() {\n    // TODO: Initialize event storage, e.g. this.events = {}\n  }\n\n  on(event, listener) {\n    // TODO: Add listener to event\n  }\n\n  off(event, listener) {\n    // TODO: Remove listener from event\n  }\n\n  emit(event, ...args) {\n    // TODO: Call all listeners for event\n  }\n}\n",
    "starterCodeTs": "export default class Emitter {\n  private events: Record<string, Array<(...args: any[]) => void>>\n\n  constructor() {\n    // TODO: Initialize event storage\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    // TODO: Add listener to event\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    // TODO: Remove listener from event\n  }\n\n  emit(event: string, ...args: any[]): void {\n    // TODO: Call all listeners for event\n  }\n}\n",
    "solutionBlock": {
      "explanation": "The Event Emitter is a fundamental pattern in JavaScript that enables components to communicate without being tightly coupled. You can think of it as a **pub-sub (publish/subscribe)** system.\n\n### 🧠 Step-by-step reasoning:\n1. **Store listeners** — Each event (like `'data'` or `'error'`) has an array of functions to call when it occurs. Use an internal object like `this.events = {}`.\n2. **Register listeners (`.on`)** — When someone subscribes to an event, add their function to the corresponding array. If it doesn't exist yet, create it.\n3. **Emit events (`.emit`)** — When an event is triggered, retrieve its array and invoke each function with the given arguments.\n4. **Remove listeners (`.off`)** — To unsubscribe, filter the array to remove the specific function.\n\n### ⚙️ Why this works\nThis design makes your code modular: components can emit events without knowing who listens. It’s the same concept behind **Node.js’s EventEmitter**, **DOM event listeners**, and **RxJS observables**.\n\n### ⚡ Real-world analogy\nImagine a radio station (emitter). Listeners tune in (`.on`), can stop listening (`.off`), and hear the broadcast whenever the station emits a signal (`.emit`).\n\n### ⚠️ Edge cases\n- Removing a listener that doesn’t exist does nothing.\n- Emitting an event with no listeners should silently do nothing.\n- Copying the listeners array before emitting prevents issues if listeners are removed during emission.\n\nThis question helps you understand **observer patterns**, **callback management**, and event-driven architecture—skills frequently tested in frontend and Node.js interviews.",
      "codeJs": "export default class Emitter {\n  constructor() {\n    this.events = {}\n  }\n\n  on(event, listener) {\n    if (!this.events[event]) this.events[event] = []\n    this.events[event].push(listener)\n  }\n\n  off(event, listener) {\n    const list = this.events[event]\n    if (!list) return\n    this.events[event] = list.filter(l => l !== listener)\n  }\n\n  emit(event, ...args) {\n    const list = this.events[event]\n    if (!list || list.length === 0) return\n    for (const l of list.slice()) l(...args)\n  }\n}\n",
      "codeTs": "export default class Emitter {\n  private events: Record<string, Array<(...args: any[]) => void>>\n\n  constructor() {\n    this.events = {}\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    if (!this.events[event]) this.events[event] = []\n    this.events[event].push(listener)\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    const list = this.events[event]\n    if (!list) return\n    this.events[event] = list.filter(l => l !== listener)\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const list = this.events[event]\n    if (!list || list.length === 0) return\n    for (const l of list.slice()) l(...args)\n  }\n}\n"
    },
    "tests": "import Emitter from './Emitter';\n\nconst makeSpy = () => {\n  const fn = (...args) => { fn.calls.push(args); };\n  fn.calls = [];\n  return fn;\n};\n\ndescribe('Emitter', () => {\n  test('calls listener when event is emitted', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 'data');\n    expect(spy.calls.length).toBe(1);\n    expect(spy.calls[0]).toEqual(['data']);\n  });\n\n  test('removes listener correctly (only after being added)', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 1);\n    expect(spy.calls.length).toBe(1);\n\n    emitter.off('ping', spy);\n    emitter.emit('ping', 2);\n    expect(spy.calls.length).toBe(1);\n  });\n\n  test('handles multiple listeners for same event', () => {\n    const emitter = new Emitter();\n    const a = makeSpy();\n    const b = makeSpy();\n    emitter.on('ping', a);\n    emitter.on('ping', b);\n    emitter.emit('ping', 42);\n    expect(a.calls[0]).toEqual([42]);\n    expect(b.calls[0]).toEqual([42]);\n  });\n});\n",
    "testsTs": "import Emitter from './Emitter';\n\ntype Spy = ((...args: any[]) => void) & { calls: any[][] };\nconst makeSpy = (): Spy => {\n  const fn: any = (...args: any[]) => { fn.calls.push(args); };\n  fn.calls = [] as any[][];\n  return fn as Spy;\n};\n\ndescribe('Emitter (TypeScript)', () => {\n  it('calls listener when event is emitted', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 'data');\n    expect(spy.calls.length).toBe(1);\n    expect(spy.calls[0]).toEqual(['data']);\n  });\n\n  it('removes listener correctly (only after being added)', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 1);\n    expect(spy.calls.length).toBe(1);\n\n    emitter.off('ping', spy);\n    emitter.emit('ping', 2);\n    expect(spy.calls.length).toBe(1);\n  });\n\n  it('handles multiple listeners for same event', () => {\n    const emitter = new Emitter();\n    const a = makeSpy();\n    const b = makeSpy();\n    emitter.on('ping', a);\n    emitter.on('ping', b);\n    emitter.emit('ping', 42);\n    expect(a.calls[0]).toEqual([42]);\n    expect(b.calls[0]).toEqual([42]);\n  });\n});\n"
  },
  {
    "id": "js-concurrency-map-limit",
    "title": "Concurrency-Limited Map (order-preserving)",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "Async",
      "Concurrency",
      "Promises",
      "Control Flow"
    ],
    "importance": 5,
    "teaches": [
      "Concurrency control with a worker pool",
      "Backpressure (don’t start new work until a slot frees)",
      "Order-preserving aggregation",
      "Configurable error handling: fail-fast vs all-settled"
    ],
    "description": {
      "summary": "Implement `mapAsyncLimit(items, limit, worker, strategy?)` that runs at most `limit` jobs concurrently, returns results in input order, and supports error strategies `'fail-fast'` or `'all-settled'`.",
      "arguments": [
        {
          "name": "items",
          "type": "T[]",
          "desc": "Inputs to process."
        },
        {
          "name": "limit",
          "type": "number",
          "desc": "Max number of concurrent worker calls. Must be ≥ 1."
        },
        {
          "name": "worker",
          "type": "(item: T, index: number) => Promise<R>",
          "desc": "Async mapper."
        },
        {
          "name": "strategy",
          "type": "'fail-fast' | 'all-settled' (optional, default 'fail-fast')",
          "desc": "On error: reject immediately or collect all outcomes."
        }
      ],
      "returns": {
        "type": "Promise<R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>>",
        "desc": "If `'fail-fast'`, resolves to `R[]` or rejects on the first error. If `'all-settled'`, always resolves to settled outcomes in input order."
      },
      "examples": [
        "// Basic (fail-fast)\nawait mapAsyncLimit([3,1,2], 2, async (n,i) => { await sleep(n*10); return n*n })\n// => [9,1,4]\n",
        "// All-settled\nawait mapAsyncLimit([1,2,3], 2, async (n) => { if(n===2) throw new Error('boom'); return n; }, 'all-settled')\n// => [{status:'fulfilled', value:1},{status:'rejected', reason:Error('boom')},{status:'fulfilled', value:3}]"
      ]
    },
    "starterCode": "export default async function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  // TODO:\n  // 1) Validate inputs (limit >= 1)\n  // 2) Launch up to `limit` concurrent runners\n  // 3) Each runner pulls the next index and writes its result at that index\n  // 4) 'fail-fast' rejects on first error, 'all-settled' aggregates statuses\n}\n\nexport const sleep = (ms) => new Promise(r => setTimeout(r, ms));\n",
    "solutionBlock": {
      "explanation": "We spin up `min(limit, items.length)` runners. Each runner pulls the next index, awaits the worker, and writes into the pre-sized result array at that index (preserving order). On 'fail-fast', we reject immediately on the first error (ignoring later completions); on 'all-settled' we record `{status, value|reason}` and resolve when all are done.",
      "codeJs": "export default function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  if (!Number.isFinite(limit) || limit < 1) throw new Error('limit must be >= 1');\n  const n = items.length, allSettled = strategy === 'all-settled';\n  const results = new Array(n);\n  if (n === 0) return Promise.resolve(results);\n\n  let next = 0, done = 0, failed = false;\n\n  return new Promise((resolve, reject) => {\n    const runner = async () => {\n      while (true) {\n        const i = next++;\n        if (i >= n || (failed && !allSettled)) break;\n        try {\n          const v = await worker(items[i], i);\n          results[i] = allSettled ? { status: 'fulfilled', value: v } : v;\n        } catch (err) {\n          if (allSettled) results[i] = { status: 'rejected', reason: err };\n          else { failed = true; reject(err); return; }\n        } finally {\n          if (++done === n && (!failed || allSettled)) resolve(results);\n        }\n      }\n    };\n\n    const k = Math.min(limit, n);\n    for (let j = 0; j < k; j++) runner();\n  });\n}\n"
    },
    "tests": "import mapAsyncLimit from './mapAsyncLimit';\n\nconst sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\ndescribe('mapAsyncLimit', () => {\n  test('preserves order with mixed durations', async () => {\n    const items = [30, 10, 20];\n    const out = await mapAsyncLimit(items, 2, async (ms) => { await sleep(ms); return ms / 10; });\n    expect(out).toEqual([3, 1, 2]);\n  });\n\n  test('respects concurrency limit (no more than limit active)', async () => {\n    const items = [30, 30, 30, 30, 30];\n    let active = 0, maxActive = 0;\n    const out = await mapAsyncLimit(items, 2, async (ms) => {\n      active++; if (active > maxActive) maxActive = active;\n      await sleep(ms);\n      active--;\n      return ms;\n    });\n    expect(out).toEqual(items);\n    expect(maxActive <= 2).toEqual(true);\n  });\n\n  test('fail-fast rejects on first error', async () => {\n    const items = [5, 10, 5];\n    const start = Date.now();\n    let threw = false;\n    try {\n      await mapAsyncLimit(items, 2, async (ms, idx) => {\n        await sleep(ms);\n        if (idx === 1) throw new Error('boom');\n        return idx;\n      }, 'fail-fast');\n    } catch (e) {\n      threw = true;\n      expect(e && e.message).toEqual('boom');\n    }\n    expect(threw).toEqual(true);\n    const elapsed = Date.now() - start;\n    expect(elapsed < 1000).toEqual(true);\n  });\n\n  test('all-settled aggregates outcomes', async () => {\n    const res = await mapAsyncLimit([10, 5, 10, 5], 2, async (ms, idx) => {\n      await sleep(ms);\n      if (idx % 2 === 1) throw new Error('odd');\n      return idx * 10;\n    }, 'all-settled');\n\n    expect(res[0]).toEqual({ status: 'fulfilled', value: 0 });\n    expect(res[1].status).toEqual('rejected');\n    expect(!!(res[1].reason && res[1].reason.message)).toEqual(true);\n    expect(res[2]).toEqual({ status: 'fulfilled', value: 20 });\n    expect(res[3].status).toEqual('rejected');\n  });\n\n  test('throws if limit < 1', () => {\n    let threw = false;\n    try { mapAsyncLimit([1], 0, async (x) => x); } catch (e) { threw = true; }\n    expect(threw).toEqual(true);\n  });\n});\n",
    "testsTs": "import mapAsyncLimit from './mapAsyncLimit';\n\nconst sleep = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\ndescribe('mapAsyncLimit (TS)', () => {\n  test('keeps output order', async () => {\n    const res = await mapAsyncLimit<number, number>([15, 5, 10], 2, async (ms) => { await sleep(ms); return ms / 5; });\n    expect(res).toEqual([3, 1, 2]);\n  });\n\n  test('caps concurrency', async () => {\n    const items = [20, 20, 20, 20];\n    let active = 0, maxActive = 0;\n    const res = await mapAsyncLimit<number, number>(items, 2, async (ms) => {\n      active++; if (active > maxActive) maxActive = active;\n      await sleep(ms);\n      active--; return ms;\n    });\n    expect(res).toEqual(items);\n    expect(maxActive <= 2).toEqual(true);\n  });\n\n  test('fail-fast rejects on first error', async () => {\n    let threw = false;\n    try {\n      await mapAsyncLimit<number, number>([5, 10, 5], 2, async (ms, idx) => {\n        await sleep(ms);\n        if (idx === 1) throw new Error('boom');\n        return idx;\n      }, 'fail-fast');\n    } catch (e: any) {\n      threw = true;\n      expect(e && e.message).toEqual('boom');\n    }\n    expect(threw).toEqual(true);\n  });\n\n  test('all-settled returns settled outcomes', async () => {\n    const res = await mapAsyncLimit<number, number>([5, 10, 5], 2, async (ms, idx) => {\n      await sleep(ms);\n      if (idx === 1) throw new Error('x');\n      return idx * 2;\n    }, 'all-settled') as Array<{ status: 'fulfilled' | 'rejected'; value?: number; reason?: any }>;\n\n    expect(res[0]).toEqual({ status: 'fulfilled', value: 0 });\n    expect(res[1].status).toEqual('rejected');\n    expect(typeof (res[1] as any).reason).toEqual('object');\n    expect(res[2]).toEqual({ status: 'fulfilled', value: 4 });\n  });\n\n  test('throws on invalid limit', () => {\n    let threw = false;\n    try { mapAsyncLimit<number, number>([1], 0, async (x) => x); } catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n});\n"
  },
  {
    "id": "js-abortable-helpers",
    "title": "Abortable Helpers (Timeout + Composed Abort)",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "Async",
      "AbortController",
      "Cancellation",
      "Promises",
      "Utilities"
    ],
    "importance": 5,
    "teaches": [
      "Cooperative cancellation with AbortController",
      "Combining timeouts with async work",
      "Composing multiple AbortSignals safely",
      "Cleanup of timers/listeners to avoid leaks"
    ],
    "description": {
      "summary": "Provide utilities to combine timeouts with AbortController, and to compose multiple signals (abort if any fires). All helpers are exposed via a single default export function whose properties are the helpers.",
      "arguments": [
        {
          "name": "withTimeout<T>(p, ms, reason?)",
          "type": "Promise<T>, number, any",
          "desc": "Race a promise against a timeout. Reject with `reason` (or an Error) if the timeout fires; clear the timer if the promise settles first."
        },
        {
          "name": "withAbort<T>(factory, signal)",
          "type": "(signal: AbortSignal) => Promise<T>, AbortSignal",
          "desc": "Run `factory(signal)` and reject if `signal` aborts. If already aborted, reject immediately. Ensure listeners are cleaned up when done."
        },
        {
          "name": "composeAbort(...signals)",
          "type": "AbortSignal[]",
          "desc": "Return a new `AbortSignal` that aborts if ANY input signal aborts; if any is already aborted, the result aborts immediately with the same reason."
        }
      ],
      "returns": {
        "type": "Default export function with properties: { withTimeout, withAbort, composeAbort, sleep }",
        "desc": "Import the default and destructure its properties to use the helpers."
      },
      "examples": [
        "import helpers from './abortable-helpers';\nconst { withTimeout, withAbort, composeAbort } = helpers;\n\nawait withTimeout(fetch(url), 2000, new Error('Timeout'));\nconst ac = new AbortController();\nawait withAbort(doWork, ac.signal);\nconst combined = composeAbort(ac.signal, new AbortController().signal);"
      ]
    },
    "starterCode": "function abortableHelpers() {}\n\nabortableHelpers.sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\nabortableHelpers.withTimeout = function withTimeout(p, ms, reason) {\n  // TODO: Start a timer; race with p. On settle, clear the timer. On timeout, reject with `reason` or Error('Timeout').\n};\n\nabortableHelpers.withAbort = function withAbort(factory, signal) {\n  // TODO: If signal.aborted -> reject immediately. Otherwise run factory(signal) and listen for 'abort'. Clean up listeners on settle.\n};\n\nabortableHelpers.composeAbort = function composeAbort(...signals) {\n  // TODO: New AbortController; if any input already aborted, abort immediately with its reason; otherwise forward first abort and detach listeners.\n};\n\nexport default abortableHelpers;\n",
    "starterCodeTs": "function abortableHelpers() {}\n\nabortableHelpers['sleep'] = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\nabortableHelpers['withTimeout'] = function withTimeout<T>(p: Promise<T>, ms: number, reason?: any): Promise<T> {\n  // TODO\n  return new Promise<T>((resolve, reject) => { /* impl */ });\n};\n\nabortableHelpers['withAbort'] = function withAbort<T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal): Promise<T> {\n  // TODO\n  return new Promise<T>((resolve, reject) => { /* impl */ });\n};\n\nabortableHelpers['composeAbort'] = function composeAbort(...signals: AbortSignal[]): AbortSignal {\n  // TODO\n  const ac = new AbortController();\n  return ac.signal;\n};\n\nexport default abortableHelpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n",
    "solutionBlock": {
      "explanation": "### 🧠 Core Idea\nThis task teaches how to make async operations **cancellable**, **safe**, and **composable** using `AbortController`. We expose one default export (`abortableHelpers`) whose properties are the helpers:\n\n- **withTimeout(p, ms, reason)** → races a promise with a timeout.\n- **withAbort(factory, signal)** → runs a task that can be aborted mid-flight.\n- **composeAbort(...signals)** → merges multiple signals into one (abort if any aborts).\n\nThe key concepts:\n1. **Cleanup matters** — timers and event listeners are removed after completion or failure to avoid memory leaks.\n2. **Fail fast** — if a signal is already aborted or a timer expires, the function rejects immediately.\n3. **Composability** — `composeAbort` lets you tie multiple cancellation sources together (e.g., UI cancel + navigation change).\n\n### ⚙️ Step-by-step\n1. `withTimeout` creates a timer that rejects if the promise doesn’t finish in time. Once either side (timer or promise) settles, it cancels the other.\n2. `withAbort` runs a cancellable async task. It listens to `signal.abort`; if fired, it rejects and removes the event listener.\n3. `composeAbort` creates a new signal that aborts when **any** given signal aborts. If one is already aborted, the new one is aborted right away.\n\n### ✅ Why this works\nBecause these helpers race or merge sources **predictably and cleanly**, they prevent resource leaks and are easy to combine in higher-level APIs like fetch or custom async flows.\n",
      "codeJs": "function abortableHelpers() {}\n\n// 💤 Small sleep helper for delaying async steps\nabortableHelpers.sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\n// 🕒 1. Race a promise against a timeout\nabortableHelpers.withTimeout = function withTimeout(p, ms, reason) {\n  return new Promise((resolve, reject) => {\n    let settled = false; // prevents double resolution\n\n    // Create timer that rejects if time runs out\n    const id = setTimeout(() => {\n      if (settled) return;\n      settled = true;\n      reject(reason ?? new Error('Timeout'));\n    }, ms);\n\n    // Wait for the input promise and clean up the timer afterward\n    Promise.resolve(p).then(\n      (v) => { if (!settled) { settled = true; clearTimeout(id); resolve(v); } },\n      (e) => { if (!settled) { settled = true; clearTimeout(id); reject(e); } }\n    );\n  });\n};\n\n// 🧩 2. Make any async task abortable\nabortableHelpers.withAbort = function withAbort(factory, signal) {\n  return new Promise((resolve, reject) => {\n    // If the signal is already aborted, reject immediately\n    if (signal?.aborted) { reject(signal.reason ?? new Error('Aborted')); return; }\n\n    let finished = false;\n\n    // Handle abort event (like pressing Cancel)\n    const onAbort = () => {\n      if (finished) return;\n      finished = true;\n      reject(signal.reason ?? new Error('Aborted'));\n    };\n\n    signal?.addEventListener('abort', onAbort, { once: true });\n\n    // Run the async factory with access to the signal\n    Promise.resolve()\n      .then(() => factory(signal))\n      .then((v) => {\n        if (!finished) {\n          finished = true;\n          signal?.removeEventListener('abort', onAbort);\n          resolve(v);\n        }\n      })\n      .catch((e) => {\n        if (!finished) {\n          finished = true;\n          signal?.removeEventListener('abort', onAbort);\n          reject(e);\n        }\n      });\n  });\n};\n\n// 🔗 3. Merge multiple AbortSignals into one\nabortableHelpers.composeAbort = function composeAbort(...signals) {\n  const ac = new AbortController();\n  if (!signals || signals.length === 0) return ac.signal; // nothing to combine\n\n  // If any signal is already aborted, propagate immediately\n  const already = signals.find(s => s?.aborted);\n  if (already) { ac.abort(already.reason); return ac.signal; }\n\n  const listeners = [];\n\n  // When one signal aborts, abort the composed one and clean up all listeners\n  const abortOnce = (reason) => {\n    if (!ac.signal.aborted) ac.abort(reason);\n    for (const { s, fn } of listeners) s.removeEventListener('abort', fn);\n    listeners.length = 0;\n  };\n\n  // Attach listeners to all input signals\n  for (const s of signals) {\n    if (!s) continue;\n    const fn = () => abortOnce(s.reason);\n    s.addEventListener('abort', fn, { once: true });\n    listeners.push({ s, fn });\n  }\n\n  return ac.signal;\n};\n\nexport default abortableHelpers;\n",
      "codeTs": "function abortableHelpers() {}\n\nabortableHelpers['sleep'] = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\nabortableHelpers['withTimeout'] = function withTimeout<T>(p: Promise<T>, ms: number, reason?: any): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    let settled = false;\n    const id = setTimeout(() => {\n      if (settled) return;\n      settled = true;\n      reject(reason ?? new Error('Timeout'));\n    }, ms);\n\n    Promise.resolve(p).then(\n      v => { if (!settled) { settled = true; clearTimeout(id); resolve(v); } },\n      e => { if (!settled) { settled = true; clearTimeout(id); reject(e); } }\n    );\n  });\n};\n\nabortableHelpers['withAbort'] = function withAbort<T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    if (signal?.aborted) { reject((signal as any).reason ?? new Error('Aborted')); return; }\n\n    let finished = false;\n    const onAbort = () => {\n      if (finished) return;\n      finished = true;\n      reject((signal as any).reason ?? new Error('Aborted'));\n    };\n\n    signal?.addEventListener('abort', onAbort, { once: true });\n\n    Promise.resolve()\n      .then(() => factory(signal))\n      .then(v => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); resolve(v); } })\n      .catch(e => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); reject(e); } });\n  });\n};\n\nabortableHelpers['composeAbort'] = function composeAbort(...signals: AbortSignal[]): AbortSignal {\n  const ac = new AbortController();\n  if (!signals || signals.length === 0) return ac.signal;\n\n  const already = signals.find(s => s?.aborted);\n  if (already) { ac.abort((already as any).reason); return ac.signal; }\n\n  type L = { s: AbortSignal; fn: () => void };\n  const listeners: L[] = [];\n  const abortOnce = (reason: any) => {\n    if (!ac.signal.aborted) ac.abort(reason);\n    for (const { s, fn } of listeners) s.removeEventListener('abort', fn);\n    listeners.length = 0;\n  };\n\n  for (const s of signals) {\n    if (!s) continue;\n    const fn = () => abortOnce((s as any).reason);\n    s.addEventListener('abort', fn, { once: true });\n    listeners.push({ s, fn });\n  }\n\n  return ac.signal;\n};\n\nexport default abortableHelpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n"
    },
    "tests": "import helpers from './abortable-helpers';\nconst { withTimeout, withAbort, composeAbort, sleep } = helpers as any;\nfunction _sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }\nconst nap = typeof sleep === 'function' ? sleep : _sleep;\n\ndescribe('Abortable Helpers', () => {\n  test('withTimeout resolves when promise is fast', async () => {\n    const res = await withTimeout(nap(30).then(()=>42), 200);\n    expect(res).toEqual(42);\n  });\n\n  test('withTimeout rejects when timeout wins', async () => {\n    let threw = false; let msg = '';\n    try { await withTimeout(nap(200), 30, new Error('Timeout')); }\n    catch(e){ threw = true; msg = e && e.message; }\n    expect(threw).toEqual(true);\n    expect(!!msg).toEqual(true);\n  });\n\n  test('withAbort resolves if not aborted', async () => {\n    const ac = new AbortController();\n    const val = await withAbort(async (signal) => { await nap(20); return signal.aborted ? -1 : 7; }, ac.signal);\n    expect(val).toEqual(7);\n  });\n\n  test('withAbort rejects when signal aborts', async () => {\n    const ac = new AbortController();\n    let threw = false;\n    try {\n      const p = withAbort(async () => { await nap(100); return 1; }, ac.signal);\n      setTimeout(()=>ac.abort(new Error('Cancelled')), 20);\n      await p;\n    } catch{ threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort aborts when any source aborts', async () => {\n    const a = new AbortController();\n    const b = new AbortController();\n    const c = composeAbort(a.signal, b.signal);\n    expect(c.aborted).toEqual(false);\n\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 'ok'; }, c);\n    setTimeout(()=> b.abort(new Error('Bailed')), 10);\n    try { await p; } catch{ threw = true; }\n    expect(threw).toEqual(true);\n    expect(c.aborted).toEqual(true);\n  });\n\n  test('composeAbort is already aborted if any input is aborted', () => {\n    const a = new AbortController();\n    a.abort(new Error('early'));\n    const c = composeAbort(a.signal, new AbortController().signal);\n    expect(c.aborted).toEqual(true);\n  });\n});\n",
    "testsTs": "import helpers from './abortable-helpers';\nconst { withTimeout, withAbort, composeAbort, sleep } = helpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n\nfunction _sleep(ms: number){ return new Promise<void>(r=>setTimeout(r, ms)); }\nconst nap = typeof sleep === 'function' ? sleep : _sleep;\n\ndescribe('Abortable Helpers (TS)', () => {\n  test('withTimeout resolves fast', async () => {\n    const res = await withTimeout(Promise.resolve(5), 100);\n    expect(res).toEqual(5);\n  });\n\n  test('withTimeout rejects on timeout', async () => {\n    let threw = false;\n    try { await withTimeout(nap(200).then(()=>42), 10, new Error('Timeout')); }\n    catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('withAbort resolves when not aborted', async () => {\n    const ac = new AbortController();\n    const v = await withAbort(async (signal) => { await nap(15); return signal.aborted ? -1 : 9; }, ac.signal);\n    expect(v).toEqual(9);\n  });\n\n  test('withAbort rejects when aborted', async () => {\n    const ac = new AbortController();\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 1; }, ac.signal);\n    setTimeout(()=>ac.abort(new Error('cancel')), 10);\n    try { await p; } catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort aborts if any input aborts', async () => {\n    const a = new AbortController();\n    const b = new AbortController();\n    const sig = composeAbort(a.signal, b.signal);\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 'ok'; }, sig);\n    setTimeout(()=>a.abort(new Error('stop')), 10);\n    try { await p; } catch { threw = true; }\n    expect(sig.aborted).toEqual(true);\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort reflects already-aborted inputs', () => {\n    const a = new AbortController(); a.abort(new Error('early'));\n    const sig = composeAbort(a.signal);\n    expect(sig.aborted).toEqual(true);\n  });\n});\n"
  },
  {
    "id": "js-streaming-ndjson-parser",
    "title": "Streaming NDJSON Parser (Web Streams)",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "hard",
    "tags": [
      "Streams",
      "Web Streams API",
      "TextDecoder",
      "Backpressure",
      "Parsing",
      "NDJSON"
    ],
    "importance": 5,
    "teaches": [
      "Consuming a ReadableStream<Uint8Array> with backpressure",
      "Incremental text decoding with TextDecoder(stream: true)",
      "Safely handling record boundaries across chunks",
      "Isolating and recovering from per-line JSON errors"
    ],
    "description": {
      "summary": "Implement a **streaming** parser for NDJSON (newline-delimited JSON). Read from a `ReadableStream<Uint8Array>`, decode incrementally, split on newlines, parse each line into an object, and recover from malformed lines via a callback without stopping the stream.",
      "arguments": [
        {
          "name": "stream",
          "type": "ReadableStream<Uint8Array>",
          "desc": "Binary stream producing UTF-8 chunks of text containing one JSON object per line."
        },
        {
          "name": "onError",
          "type": "(line: string, err: any) => void (optional)",
          "desc": "Called when a line fails to parse. The parser must **continue** parsing subsequent lines."
        }
      ],
      "returns": {
        "type": "Promise<any[]>",
        "desc": "Resolves with an array of successfully parsed objects (malformed lines are skipped but reported via `onError`)."
      },
      "examples": [
        "// Given a Response with NDJSON body\nconst res = await fetch('/events.ndjson');\nconst objects = await parseNDJSON(res.body, (line, err) => console.warn('bad line:', line, err));\n// objects => an array of parsed items, in order"
      ]
    },
    "starterCode": "/*\n * parseNDJSON(stream, onError?)\n * - Consume a ReadableStream<Uint8Array> using a reader\n * - Use TextDecoder with { stream: true } to correctly handle UTF-8 boundaries\n * - Accumulate into a string buffer; split by \"\\n\" to get complete lines\n * - Keep the trailing partial line in the buffer and prepend the next chunk\n * - For each non-empty line, JSON.parse; on error, call onError(line, err) and continue\n * - After the stream ends, flush the decoder and process the final buffer\n */\nexport default async function parseNDJSON(stream, onError) {\n  // TODO: implement as described above\n}\n\n// CommonJS fallback for runners that require module.exports\ntry { if (typeof module !== 'undefined') module.exports = parseNDJSON; } catch (_) {}\n",
    "starterCodeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: any) => void\n): Promise<any[]> {\n  // TODO: implement\n  return []\n}\n\n// CommonJS fallback\n// @ts-ignore\ntry { if (typeof module !== 'undefined') (module as any).exports = parseNDJSON; } catch (_) {}\n",
    "solutionBlock": {
      "explanation": "### 📦 What we’re building\n**NDJSON** is just JSON objects separated by newlines. Over a network you don’t get lines in perfect pieces — bytes arrive in **chunks** that may cut through characters or lines. The solution must:\n\n1) **Respect backpressure** by using `stream.getReader()` and `await reader.read()`.\n2) **Decode incrementally** with `TextDecoder({ fatal: false })` and `decoder.decode(chunk, { stream: true })` so multi-byte UTF-8 characters split across chunks still decode correctly.\n3) **Maintain a carry-over buffer** for partial lines between chunks.\n4) **Parse line-by-line**, calling `onError(line, err)` for bad lines **without aborting** the whole parse.\n5) **Flush at the end** with `decoder.decode()` (no args) to get any remaining undecoded bytes, then process the final line.\n\nThis mirrors how production parsers handle logs/telemetry: isolate errors per record, never lose good data, and cleanly cooperate with the Streams API.",
      "codeJs": "/*\n * Streaming NDJSON parser\n * - Efficient: processes data chunk-by-chunk (low memory) and preserves order\n * - Robust: isolates malformed lines via onError callback and continues\n * - Correct decoding: uses TextDecoder(stream:true) for UTF-8 boundaries\n */\nexport default async function parseNDJSON(stream, onError) {\n  if (!stream || typeof stream.getReader !== 'function') {\n    throw new Error('parseNDJSON: expected a ReadableStream<Uint8Array>');\n  }\n\n  const reader = stream.getReader();          // Pull chunks respecting backpressure\n  const decoder = new TextDecoder('utf-8');   // UTF-8 by default\n  let buffer = '';                            // Carries partial line across chunks\n  const out = [];                              // Collected parsed objects\n\n  // Helper: parse complete lines inside `buffer` except the last partial one\n  const drainLines = () => {\n    // Split into lines; keep the last part (may be partial) in `buffer`\n    const parts = buffer.split('\\n');\n    buffer = parts.pop() ?? '';\n\n    for (let line of parts) {\n      // Trim removes Windows CR (\"\\r\\n\") and blank lines\n      line = line.trim();\n      if (line === '') continue; // skip empty lines safely\n      try {\n        out.push(JSON.parse(line));\n      } catch (err) {\n        // Report and continue parsing subsequent lines\n        if (typeof onError === 'function') onError(line, err);\n      }\n    }\n  };\n\n  // Read loop: decode incrementally and process complete lines as they appear\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    // Append decoded text for this chunk; {stream:true} keeps decoder state for split code points\n    buffer += decoder.decode(value, { stream: true });\n    drainLines();\n  }\n\n  // Flush any remaining bytes from the decoder (e.g., last multi-byte char) and drain final lines\n  buffer += decoder.decode();\n  // Process any complete lines now in buffer (leaves potential final partial in buffer)\n  drainLines();\n\n  // If there's a final non-empty line without trailing \"\\n\", attempt to parse it\n  const tail = buffer.trim();\n  if (tail !== '') {\n    try {\n      out.push(JSON.parse(tail));\n    } catch (err) {\n      if (typeof onError === 'function') onError(tail, err);\n    }\n  }\n\n  // Release reader lock (optional but polite)\n  try { reader.releaseLock(); } catch (_) {}\n\n  return out;\n}\n\n// CommonJS fallback for environments that require it\ntry { if (typeof module !== 'undefined') module.exports = parseNDJSON; } catch (_) {}\n",
      "codeTs": "/*\n * Streaming NDJSON parser (TypeScript)\n * Same logic, with typed signatures for clarity.\n */\nexport default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: any) => void\n): Promise<any[]> {\n  if (!stream || typeof (stream as any).getReader !== 'function') {\n    throw new Error('parseNDJSON: expected a ReadableStream<Uint8Array>');\n  }\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n  const out: any[] = [];\n\n  const drainLines = () => {\n    const parts = buffer.split('\\n');\n    buffer = parts.pop() ?? '';\n    for (let raw of parts) {\n      const line = raw.trim();\n      if (line === '') continue;\n      try { out.push(JSON.parse(line)); }\n      catch (err) { if (onError) onError(line, err); }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, { stream: true });\n    drainLines();\n  }\n\n  buffer += decoder.decode();\n  drainLines();\n  const tail = buffer.trim();\n  if (tail !== '') {\n    try { out.push(JSON.parse(tail)); }\n    catch (err) { if (onError) onError(tail, err); }\n  }\n\n  try { reader.releaseLock(); } catch {}\n  return out;\n}\n\n// CommonJS fallback\n// @ts-ignore\ntry { if (typeof module !== 'undefined') (module as any).exports = parseNDJSON; } catch {}\n"
    },
    "tests": "import parseNDJSON from './ndjson-parser';\n\n// Helper: build a ReadableStream<Uint8Array> that emits given string chunks\nconst te = new TextEncoder();\nfunction streamFromStrings(chunks) {\n  return new ReadableStream({\n    start(controller) {\n      let i = 0;\n      const pump = () => {\n        if (i >= chunks.length) { controller.close(); return; }\n        controller.enqueue(te.encode(chunks[i++]));\n        setTimeout(pump, 0); // async to exercise the reader loop\n      };\n      pump();\n    }\n  });\n}\n\nfunction expectEqual(a, b){ expect(JSON.stringify(a)).toEqual(JSON.stringify(b)); }\n\ndescribe('Streaming NDJSON Parser', () => {\n  test('parses lines across arbitrary chunk boundaries', async () => {\n    const chunks = [\n      '{\"a\":1}\\n{\"b\"',\n      ':2}\\n{\"c\":3}\\n',\n    ];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{a:1},{b:2},{c:3}]);\n  });\n\n  test('handles last line without trailing newline', async () => {\n    const chunks = ['{\"x\":1}\\n{\"y\":2}'];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{x:1},{y:2}]);\n  });\n\n  test('skips blank lines and trims CRLF', async () => {\n    const chunks = ['\\r\\n', '{\"n\":1}\\r\\n', '\\n', '{\"m\":2}\\n'];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{n:1},{m:2}]);\n  });\n\n  test('reports malformed lines via onError and continues', async () => {\n    const bad = []; // collect bad lines\n    const chunks = ['{\"ok\":1}\\n', '{bad json}\\n', '{\"ok\":2}\\n'];\n    const res = await parseNDJSON(streamFromStrings(chunks), (line, err) => { bad.push(line); });\n    expectEqual(res, [{ok:1},{ok:2}]);\n    expectEqual(bad, ['{bad json}']);\n  });\n});\n",
    "testsTs": "import parseNDJSON from './ndjson-parser';\n\nconst te = new TextEncoder();\nfunction streamFromStrings(chunks: string[]): ReadableStream<Uint8Array> {\n  return new ReadableStream<Uint8Array>({\n    start(controller) {\n      let i = 0;\n      const pump = () => {\n        if (i >= chunks.length) { controller.close(); return; }\n        controller.enqueue(te.encode(chunks[i++]));\n        setTimeout(pump, 0);\n      };\n      pump();\n    }\n  });\n}\n\nfunction expectEqual(a: any, b: any){ expect(JSON.stringify(a)).toEqual(JSON.stringify(b)); }\n\ndescribe('Streaming NDJSON Parser (TS)', () => {\n  test('parses across chunk boundaries', async () => {\n    const res = await parseNDJSON(streamFromStrings(['{\"a\":1}\\n{\"b\"', ':2}\\n']));\n    expectEqual(res, [{a:1},{b:2}]);\n  });\n\n  test('no trailing newline', async () => {\n    const res = await parseNDJSON(streamFromStrings(['{\"x\":1}\\n{\"y\":2}']));\n    expectEqual(res, [{x:1},{y:2}]);\n  });\n\n  test('error isolation', async () => {\n    const errors: string[] = [];\n    const res = await parseNDJSON(streamFromStrings(['{\"ok\":1}\\n','{oops}\\n','{\"ok\":2}\\n']), (line) => errors.push(line));\n    expectEqual(res, [{ok:1},{ok:2}]);\n    expectEqual(errors, ['{oops}']);\n  });\n});\n"
  },
  {
    "id": "js-array-prototype-map",
    "title": "Implement Array.prototype.map",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Arrays",
      "Callbacks",
      "Iteration",
      "Polyfills"
    ],
    "importance": 4,
    "teaches": [
      "How built-in array iteration works under the hood",
      "Correct callback invocation and thisArg binding",
      "Handling sparse arrays (holes) correctly",
      "Spec-aware details: boxing, length coercion, property checks"
    ],
    "description": {
      "summary": "Recreate the native `.map()` method **without using it**. Your `myMap` must call the callback for each existing index, pass `(value, index, array)`, respect `thisArg`, and return a new array with the mapped values. It must **skip holes** (no callback for missing indices) and preserve array length.",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "(currentValue: any, index: number, array: any[]) => any",
          "desc": "Function to execute on each existing element."
        },
        {
          "name": "thisArg",
          "type": "any (optional)",
          "desc": "Value to use as `this` when executing callback."
        }
      ],
      "returns": {
        "type": "Array",
        "desc": "A new array with the results of calling `callbackFn` on every existing element."
      },
      "examples": [
        "[1, 2, 3].myMap(x => x * 2) // => [2, 4, 6]",
        "[, 10, , 30].myMap((v,i) => i) // => [ , 1, , 3 ] (holes preserved)",
        "[1].myMap(function(x){ return this.add + x }, { add: 5 }) // => [6]"
      ]
    },
    "starterCode": "/* Boilerplate — replace the throw with a correct implementation */\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};\n",
    "starterCodeTs": "declare global {\n  interface Array<T> {\n    myMap<U>(\n      callbackFn: (value: T, index: number, array: Array<T>) => U,\n      thisArg?: any\n    ): Array<U>;\n  }\n}\n\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};\n",
    "solutionBlock": {
      "explanation": "### Simplified `.map()` behavior\nThis version focuses on practical behavior — iterating over defined indices, skipping holes, and preserving length — without extra spec checks like validating the callback type or boxing `this`. It demonstrates how callbacks and `thisArg` binding work while ignoring sparse indices.",
      "codeJs": "Array.prototype.myMap = function (callbackFn, thisArg) {\n  const len = this.length;\n  const array = new Array(len);\n\n  for (let k = 0; k < len; k++) {\n    // Ignore index if value is not defined for index (e.g. in sparse arrays).\n    if (Object.hasOwn(this, k)) {\n      array[k] = callbackFn.call(thisArg, this[k], k, this);\n    }\n  }\n\n  return array;\n};\n",
      "codeTs": "interface Array<T> {\n  myMap<U>(\n    callbackFn: (value: T, index: number, array: Array<T>) => U,\n    thisArg?: any,\n  ): Array<U>;\n}\n\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  const len = this.length;\n  const array = new Array(len);\n\n  for (let k = 0; k < len; k++) {\n    // Ignore index if value is not defined for index (e.g. in sparse arrays).\n    if (Object.hasOwn(this, k)) {\n      array[k] = callbackFn.call(thisArg, this[k], k, this);\n    }\n  }\n\n  return array;\n};\n"
    },
    "tests": "const identity = (x) => x;\nconst square = (n) => n * n;\n\ndescribe('Array.prototype.myMap', () => {\n  test('identity', () => {\n    expect([10].myMap(identity)).toEqual([10]);\n    expect([10, 20].myMap(identity)).toEqual([10, 20]);\n  });\n\n  test('square', () => {\n    expect([-4].myMap(square)).toEqual([16]);\n    expect([5].myMap(square)).toEqual([25]);\n  });\n\n  test('skips holes and preserves length', () => {\n    const a = [, 10, , 30];\n    const r = a.myMap((v, i) => i);\n    expect(r.length).toBe(4);\n    expect(0 in r).toBe(false);\n    expect(1 in r).toBe(true);\n    expect(2 in r).toBe(false);\n    expect(3 in r).toBe(true);\n  });\n\n  test('binds thisArg', () => {\n    const ctx = { add: 5 };\n    const out = [1].myMap(function (x) { return this.add + x; }, ctx);\n    expect(out).toEqual([6]);\n  });\n});\n",
    "testsTs": "// @ts-nocheck\nconst _shimMap = (arr, cb, thisArg) => {\n  const O = Object(arr);\n  const len = O.length >>> 0;\n  const A = new Array(len);\n  for (let k = 0; k < len; k++) {\n    if (k in O) A[k] = cb.call(thisArg, O[k], k, O);\n  }\n  return A;\n};\n\nconst callMap = (arr, cb, thisArg) =>\n  typeof arr.myMap === 'function' ? arr.myMap(cb, thisArg) : _shimMap(arr, cb, thisArg);\n\nconst identity = (element) => element;\nconst square = (element) => element * element;\n\ndescribe('Array.prototype.myMap', () => {\n  test('identity', () => {\n    expect(callMap([10], identity)).toEqual([10]);\n    expect(callMap([10, 20], identity)).toEqual([10, 20]);\n  });\n\n  test('square', () => {\n    expect(callMap([-4], square)).toEqual([16]);\n    expect(callMap([5], square)).toEqual([25]);\n  });\n});\n"
  }
]