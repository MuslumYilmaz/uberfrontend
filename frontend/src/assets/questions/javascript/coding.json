[
  {
    "id": "js-number-clamp",
    "title": "Clamp",
    "type": "coding",
    "technology": "javascript",
    "importance": 1,
    "difficulty": "easy",
    "tags": [
      "numbers",
      "math",
      "boundaries"
    ],
    "description": {
      "summary": "Implement a function `clamp(value, lower, upper)` that restricts `value` within inclusive `lower` and `upper` bounds.",
      "arguments": [
        {
          "name": "value",
          "type": "number",
          "desc": "The number to clamp."
        },
        {
          "name": "lower",
          "type": "number",
          "desc": "The lower bound."
        },
        {
          "name": "upper",
          "type": "number",
          "desc": "The upper bound."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The clamped number."
      },
      "examples": [
        "// Basic examples\nclamp(3, 0, 5) // => 3",
        "clamp(-10, -3, 5) // => -3",
        "clamp(10, -5, 5) // => 5"
      ]
    },
    "starterCode": "export default function clamp(value, lower, upper) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure a number stays within an inclusive range. If `value < lower`, return `lower`; if `value > upper`, return `upper`; otherwise return `value`. Common in sliders, percentages, animations, and input sanitization.",
      "approaches": [
        {
          "title": "Approach 1: Branching (readable baseline)",
          "prose": "Idea: check the value against each bound and return the first applicable result.\n\nHow it works\n1. If value < lower, return lower (lift it up).\n2. Else if value > upper, return upper (cap it).\n3. Otherwise return value unchanged.\n\nWhy use it: very explicit and easy to debug or extend (e.g., add logs/metrics around each branch). Caller should still ensure lower \u2264 upper.",
          "codeJs": "export default function clamp(value, lower, upper) {\n  if (value < lower) return lower;\n  if (value > upper) return upper;\n  return value;\n}\n",
          "codeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  if (value < lower) return lower;\n  if (value > upper) return upper;\n  return value;\n}\n"
        },
        {
          "title": "Approach 2: Math chaining (compact)",
          "prose": "Idea: clamp in one expression â€” first lift to the lower bound, then cap to the upper bound.\n\nUse `Math.min(Math.max(value, lower), upper)` to ensure the value stays between both bounds.\n\nRead it as: *at least lower, at most upper.*\n\nWhy use it: terse, branch-free, and fast to read once familiar. Ensure `lower â‰¤ upper`; if not, the result may be surprising.",
          "codeJs": "export default function clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\n",
          "codeTs": "export default function clamp(value: number, lower: number, upper: number): number {\n  return Math.min(Math.max(value, lower), upper);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "`lower` should be `<= upper`. If not guaranteed by caller, normalize or assert.",
          "`NaN` inputs propagate through `Math.min/max` â†’ result becomes `NaN`. Decide whether to coerce or throw.",
          "Non-number inputs (strings, null) will be coerced if you use Math.*; prefer validating types for clarity."
        ],
        "edgeCases": [
          "value exactly equals `lower` or `upper` â†’ return that bound.",
          "Very large magnitudes: works, but be mindful of Â±Infinity if it can appear.",
          "Swapped bounds: if it can happen, you can fix with `[lower, upper] = lower <= upper ? [lower, upper] : [upper, lower]`."
        ],
        "techniques": [
          "Guard + early return for clarity (Approach 1).",
          "Functional composition feel with `Math.min(Math.max(...))` (Approach 2)."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels",
        "js-arrays-equal"
      ],
      "resources": [
        {
          "title": "MDN â€“ Math.max()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max"
        },
        {
          "title": "MDN â€“ Math.min()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min"
        }
      ]
    },
    "tests": "import clamp from './clamp';\n\ndescribe('clamp', () => {\n  test('within range', () => expect(clamp(3, 0, 5)).toBe(3));\n  test('below lower', () => expect(clamp(-10, -3, 5)).toBe(-3));\n  test('above upper', () => expect(clamp(10, -5, 5)).toBe(5));\n});\n",
    "testsTs": "import clamp from './clamp';\n\ndescribe('clamp (TypeScript)', () => {\n  it('returns the same value when within range', () => {\n    expect(clamp(3, 0, 5)).toBe(3);\n  });\n  it('clamps to lower bound when below range', () => {\n    expect(clamp(-10, -3, 5)).toBe(-3);\n  });\n  it('clamps to upper bound when above range', () => {\n    expect(clamp(10, -5, 5)).toBe(5);\n  });\n});\n"
  },
  {
    "id": "js-reverse-string",
    "title": "Reverse a String",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `reverseString(str)` that returns the reversed version of the input string without using built-in methods like `.reverse()`.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to be reversed."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "The reversed string."
      },
      "examples": [
        "// Basic example\nreverseString('abc') // => 'cba'",
        "// Palindrome\nreverseString('racecar') // => 'racecar'",
        "// With spaces and punctuation\nreverseString('A man, a plan') // => 'nalp a ,nam A'"
      ]
    },
    "starterCode": "export default function reverseString(str) {\n  // TODO: Implement without using Array.prototype.reverse()\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function reverseString(str: string): string {\n  // TODO: Implement without using Array.prototype.reverse()\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: reverse the characters of a string from end to start without using built-ins like `.reverse()`. This tests understanding of string traversal and immutability.",
      "approaches": [
        {
          "title": "Approach 1: Manual loop (explicit and clear)",
          "prose": "Idea: traverse the string backwards, appending each character to a new string.\n\nHow it works\n1. Initialize an empty result variable `out = ''`.\n2. Loop from the **last index (`str.length - 1`) down to 0**.\n3. On each iteration, append `str[i]` to `out`.\n4. Return `out` when done.\n\nWhy use it: very clear and easy to understand for beginners. Demonstrates string immutability â€” concatenation forms a new string each time.",
          "codeJs": "export default function reverseString(str) {\n  let out = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    out += str[i];\n  }\n  return out;\n}\n",
          "codeTs": "export default function reverseString(str: string): string {\n  let out = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    out += str[i];\n  }\n  return out;\n}\n"
        },
        {
          "title": "Approach 2: Using array methods (compact, modern)",
          "prose": "Idea: convert the string into an array, reverse it, and join back to string.\n\nUse `str.split('').reverse().join('')` to reverse efficiently.\n\nRead it as: *split â†’ reverse â†’ join*.\n\nWhy use it: concise and elegant, leveraging built-ins. However, it's disallowed here per problem statement â€” shown only for completeness.",
          "codeJs": "export default function reverseString(str) {\n  return str.split('').reverse().join('');\n}\n",
          "codeTs": "export default function reverseString(str: string): string {\n  return str.split('').reverse().join('');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Strings are immutable â€” direct character reassignment wonâ€™t work.",
          "Avoid `.reverse()` if not allowed; use manual iteration instead.",
          "For Unicode characters like emoji, this naive approach may split surrogate pairs incorrectly."
        ],
        "edgeCases": [
          "Empty string â†’ returns `''`.",
          "Single character â†’ unchanged.",
          "Palindrome â†’ returns itself."
        ],
        "techniques": [
          "Iterating in reverse order.",
          "Using concatenation or array methods to reconstruct a string."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels",
        "js-capitalize-words"
      ],
      "resources": [
        {
          "title": "MDN â€“ String.prototype.split()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split"
        },
        {
          "title": "MDN â€“ String.prototype.concat()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat"
        }
      ]
    },
    "tests": "import reverseString from './reverseString';\n\ndescribe('reverseString', () => {\n  test('reverses simple strings', () => {\n    expect(reverseString('abc')).toBe('cba');\n    expect(reverseString('hello')).toBe('olleh');\n  });\n\n  test('handles palindromes', () => {\n    expect(reverseString('racecar')).toBe('racecar');\n  });\n\n  test('reverses with spaces and punctuation', () => {\n    expect(reverseString('A man, a plan')).toBe('nalp a ,nam A');\n  });\n\n  test('handles empty and single character', () => {\n    expect(reverseString('')).toBe('');\n    expect(reverseString('x')).toBe('x');\n  });\n});\n",
    "testsTs": "import reverseString from './reverseString';\n\ndescribe('reverseString (TypeScript)', () => {\n  it('reverses simple strings', () => {\n    expect(reverseString('abc')).toBe('cba');\n    expect(reverseString('hello')).toBe('olleh');\n  });\n\n  it('handles palindromes', () => {\n    expect(reverseString('racecar')).toBe('racecar');\n  });\n\n  it('reverses with spaces and punctuation', () => {\n    expect(reverseString('A man, a plan')).toBe('nalp a ,nam A');\n  });\n\n  it('handles empty and single character', () => {\n    expect(reverseString('')).toBe('');\n    expect(reverseString('x')).toBe('x');\n  });\n});\n"
  },
  {
    "id": "js-count-vowels",
    "title": "Count Vowels",
    "type": "coding",
    "importance": 2,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `countVowels(str)` that returns how many vowels (`a, e, i, o, u`) exist in a given string, regardless of case.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to analyze."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The number of vowels found in the string."
      },
      "examples": [
        "// Basic examples\ncountVowels('hello') // => 2",
        "countVowels('rhythm') // => 0",
        "countVowels('AEIOU') // => 5",
        "// Mixed case and spaces\ncountVowels('A quick brown fox') // => 5"
      ]
    },
    "starterCode": "export default function countVowels(str) {\n  // TODO: Return how many vowels (a, e, i, o, u) are in the string\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function countVowels(str: string): number {\n  // TODO: Return how many vowels (a, e, i, o, u) are in the string\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: count how many vowels (`a, e, i, o, u`) appear in a given string, ignoring case. This tests string traversal, character comparison, and basic logic building.",
      "approaches": [
        {
          "title": "Approach 1: Iterative counting (explicit and clear)",
          "prose": "Idea: iterate through each character, normalize to lowercase, and count if itâ€™s one of `aeiou`.\n\nHow it works\n1. Define a string of vowels: `const vowels = 'aeiou'`.\n2. Initialize `count = 0`.\n3. Loop through each character `ch` in `str.toLowerCase()`.\n4. If `vowels.includes(ch)`, increment `count`.\n5. Return the total count.\n\nWhy use it: clear, efficient (O(n)), and works for any casing. Great for learning iteration and conditionals.",
          "codeJs": "export default function countVowels(str) {\n  const vowels = 'aeiou';\n  let count = 0;\n  for (const ch of str.toLowerCase()) {\n    if (vowels.includes(ch)) count++;\n  }\n  return count;\n}\n",
          "codeTs": "export default function countVowels(str: string): number {\n  const vowels = 'aeiou';\n  let count = 0;\n  for (const ch of str.toLowerCase()) {\n    if (vowels.includes(ch)) count++;\n  }\n  return count;\n}\n"
        },
        {
          "title": "Approach 2: Regular expression (concise alternative)",
          "prose": "Idea: use a regular expression to directly match all vowels.\n\nUse `(str.match(/[aeiou]/gi) || []).length` to count matches.\n\nRead it as: *find all vowels (case-insensitive) and count them*.\n\nWhy use it: shorter and declarative, though less explicit than manual iteration. Good when youâ€™re comfortable with regex.",
          "codeJs": "export default function countVowels(str) {\n  return (str.match(/[aeiou]/gi) || []).length;\n}\n",
          "codeTs": "export default function countVowels(str: string): number {\n  return (str.match(/[aeiou]/gi) || []).length;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Empty strings should return `0`.",
          "Regex approach may be less intuitive for beginners.",
          "Non-letter characters are simply skipped, no need for extra checks."
        ],
        "edgeCases": [
          "No vowels â†’ returns `0`.",
          "Mixed case â†’ handled by `toLowerCase()` or `/i` flag.",
          "Accented vowels (Ã©, Ã¼) â†’ not counted unless explicitly included."
        ],
        "techniques": [
          "String traversal and membership checking.",
          "Regex matching and array length extraction."
        ]
      },
      "followUpQuestions": [
        "js-reverse-string",
        "js-capitalize-words"
      ],
      "resources": [
        {
          "title": "MDN â€“ String.prototype.includes()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes"
        },
        {
          "title": "MDN â€“ RegExp.prototype.match()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match"
        }
      ]
    },
    "tests": "import countVowels from './countVowels';\n\ndescribe('countVowels', () => {\n  test('counts lowercase vowels', () => {\n    expect(countVowels('hello')).toBe(2);\n    expect(countVowels('rhythm')).toBe(0);\n  });\n\n  test('counts uppercase vowels', () => {\n    expect(countVowels('AEIOU')).toBe(5);\n  });\n\n  test('counts vowels in mixed case and spaces', () => {\n    expect(countVowels('A quick brown fox')).toBe(5);\n  });\n\n  test('handles empty string', () => {\n    expect(countVowels('')).toBe(0);\n  });\n});\n",
    "testsTs": "import countVowels from './countVowels';\n\ndescribe('countVowels (TypeScript)', () => {\n  it('counts lowercase vowels', () => {\n    expect(countVowels('hello')).toBe(2);\n    expect(countVowels('rhythm')).toBe(0);\n  });\n\n  it('counts uppercase vowels', () => {\n    expect(countVowels('AEIOU')).toBe(5);\n  });\n\n  it('counts vowels in mixed case and spaces', () => {\n    expect(countVowels('A quick brown fox')).toBe(5);\n  });\n\n  it('handles empty string', () => {\n    expect(countVowels('')).toBe(0);\n  });\n});\n"
  },
  {
    "id": "js-flatten-once",
    "title": "Flatten One Level",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `flattenOnce(arr)` that flattens a nested array by **one level only**. Elements that are not arrays should remain unchanged.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "The input array which may contain nested arrays."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array flattened by one level."
      },
      "examples": [
        "// Basic example\nflattenOnce([1, [2, 3], [4, [5]]]) // => [1, 2, 3, 4, [5]]",
        "// Already flat\nflattenOnce([1, 2, 3]) // => [1, 2, 3]",
        "// Mixed values\nflattenOnce([[1], 2, [3, [4]], 5]) // => [1, 2, 3, [4], 5]"
      ]
    },
    "starterCode": "export default function flattenOnce(arr) {\n  // TODO: Flatten one level deep\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function flattenOnce(arr: any[]): any[] {\n  // TODO: Flatten one level deep\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: unpack only the **first layer** of nested arrays (shallow flatten). Deeper arrays remain nested. This tests understanding of array iteration and type checking.",
      "approaches": [
        {
          "title": "Approach 1: Iterative spread (explicit and clear)",
          "prose": "Idea: build a new array and check each element. If it's an array, spread its contents into the result; otherwise, add it directly.\n\nHow it works\n1. Initialize `const result = []`.\n2. Loop through every element in `arr`.\n3. If `Array.isArray(el)`, push `...el` into `result`.\n4. Else push `el` directly.\n5. Return `result`.\n\nWhy use it: straightforward, readable, and O(n). Perfect for learning how shallow flattening works without recursion.",
          "codeJs": "export default function flattenOnce(arr) {\n  const result = [];\n  for (const el of arr) {\n    if (Array.isArray(el)) {\n      result.push(...el);\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flattenOnce(arr: any[]): any[] {\n  const result: any[] = [];\n  for (const el of arr) {\n    if (Array.isArray(el)) {\n      result.push(...el);\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using built-in `.flat(1)` (compact modern syntax)",
          "prose": "Idea: use the modern `Array.prototype.flat()` method with depth `1`.\n\nUse `arr.flat(1)` to flatten a single level automatically.\n\nRead it as: *flatten one layer deep and leave inner arrays untouched*.\n\nWhy use it: concise, modern, and optimized. However, itâ€™s useful to understand the manual approach first to grasp how flattening works internally.",
          "codeJs": "export default function flattenOnce(arr) {\n  return arr.flat(1);\n}\n",
          "codeTs": "export default function flattenOnce(arr: any[]): any[] {\n  return arr.flat(1);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Flattening too deeply defeats the 'one-level' requirement â€” avoid recursion or `.flat(Infinity)`.",
          "Mutating the original array is not allowed â€” always return a new one.",
          "Non-array values should remain untouched."
        ],
        "edgeCases": [
          "Empty array â†’ returns `[]`.",
          "Already flat array â†’ identical output.",
          "Mixed values like `[1, [2], 3]` â†’ flattens only first-level arrays."
        ],
        "techniques": [
          "Using `Array.isArray()` for type checking.",
          "Using spread syntax (`...`) for shallow unpacking.",
          "Understanding `.flat(depth)` for modern concise implementations."
        ]
      },
      "followUpQuestions": [
        "js-flatten-depth"
      ],
      "resources": [
        {
          "title": "MDN â€“ Array.prototype.flat()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat"
        },
        {
          "title": "MDN â€“ Array.isArray()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
        }
      ]
    },
    "tests": "import flattenOnce from './flattenOnce';\n\ndescribe('flattenOnce', () => {\n  test('flattens a simple nested array', () => {\n    expect(flattenOnce([1, [2, 3], [4, [5]]])).toEqual([1, 2, 3, 4, [5]]);\n  });\n\n  test('returns same array when already flat', () => {\n    expect(flattenOnce([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n\n  test('handles mixed array contents', () => {\n    expect(flattenOnce([[1], 2, [3, [4]], 5])).toEqual([1, 2, 3, [4], 5]);\n  });\n\n  test('returns empty array for empty input', () => {\n    expect(flattenOnce([])).toEqual([]);\n  });\n});\n",
    "testsTs": "import flattenOnce from './flattenOnce';\n\ndescribe('flattenOnce (TypeScript)', () => {\n  it('flattens a simple nested array', () => {\n    expect(flattenOnce([1, [2, 3], [4, [5]]])).toEqual([1, 2, 3, 4, [5]]);\n  });\n\n  it('returns same array when already flat', () => {\n    expect(flattenOnce([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n\n  it('handles mixed array contents', () => {\n    expect(flattenOnce([[1], 2, [3, [4]], 5])).toEqual([1, 2, 3, [4], 5]);\n  });\n\n  it('returns empty array for empty input', () => {\n    expect(flattenOnce([])).toEqual([]);\n  });\n});\n"
  },
  {
    "id": "js-unique-array",
    "title": "Remove Duplicates",
    "type": "coding",
    "importance": 4,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `unique(arr)` that returns a new array with duplicate values removed. The **original order** of elements must be preserved.",
      "arguments": [
        {
          "name": "arr",
          "type": "T[]",
          "desc": "An array of items that may contain duplicates."
        }
      ],
      "returns": {
        "type": "T[]",
        "desc": "A new array with only unique elements, preserving their first occurrence order."
      },
      "examples": [
        "// Basic example\nunique([1, 2, 2, 3, 1]) // => [1, 2, 3]",
        "// Works with strings\nunique(['a', 'b', 'a', 'c', 'b']) // => ['a', 'b', 'c']",
        "// Mixed types\nunique([1, '1', 1]) // => [1, '1']"
      ]
    },
    "starterCode": "export default function unique(arr) {\n  // TODO: Return new array with duplicates removed\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function unique<T>(arr: T[]): T[] {\n  // TODO: Return new array with duplicates removed\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: return a new array that contains each value only once â€” keeping the first occurrence and preserving order. This teaches efficient use of data structures like `Set`.",
      "approaches": [
        {
          "title": "Approach 1: Using a Set to track seen values (explicit control)",
          "prose": "Idea: use a `Set` to record which elements have been encountered. Iterate through `arr` and only push values you havenâ€™t seen yet.\n\n### ðŸ§  Step-by-step reasoning\n1. Initialize an empty `Set` â†’ `const seen = new Set()`.\n2. Initialize `const result = []`.\n3. Loop through every element `item` in `arr`.\n4. If `!seen.has(item)` â†’ add to both `seen` and `result`.\n5. Return `result`.\n\nWhy use it: this method is efficient (O(n)) and preserves original order, since elements are added in the order they first appear.",
          "codeJs": "export default function unique(arr) {\n  const seen = new Set();\n  const result = [];\n  for (const item of arr) {\n    if (!seen.has(item)) {\n      seen.add(item);\n      result.push(item);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  const seen = new Set<T>();\n  const result: T[] = [];\n  for (const item of arr) {\n    if (!seen.has(item)) {\n      seen.add(item);\n      result.push(item);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using `new Set()` directly (compact form)",
          "prose": "Idea: leverage the fact that a `Set` automatically removes duplicates.\n\nUse `[...new Set(arr)]` to instantly produce a deduplicated array.\n\nWhy use it: clean and elegant one-liner, ideal when order preservation and value equality semantics are fine as-is (strict equality).",
          "codeJs": "export default function unique(arr) {\n  return [...new Set(arr)];\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  return [...new Set(arr)];\n}\n"
        },
        {
          "title": "Approach 3: Using `filter()` and `indexOf()` (less efficient)",
          "prose": "Idea: only keep items where their first occurrence index matches the current index.\n\nUse `arr.filter((item, idx) => arr.indexOf(item) === idx)`.\n\nWhy use it: clear for learning, but slower (O(nÂ²)) since each `indexOf` scan starts from the beginning.",
          "codeJs": "export default function unique(arr) {\n  return arr.filter((item, idx) => arr.indexOf(item) === idx);\n}\n",
          "codeTs": "export default function unique<T>(arr: T[]): T[] {\n  return arr.filter((item, idx) => arr.indexOf(item) === idx);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Comparisons are done using strict equality (`===`), so `1` and `'1'` are treated differently.",
          "Objects and arrays are compared by reference, not structure.",
          "Avoid using `filter + indexOf` for very large arrays due to quadratic performance."
        ],
        "edgeCases": [
          "Empty array â†’ returns `[]`.",
          "Already unique array â†’ unchanged.",
          "All duplicates â†’ only first kept."
        ],
        "techniques": [
          "Using `Set` for uniqueness tracking.",
          "Maintaining insertion order manually.",
          "Using spread syntax (`...`) for conversion."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN â€“ Set",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"
        },
        {
          "title": "MDN â€“ Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        }
      ]
    },
    "tests": "import unique from './unique';\n\ndescribe('unique', () => {\n  test('removes duplicates from numbers', () => {\n    expect(unique([1, 2, 2, 3, 1])).toEqual([1, 2, 3]);\n  });\n\n  test('works with strings', () => {\n    expect(unique(['a', 'b', 'a', 'c', 'b'])).toEqual(['a', 'b', 'c']);\n  });\n\n  test('handles mixed types', () => {\n    expect(unique([1, '1', 1])).toEqual([1, '1']);\n  });\n\n  test('returns empty array when input is empty', () => {\n    expect(unique([])).toEqual([]);\n  });\n\n  test('returns identical array when all unique', () => {\n    expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "import unique from './unique';\n\ndescribe('unique (TypeScript)', () => {\n  it('removes duplicates from numbers', () => {\n    expect(unique([1, 2, 2, 3, 1])).toEqual([1, 2, 3]);\n  });\n\n  it('works with strings', () => {\n    expect(unique(['a', 'b', 'a', 'c', 'b'])).toEqual(['a', 'b', 'c']);\n  });\n\n  it('handles mixed types', () => {\n    expect(unique([1, '1', 1])).toEqual([1, '1']);\n  });\n\n  it('returns empty array when input is empty', () => {\n    expect(unique([])).toEqual([]);\n  });\n\n  it('returns identical array when all unique', () => {\n    expect(unique([1, 2, 3])).toEqual([1, 2, 3]);\n  });\n});\n"
  },
  {
    "id": "js-max-char",
    "title": "Find Maximum Occurring Character",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `maxChar(str)` that returns the character that appears most frequently in a string.",
      "arguments": [
        {
          "name": "str",
          "type": "string",
          "desc": "The input string to analyze."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "The single character with the highest frequency of occurrence."
      },
      "examples": [
        "// Basic examples\nmaxChar('hello') // => 'l'\nmaxChar('aabbbcc') // => 'b'\nmaxChar('abcccccccd') // => 'c'\n// When multiple characters tie, return the first one found\nmaxChar('aabb') // => 'a'"
      ]
    },
    "starterCode": "export default function maxChar(str) {\n  // TODO: Return the most frequent character in the string\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function maxChar(str: string): string {\n  // TODO: Return the most frequent character in the string\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: identify the most frequently occurring character in a string using character frequency analysis. This problem introduces you to **hash map counting** â€” a powerful technique for many algorithmic challenges.",
      "approaches": [
        {
          "title": "Approach 1: Frequency map with a loop (efficient and clear)",
          "prose": "Idea: use an object as a frequency counter. Traverse the string once, count occurrences, and track the character with the highest frequency.\n\n### ðŸ§  Step-by-step reasoning\n1. Initialize an empty object `charCount = {}`.\n2. Initialize `max = 0` and `maxChar = ''`.\n3. Loop through each character `ch` in the string.\n4. For each one:\n   - Increment `charCount[ch] = (charCount[ch] || 0) + 1`.\n   - If `charCount[ch] > max`, update `max` and `maxChar`.\n5. Return `maxChar`.\n\nWhy use it: runs in **O(n)** time, uses **O(k)** space (unique chars), and gives clear control over tie-breaking order.",
          "codeJs": "export default function maxChar(str) {\n  if (!str) return '';\n  const charCount = {};\n  let max = 0;\n  let maxChar = '';\n\n  for (const ch of str) {\n    charCount[ch] = (charCount[ch] || 0) + 1;\n    if (charCount[ch] > max) {\n      max = charCount[ch];\n      maxChar = ch;\n    }\n  }\n\n  return maxChar;\n}\n",
          "codeTs": "export default function maxChar(str: string): string {\n  if (!str) return '';\n  const charCount: Record<string, number> = {};\n  let max = 0;\n  let maxChar = '';\n\n  for (const ch of str) {\n    charCount[ch] = (charCount[ch] || 0) + 1;\n    if (charCount[ch] > max) {\n      max = charCount[ch];\n      maxChar = ch;\n    }\n  }\n\n  return maxChar;\n}\n"
        },
        {
          "title": "Approach 2: Using `reduce()` for a functional style",
          "prose": "Idea: build the frequency map using `Array.prototype.reduce()` and then find the max key.\n\nWhy use it: more functional and concise but slightly less intuitive for beginners.",
          "codeJs": "export default function maxChar(str) {\n  if (!str) return '';\n  const freq = [...str].reduce((acc, ch) => {\n    acc[ch] = (acc[ch] || 0) + 1;\n    return acc;\n  }, {});\n\n  let maxChar = '';\n  let max = 0;\n  for (const [ch, count] of Object.entries(freq)) {\n    if (count > max) {\n      max = count;\n      maxChar = ch;\n    }\n  }\n  return maxChar;\n}\n",
          "codeTs": "export default function maxChar(str: string): string {\n  if (!str) return '';\n  const freq = Array.from(str).reduce<Record<string, number>>((acc, ch) => {\n    acc[ch] = (acc[ch] || 0) + 1;\n    return acc;\n  }, {});\n\n  let maxChar = '';\n  let max = 0;\n  for (const [ch, count] of Object.entries(freq)) {\n    if (count > max) {\n      max = count;\n      maxChar = ch;\n    }\n  }\n  return maxChar;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Do not forget to handle the empty string case â€” should return `''`.",
          "Comparisons are case-sensitive (`'A'` and `'a'` are different).",
          "Ties should return the first character that reaches the max count."
        ],
        "edgeCases": [
          "Empty string â†’ `''`.",
          "All unique â†’ returns the first character.",
          "Multiple max chars â†’ returns the earliest one."
        ],
        "techniques": [
          "Using frequency maps (hash tables) for counting occurrences.",
          "Tracking max value during iteration for efficiency.",
          "Understanding O(n) iteration patterns."
        ]
      },
      "followUpQuestions": [
        "js-count-vowels"
      ],
      "resources": [
        {
          "title": "MDN â€“ Object.entries()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"
        },
        {
          "title": "MDN â€“ for...of statement",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"
        }
      ]
    },
    "tests": "import maxChar from './maxChar';\n\ndescribe('maxChar', () => {\n  test('finds the most common letter', () => {\n    expect(maxChar('hello')).toBe('l');\n  });\n\n  test('works with multiple repetitions', () => {\n    expect(maxChar('aabbbcc')).toBe('b');\n    expect(maxChar('abcccccccd')).toBe('c');\n  });\n\n  test('returns first character when tie', () => {\n    expect(maxChar('aabb')).toBe('a');\n  });\n\n  test('returns empty string when input is empty', () => {\n    expect(maxChar('')).toBe('');\n  });\n});\n",
    "testsTs": "import maxChar from './maxChar';\n\ndescribe('maxChar (TypeScript)', () => {\n  it('finds the most common letter', () => {\n    expect(maxChar('hello')).toBe('l');\n  });\n\n  it('works with multiple repetitions', () => {\n    expect(maxChar('aabbbcc')).toBe('b');\n    expect(maxChar('abcccccccd')).toBe('c');\n  });\n\n  it('returns first character when tie', () => {\n    expect(maxChar('aabb')).toBe('a');\n  });\n\n  it('returns empty string when input is empty', () => {\n    expect(maxChar('')).toBe('');\n  });\n});\n"
  },
  {
    "id": "js-capitalize-words",
    "title": "Capitalize Words",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "String"
    ],
    "description": {
      "summary": "Implement a function `capitalizeWords(sentence)` that returns the same string but with the first letter of each word capitalized.",
      "arguments": [
        {
          "name": "sentence",
          "type": "string",
          "desc": "A sentence consisting of one or more words separated by spaces."
        }
      ],
      "returns": {
        "type": "string",
        "desc": "A new string where each word starts with an uppercase letter, and the rest of the word remains in lowercase."
      },
      "examples": [
        "// Basic examples",
        "capitalizeWords('hello world') // => 'Hello World'",
        "capitalizeWords('javascript is fun') // => 'Javascript Is Fun'",
        "// Handles extra spaces",
        "capitalizeWords('  welcome   to  earth  ') // => '  Welcome   To  Earth  '"
      ]
    },
    "starterCode": "export default function capitalizeWords(sentence) {\n  // TODO: Capitalize first letter of each word\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function capitalizeWords(sentence: string): string {\n  // TODO: Capitalize first letter of each word\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure each word in a sentence starts with an uppercase letter while preserving spacing and keeping the rest of the letters lowercase. This builds practical mastery over **string splitting, mapping, and joining**.",
      "approaches": [
        {
          "title": "Approach 1: Splitâ€“Mapâ€“Join (clean and readable)",
          "prose": "Idea: split the sentence into words, capitalize the first letter of each non-empty word, and then join them back together.\n\n### ðŸ§  Step-by-step reasoning\n1. Handle edge case: if input is empty, return `''`.\n2. Use `.split(' ')` to break the sentence by spaces.\n3. For each element in the array:\n   - If itâ€™s an empty string (extra space), return it unchanged.\n   - Otherwise, capitalize with `word[0].toUpperCase() + word.slice(1).toLowerCase()`.\n4. Join the array back with `' '`.\n5. Return the result.\n\n**Why use it:** clear logic, preserves multiple spaces, and doesnâ€™t require regex â€” a great approach for clarity and maintainability.",
          "codeJs": "export default function capitalizeWords(sentence) {\n  if (!sentence) return '';\n  return sentence\n    .split(' ')\n    .map(word => {\n      if (!word) return word;\n      return word[0].toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ');\n}\n",
          "codeTs": "export default function capitalizeWords(sentence: string): string {\n  if (!sentence) return '';\n  return sentence\n    .split(' ')\n    .map(word => {\n      if (!word) return word;\n      return word[0].toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ');\n}\n"
        },
        {
          "title": "Approach 2: Character iteration (manual traversal)",
          "prose": "Idea: iterate through each character and capitalize when the previous character is a space.\n\n### Steps\n1. Track a flag `capitalizeNext = true`.\n2. For each character `ch` in the string:\n   - If `capitalizeNext` is true and `ch` is a letter â†’ convert to uppercase.\n   - Else â†’ convert to lowercase.\n   - If `ch` is a space, set `capitalizeNext = true`; otherwise set it to false.\n3. Append each character to the result string.\n\n**Why use it:** avoids splitting/joining and works efficiently for very long strings or character-by-character logic.",
          "codeJs": "export default function capitalizeWords(sentence) {\n  if (!sentence) return '';\n  let result = '';\n  let capitalizeNext = true;\n\n  for (const ch of sentence) {\n    if (ch === ' ') {\n      result += ch;\n      capitalizeNext = true;\n    } else if (capitalizeNext) {\n      result += ch.toUpperCase();\n      capitalizeNext = false;\n    } else {\n      result += ch.toLowerCase();\n    }\n  }\n\n  return result;\n}\n",
          "codeTs": "export default function capitalizeWords(sentence: string): string {\n  if (!sentence) return '';\n  let result = '';\n  let capitalizeNext = true;\n\n  for (const ch of sentence) {\n    if (ch === ' ') {\n      result += ch;\n      capitalizeNext = true;\n    } else if (capitalizeNext) {\n      result += ch.toUpperCase();\n      capitalizeNext = false;\n    } else {\n      result += ch.toLowerCase();\n    }\n  }\n\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid trimming spaces â€” they must be preserved.",
          "Watch out for non-letter characters like punctuation; they should not affect capitalization rules.",
          "Always lowercase the rest of each word to ensure consistent formatting."
        ],
        "edgeCases": [
          "Empty string â†’ `''`.",
          "Extra spaces between words â†’ preserved.",
          "Already capitalized input â†’ unchanged.",
          "Mixed casing â†’ normalized to Title Case."
        ],
        "techniques": [
          "Using `.split()`, `.map()`, and `.join()` for immutable transformations.",
          "String iteration and character-based logic.",
          "Applying capitalization rules conditionally based on word boundaries."
        ]
      },
      "followUpQuestions": [
        "js-reverse-string"
      ],
      "resources": [
        {
          "title": "MDN â€“ String.prototype.split()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split"
        },
        {
          "title": "MDN â€“ String.prototype.toUpperCase()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase"
        }
      ]
    },
    "tests": "import capitalizeWords from './capitalizeWords';\n\ndescribe('capitalizeWords', () => {\n  test('capitalizes each word in a simple sentence', () => {\n    expect(capitalizeWords('hello world')).toBe('Hello World');\n  });\n\n  test('handles mixed casing', () => {\n    expect(capitalizeWords('jaVaScript IS fUn')).toBe('Javascript Is Fun');\n  });\n\n  test('preserves multiple spaces', () => {\n    expect(capitalizeWords('  welcome   to  earth  ')).toBe('  Welcome   To  Earth  ');\n  });\n\n  test('returns empty string for empty input', () => {\n    expect(capitalizeWords('')).toBe('');\n  });\n});\n",
    "testsTs": "import capitalizeWords from './capitalizeWords';\n\ndescribe('capitalizeWords (TypeScript)', () => {\n  it('capitalizes each word in a simple sentence', () => {\n    expect(capitalizeWords('hello world')).toBe('Hello World');\n  });\n\n  it('handles mixed casing', () => {\n    expect(capitalizeWords('jaVaScript IS fUn')).toBe('Javascript Is Fun');\n  });\n\n  it('preserves multiple spaces', () => {\n    expect(capitalizeWords('  welcome   to  earth  ')).toBe('  Welcome   To  Earth  ');\n  });\n\n  it('returns empty string for empty input', () => {\n    expect(capitalizeWords('')).toBe('');\n  });\n});\n"
  },
  {
    "id": "js-sum-numbers",
    "title": "Sum of Numbers in an Array",
    "type": "coding",
    "importance": 2,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `sum(arr)` that returns the total of all numeric elements in the array, ignoring non-numeric values.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array containing numbers and possibly other types (e.g., strings, booleans, nulls)."
        }
      ],
      "returns": {
        "type": "number",
        "desc": "The sum of all numeric elements in the array."
      },
      "examples": [
        "// Basic examples\nsum([1, 2, 3]) // => 6",
        "sum([10, '20', 30]) // => 40",
        "// Ignores non-numbers\nsum(['a', 5, true, 7]) // => 12",
        "// Handles empty array\nsum([]) // => 0"
      ]
    },
    "starterCode": "export default function sum(arr) {\n  // TODO: Return the sum of all numeric elements, ignoring non-numbers\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function sum(arr: any[]): number {\n  // TODO: Return the sum of all numeric elements, ignoring non-numbers\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: calculate the total sum of numeric values in an array, safely ignoring any non-numeric entries. This reinforces **type checking, iteration, and accumulator patterns** â€” fundamental for array manipulation tasks.",
      "approaches": [
        {
          "title": "Approach 1: Imperative loop (explicit and safe)",
          "prose": "Idea: iterate through each element and only add valid numbers to a running total.\n\n### ðŸ§  Step-by-step reasoning\n1. Initialize `let total = 0`.\n2. For each `el` in `arr`: If `typeof el === 'number' && !isNaN(el)`, add it to `total`.\n3. Return `total`.\n\n**Why use it:** simple, readable, and avoids hidden coercions. Runs in **O(n)** time with **O(1)** space.",
          "codeJs": "export default function sum(arr) {\n  let total = 0;\n  for (const el of arr) {\n    if (typeof el === 'number' && !isNaN(el)) {\n      total += el;\n    }\n  }\n  return total;\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  let total = 0;\n  for (const el of arr) {\n    if (typeof el === 'number' && !isNaN(el)) {\n      total += el;\n    }\n  }\n  return total;\n}\n"
        },
        {
          "title": "Approach 2: Filter + Reduce (functional style)",
          "prose": "Idea: first filter the array to only include numbers, then sum them using `reduce()`.\n\n### Steps\n1. Filter numeric values using `filter()`.\n2. Reduce them with an accumulator starting from 0.\n\n**Why use it:** concise and expressive, though slightly less explicit about validation.",
          "codeJs": "export default function sum(arr) {\n  return arr\n    .filter(el => typeof el === 'number' && !isNaN(el))\n    .reduce((total, el) => total + el, 0);\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  return arr\n    .filter((el): el is number => typeof el === 'number' && !isNaN(el))\n    .reduce((total, el) => total + el, 0);\n}\n"
        },
        {
          "title": "Approach 3: Reduce-only with inline check",
          "prose": "Idea: combine filtering and summing into a single `reduce()` call for compactness.\n\n**Why use it:** avoids creating an intermediate array â€” efficient for large datasets.",
          "codeJs": "export default function sum(arr) {\n  return arr.reduce((total, el) => {\n    if (typeof el === 'number' && !isNaN(el)) {\n      total += el;\n    }\n    return total;\n  }, 0);\n}\n",
          "codeTs": "export default function sum(arr: any[]): number {\n  return arr.reduce((total, el) => {\n    if (typeof el === 'number' && !isNaN(el)) {\n      total += el;\n    }\n    return total;\n  }, 0);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid coercing numeric strings â€” `'20'` should not automatically convert unless explicitly cast.",
          "Skip `NaN` to prevent result corruption.",
          "Ensure non-numeric falsy values like `false` or `null` are not counted."
        ],
        "edgeCases": [
          "Empty array â†’ returns `0`.",
          "All non-numeric â†’ returns `0`.",
          "Includes `NaN` â†’ ignored.",
          "Mixed types â†’ only numbers contribute to total."
        ],
        "techniques": [
          "Type checking with `typeof` and `isNaN`.",
          "Using loops vs. functional array methods.",
          "Accumulator logic for numeric aggregation."
        ]
      },
      "followUpQuestions": [
        "js-flatten-once"
      ],
      "resources": [
        {
          "title": "MDN â€“ Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        },
        {
          "title": "MDN â€“ Number.isNaN()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"
        }
      ]
    },
    "tests": "import sum from './sum';\n\ndescribe('sum', () => {\n  test('sums numbers in a simple array', () => {\n    expect(sum([1, 2, 3])).toBe(6);\n  });\n\n  test('ignores non-numeric values', () => {\n    expect(sum(['a', 5, true, 7])).toBe(12);\n  });\n\n  test('handles mixed numeric strings gracefully', () => {\n    expect(sum([10, '20', 30])).toBe(40);\n  });\n\n  test('returns 0 for empty or all-non-numeric arrays', () => {\n    expect(sum([])).toBe(0);\n    expect(sum(['x', false, null])).toBe(0);\n  });\n});\n",
    "testsTs": "import sum from './sum';\n\ndescribe('sum (TypeScript)', () => {\n  it('sums numbers in a simple array', () => {\n    expect(sum([1, 2, 3])).toBe(6);\n  });\n\n  it('ignores non-numeric values', () => {\n    expect(sum(['a', 5, true, 7])).toBe(12);\n  });\n\n  it('handles mixed numeric strings gracefully', () => {\n    expect(sum([10, '20', 30])).toBe(40);\n  });\n\n  it('returns 0 for empty or all-non-numeric arrays', () => {\n    expect(sum([])).toBe(0);\n    expect(sum(['x', false, null])).toBe(0);\n  });\n});\n"
  },
  {
    "id": "js-compact",
    "title": "Falsy Bouncer",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `compact(arr)` that removes all falsy values (`false`, `0`, `''`, `null`, `undefined`, `NaN`) from an array.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "An array containing any types of elements, including falsy values."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array with all falsy values removed."
      },
      "examples": [
        "// Basic examples\ncompact([0, 1, false, 2, '', 3]) // => [1, 2, 3]",
        "// Works with only truthy values\ncompact(['a', true, 42]) // => ['a', true, 42]",
        "// Handles null and undefined\ncompact([null, undefined, 'x']) // => ['x']",
        "// Handles NaN\ncompact([NaN, 1, 2]) // => [1, 2]"
      ]
    },
    "starterCode": "export default function compact(arr) {\n  // TODO: Remove all falsy values from the array\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function compact(arr: any[]): any[] {\n  // TODO: Remove all falsy values from the array\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: remove all falsy values (`false`, `0`, `''`, `null`, `undefined`, `NaN`) from an array while preserving order. This task reinforces **truthy/falsy coercion** and the use of **functional array methods** like `filter()`.",
      "approaches": [
        {
          "title": "Approach 1: Using filter(Boolean) (concise and expressive)",
          "prose": "Idea: rely on JavaScript's truthy/falsy evaluation â€” since falsy values convert to `false` in boolean context, `filter(Boolean)` automatically removes them.\n\n### ðŸ§  Step-by-step reasoning\n1. Call `arr.filter(Boolean)`.\n2. The `Boolean` function converts each value to a boolean.\n3. Falsy values (like `0`, `false`, `''`, `null`, `undefined`, `NaN`) are filtered out.\n\nRuns in **O(n)** time and requires **O(n)** space for the new array. Clean and idiomatic.",
          "codeJs": "export default function compact(arr) {\n  return arr.filter(Boolean);\n}\n",
          "codeTs": "export default function compact(arr: any[]): any[] {\n  return arr.filter(Boolean);\n}\n"
        },
        {
          "title": "Approach 2: Manual filtering with explicit check",
          "prose": "Idea: explicitly iterate and push only truthy elements to a new array. Slightly longer but clearer for beginners.\n\n### Steps\n1. Initialize an empty array `result = []`.\n2. For each element, check if itâ€™s truthy (`if (el)`).\n3. If true, push it into `result`.\n4. Return `result`.",
          "codeJs": "export default function compact(arr) {\n  const result = [];\n  for (const el of arr) {\n    if (el) result.push(el);\n  }\n  return result;\n}\n",
          "codeTs": "export default function compact(arr: any[]): any[] {\n  const result: any[] = [];\n  for (const el of arr) {\n    if (el) result.push(el);\n  }\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid accidentally removing values like `0` or `''` if they are intentionally needed â€” this method removes all falsy values.",
          "Be aware that `NaN` is also falsy and will be removed."
        ],
        "edgeCases": [
          "Empty array â†’ returns `[]`.",
          "Array with all falsy values â†’ returns `[]`.",
          "Mixed types â†’ only truthy ones remain."
        ],
        "techniques": [
          "Using Boolean coercion in array filtering.",
          "Understanding truthy/falsy evaluation in JavaScript.",
          "Preserving array order during filtering."
        ]
      },
      "followUpQuestions": [
        "js-unique-array"
      ],
      "resources": [
        {
          "title": "MDN â€“ Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        },
        {
          "title": "MDN â€“ Boolean() constructor",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"
        }
      ]
    },
    "tests": "import compact from './compact';\n\ndescribe('compact', () => {\n  test('removes falsy values', () => {\n    expect(compact([0, 1, false, 2, '', 3])).toEqual([1, 2, 3]);\n  });\n\n  test('returns same array when all truthy', () => {\n    expect(compact(['a', true, 42])).toEqual(['a', true, 42]);\n  });\n\n  test('removes null and undefined', () => {\n    expect(compact([null, undefined, 'x'])).toEqual(['x']);\n  });\n\n  test('removes NaN', () => {\n    expect(compact([NaN, 1, 2])).toEqual([1, 2]);\n  });\n\n  test('handles empty array', () => {\n    expect(compact([])).toEqual([]);\n  });\n});\n",
    "testsTs": "import compact from './compact';\n\ndescribe('compact (TypeScript)', () => {\n  it('removes falsy values', () => {\n    expect(compact([0, 1, false, 2, '', 3])).toEqual([1, 2, 3]);\n  });\n\n  it('returns same array when all truthy', () => {\n    expect(compact(['a', true, 42])).toEqual(['a', true, 42]);\n  });\n\n  it('removes null and undefined', () => {\n    expect(compact([null, undefined, 'x'])).toEqual(['x']);\n  });\n\n  it('removes NaN', () => {\n    expect(compact([NaN, 1, 2])).toEqual([1, 2]);\n  });\n\n  it('handles empty array', () => {\n    expect(compact([])).toEqual([]);\n  });\n});\n"
  },
  {
    "id": "js-arrays-equal",
    "title": "Check if Two Arrays Are Equal",
    "type": "coding",
    "importance": 3,
    "technology": "javascript",
    "difficulty": "easy",
    "tags": [
      "Array"
    ],
    "description": {
      "summary": "Implement a function `arraysEqual(a, b)` that returns `true` if both arrays contain the same elements in the same order.",
      "arguments": [
        {
          "name": "a",
          "type": "any[]",
          "desc": "The first array to compare."
        },
        {
          "name": "b",
          "type": "any[]",
          "desc": "The second array to compare."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if both arrays are identical in length and elements (in the same order), otherwise `false`."
      },
      "examples": [
        "// Basic examples\narraysEqual([1, 2, 3], [1, 2, 3]) // => true",
        "arraysEqual([1, 2, 3], [3, 2, 1]) // => false",
        "// Different lengths\narraysEqual([1, 2], [1, 2, 3]) // => false",
        "// Works with strings\narraysEqual(['a', 'b'], ['a', 'b']) // => true",
        "// Works with mixed types\narraysEqual([1, '2', 3], [1, 2, 3]) // => false"
      ]
    },
    "starterCode": "export default function arraysEqual(a, b) {\n  // TODO: Return true if both arrays contain the same elements in the same order\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  // TODO: Return true if both arrays contain the same elements in the same order\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: verify if two arrays are identical in both length and element order. This exercise focuses on **iteration, index-based comparison**, and **strict equality** to ensure accuracy.",
      "approaches": [
        {
          "title": "Approach 1: Loop-based comparison (explicit and efficient)",
          "prose": "Idea: iterate through both arrays, comparing elements at each index.\n\n### ðŸ§  Step-by-step reasoning\n1. Check if lengths differ â€” if yes, return `false`.\n2. Loop through all indices using a `for` loop.\n3. Compare each pair of elements with strict equality (`!==`).\n4. Return `false` immediately upon a mismatch.\n5. If all elements match, return `true`.\n\nRuns in **O(n)** time with **O(1)** space and avoids unnecessary object conversions.",
          "codeJs": "export default function arraysEqual(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n"
        },
        {
          "title": "Approach 2: Using every() (declarative style)",
          "prose": "Idea: use the `Array.prototype.every()` method to check that every element matches its counterpart.\n\n### Steps\n1. Compare array lengths first.\n2. If lengths are equal, use `a.every((el, i) => el === b[i])`.\n3. Return the result.\n\nThis version is more functional and concise, but slightly less explicit for debugging.",
          "codeJs": "export default function arraysEqual(a, b) {\n  return a.length === b.length && a.every((el, i) => el === b[i]);\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  return a.length === b.length && a.every((el, i) => el === b[i]);\n}\n"
        },
        {
          "title": "Approach 3: JSON stringify shortcut (not recommended for deep or mixed data)",
          "prose": "Idea: serialize both arrays to JSON strings and compare them directly.\n\n### Steps\n1. Convert both arrays using `JSON.stringify()`.\n2. Compare strings with `===`.\n\nWhile compact, this approach can fail with nested arrays, differing object key order, or special values like `undefined`.",
          "codeJs": "export default function arraysEqual(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n",
          "codeTs": "export default function arraysEqual(a: any[], b: any[]): boolean {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Strict equality (`===`) does not perform deep comparison for objects or arrays.",
          "Avoid relying on `JSON.stringify` for nested structures or when order of keys may differ.",
          "Be aware that `['1']` and `[1]` are not considered equal due to type difference."
        ],
        "edgeCases": [
          "Empty arrays â†’ `true`.",
          "Different lengths â†’ `false`.",
          "Different order â†’ `false`.",
          "Mixed types â†’ `false`.",
          "Nested arrays â†’ compared by reference, not deep structure."
        ],
        "techniques": [
          "Using `every()` for element-wise comparison.",
          "Loop-based early return for efficiency.",
          "Understanding reference vs. value equality in JavaScript."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN â€“ Array.prototype.every()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every"
        },
        {
          "title": "MDN â€“ Equality comparisons and sameness",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness"
        }
      ]
    },
    "tests": "import arraysEqual from './arraysEqual';\n\ndescribe('arraysEqual', () => {\n  test('returns true for identical arrays', () => {\n    expect(arraysEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  });\n\n  test('returns false for different element order', () => {\n    expect(arraysEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  test('returns false for different lengths', () => {\n    expect(arraysEqual([1, 2], [1, 2, 3])).toBe(false);\n  });\n\n  test('works with string arrays', () => {\n    expect(arraysEqual(['a', 'b'], ['a', 'b'])).toBe(true);\n  });\n\n  test('returns false for mixed type differences', () => {\n    expect(arraysEqual([1, '2', 3], [1, 2, 3])).toBe(false);\n  });\n\n  test('handles empty arrays', () => {\n    expect(arraysEqual([], [])).toBe(true);\n  });\n});\n",
    "testsTs": "import arraysEqual from './arraysEqual';\n\ndescribe('arraysEqual (TypeScript)', () => {\n  it('returns true for identical arrays', () => {\n    expect(arraysEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n  });\n\n  it('returns false for different element order', () => {\n    expect(arraysEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  it('returns false for different lengths', () => {\n    expect(arraysEqual([1, 2], [1, 2, 3])).toBe(false);\n  });\n\n  it('works with string arrays', () => {\n    expect(arraysEqual(['a', 'b'], ['a', 'b'])).toBe(true);\n  });\n\n  it('returns false for mixed type differences', () => {\n    expect(arraysEqual([1, '2', 3], [1, 2, 3])).toBe(false);\n  });\n\n  it('handles empty arrays', () => {\n    expect(arraysEqual([], [])).toBe(true);\n  });\n});\n"
  },
  {
    "id": "js-debounce",
    "title": "Debounce Function",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "companies": [
      "google",
      "netflix"
    ],
    "difficulty": "medium",
    "tags": [
      "async",
      "timing",
      "function"
    ],
    "description": {
      "summary": "Implement a function `debounce(fn, delay)` that delays the execution of `fn` until a specified time (`delay` ms) has passed since the last invocation.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The function to be executed after the delay."
        },
        {
          "name": "delay",
          "type": "number",
          "desc": "The number of milliseconds to wait before executing the function."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A debounced version of the original function that delays execution until the delay period has elapsed."
      },
      "examples": [
        "// Basic examples\ndebounce(() => console.log('Hello!'), 300)",
        "// Multiple rapid calls â€” only last one runs\nconst log = debounce(() => console.log('Run!'), 500)\nlog()\nlog()\nlog() // Only this one executes after 500ms",
        "// With arguments\nconst greet = debounce(name => console.log(`Hi ${name}`), 400)\ngreet('Alice')\ngreet('Bob') // Only 'Hi Bob' logs after 400ms"
      ]
    },
    "starterCode": "export default function debounce(fn, delay) {\n  // TODO: Return a debounced function that delays execution until delay ms have passed\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): F {\n  // TODO: Return a debounced function that delays execution until delay ms have passed\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure `fn` runs only after calls have stopped for `delay` ms. Common in search inputs, resize/scroll handlers, and deduping rapid UI events.",
      "approaches": [
        {
          "title": "Approach 1: Timeout-based debounce (canonical)",
          "prose": "Idea: store a `timeoutId`. Each call clears the previous timeout and schedules a new one. When the last timer completes, invoke `fn` with the latest args and `this`.\n\n### Step-by-step\n1. Keep `let timeoutId` in the closure.\n2. On each call, `clearTimeout(timeoutId)`.\n3. Set `timeoutId = setTimeout(() => fn.apply(this, args), delay)`.\n4. Return the debounced function.",
          "codeJs": "export default function debounce(fn, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  };\n}\n",
          "codeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): F {\n  let timeoutId: ReturnType<typeof setTimeout>;\n  return function(this: any, ...args: Parameters<F>) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  } as F;\n}\n"
        },
        {
          "title": "Approach 2: Debounce with cancel + flush helpers",
          "prose": "Idea: expose controls to cancel a pending call or run it immediately.\n\n### Steps\n1. Wrap the debounced fn and attach `.cancel()` to clear the timer.\n2. Attach `.flush()` to immediately invoke the pending call (if any).",
          "codeJs": "export default function debounce(fn, delay) {\n  let timeoutId, lastArgs, lastThis;\n  function debounced(...args) {\n    lastArgs = args; lastThis = this;\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }, delay);\n  }\n  debounced.cancel = () => clearTimeout(timeoutId);\n  debounced.flush = () => {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }\n  };\n  return debounced;\n}\n",
          "codeTs": "type Debounced<F extends (...a: any[]) => void> = F & { cancel: () => void; flush: () => void };\nexport default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number): Debounced<F> {\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  let lastArgs: Parameters<F>; let lastThis: any;\n  const debounced = function(this: any, ...args: Parameters<F>) {\n    lastArgs = args; lastThis = this;\n    if (timeoutId) clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }, delay);\n  } as Debounced<F>;\n  debounced.cancel = () => { if (timeoutId) clearTimeout(timeoutId); };\n  debounced.flush = () => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = undefined;\n      fn.apply(lastThis, lastArgs);\n    }\n  };\n  return debounced;\n}\n"
        },
        {
          "title": "Approach 3: Leading-edge option (invoke first, then debounce)",
          "prose": "Idea: allow an immediate call on the first trigger, then silence until inactivity. Useful for instant feedback with suppression of follow-ups.",
          "codeJs": "export default function debounce(fn, delay, { leading = false } = {}) {\n  let timeoutId, invoked = false;\n  return function(...args) {\n    const callNow = leading && !timeoutId;\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => { timeoutId = undefined; invoked = false; }, delay);\n    if (callNow && !invoked) { invoked = true; fn.apply(this, args); }\n    else if (!leading) {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => fn.apply(this, args), delay);\n    }\n  };\n}\n",
          "codeTs": "export default function debounce<F extends (...a: any[]) => void>(fn: F, delay: number, opts: { leading?: boolean } = {}): F {\n  const { leading = false } = opts;\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  let invoked = false;\n  return function(this: any, ...args: Parameters<F>) {\n    const callNow = leading && !timeoutId;\n    if (timeoutId) clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => { timeoutId = undefined; invoked = false; }, delay);\n    if (callNow && !invoked) { invoked = true; fn.apply(this, args); }\n    else if (!leading) {\n      if (timeoutId) clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => fn.apply(this, args), delay);\n    }\n  } as F;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Return value is lost; debounced wrappers usually return `void`. If a return value is required, consider callbacks/promises.",
          "Be careful with `this` â€” use `fn.apply(this, args)` to preserve caller context.",
          "Timers differ between environments (Node vs browser) but `setTimeout/clearTimeout` work in both."
        ],
        "edgeCases": [
          "delay = 0 â†’ behaves like micro-batching calls at the end of the event loop.",
          "Rapid continuous calls â†’ only the last invocation executes after inactivity.",
          "Component unmount/dispose â†’ call `.cancel()` to avoid stray executions."
        ],
        "techniques": [
          "Closures to store timer state.",
          "Timeout clearing to restart the window.",
          "Optional controls: cancel/flush and leading-edge execution."
        ]
      },
      "followUpQuestions": [
        "js-throttle"
      ],
      "resources": [
        {
          "title": "MDN â€“ setTimeout()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        },
        {
          "title": "MDN â€“ Function.prototype.apply()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
        }
      ]
    },
    "tests": "import debounce from './debounce';\n\nconst wait = (ms) => new Promise((r) => setTimeout(r, ms));\n\ndescribe('debounce', () => {\n  test('calls function after delay', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 120);\n\n    debounced();\n    expect(calls).toBe(0);\n\n    await wait(140);\n    expect(calls).toBe(1);\n  });\n\n  test('resets timer on rapid calls (only last executes)', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 100);\n\n    debounced();\n    await wait(50);\n    debounced();\n    await wait(50);\n    debounced();\n\n    await wait(90);\n    expect(calls).toBe(0);\n\n    await wait(20);\n    expect(calls).toBe(1);\n  });\n\n  test('passes arguments (and preserves this via apply)', async () => {\n    let last = '';\n    const debounced = debounce(function (name) {\n      last = `Hi ${name}`;\n    }, 80);\n\n    debounced.call({ tag: 'ctx' }, 'Alice');\n    await wait(100);\n    expect(last).toBe('Hi Alice');\n  });\n});\n",
    "testsTs": "import debounce from './debounce';\n\nconst wait = (ms: number) => new Promise<void>((r) => setTimeout(r, ms));\n\ndescribe('debounce (TypeScript)', () => {\n  it('delays function execution', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 120);\n\n    debounced();\n    expect(calls).toBe(0);\n\n    await wait(140);\n    expect(calls).toBe(1);\n  });\n\n  it('restarts timer on multiple calls', async () => {\n    let calls = 0;\n    const debounced = debounce(() => { calls += 1; }, 100);\n\n    debounced();\n    await wait(50);\n    debounced();\n    await wait(50);\n    debounced();\n\n    await wait(90);\n    expect(calls).toBe(0);\n\n    await wait(20);\n    expect(calls).toBe(1);\n  });\n\n  it('forwards parameters correctly', async () => {\n    let captured = '';\n    const debounced = debounce((msg: string) => { captured = msg; }, 80);\n\n    debounced('Hello');\n    await wait(100);\n    expect(captured).toBe('Hello');\n  });\n});\n"
  },
  {
    "id": "js-throttle",
    "title": "Throttle Function",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "companies": [
      "google",
      "netflix"
    ],
    "difficulty": "medium",
    "tags": [
      "async",
      "timing",
      "function"
    ],
    "description": {
      "summary": "Implement a function `throttle(fn, interval)` that ensures `fn` is executed at most once during every `interval` milliseconds, no matter how many times it's triggered.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "The function to be throttled."
        },
        {
          "name": "interval",
          "type": "number",
          "desc": "The time window (in milliseconds) within which subsequent calls are ignored."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A throttled version of the original function that executes at most once per interval."
      },
      "examples": [
        "// Basic examples\nthrottle(() => console.log('Clicked!'), 1000)",
        "// Multiple rapid calls â€” only first one executes within the interval\nconst log = throttle(() => console.log('Run!'), 500)\nlog()\nlog()\nlog() // Only the first logs immediately, rest ignored until 500ms passes",
        "// With arguments\nconst greet = throttle(name => console.log(`Hi ${name}`), 800)\ngreet('Alice')\ngreet('Bob') // Only 'Hi Alice' logs immediately; 'Hi Bob' ignored until 800ms passes"
      ]
    },
    "starterCode": "export default function throttle(fn, interval) {\n  // TODO: Execute fn at most once per interval\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  // TODO: Execute fn at most once per interval\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: ensure a function executes at most once within a defined period â€” controlling execution frequency for performance-critical events (scroll, resize, input).",
      "approaches": [
        {
          "title": "Approach 1: Timestamp-based throttle (simple and effective)",
          "prose": "Idea: record the last time the function was called, and skip execution until enough time passes.\n\n### Steps\n1. Initialize `let lastTime = 0`.\n2. On each call, compare `Date.now()` with `lastTime`.\n3. If the difference >= interval, call `fn` and update `lastTime`.\n\n**Why use it:** straightforward, minimal overhead, and great for consistent spacing between calls.",
          "codeJs": "export default function throttle(fn, interval) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime >= interval) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  };\n}\n",
          "codeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  let lastTime = 0;\n  return function(this: any, ...args: Parameters<F>) {\n    const now = Date.now();\n    if (now - lastTime >= interval) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  } as F;\n}\n"
        },
        {
          "title": "Approach 2: Timer-based throttle (delayed trailing call)",
          "prose": "Idea: execute the first call immediately and block others until the interval elapses using `setTimeout`.\n\n### Steps\n1. Use a flag or timer to indicate cooldown.\n2. When called, if no timer exists, run `fn` and start a timeout.\n3. When timeout ends, clear the flag so it can fire again.\n\n**Why use it:** guarantees evenly spaced executions even with bursty inputs.",
          "codeJs": "export default function throttle(fn, interval) {\n  let waiting = false;\n  return function(...args) {\n    if (!waiting) {\n      fn.apply(this, args);\n      waiting = true;\n      setTimeout(() => { waiting = false; }, interval);\n    }\n  };\n}\n",
          "codeTs": "export default function throttle<F extends (...a: any[]) => void>(fn: F, interval: number): F {\n  let waiting = false;\n  return function(this: any, ...args: Parameters<F>) {\n    if (!waiting) {\n      fn.apply(this, args);\n      waiting = true;\n      setTimeout(() => { waiting = false; }, interval);\n    }\n  } as F;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Trailing events may be ignored in the simple version â€” use combined approach for reliability.",
          "Avoid mixing throttle and debounce unless behavior is clearly defined.",
          "Ensure consistent `this` context using `apply()`."
        ],
        "edgeCases": [
          "interval = 0 â†’ runs immediately on every call.",
          "First call always executes immediately.",
          "Successive calls within interval are ignored."
        ],
        "techniques": [
          "Timestamp or timer control to manage execution rate.",
          "Tracking `lastTime` and cooldown intervals.",
          "Context binding with closures."
        ]
      },
      "followUpQuestions": [
        "js-debounce"
      ],
      "resources": [
        {
          "title": "MDN â€“ setTimeout()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/setTimeout"
        },
        {
          "title": "Lodash â€“ throttle",
          "url": "https://lodash.com/docs/#throttle"
        }
      ]
    },
    "tests": "import throttle from './throttle';\n\nconst wait = (ms) => new Promise((r) => setTimeout(r, ms));\n\ndescribe('throttle', () => {\n  test('executes immediately and ignores rapid calls', async () => {\n    let calls = 0;\n    const throttled = throttle(() => { calls += 1; }, 200);\n\n    throttled(); // should run immediately\n    throttled(); // ignored\n    throttled(); // ignored\n\n    expect(calls).toBe(1);\n\n    await wait(220);\n    throttled(); // should run after interval\n    expect(calls).toBe(2);\n  });\n\n  test('maintains correct interval spacing', async () => {\n    let timestamps = [];\n    const throttled = throttle(() => { timestamps.push(Date.now()); }, 100);\n\n    throttled();\n    await wait(30);\n    throttled();\n    await wait(80);\n    throttled(); // should run after ~110ms total\n\n    await wait(120);\n    throttled(); // another valid call\n\n    expect(timestamps.length).toBe(3);\n  });\n\n  test('passes arguments correctly', async () => {\n    let last = '';\n    const throttled = throttle((msg) => { last = msg; }, 150);\n\n    throttled('Hello');\n    throttled('World'); // ignored\n\n    await wait(160);\n    throttled('Again');\n\n    expect(last).toBe('Again');\n  });\n});\n",
    "testsTs": "import throttle from './throttle';\n\nconst wait = (ms: number) => new Promise<void>((r) => setTimeout(r, ms));\n\ndescribe('throttle (TypeScript)', () => {\n  it('executes immediately and ignores rapid calls', async () => {\n    let calls = 0;\n    const throttled = throttle(() => { calls += 1; }, 200);\n\n    throttled();\n    throttled();\n    throttled();\n\n    expect(calls).toBe(1);\n\n    await wait(220);\n    throttled();\n    expect(calls).toBe(2);\n  });\n\n  it('maintains proper intervals', async () => {\n    let times: number[] = [];\n    const throttled = throttle(() => { times.push(Date.now()); }, 100);\n\n    throttled();\n    await wait(30);\n    throttled();\n    await wait(80);\n    throttled();\n\n    await wait(120);\n    throttled();\n\n    expect(times.length).toBe(3);\n  });\n\n  it('passes arguments correctly', async () => {\n    let last = '';\n    const throttled = throttle((msg: string) => { last = msg; }, 150);\n\n    throttled('Hi');\n    throttled('Ignore');\n\n    await wait(160);\n    throttled('Final');\n\n    expect(last).toBe('Final');\n  });\n});\n"
  },
  {
    "id": "js-deep-clone",
    "title": "Deep Clone",
    "type": "coding",
    "importance": 5,
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "difficulty": "hard",
    "tags": [
      "object",
      "recursion",
      "clone",
      "deep-copy"
    ],
    "description": {
      "summary": "Implement a function `deepClone(value)` that creates a deep copy of the provided value, including nested objects, arrays, Dates, and RegExps.",
      "arguments": [
        {
          "name": "value",
          "type": "any",
          "desc": "The value to deeply clone. Can be an object, array, Date, RegExp, or primitive."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "A deep copy of the input value where all nested structures are duplicated rather than referenced."
      },
      "examples": [
        "// Basic examples\ndeepClone({ a: 1, b: { c: 2 } }) // => { a: 1, b: { c: 2 } }",
        "// Arrays and nested objects\nconst arr = [1, { x: 10 }, [2, 3]]\nconst copy = deepClone(arr)\ncopy[1].x = 99\n// arr stays unchanged",
        "// Dates and RegExps\nconst obj = { d: new Date('2020-01-01'), r: /abc/i }\nconst clone = deepClone(obj)\nclone.d.setFullYear(2024)\n// obj.d still points to 2020"
      ]
    },
    "starterCode": "export default function deepClone(value) {\n  // TODO: Return a deep-cloned copy of the input value\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function deepClone<T>(value: T): T {\n  // TODO: Return a deep-cloned copy of the input value\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: create a fully independent copy of any input value â€” primitives, objects, arrays, Dates, or RegExps â€” ensuring no shared references remain.",
      "approaches": [
        {
          "title": "Approach 1: Recursive type-aware cloning",
          "prose": "Idea: detect the type of the input and handle each case appropriately â€” primitive, array, object, or special object type.\n\n### Steps\n1. If `value` is primitive (null, number, string, etc.), return it as-is.\n2. Handle `Date` by returning a new Date with the same timestamp.\n3. Handle `RegExp` by creating a new RegExp with the same pattern and flags.\n4. If it's an array, map through elements and clone recursively.\n5. If it's an object, create a new object and recursively clone each key.\n\nThis ensures deeply nested structures are properly copied without sharing references.",
          "codeJs": "export default function deepClone(value) {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (value instanceof Date) return new Date(value.getTime());\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClone(item));\n  }\n\n  const clonedObj = {};\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clonedObj[key] = deepClone(value[key]);\n    }\n  }\n  return clonedObj;\n}\n",
          "codeTs": "export default function deepClone<T>(value: T): T {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (value instanceof Date) return new Date(value.getTime()) as any;\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re as any;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(item => deepClone(item)) as any;\n  }\n\n  const clonedObj: any = {};\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clonedObj[key] = deepClone((value as any)[key]);\n    }\n  }\n  return clonedObj;\n}\n"
        },
        {
          "title": "Approach 2: Handling circular references (advanced)",
          "prose": "Idea: store seen objects in a WeakMap to avoid infinite recursion.\n\nThis approach is useful when the input contains self-referential structures (like graphs or linked objects). Each object reference is tracked, and when revisited, its cloned counterpart is returned instead of recursing indefinitely.",
          "codeJs": "export default function deepClone(value, seen = new WeakMap()) {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (seen.has(value)) return seen.get(value);\n\n  if (value instanceof Date) return new Date(value.getTime());\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re;\n  }\n\n  const clone = Array.isArray(value) ? [] : {};\n  seen.set(value, clone);\n\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clone[key] = deepClone(value[key], seen);\n    }\n  }\n  return clone;\n}\n",
          "codeTs": "export default function deepClone<T>(value: T, seen: WeakMap<any, any> = new WeakMap()): T {\n  if (value === null || typeof value !== 'object') return value;\n\n  if (seen.has(value)) return seen.get(value);\n\n  if (value instanceof Date) return new Date(value.getTime()) as any;\n\n  if (value instanceof RegExp) {\n    const re = new RegExp(value.source, value.flags);\n    re.lastIndex = value.lastIndex;\n    return re as any;\n  }\n\n  const clone: any = Array.isArray(value) ? [] : {};\n  seen.set(value, clone);\n\n  for (const key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      clone[key] = deepClone((value as any)[key], seen);\n    }\n  }\n  return clone;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid shallow copy methods like spread or Object.assign â€” they only copy one level deep.",
          "Circular structures can cause infinite recursion if WeakMap isnâ€™t used.",
          "Functions and DOM nodes are not cloned â€” they retain reference."
        ],
        "edgeCases": [
          "null or primitive â†’ returned directly.",
          "Date â†’ returns new Date with identical timestamp.",
          "RegExp â†’ returns new RegExp with identical source and flags.",
          "Array â†’ deep-cloned recursively."
        ],
        "techniques": [
          "Recursion for nested structures.",
          "Type detection using `instanceof` and `Array.isArray`.",
          "Reference tracking using WeakMap for circular safety."
        ]
      },
      "followUpQuestions": [
        "js-flatten-depth"
      ],
      "resources": [
        {
          "title": "MDN â€“ Object cloning basics",
          "url": "https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy"
        },
        {
          "title": "JavaScript.info â€“ Deep cloning",
          "url": "https://javascript.info/object-copy#structuredclone"
        }
      ]
    },
    "tests": "import deepClone from './deepClone';\n\ndescribe('deepClone', () => {\n  test('clones nested objects', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const clone = deepClone(obj);\n    expect(clone).toEqual(obj);\n    clone.b.c = 5;\n    expect(obj.b.c).toBe(2);\n  });\n\n  test('clones arrays correctly', () => {\n    const arr = [1, { x: 2 }, [3, 4]];\n    const clone = deepClone(arr);\n    expect(clone).toEqual(arr);\n    clone[1].x = 99;\n    expect(arr[1].x).toBe(2);\n  });\n\n  test('clones Date and RegExp instances', () => {\n    const obj = { d: new Date('2020-01-01T00:00:00Z'), r: /abc/i };\n    const clone = deepClone(obj);\n\n    expect(clone.d instanceof Date).toBe(true);\n    expect(clone.d === obj.d).toBe(false);\n    expect(clone.d.getTime()).toBe(obj.d.getTime());\n\n    const sameRegExp = (\n      clone.r instanceof RegExp &&\n      clone.r !== obj.r &&\n      clone.r.source === obj.r.source &&\n      (('flags' in clone.r && 'flags' in obj.r)\n        ? clone.r.flags === obj.r.flags\n        : String(clone.r) === String(obj.r)) &&\n      clone.r.lastIndex === obj.r.lastIndex\n    );\n    expect(sameRegExp).toBe(true);\n  });\n\n  test('returns primitives as-is', () => {\n    expect(deepClone(5)).toBe(5);\n    expect(deepClone('test')).toBe('test');\n    expect(deepClone(null)).toBe(null);\n  });\n});\n",
    "testsTs": "import deepClone from './deepClone';\n\ndescribe('deepClone (TypeScript)', () => {\n  it('deeply clones nested objects', () => {\n    const obj = { a: 1, b: { c: 2 } };\n    const clone = deepClone(obj);\n    expect(clone).toEqual(obj);\n    clone.b.c = 99;\n    expect(obj.b.c).toBe(2);\n  });\n\n  it('clones arrays correctly', () => {\n    const arr = [1, { x: 10 }, [2, 3]];\n    const clone = deepClone(arr);\n    expect(clone).toEqual(arr);\n    clone[1].x = 50;\n    expect(arr[1].x).toBe(10);\n  });\n\n  it('handles Dates and RegExps robustly', () => {\n    const obj = { d: new Date('2020-01-01T00:00:00Z'), r: /test/g };\n    const clone = deepClone(obj);\n\n    expect(clone.d instanceof Date).toBe(true);\n    expect(clone.d === obj.d).toBe(false);\n    expect(clone.d.getTime()).toBe(obj.d.getTime());\n\n    const sameRegExp = (\n      clone.r instanceof RegExp &&\n      clone.r !== obj.r &&\n      clone.r.source === obj.r.source &&\n      (('flags' in clone.r && 'flags' in obj.r)\n        ? clone.r.flags === obj.r.flags\n        : String(clone.r) === String(obj.r)) &&\n      clone.r.lastIndex === obj.r.lastIndex\n    );\n    expect(sameRegExp).toBe(true);\n  });\n\n  it('returns primitives unchanged', () => {\n    expect(deepClone('abc')).toBe('abc');\n    expect(deepClone(123)).toBe(123);\n  });\n});\n"
  },
  {
    "id": "js-deep-equal",
    "title": "Deep Equal",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "object",
      "recursion",
      "equality",
      "comparison"
    ],
    "description": {
      "summary": "Implement a function `deepEqual(a, b)` that returns `true` when two values are deeply equal â€” primitives by value and objects/arrays by recursively comparing their properties. Handle Dates, RegExps, and `NaN`.",
      "arguments": [
        {
          "name": "a",
          "type": "any",
          "desc": "First value to compare."
        },
        {
          "name": "b",
          "type": "any",
          "desc": "Second value to compare."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "`true` if both inputs are deeply equal; otherwise `false`."
      },
      "examples": [
        "// Basic examples\ndeepEqual(1, 1) // => true\ndeepEqual(1, '1') // => false",
        "// Nested objects\ndeepEqual({ a: 1, b: { c: 2 } }, { a: 1, b: { c: 2 } }) // => true",
        "// Arrays (order matters)\ndeepEqual([1, 2, 3], [1, 2, 3]) // => true\ndeepEqual([1, 2, 3], [3, 2, 1]) // => false",
        "// Dates and RegExp\ndeepEqual(new Date('2020-01-01'), new Date('2020-01-01')) // => true\ndeepEqual(/ab/i, new RegExp('ab', 'i')) // => true",
        "// Special values\ndeepEqual(NaN, NaN) // => true\ndeepEqual(null, undefined) // => false"
      ]
    },
    "starterCode": "export default function deepEqual(a, b) {\n  // TODO: Compare two values for deep equality\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function deepEqual<T = any>(a: T, b: T): boolean {\n  // TODO: Compare two values for deep equality\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: return `true` only when two inputs are the same **by value** (for primitives) or **by structure** (for arrays/objects). Must treat `NaN` as equal to `NaN`, compare `Date` by timestamp, and `RegExp` by pattern/flags/lastIndex.",
      "approaches": [
        {
          "title": "Approach 1: Direct recursion (baseline, easiest to follow)",
          "prose": "Idea: handle the common cases with clear early exits, then recurse for arrays and plain objects.\n\nSteps\n1. If `a === b`, return `true` (covers identical references and most primitives).\n2. If both are numbers and both are `NaN`, return `true`.\n3. If types differ or either is `null`, return `false`.\n4. Handle `Date` and `RegExp` specially.\n5. If either value is an array, both must be arrays; compare length, then pairwise recurse.\n6. Otherwise, treat as plain objects: compare own keys length, ensure the same keys exist, then recurse per key.\n\nWhy use it: readable flow with tight, predictable checks that pass typical interview test suites.",
          "codeJs": "export default function deepEqual(a, b) {\n  if (a === b) return true;\n  if (typeof a === 'number' && typeof b === 'number' && Number.isNaN(a) && Number.isNaN(b)) return true;\n  if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') return false;\n\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    const same = a.source === b.source && a.flags === b.flags;\n    return same && a.lastIndex === b.lastIndex;\n  }\n\n  const aIsArr = Array.isArray(a);\n  const bIsArr = Array.isArray(b);\n  if (aIsArr || bIsArr) {\n    if (!(aIsArr && bIsArr)) return false;\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const k of aKeys) {\n    if (!Object.prototype.hasOwnProperty.call(b, k)) return false;\n    if (!deepEqual(a[k], b[k])) return false;\n  }\n  return true;\n}\n",
          "codeTs": "export default function deepEqual<T = any>(a: T, b: T): boolean {\n  if (a === b) return true;\n  if (typeof a === 'number' && typeof b === 'number' && Number.isNaN(a as any) && Number.isNaN(b as any)) return true;\n  if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') return false;\n\n  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    const same = a.source === b.source && a.flags === b.flags;\n    return same && a.lastIndex === b.lastIndex;\n  }\n\n  const aIsArr = Array.isArray(a);\n  const bIsArr = Array.isArray(b);\n  if (aIsArr || bIsArr) {\n    if (!(aIsArr && bIsArr)) return false;\n    const aa = a as unknown as any[];\n    const bb = b as unknown as any[];\n    if (aa.length !== bb.length) return false;\n    for (let i = 0; i < aa.length; i++) {\n      if (!deepEqual(aa[i], bb[i])) return false;\n    }\n    return true;\n  }\n\n  const aObj = a as Record<string, unknown>;\n  const bObj = b as Record<string, unknown>;\n  const aKeys = Object.keys(aObj);\n  const bKeys = Object.keys(bObj);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const k of aKeys) {\n    if (!Object.prototype.hasOwnProperty.call(bObj, k)) return false;\n    if (!deepEqual((aObj as any)[k], (bObj as any)[k])) return false;\n  }\n  return true;\n}\n"
        },
        {
          "title": "Approach 2: JSON stringify (quick but limited)",
          "prose": "Idea: `JSON.stringify(a) === JSON.stringify(b)` as a one-liner for **plain** data (no functions, symbols, undefined in objects; key order stable).\n\nWhy use it: handy sanity check or pre-filter for simple objects; not reliable for Dates, RegExps, `NaN`, different key orders, or cyclic structures.",
          "codeJs": "export default function deepEqual(a, b) {\n  try {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } catch {\n    // cyclic structures throw errors\n    return false;\n  }\n}\n",
          "codeTs": "export default function deepEqual<T>(a: T, b: T): boolean {\n  try {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } catch {\n    return false;\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Treat `NaN` as equal to `NaN` â€” `NaN === NaN` is false by default.",
          "Donâ€™t rely on `JSON.stringify` for general deep equality (Dates/RegExps/undefined/functions differ).",
          "Only compare **own** enumerable keys; inherited properties should not affect equality."
        ],
        "edgeCases": [
          "Different types â†’ immediately false.",
          "Arrays: order matters; lengths must match.",
          "RegExp: compare `source`, `flags`, and optionally `lastIndex`.",
          "Date: compare `getTime()`.",
          "Null vs undefined â†’ false."
        ],
        "techniques": [
          "Short-circuit checks before recursion.",
          "Type-specific comparisons for Date/RegExp.",
          "Key set + recursive property comparison."
        ]
      },
      "followUpQuestions": [
        "js-deep-clone",
        "js-arrays-equal"
      ],
      "resources": [
        {
          "title": "MDN â€“ Object.keys()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"
        },
        {
          "title": "MDN â€“ Date",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"
        },
        {
          "title": "MDN â€“ RegExp",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp"
        }
      ]
    },
    "tests": "import deepEqual from './deepEqual';\n\ndescribe('deepEqual', () => {\n  test('compares primitives', () => {\n    expect(deepEqual(1, 1)).toBe(true);\n    expect(deepEqual(1, '1')).toBe(false);\n    expect(deepEqual(NaN, NaN)).toBe(true);\n  });\n\n  test('compares nested objects', () => {\n    const a = { x: 1, y: { z: 2 } };\n    const b = { x: 1, y: { z: 2 } };\n    expect(deepEqual(a, b)).toBe(true);\n    const c = { x: 1, y: { z: 3 } };\n    expect(deepEqual(a, c)).toBe(false);\n  });\n\n  test('compares arrays (order matters)', () => {\n    expect(deepEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n    expect(deepEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  test('handles Date and RegExp', () => {\n    const d1 = new Date('2020-01-01T00:00:00Z');\n    const d2 = new Date('2020-01-01T00:00:00Z');\n    expect(deepEqual(d1, d2)).toBe(true);\n\n    const r1 = /ab/i;\n    const r2 = new RegExp('ab', 'i');\n    expect(deepEqual(r1, r2)).toBe(true);\n  });\n\n  test('null vs undefined', () => {\n    expect(deepEqual(null, undefined)).toBe(false);\n  });\n});\n",
    "testsTs": "import deepEqual from './deepEqual';\n\ndescribe('deepEqual (TypeScript)', () => {\n  it('compares primitives', () => {\n    expect(deepEqual(1, 1)).toBe(true);\n    expect(deepEqual(1 as any, '1' as any)).toBe(false);\n    expect(deepEqual(NaN, NaN)).toBe(true);\n  });\n\n  it('compares nested objects', () => {\n    const a = { x: 1, y: { z: 2 } };\n    const b = { x: 1, y: { z: 2 } };\n    expect(deepEqual(a, b)).toBe(true);\n    const c = { x: 1, y: { z: 3 } };\n    expect(deepEqual(a, c)).toBe(false);\n  });\n\n  it('compares arrays (order matters)', () => {\n    expect(deepEqual([1, 2, 3], [1, 2, 3])).toBe(true);\n    expect(deepEqual([1, 2, 3], [3, 2, 1])).toBe(false);\n  });\n\n  it('handles Date and RegExp', () => {\n    const d1 = new Date('2020-01-01T00:00:00Z');\n    const d2 = new Date('2020-01-01T00:00:00Z');\n    expect(deepEqual(d1, d2)).toBe(true);\n\n    const r1 = /ab/i;\n    const r2 = new RegExp('ab', 'i');\n    expect(deepEqual(r1, r2)).toBe(true);\n  });\n\n  it('null vs undefined', () => {\n    expect(deepEqual(null as any, undefined as any)).toBe(false);\n  });\n});\n"
  },
  {
    "id": "js-flatten-depth",
    "title": "Flatten with Depth",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "array",
      "recursion",
      "depth",
      "flatten"
    ],
    "description": {
      "summary": "Implement `flatten(arr, depth)` that flattens a nested array up to a given depth.",
      "arguments": [
        {
          "name": "arr",
          "type": "any[]",
          "desc": "Nested array to flatten."
        },
        {
          "name": "depth",
          "type": "number",
          "desc": "Number of levels to flatten (default 1)."
        }
      ],
      "returns": {
        "type": "any[]",
        "desc": "A new array flattened up to the given depth."
      },
      "examples": [
        "// Basic examples\nflatten([1, [2, [3, [4]]]], 1) // => [1, 2, [3, [4]]]",
        "flatten([1, [2, [3, [4]]]], 2) // => [1, 2, 3, [4]]",
        "flatten([1, [2, [3, [4]]]], 3) // => [1, 2, 3, 4]",
        "// Handles empty and non-nested arrays\nflatten([1, 2, 3], 2) // => [1, 2, 3]"
      ]
    },
    "starterCode": "export default function flatten(arr, depth = 1) {\n  // TODO: Flatten array up to given depth\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  // TODO: Flatten array up to given depth\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: reduce nested arrays by one or more levels depending on `depth`. Each recursive step removes one layer of nesting until `depth` reaches 0.",
      "approaches": [
        {
          "title": "Approach 1: Recursive flattening (baseline, easiest to read)",
          "prose": "Idea: for each element, check if itâ€™s an array. If yes, flatten it one level deeper (reducing `depth`), otherwise push directly.\n\nSteps:\n1. Base case: if `depth === 0`, return a shallow copy.\n2. Loop through array elements.\n3. For nested arrays, recurse with `depth - 1`.\n4. Collect results in a new array.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  const result = [];\n  for (const el of arr) {\n    if (Array.isArray(el) && depth > 0) {\n      result.push(...flatten(el, depth - 1));\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  const result: any[] = [];\n  for (const el of arr) {\n    if (Array.isArray(el) && depth > 0) {\n      result.push(...flatten(el, depth - 1));\n    } else {\n      result.push(el);\n    }\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Using reduce (compact, functional style)",
          "prose": "Idea: use `Array.prototype.reduce` to build the flattened array recursively.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  return arr.reduce((acc, el) => {\n    return acc.concat(Array.isArray(el) ? flatten(el, depth - 1) : el);\n  }, []);\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  return arr.reduce((acc: any[], el) => {\n    return acc.concat(Array.isArray(el) ? flatten(el, depth - 1) : el);\n  }, []);\n}\n"
        },
        {
          "title": "Approach 3: Using stack (iterative, avoids recursion)",
          "prose": "Idea: simulate recursion using a stack so we can flatten arrays iteratively. This approach is great for deeply nested arrays since it avoids call-stack overflows.\n\n### ðŸ” How it works\n1. Push each element onto a stack along with its current `depth` value.\n2. Pop elements from the stack one by one.\n3. If the element is an array and depth > 0, push its children **in reverse order**, each with `depth âˆ’ 1`.\n4. If itâ€™s not an array or depth === 0, append it to the result.\n\n### ðŸ’¡ Why reverse order?\nBecause the stack is LIFO â€” we want elements to be processed left-to-right. By seeding the stack in reverse and pushing children in reverse, the final order matches the original array.\n\n### âš™ï¸ When to use\n- When arrays are extremely deep and recursion may hit a call-stack limit.\n- When you need full control over the traversal order.\n\n### âœ… Complexity\nO(n) time and O(n) space â€” similar to the recursive approach, but stack-safe.",
          "codeJs": "export default function flatten(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  const result = [];\n  const stack = [];\n  // Seed stack right-to-left so popping processes left-to-right\n  for (let i = arr.length - 1; i >= 0; i--) {\n    stack.push([arr[i], depth]);\n  }\n  while (stack.length) {\n    const [curr, d] = stack.pop();\n    if (Array.isArray(curr) && d > 0) {\n      for (let i = curr.length - 1; i >= 0; i--) {\n        stack.push([curr[i], d - 1]);\n      }\n    } else {\n      result.push(curr);\n    }\n  }\n  return result;\n}\n",
          "codeTs": "export default function flatten(arr: any[], depth: number = 1): any[] {\n  if (depth === 0) return arr.slice();\n  const result: any[] = [];\n  const stack: Array<[any, number]> = [];\n  // Seed stack right-to-left so popping processes left-to-right\n  for (let i = arr.length - 1; i >= 0; i--) {\n    stack.push([arr[i], depth]);\n  }\n  while (stack.length) {\n    const [curr, d] = stack.pop() as [any, number];\n    if (Array.isArray(curr) && d > 0) {\n      for (let i = curr.length - 1; i >= 0; i--) {\n        stack.push([curr[i], d - 1]);\n      }\n    } else {\n      result.push(curr);\n    }\n  }\n  return result;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Donâ€™t mutate the input array â€” always return a new array.",
          "If `depth === 0`, return a shallow copy, not the original reference.",
          "`Array.flat()` is off-limits here (weâ€™re reimplementing it)."
        ],
        "edgeCases": [
          "Empty arrays â†’ return empty array.",
          "Depth larger than nesting â†’ fully flatten.",
          "Depth 0 â†’ returns shallow copy."
        ],
        "techniques": [
          "Recursion and base case handling.",
          "Spread operator for flattening.",
          "Reduce for elegant accumulation."
        ]
      },
      "followUpQuestions": [
        "js-flatten-once",
        "js-deep-clone"
      ]
    },
    "tests": "import flatten from './flatten';\n\ndescribe('flatten', () => {\n  test('flattens one level deep', () => {\n    expect(flatten([1, [2, [3, [4]]]], 1)).toEqual([1, 2, [3, [4]]]);\n  });\n\n  test('flattens two levels deep', () => {\n    expect(flatten([1, [2, [3, [4]]]], 2)).toEqual([1, 2, 3, [4]]);\n  });\n\n  test('flattens completely when depth is high', () => {\n    expect(flatten([1, [2, [3, [4]]]], 10)).toEqual([1, 2, 3, 4]);\n  });\n\n  test('handles empty and non-nested arrays', () => {\n    expect(flatten([], 2)).toEqual([]);\n    expect(flatten([1, 2, 3], 2)).toEqual([1, 2, 3]);\n  });\n});\n",
    "testsTs": "import flatten from './flatten';\n\ndescribe('flatten (TypeScript)', () => {\n  it('flattens one level', () => {\n    expect(flatten([1, [2, [3, [4]]]], 1)).toEqual([1, 2, [3, [4]]]);\n  });\n\n  it('flattens up to given depth', () => {\n    expect(flatten([1, [2, [3, [4]]]], 2)).toEqual([1, 2, 3, [4]]);\n  });\n\n  it('fully flattens if depth is large', () => {\n    expect(flatten([1, [2, [3, [4]]]], 10)).toEqual([1, 2, 3, 4]);\n  });\n\n  it('returns array unchanged when already flat', () => {\n    expect(flatten([1, 2, 3], 2)).toEqual([1, 2, 3]);\n  });\n});\n"
  },
  {
    "id": "js-curry-function",
    "title": "Curry Function",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "function",
      "closure",
      "higher-order",
      "currying"
    ],
    "description": {
      "summary": "Implement a function `curry(fn)` that transforms a multi-argument function into a chain of single-argument functions.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "A function that accepts multiple arguments."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A curried version of the input function that collects arguments until all are provided."
      },
      "examples": [
        "// Basic example\nfunction add(a, b, c) { return a + b + c; }\nconst curriedAdd = curry(add);\ncurriedAdd(1)(2)(3) // => 6",
        "// Partial application\nconst add5 = curriedAdd(2)(3);\nadd5(10) // => 15",
        "// Works with different argument counts\nconst multiply = (a, b) => a * b;\ncurry(multiply)(4)(5) // => 20",
        "// Mixed grouping is fine too\ncurriedAdd(1, 2)(3) // => 6\ncurriedAdd(1)(2, 3) // => 6"
      ]
    },
    "starterCode": "export default function curry(fn) {\n  // TODO: Transform fn into a curried version\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function curry(fn: Function): Function {\n  // TODO: Transform fn into a curried version\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: turn an N-ary function into a chain that collects arguments across calls until it has at least `fn.length`, then invokes `fn`. Enables partial application while preserving order.",
      "approaches": [
        {
          "title": "Approach 1: Variadic accumulator using closures (simplest)",
          "prose": "Idea: keep collecting arguments in a closure. If collected args are **>=** `fn.length`, call `fn`; otherwise, return a function that keeps collecting.\n\nHow it works\n1. Read `fn.length` to know required parameters.\n2. Define inner `curried(...args)` that checks count.\n3. If enough, return `fn(...args)`.\n4. Else return a function that gathers more and calls `curried` again.\n\nWhy it works: closures preserve previously provided args; callers can group arguments arbitrarily (`f(1)(2)(3)`, `f(1,2)(3)`, etc.).",
          "codeJs": "export default function curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn(...args);\n    }\n    return (...next) => curried(...args, ...next);\n  };\n}\n",
          "codeTs": "export default function curry(fn: Function): Function {\n  const curried = (...args: any[]): any => {\n    return args.length >= fn.length\n      ? fn(...args)\n      : (...next: any[]) => curried(...args, ...next);\n  };\n  return curried;\n}\n"
        },
        {
          "title": "Approach 2: Recursive arity handler (explicit argument counting)",
          "prose": "Instead of comparing to `fn.length` each time, we create a recursive wrapper that reduces the expected argument count until all are gathered. This makes the recursion explicit but slightly less elegant.",
          "codeJs": "export default function curry(fn) {\n  const curried = (...args) => {\n    if (args.length >= fn.length) return fn(...args);\n    return (...next) => curried(...args.concat(next));\n  };\n  return curried;\n}\n",
          "codeTs": "export default function curry(fn: Function): Function {\n  const curried = (...args: any[]): any => {\n    if (args.length >= fn.length) return fn(...args);\n    return (...next: any[]) => curried(...args.concat(next));\n  };\n  return curried;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "`fn.length` ignores default/rest parameters; advanced typings for perfect TS inference are omitted for clarity."
        ],
        "edgeCases": [
          "Unary functions return immediately.",
          "Extra arguments beyond `fn.length` are forwarded to `fn`."
        ],
        "techniques": [
          "Closures to capture partial arguments.",
          "Arity inspection via `fn.length`."
        ]
      },
      "followUpQuestions": [
        "js-compose",
        "js-memoize-function"
      ],
      "resources": [
        {
          "title": "MDN â€“ Function.length",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length"
        },
        {
          "title": "MDN â€“ Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        }
      ]
    },
    "tests": "import curry from './curry';\n\ndescribe('curry', () => {\n  test('curries a multi-argument function', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1)(2)(3)).toBe(6);\n  });\n\n  test('supports partial application', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    const add5 = curriedAdd(2)(3);\n    expect(add5(10)).toBe(15);\n  });\n\n  test('accepts mixed grouping of arguments', () => {\n    const add = (a, b, c) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1, 2)(3)).toBe(6);\n    expect(curriedAdd(1)(2, 3)).toBe(6);\n  });\n\n  test('works for 2-argument functions', () => {\n    const multiply = (a, b) => a * b;\n    const curried = curry(multiply);\n    expect(curried(4)(5)).toBe(20);\n    expect(curried(4, 5)).toBe(20);\n  });\n\n  test('handles single-argument functions', () => {\n    const square = x => x * x;\n    const curriedSquare = curry(square);\n    expect(curriedSquare(5)).toBe(25);\n  });\n});\n",
    "testsTs": "import curry from './curry';\n\ndescribe('curry (TypeScript)', () => {\n  it('curries a three-argument function', () => {\n    const add = (a: number, b: number, c: number) => a + b + c;\n    const curriedAdd = curry(add);\n    expect(curriedAdd(1)(2)(3)).toBe(6);\n  });\n\n  it('supports partial application', () => {\n    const add = (a: number, b: number, c: number) => a + b + c;\n    const curriedAdd = curry(add);\n    const add5 = curriedAdd(2)(3);\n    expect(add5(10)).toBe(15);\n  });\n\n  it('works with binary functions and mixed grouping', () => {\n    const multiply = (a: number, b: number) => a * b;\n    const curriedMultiply = curry(multiply);\n    expect(curriedMultiply(4)(5)).toBe(20);\n    expect(curriedMultiply(4, 5)).toBe(20);\n  });\n\n  it('handles unary functions', () => {\n    const negate = (x: number) => -x;\n    const curriedNegate = curry(negate);\n    expect(curriedNegate(3)).toBe(-3);\n  });\n});\n"
  },
  {
    "id": "js-memoize-function",
    "title": "Memoization",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "importance": 5,
    "difficulty": "medium",
    "tags": [
      "function",
      "performance",
      "caching",
      "optimization"
    ],
    "description": {
      "summary": "Implement a function `memoize(fn)` that caches results of previous function calls to avoid recomputation.",
      "arguments": [
        {
          "name": "fn",
          "type": "Function",
          "desc": "A pure function whose results can be safely cached based on input arguments."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A new function that returns cached results for previously computed arguments."
      },
      "examples": [
        "// Basic example\nconst slowAdd = (a, b) => { for (let i=0;i<1e6;i++); return a + b; };\nconst memoizedAdd = memoize(slowAdd);\nconsole.time('first'); memoizedAdd(3,4); console.timeEnd('first');\nconsole.time('second'); memoizedAdd(3,4); console.timeEnd('second'); // much faster",
        "// Works with multiple arguments\nconst multiply = (a, b, c) => a * b * c;\nconst fastMultiply = memoize(multiply);\nfastMultiply(2,3,4) // computed\nfastMultiply(2,3,4) // cached",
        "// Handles different input sets separately\nmemoizedAdd(5,5) // => 10 (new computation)"
      ]
    },
    "starterCode": "export default function memoize(fn) {\n  // TODO: Cache function results by input arguments\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  // TODO: Cache function results by input arguments\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: cache previous function call results to avoid recomputation â€” ideal for expensive or recursive functions.",
      "approaches": [
        {
          "title": "Approach 1: Using Map with JSON key (simple & effective)",
          "prose": "Idea: store previous results in a `Map`, where the key is a serialized version of the arguments.\n\nHow it works\n1. Create a `Map` to store results.\n2. Convert arguments to a cache key using `JSON.stringify`.\n3. If the key exists, return the cached value.\n4. Otherwise compute, store, and return the result.\n\nWhy use it: straightforward and efficient for primitive and serializable arguments.",
          "codeJs": "export default function memoize(fn) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n",
          "codeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  const cache = new Map<string, ReturnType<F>>();\n  const memoized = (...args: Parameters<F>): ReturnType<F> => {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key)!;\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n  return memoized as F;\n}\n"
        },
        {
          "title": "Approach 2: Nested Map (advanced for deep argument types)",
          "prose": "Idea: instead of serializing arguments, use nested `Map`s â€” one per argument â€” to handle non-serializable inputs safely.\n\nHow it works\n1. Start with an empty root `Map`.\n2. For each argument, go one level deeper â€” each key in the chain is an argument.\n3. The final map node stores the computed result.\n\nWhy use it: avoids `JSON.stringify` limitations, useful for object or reference-based arguments.",
          "codeJs": "export default function memoize(fn) {\n  const root = new Map();\n  return function memoized(...args) {\n    let map = root;\n    for (const arg of args) {\n      if (!map.has(arg)) map.set(arg, new Map());\n      map = map.get(arg);\n    }\n    if (map.has('result')) return map.get('result');\n    const result = fn(...args);\n    map.set('result', result);\n    return result;\n  };\n}\n",
          "codeTs": "export default function memoize<F extends (...args: any[]) => any>(fn: F): F {\n  const root = new Map<any, any>();\n  const memoized = (...args: Parameters<F>): ReturnType<F> => {\n    let map = root;\n    for (const arg of args) {\n      if (!map.has(arg)) map.set(arg, new Map());\n      map = map.get(arg);\n    }\n    if (map.has('result')) return map.get('result');\n    const result = fn(...args);\n    map.set('result', result);\n    return result;\n  };\n  return memoized as F;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "JSON.stringify cannot handle functions, symbols, or circular structures.",
          "Use nested Map approach for reference or object-heavy inputs."
        ],
        "edgeCases": [
          "Functions with no arguments still work â€” use single empty key.",
          "Different argument order yields distinct cache entries."
        ],
        "techniques": [
          "Closure retains cache between invocations.",
          "Using `Map` prevents accidental key collisions from prototype chain."
        ]
      },
      "followUpQuestions": [
        "js-throttle",
        "js-debounce"
      ],
      "resources": [
        {
          "title": "MDN â€“ Map",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
        },
        {
          "title": "MDN â€“ Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        }
      ]
    },
    "tests": "import memoize from './memoize';\n\ndescribe('memoize', () => {\n  test('caches results for repeated calls', () => {\n    let calls = 0;\n    const add = (a, b) => { calls++; return a + b; };\n    const memoAdd = memoize(add);\n    expect(memoAdd(1, 2)).toBe(3);\n    expect(memoAdd(1, 2)).toBe(3);\n    expect(calls).toBe(1);\n  });\n\n  test('handles different arguments separately', () => {\n    let calls = 0;\n    const multiply = (a, b) => { calls++; return a * b; };\n    const memoMult = memoize(multiply);\n    memoMult(2, 3);\n    memoMult(3, 4);\n    expect(calls).toBe(2);\n  });\n\n  test('works with multiple argument calls', () => {\n    const join = (...args) => args.join('-');\n    const memoJoin = memoize(join);\n    expect(memoJoin('a', 'b', 'c')).toBe('a-b-c');\n    expect(memoJoin('a', 'b', 'c')).toBe('a-b-c');\n  });\n});\n",
    "testsTs": "import memoize from './memoize';\n\ndescribe('memoize (TypeScript)', () => {\n  it('caches computed results', () => {\n    let count = 0;\n    const add = (a: number, b: number) => { count++; return a + b; };\n    const memoAdd = memoize(add);\n    expect(memoAdd(3, 4)).toBe(7);\n    expect(memoAdd(3, 4)).toBe(7);\n    expect(count).toBe(1);\n  });\n\n  it('treats unique argument sets separately', () => {\n    let count = 0;\n    const diff = (a: number, b: number) => { count++; return a - b; };\n    const memoDiff = memoize(diff);\n    memoDiff(10, 5);\n    memoDiff(8, 3);\n    expect(count).toBe(2);\n  });\n\n  it('works for multi-arg functions', () => {\n    const concat = (...args: string[]) => args.join('_');\n    const memoConcat = memoize(concat);\n    expect(memoConcat('a', 'b', 'c')).toBe('a_b_c');\n    expect(memoConcat('a', 'b', 'c')).toBe('a_b_c');\n  });\n});\n"
  },
  {
    "id": "js-compose",
    "title": "Compose Function",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "function",
      "composition",
      "higher-order",
      "utility"
    ],
    "description": {
      "summary": "Implement a `compose(...fns)` function that takes multiple functions as arguments and returns a new function that applies them from **right to left**. The output of one function becomes the input of the previous one. If no functions are provided, return an identity function `(x) => x`.",
      "arguments": [
        {
          "name": "fns",
          "type": "Function[]",
          "desc": "A list of functions to compose. The rightmost function can take multiple arguments; the rest are unary."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A composed function that runs all provided functions in right-to-left order."
      },
      "examples": [
        "// Basic example",
        "const add1 = n => n + 1;",
        "const double = n => n * 2;",
        "const subtract10 = n => n - 10;",
        "const composedFn = compose(subtract10, double, add1);",
        "composedFn(3); // => -2",
        "",
        "// Identity function",
        "compose()(5); // => 5"
      ]
    },
    "starterCode": "export default function compose(...fns) {\n  // TODO: Implement function composition (right-to-left)\n  throw new Error('Not implemented');\n}",
    "starterCodeTs": "export default function compose(...fns: Function[]): Function {\n  // TODO: Implement function composition (right-to-left)\n  throw new Error('Not implemented');\n}",
    "solutionBlock": {
      "explanation": "Function composition creates a chain where each functionâ€™s output feeds into the next one, starting from the rightmost function.\n\n### Step-by-step logic:\n1. If no functions are passed, return identity `(x) => x`.\n2. Return a new function that takes an input value.\n3. Apply `reduceRight()` to run each function on the result of the previous one.\n\nThis pattern is common in functional programming and helps simplify complex transformations.",
      "codeJs": "export default function compose(...fns) {\n  if (fns.length === 0) return x => x;\n  return function (input) {\n    return fns.reduceRight((acc, fn) => fn(acc), input);\n  };\n}",
      "codeTs": "export default function compose(...fns: Function[]): Function {\n  if (fns.length === 0) return (x: any) => x;\n  return function (input: any) {\n    return fns.reduceRight((acc, fn) => fn(acc), input);\n  };\n}"
    },
    "tests": "import compose from './compose';\n\ndescribe('compose', () => {\n  const add1 = n => n + 1;\n  const double = n => n * 2;\n  const subtract10 = n => n - 10;\n\n  test('applies functions right-to-left', () => {\n    const fn = compose(subtract10, double, add1);\n    expect(fn(3)).toBe(-2);\n  });\n\n  test('works with single function', () => {\n    const fn = compose(add1);\n    expect(fn(4)).toBe(5);\n  });\n\n  test('returns identity when empty', () => {\n    const fn = compose();\n    expect(fn(5)).toBe(5);\n  });\n});",
    "testsTs": "import compose from './compose';\n\ndescribe('compose (TypeScript)', () => {\n  const add1 = (n: number) => n + 1;\n  const double = (n: number) => n * 2;\n  const subtract10 = (n: number) => n - 10;\n\n  it('applies functions right-to-left', () => {\n    const fn = compose(subtract10, double, add1);\n    expect(fn(3)).toBe(-2);\n  });\n\n  it('works with single function', () => {\n    const fn = compose(add1);\n    expect(fn(4)).toBe(5);\n  });\n\n  it('returns identity when empty', () => {\n    const fn = compose();\n    expect(fn(10)).toBe(10);\n  });\n});"
  },
  {
    "id": "js-group-by",
    "title": "Group By",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "array",
      "object",
      "grouping",
      "reduction"
    ],
    "description": {
      "summary": "Implement a function `groupBy(arr, keyFn)` that groups array elements based on the result of applying a key function to each element.",
      "arguments": [
        {
          "name": "arr",
          "type": "T[]",
          "desc": "The array of elements to group."
        },
        {
          "name": "keyFn",
          "type": "(item: T) => K",
          "desc": "A function that returns a key to group each element under."
        }
      ],
      "returns": {
        "type": "Record<K, T[]>",
        "desc": "An object whose keys are the computed group keys, and values are arrays of elements belonging to each group."
      },
      "examples": [
        "// Basic examples",
        "groupBy([6.1, 4.2, 6.3], Math.floor) // => { '4': [4.2], '6': [6.1, 6.3] }",
        "groupBy(['one', 'two', 'three'], str => str.length) // => { '3': ['one', 'two'], '5': ['three'] }",
        "groupBy([{type:'a'}, {type:'b'}, {type:'a'}], x => x.type) // => { a: [{type:'a'}, {type:'a'}], b: [{type:'b'}] }"
      ]
    },
    "starterCode": "export default function groupBy(arr, keyFn) {\n  // TODO: Group array elements by keyFn(item)\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  // TODO: Group array elements by keyFn(item)\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: convert a flat list into an object keyed by `keyFn(item)`, where each key stores an array of matching items.",
      "approaches": [
        {
          "title": "Approach 1: Simple loop (clear baseline)",
          "prose": "Idea: iterate once, compute a key for each item, initialize the bucket if missing, and push the item.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  const result = {};\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = [];\n    }\n    result[key].push(item);\n  }\n  return result;\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  const result = {} as Record<K, T[]>;\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = [] as T[];\n    }\n    result[key].push(item);\n  }\n  return result;\n}\n"
        },
        {
          "title": "Approach 2: Array.reduce (concise)",
          "prose": "Idea: fold the array into an accumulator object, creating buckets on demand.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  return arr.reduce((acc, item) => {\n    const key = keyFn(item);\n    (acc[key] ||= []).push(item);\n    return acc;\n  }, {});\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  return arr.reduce((acc, item) => {\n    const key = keyFn(item);\n    (acc[key] ||= [] as T[]).push(item);\n    return acc;\n  }, {} as Record<K, T[]>);\n}\n"
        },
        {
          "title": "Approach 3: Map-based grouping (robust keys, then to object)",
          "prose": "Idea: accumulate groups in a `Map` (supports non-string keys reliably), then convert to a plain object at the end.",
          "codeJs": "export default function groupBy(arr, keyFn) {\n  const map = new Map();\n  for (const item of arr) {\n    const key = keyFn(item);\n    if (!map.has(key)) map.set(key, []);\n    map.get(key).push(item);\n  }\n  // Convert to plain object with string keys\n  return Object.fromEntries(Array.from(map.entries(), ([k, v]) => [String(k), v]));\n}\n",
          "codeTs": "export default function groupBy<T, K extends string | number | symbol>(arr: T[], keyFn: (item: T) => K): Record<K, T[]> {\n  const map = new Map<K, T[]>();\n  for (const item of arr) {\n    const key = keyFn(item);\n    const bucket = map.get(key);\n    if (bucket) bucket.push(item); else map.set(key, [item]);\n  }\n  const out = {} as Record<K, T[]>;\n  for (const [k, v] of map.entries()) out[k] = v;\n  return out;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Plain object keys are strings/symbols â€” non-string keys will be stringified.",
          "Ensure `keyFn` is deterministic (same input â†’ same key)."
        ],
        "edgeCases": [
          "Empty array â†’ `{}`.",
          "Many items mapping to the same key â†’ all coalesce into one bucket.",
          "`undefined` or `null` keys are valid but will become the string 'undefined'/'null' when used as object keys."
        ],
        "techniques": [
          "Reduction/folding patterns.",
          "Bucket initialization with nullish coalescing or `||=`.",
          "Using `Map` for robust key handling, then converting to an object."
        ]
      },
      "followUpQuestions": [
        "js-sum-numbers",
        "js-unique-array"
      ],
      "resources": [
        {
          "title": "MDN â€“ Array.prototype.reduce()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
        },
        {
          "title": "MDN â€“ Map",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"
        }
      ]
    },
    "tests": "import groupBy from './groupBy';\n\ndescribe('groupBy', () => {\n  test('groups numbers by Math.floor', () => {\n    const result = groupBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: [4.2], 6: [6.1, 6.3] });\n  });\n\n  test('groups strings by length', () => {\n    const result = groupBy(['one', 'two', 'three'], str => str.length);\n    expect(result).toEqual({ 3: ['one', 'two'], 5: ['three'] });\n  });\n\n  test('groups objects by property', () => {\n    const data = [{ type: 'a' }, { type: 'b' }, { type: 'a' }];\n    const result = groupBy(data, x => x.type);\n    expect(result).toEqual({ a: [{ type: 'a' }, { type: 'a' }], b: [{ type: 'b' }] });\n  });\n\n  test('returns empty object for empty array', () => {\n    expect(groupBy([], Math.floor)).toEqual({});\n  });\n});\n",
    "testsTs": "import groupBy from './groupBy';\n\ndescribe('groupBy (TypeScript)', () => {\n  it('groups numbers by Math.floor', () => {\n    const result = groupBy([6.1, 4.2, 6.3], Math.floor);\n    expect(result).toEqual({ 4: [4.2], 6: [6.1, 6.3] });\n  });\n\n  it('groups strings by length', () => {\n    const result = groupBy(['one', 'two', 'three'], str => str.length);\n    expect(result).toEqual({ 3: ['one', 'two'], 5: ['three'] });\n  });\n\n  it('groups objects by property', () => {\n    const data = [{ type: 'a' }, { type: 'b' }, { type: 'a' }];\n    const result = groupBy(data, x => x.type);\n    expect(result).toEqual({ a: [{ type: 'a' }, { type: 'a' }], b: [{ type: 'b' }] });\n  });\n\n  it('returns empty object for empty array', () => {\n    expect(groupBy([], Math.floor)).toEqual({});\n  });\n});\n"
  },
  {
    "id": "js-event-emitter-mini",
    "title": "Event Emitter (Mini Implementation)",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "medium",
    "importance": 4,
    "tags": [
      "OOP",
      "Async",
      "Design Patterns"
    ],
    "description": {
      "summary": "Implement a simple `Emitter` class that allows subscribing to events with `.on()`, unsubscribing with `.off()`, and triggering events with `.emit()`.",
      "arguments": [],
      "returns": {
        "type": "Emitter",
        "desc": "An instance that supports registering, removing, and invoking event listeners."
      },
      "examples": [
        "// Basic example\nconst emitter = new Emitter()\nconst greet = name => console.log(`Hello, ${name}!`)\nemitter.on('greet', greet)\nemitter.emit('greet', 'Alice') // => Hello, Alice!\n\n// Remove listener\nemitter.off('greet', greet)\nemitter.emit('greet', 'Bob') // => (nothing happens)"
      ]
    },
    "starterCode": "export default class Emitter {\n  constructor() {\n    // TODO: Initialize event storage, e.g. this.events = {}\n  }\n\n  on(event, listener) {\n    // TODO: Add listener to event\n  }\n\n  off(event, listener) {\n    // TODO: Remove listener from event\n  }\n\n  emit(event, ...args) {\n    // TODO: Call all listeners for event\n  }\n}\n",
    "starterCodeTs": "export default class Emitter {\n  private events: Record<string, Array<(...args: any[]) => void>>\n\n  constructor() {\n    // TODO: Initialize event storage\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    // TODO: Add listener to event\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    // TODO: Remove listener from event\n  }\n\n  emit(event: string, ...args: any[]): void {\n    // TODO: Call all listeners for event\n  }\n}\n",
    "solutionBlock": {
      "overview": "Goal: implement a simple publish/subscribe system that allows components to communicate through events without tight coupling.",
      "approaches": [
        {
          "title": "Approach 1: Object-based event registry (baseline)",
          "prose": "Idea: use a plain object where keys are event names and values are arrays of listeners.\n\nHow it works\n1. `.on(event, listener)` adds the listener to an array.\n2. `.off(event, listener)` removes it via filtering.\n3. `.emit(event, ...args)` loops over all listeners and calls them.\n\nWhy use it: very readable and mirrors the logic of Node.js EventEmitter.",
          "codeJs": "export default class Emitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, listener) {\n    if (!this.events[event]) this.events[event] = [];\n    this.events[event].push(listener);\n  }\n\n  off(event, listener) {\n    const list = this.events[event];\n    if (!list) return;\n    this.events[event] = list.filter(l => l !== listener);\n  }\n\n  emit(event, ...args) {\n    const list = this.events[event];\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n",
          "codeTs": "export default class Emitter {\n  private events: Record<string, Array<(...args: any[]) => void>>;\n\n  constructor() {\n    this.events = {};\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    if (!this.events[event]) this.events[event] = [];\n    this.events[event].push(listener);\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    const list = this.events[event];\n    if (!list) return;\n    this.events[event] = list.filter(l => l !== listener);\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const list = this.events[event];\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n"
        },
        {
          "title": "Approach 2: Map-based storage (cleaner key isolation)",
          "prose": "Idea: use a `Map` instead of a plain object to avoid key collisions and improve clarity.\n\nWhy use it: avoids issues with prototype keys like `toString`, supports any key type, and simplifies listener lookup logic.",
          "codeJs": "export default class Emitter {\n  constructor() {\n    this.events = new Map();\n  }\n\n  on(event, listener) {\n    if (!this.events.has(event)) this.events.set(event, []);\n    this.events.get(event).push(listener);\n  }\n\n  off(event, listener) {\n    const list = this.events.get(event);\n    if (!list) return;\n    this.events.set(event, list.filter(l => l !== listener));\n  }\n\n  emit(event, ...args) {\n    const list = this.events.get(event);\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n",
          "codeTs": "export default class Emitter {\n  private events: Map<string, Array<(...args: any[]) => void>>;\n\n  constructor() {\n    this.events = new Map();\n  }\n\n  on(event: string, listener: (...args: any[]) => void): void {\n    if (!this.events.has(event)) this.events.set(event, []);\n    this.events.get(event)!.push(listener);\n  }\n\n  off(event: string, listener: (...args: any[]) => void): void {\n    const list = this.events.get(event);\n    if (!list) return;\n    this.events.set(event, list.filter(l => l !== listener));\n  }\n\n  emit(event: string, ...args: any[]): void {\n    const list = this.events.get(event);\n    if (!list || list.length === 0) return;\n    for (const l of list.slice()) l(...args);\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Removing a listener that doesnâ€™t exist should do nothing.",
          "Mutating listener arrays while emitting may skip calls â€” always clone before iteration."
        ],
        "edgeCases": [
          "Emitting an event that has no listeners â†’ no error should occur.",
          "Removing all listeners should leave an empty array."
        ],
        "techniques": [
          "Use closures or class fields to isolate internal state.",
          "Slice listener array before emitting to prevent concurrent modification."
        ]
      },
      "followUpQuestions": [
        "js-throttle"
      ],
      "resources": [
        {
          "title": "Node.js EventEmitter Docs",
          "url": "https://nodejs.org/api/events.html"
        },
        {
          "title": "MDN â€“ Observer Pattern",
          "url": "https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Code_snippets/Custom_events"
        }
      ]
    },
    "tests": "import Emitter from './Emitter';\n\nconst makeSpy = () => {\n  const fn = (...args) => { fn.calls.push(args); };\n  fn.calls = [];\n  return fn;\n};\n\ndescribe('Emitter', () => {\n  test('calls listener when event is emitted', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 'data');\n    expect(spy.calls.length).toBe(1);\n    expect(spy.calls[0]).toEqual(['data']);\n  });\n\n  test('removes listener correctly', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 1);\n    expect(spy.calls.length).toBe(1);\n    emitter.off('ping', spy);\n    emitter.emit('ping', 2);\n    expect(spy.calls.length).toBe(1);\n  });\n\n  test('handles multiple listeners for same event', () => {\n    const emitter = new Emitter();\n    const a = makeSpy();\n    const b = makeSpy();\n    emitter.on('ping', a);\n    emitter.on('ping', b);\n    emitter.emit('ping', 42);\n    expect(a.calls[0]).toEqual([42]);\n    expect(b.calls[0]).toEqual([42]);\n  });\n});\n",
    "testsTs": "import Emitter from './Emitter';\n\ntype Spy = ((...args: any[]) => void) & { calls: any[][] };\nconst makeSpy = (): Spy => {\n  const fn: any = (...args: any[]) => { fn.calls.push(args); };\n  fn.calls = [] as any[][];\n  return fn as Spy;\n};\n\ndescribe('Emitter (TypeScript)', () => {\n  it('calls listener when event is emitted', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 'data');\n    expect(spy.calls.length).toBe(1);\n    expect(spy.calls[0]).toEqual(['data']);\n  });\n\n  it('removes listener correctly', () => {\n    const emitter = new Emitter();\n    const spy = makeSpy();\n    emitter.on('ping', spy);\n    emitter.emit('ping', 1);\n    expect(spy.calls.length).toBe(1);\n    emitter.off('ping', spy);\n    emitter.emit('ping', 2);\n    expect(spy.calls.length).toBe(1);\n  });\n\n  it('handles multiple listeners for same event', () => {\n    const emitter = new Emitter();\n    const a = makeSpy();\n    const b = makeSpy();\n    emitter.on('ping', a);\n    emitter.on('ping', b);\n    emitter.emit('ping', 42);\n    expect(a.calls[0]).toEqual([42]);\n    expect(b.calls[0]).toEqual([42]);\n  });\n});\n"
  },
  {
    "id": "js-concurrency-map-limit",
    "title": "Concurrency-Limited Map (order-preserving)",
    "type": "coding",
    "technology": "javascript",
    "difficulty": "hard",
    "importance": 5,
    "tags": [
      "Async",
      "Concurrency",
      "Promises",
      "Control Flow"
    ],
    "teaches": [
      "Concurrency control with a worker pool",
      "Backpressure (donâ€™t start new work until a slot frees)",
      "Order-preserving aggregation",
      "Configurable error handling: fail-fast vs all-settled"
    ],
    "description": {
      "summary": "Implement `mapAsyncLimit(items, limit, worker, strategy?)` that runs at most `limit` jobs concurrently, returns results in input order, and supports error strategies `'fail-fast'` or `'all-settled'`.",
      "arguments": [
        {
          "name": "items",
          "type": "T[]",
          "desc": "Inputs to process."
        },
        {
          "name": "limit",
          "type": "number",
          "desc": "Max number of concurrent worker calls. Must be â‰¥ 1."
        },
        {
          "name": "worker",
          "type": "(item: T, index: number) => Promise<R>",
          "desc": "Async mapper."
        },
        {
          "name": "strategy",
          "type": "'fail-fast' | 'all-settled' (optional, default 'fail-fast')",
          "desc": "On error: reject immediately or collect all outcomes."
        }
      ],
      "returns": {
        "type": "Promise<R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>>",
        "desc": "If `'fail-fast'`, resolves to `R[]` or rejects on the first error. If `'all-settled'`, always resolves to settled outcomes in input order."
      },
      "examples": [
        "// Basic (fail-fast)\nawait mapAsyncLimit([3,1,2], 2, async (n,i) => { await sleep(n*10); return n*n })\n// => [9,1,4]\n",
        "// All-settled\nawait mapAsyncLimit([1,2,3], 2, async (n) => { if(n===2) throw new Error('boom'); return n; }, 'all-settled')\n// => [{status:'fulfilled', value:1},{status:'rejected', reason:Error('boom')},{status:'fulfilled', value:3}]"
      ]
    },
    "starterCode": "export default async function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  // TODO:\n  // 1) Validate inputs (limit >= 1)\n  // 2) Launch up to `limit` concurrent runners\n  // 3) Each runner pulls the next index and writes its result at that index\n  // 4) 'fail-fast' rejects on first error, 'all-settled' aggregates statuses\n}\n\nexport const sleep = (ms) => new Promise(r => setTimeout(r, ms));\n",
    "solutionBlock": {
      "overview": "Goal: Execute async work in parallel but never exceed a maximum number of concurrent tasks, while preserving input order and supporting different error-handling strategies.",
      "approaches": [
        {
          "title": "Approach 1: Simple worker-pool with loop control (clean & readable)",
          "prose": "Idea: Maintain a shared `next` index and spawn `limit` workers that each pull new tasks until none remain.\n\nHow it works:\n1. Create a result array of equal length to `items`.\n2. Maintain a shared `next` pointer for the next index to process.\n3. Start up to `limit` async runners.\n4. Each runner picks an index, awaits `worker(item, index)`, and writes the result in place.\n5. If `strategy` = `'fail-fast'`, reject immediately on first error; if `'all-settled'`, collect `{status, value|reason}` objects.\n6. When all tasks complete, resolve the array in the original order.\n\nWhy use it: clean control of concurrency and order, while avoiding Promise.all race conditions.",
          "codeJs": "export default function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  if (!Number.isFinite(limit) || limit < 1) throw new Error('limit must be >= 1');\n  const n = items.length, allSettled = strategy === 'all-settled';\n  const results = new Array(n);\n  if (n === 0) return Promise.resolve(results);\n\n  let next = 0, done = 0, failed = false;\n\n  return new Promise((resolve, reject) => {\n    const runner = async () => {\n      while (true) {\n        const i = next++;\n        if (i >= n || (failed && !allSettled)) break;\n        try {\n          const v = await worker(items[i], i);\n          results[i] = allSettled ? { status: 'fulfilled', value: v } : v;\n        } catch (err) {\n          if (allSettled) results[i] = { status: 'rejected', reason: err };\n          else { failed = true; reject(err); return; }\n        } finally {\n          if (++done === n && (!failed || allSettled)) resolve(results);\n        }\n      }\n    };\n\n    const k = Math.min(limit, n);\n    for (let j = 0; j < k; j++) runner();\n  });\n}\n",
          "codeTs": "export default function mapAsyncLimit<T, R>(items: T[], limit: number, worker: (item: T, index: number) => Promise<R>, strategy: 'fail-fast' | 'all-settled' = 'fail-fast'): Promise<R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>> {\n  if (!Number.isFinite(limit) || limit < 1) throw new Error('limit must be >= 1');\n  const n = items.length, allSettled = strategy === 'all-settled';\n  const results: any[] = new Array(n);\n  if (n === 0) return Promise.resolve(results);\n\n  let next = 0, done = 0, failed = false;\n\n  return new Promise((resolve, reject) => {\n    const runner = async () => {\n      while (true) {\n        const i = next++;\n        if (i >= n || (failed && !allSettled)) break;\n        try {\n          const v = await worker(items[i], i);\n          results[i] = allSettled ? { status: 'fulfilled', value: v } : v;\n        } catch (err) {\n          if (allSettled) results[i] = { status: 'rejected', reason: err };\n          else { failed = true; reject(err); return; }\n        } finally {\n          if (++done === n && (!failed || allSettled)) resolve(results);\n        }\n      }\n    };\n\n    const k = Math.min(limit, n);\n    for (let j = 0; j < k; j++) runner();\n  });\n}\n"
        },
        {
          "title": "Approach 2: Queue-based control with Promise chaining (functional alternative)",
          "prose": "Idea: use an index queue and recursively chain `.then()` calls to fill empty slots.\n\nThis version explicitly schedules the next job after one finishes rather than looping inside a worker. Itâ€™s easier to visualize but less efficient for heavy workloads.\n\nWhy use it: helpful for educational understanding of how concurrency pools refill slots dynamically.",
          "codeJs": "export default async function mapAsyncLimit(items, limit, worker, strategy = 'fail-fast') {\n  if (limit < 1) throw new Error('limit must be >= 1');\n  const results = new Array(items.length);\n  let current = 0;\n\n  async function run() {\n    const i = current++;\n    if (i >= items.length) return;\n    try {\n      const val = await worker(items[i], i);\n      results[i] = val;\n    } catch (err) {\n      if (strategy === 'fail-fast') throw err;\n      results[i] = { status: 'rejected', reason: err };\n    }\n    await run(); // fill next slot\n  }\n\n  const runners = Array.from({ length: Math.min(limit, items.length) }, run);\n  await Promise.allSettled(runners);\n  return results;\n}\n",
          "codeTs": "export default function mapAsyncLimit<T, R>(\n  items: T[],\n  limit: number,\n  worker: (item: T, index: number) => Promise<R>,\n  strategy: 'fail-fast' | 'all-settled' = 'fail-fast'\n): Promise<\n  R[] | Array<{ status: 'fulfilled' | 'rejected'; value?: R; reason?: any }>\n> {\n  if (!Number.isFinite(limit) || limit < 1) {\n    throw new Error('limit must be >= 1');\n  }\n\n  const results: any[] = new Array(items.length);\n  let current = 0;\n\n  const run = async (): Promise<void> => {\n    const i = current++;\n    if (i >= items.length) return;\n\n    try {\n      const val = await worker(items[i], i);\n      results[i] =\n        strategy === 'all-settled'\n          ? { status: 'fulfilled', value: val }\n          : val;\n    } catch (err) {\n      if (strategy === 'fail-fast') throw err;\n      results[i] = { status: 'rejected', reason: err };\n    }\n\n    return run(); // refill the slot\n  };\n\n  const k = Math.min(limit, items.length);\n  const runners = Array.from({ length: k }, () => run());\n\n  return strategy === 'fail-fast'\n    ? Promise.all(runners).then(() => results)\n    : Promise.allSettled(runners).then(() => results);\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting to preserve order â€” storing results directly in completion order breaks determinism.",
          "Not handling rejections properly may hang the promise when using `fail-fast`.",
          "If limit < 1, function must throw immediately."
        ],
        "edgeCases": [
          "Empty input array resolves instantly.",
          "If limit >= items.length, all run concurrently."
        ],
        "techniques": [
          "Use a shared counter for task dispatch.",
          "Keep results in a pre-sized array for order preservation.",
          "Apply Promise-based worker pool pattern for concurrency control."
        ]
      },
      "followUpQuestions": [
        "js-add-two-promises",
        "js-throttle"
      ],
      "resources": [
        {
          "title": "MDN â€“ Using Promises",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises"
        },
        {
          "title": "Jake Archibald â€“ In The Loop (Concurrency explained)",
          "url": "https://www.youtube.com/watch?v=cCOL7MC4Pl0"
        }
      ]
    },
    "tests": "import mapAsyncLimit from './mapAsyncLimit';\n\nconst sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\ndescribe('mapAsyncLimit', () => {\n  test('preserves order with mixed durations', async () => {\n    const items = [30, 10, 20];\n    const out = await mapAsyncLimit(items, 2, async (ms) => { await sleep(ms); return ms / 10; });\n    expect(out).toEqual([3, 1, 2]);\n  });\n\n  test('respects concurrency limit (no more than limit active)', async () => {\n    const items = [30, 30, 30, 30, 30];\n    let active = 0, maxActive = 0;\n    const out = await mapAsyncLimit(items, 2, async (ms) => {\n      active++; if (active > maxActive) maxActive = active;\n      await sleep(ms);\n      active--;\n      return ms;\n    });\n    expect(out).toEqual(items);\n    expect(maxActive <= 2).toEqual(true);\n  });\n\n  test('fail-fast rejects on first error', async () => {\n    const items = [5, 10, 5];\n    let threw = false;\n    try {\n      await mapAsyncLimit(items, 2, async (ms, idx) => {\n        await sleep(ms);\n        if (idx === 1) throw new Error('boom');\n        return idx;\n      }, 'fail-fast');\n    } catch (e) {\n      threw = true;\n      expect(e && e.message).toEqual('boom');\n    }\n    expect(threw).toEqual(true);\n  });\n\n  test('all-settled aggregates outcomes', async () => {\n    const res = await mapAsyncLimit([10, 5, 10, 5], 2, async (ms, idx) => {\n      await sleep(ms);\n      if (idx % 2 === 1) throw new Error('odd');\n      return idx * 10;\n    }, 'all-settled');\n\n    expect(res[0]).toEqual({ status: 'fulfilled', value: 0 });\n    expect(res[1].status).toEqual('rejected');\n    expect(res[2]).toEqual({ status: 'fulfilled', value: 20 });\n    expect(res[3].status).toEqual('rejected');\n  });\n\n  test('throws if limit < 1', () => {\n    let threw = false;\n    try { mapAsyncLimit([1], 0, async (x) => x); } catch (e) { threw = true; }\n    expect(threw).toEqual(true);\n  });\n});\n",
    "testsTs": "import mapAsyncLimit from './mapAsyncLimit';\n\nconst sleep = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\ndescribe('mapAsyncLimit (TS)', () => {\n  test('keeps output order', async () => {\n    const res = await mapAsyncLimit<number, number>([15, 5, 10], 2, async (ms) => { await sleep(ms); return ms / 5; });\n    expect(res).toEqual([3, 1, 2]);\n  });\n\n  test('caps concurrency', async () => {\n    const items = [20, 20, 20, 20];\n    let active = 0, maxActive = 0;\n    const res = await mapAsyncLimit<number, number>(items, 2, async (ms) => {\n      active++; if (active > maxActive) maxActive = active;\n      await sleep(ms);\n      active--; return ms;\n    });\n    expect(res).toEqual(items);\n    expect(maxActive <= 2).toEqual(true);\n  });\n\n  test('fail-fast rejects on first error', async () => {\n    let threw = false;\n    try {\n      await mapAsyncLimit<number, number>([5, 10, 5], 2, async (ms, idx) => {\n        await sleep(ms);\n        if (idx === 1) throw new Error('boom');\n        return idx;\n      }, 'fail-fast');\n    } catch (e: any) {\n      threw = true;\n      expect(e && e.message).toEqual('boom');\n    }\n    expect(threw).toEqual(true);\n  });\n\n  test('all-settled returns settled outcomes', async () => {\n    const res = await mapAsyncLimit<number, number>([5, 10, 5], 2, async (ms, idx) => {\n      await sleep(ms);\n      if (idx === 1) throw new Error('x');\n      return idx * 2;\n    }, 'all-settled') as Array<{ status: 'fulfilled' | 'rejected'; value?: number; reason?: any }>;\n\n    expect(res[0]).toEqual({ status: 'fulfilled', value: 0 });\n    expect(res[1].status).toEqual('rejected');\n    expect(typeof (res[1] as any).reason).toEqual('object');\n    expect(res[2]).toEqual({ status: 'fulfilled', value: 4 });\n  });\n\n  test('throws on invalid limit', () => {\n    let threw = false;\n    try { mapAsyncLimit<number, number>([1], 0, async (x) => x); } catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n});\n"
  },
  {
    "id": "js-abortable-helpers",
    "title": "Abortable Helpers (Timeout + Composed Abort)",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "Async",
      "AbortController",
      "Cancellation",
      "Promises",
      "Utilities"
    ],
    "description": {
      "summary": "Provide utilities to combine timeouts with AbortController, and to compose multiple signals (abort if any fires). All helpers are exposed via a single default export function whose properties are the helpers.",
      "arguments": [
        {
          "name": "withTimeout<T>(p, ms, reason?)",
          "type": "Promise<T>, number, any",
          "desc": "Race a promise against a timeout. Reject with `reason` (or an Error) if the timeout fires; clear the timer if the promise settles first."
        },
        {
          "name": "withAbort<T>(factory, signal)",
          "type": "(signal: AbortSignal) => Promise<T>, AbortSignal",
          "desc": "Run `factory(signal)` and reject if `signal` aborts. If already aborted, reject immediately. Ensure listeners are cleaned up when done."
        },
        {
          "name": "composeAbort(...signals)",
          "type": "AbortSignal[]",
          "desc": "Return a new `AbortSignal` that aborts if ANY input signal aborts; if any is already aborted, the result aborts immediately with the same reason."
        }
      ],
      "returns": {
        "type": "Default export function with properties: { withTimeout, withAbort, composeAbort, sleep }",
        "desc": "Import the default and destructure its properties to use the helpers."
      },
      "examples": [
        "import helpers from './abortable-helpers';",
        "const { withTimeout, withAbort, composeAbort } = helpers;",
        "",
        "await withTimeout(fetch(url), 2000, new Error('Timeout'));",
        "const ac = new AbortController();",
        "await withAbort(doWork, ac.signal);",
        "const combined = composeAbort(ac.signal, new AbortController().signal);"
      ]
    },
    "starterCode": "function abortableHelpers() {}\n\nabortableHelpers.sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\nabortableHelpers.withTimeout = function withTimeout(p, ms, reason) {\n  // TODO: Start a timer; race with p. On settle, clear the timer. On timeout, reject with `reason` or Error('Timeout').\n};\n\nabortableHelpers.withAbort = function withAbort(factory, signal) {\n  // TODO: If signal.aborted -> reject immediately. Otherwise run factory(signal) and listen for 'abort'. Clean up listeners on settle.\n};\n\nabortableHelpers.composeAbort = function composeAbort(...signals) {\n  // TODO: New AbortController; if any input already aborted, abort immediately with its reason; otherwise forward first abort and detach listeners.\n};\n\nexport default abortableHelpers;\n",
    "starterCodeTs": "function abortableHelpers() {}\n\nabortableHelpers['sleep'] = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\nabortableHelpers['withTimeout'] = function withTimeout<T>(p: Promise<T>, ms: number, reason?: any): Promise<T> {\n  // TODO\n  return new Promise<T>((resolve, reject) => { /* impl */ });\n};\n\nabortableHelpers['withAbort'] = function withAbort<T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal): Promise<T> {\n  // TODO\n  return new Promise<T>((resolve, reject) => { /* impl */ });\n};\n\nabortableHelpers['composeAbort'] = function composeAbort(...signals: AbortSignal[]): AbortSignal {\n  // TODO\n  const ac = new AbortController();\n  return ac.signal;\n};\n\nexport default abortableHelpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n",
    "solutionBlock": {
      "overview": "Goal: enable cooperative cancellation and safe async composition using `AbortController`. Helpers simplify racing timeouts, making async functions abortable, and merging multiple signals cleanly.",
      "approaches": [
        {
          "title": "Core idea and cleanup discipline",
          "prose": "We implement a single export `abortableHelpers` object with methods `withTimeout`, `withAbort`, `composeAbort`, and `sleep`.\n\n- **withTimeout(p, ms, reason)**: Races a promise with a timeout.\n- **withAbort(factory, signal)**: Runs cancellable async work.\n- **composeAbort(...signals)**: Merges signals into one â€” aborts when any does.\n\nEach helper ensures proper cleanup of timers or listeners to prevent leaks.",
          "codeJs": "function abortableHelpers() {}\n\nabortableHelpers.sleep = (ms) => new Promise(r => setTimeout(r, ms));\n\nabortableHelpers.withTimeout = function withTimeout(p, ms, reason) {\n  return new Promise((resolve, reject) => {\n    let settled = false;\n    const id = setTimeout(() => {\n      if (settled) return;\n      settled = true;\n      reject(reason ?? new Error('Timeout'));\n    }, ms);\n\n    Promise.resolve(p).then(\n      v => { if (!settled) { settled = true; clearTimeout(id); resolve(v); } },\n      e => { if (!settled) { settled = true; clearTimeout(id); reject(e); } }\n    );\n  });\n};\n\nabortableHelpers.withAbort = function withAbort(factory, signal) {\n  return new Promise((resolve, reject) => {\n    if (signal?.aborted) { reject(signal.reason ?? new Error('Aborted')); return; }\n\n    let finished = false;\n    const onAbort = () => {\n      if (finished) return;\n      finished = true;\n      reject(signal.reason ?? new Error('Aborted'));\n    };\n\n    signal?.addEventListener('abort', onAbort, { once: true });\n\n    Promise.resolve()\n      .then(() => factory(signal))\n      .then(v => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); resolve(v); } })\n      .catch(e => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); reject(e); } });\n  });\n};\n\nabortableHelpers.composeAbort = function composeAbort(...signals) {\n  const ac = new AbortController();\n  if (!signals || signals.length === 0) return ac.signal;\n\n  const already = signals.find(s => s?.aborted);\n  if (already) { ac.abort(already.reason); return ac.signal; }\n\n  const listeners = [];\n  const abortOnce = (reason) => {\n    if (!ac.signal.aborted) ac.abort(reason);\n    for (const { s, fn } of listeners) s.removeEventListener('abort', fn);\n    listeners.length = 0;\n  };\n\n  for (const s of signals) {\n    if (!s) continue;\n    const fn = () => abortOnce(s.reason);\n    s.addEventListener('abort', fn, { once: true });\n    listeners.push({ s, fn });\n  }\n\n  return ac.signal;\n};\n\nexport default abortableHelpers;\n",
          "codeTs": "function abortableHelpers() {}\n\nabortableHelpers['sleep'] = (ms: number) => new Promise<void>(r => setTimeout(r, ms));\n\nabortableHelpers['withTimeout'] = function withTimeout<T>(p: Promise<T>, ms: number, reason?: any): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    let settled = false;\n    const id = setTimeout(() => {\n      if (settled) return;\n      settled = true;\n      reject(reason ?? new Error('Timeout'));\n    }, ms);\n\n    Promise.resolve(p).then(\n      v => { if (!settled) { settled = true; clearTimeout(id); resolve(v); } },\n      e => { if (!settled) { settled = true; clearTimeout(id); reject(e); } }\n    );\n  });\n};\n\nabortableHelpers['withAbort'] = function withAbort<T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    if (signal?.aborted) { reject((signal as any).reason ?? new Error('Aborted')); return; }\n\n    let finished = false;\n    const onAbort = () => {\n      if (finished) return;\n      finished = true;\n      reject((signal as any).reason ?? new Error('Aborted'));\n    };\n\n    signal?.addEventListener('abort', onAbort, { once: true });\n\n    Promise.resolve()\n      .then(() => factory(signal))\n      .then(v => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); resolve(v); } })\n      .catch(e => { if (!finished) { finished = true; signal?.removeEventListener('abort', onAbort); reject(e); } });\n  });\n};\n\nabortableHelpers['composeAbort'] = function composeAbort(...signals: AbortSignal[]): AbortSignal {\n  const ac = new AbortController();\n  if (!signals || signals.length === 0) return ac.signal;\n\n  const already = signals.find(s => s?.aborted);\n  if (already) { ac.abort((already as any).reason); return ac.signal; }\n\n  type L = { s: AbortSignal; fn: () => void };\n  const listeners: L[] = [];\n  const abortOnce = (reason: any) => {\n    if (!ac.signal.aborted) ac.abort(reason);\n    for (const { s, fn } of listeners) s.removeEventListener('abort', fn);\n    listeners.length = 0;\n  };\n\n  for (const s of signals) {\n    if (!s) continue;\n    const fn = () => abortOnce((s as any).reason);\n    s.addEventListener('abort', fn, { once: true });\n    listeners.push({ s, fn });\n  }\n\n  return ac.signal;\n};\n\nexport default abortableHelpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Always remove abort listeners and clear timers to avoid leaks.",
          "Avoid double resolution; track state with a `settled` flag.",
          "If a signal is already aborted, reject immediately without side effects."
        ],
        "edgeCases": [
          "Zero-timeout case (ms = 0) â†’ rejects immediately.",
          "Aborted signal passed to `withAbort` â†’ immediate rejection.",
          "Composed signal with any already-aborted input â†’ aborts instantly."
        ],
        "techniques": [
          "Use AbortController to coordinate cancellations.",
          "Use Promise.race-style logic for timeouts.",
          "Clean up listeners and timers explicitly."
        ]
      },
      "followUpQuestions": [
        "js-add-two-promises"
      ],
      "resources": [
        {
          "title": "MDN â€“ AbortController",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController"
        },
        {
          "title": "MDN â€“ Promise.race()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"
        }
      ]
    },
    "tests": "import helpers from './abortable-helpers';\nconst { withTimeout, withAbort, composeAbort, sleep } = helpers as any;\nfunction _sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }\nconst nap = typeof sleep === 'function' ? sleep : _sleep;\n\ndescribe('Abortable Helpers', () => {\n  test('withTimeout resolves when promise is fast', async () => {\n    const res = await withTimeout(nap(30).then(()=>42), 200);\n    expect(res).toEqual(42);\n  });\n\n  test('withTimeout rejects when timeout wins', async () => {\n    let threw = false; let msg = '';\n    try { await withTimeout(nap(200), 30, new Error('Timeout')); }\n    catch(e){ threw = true; msg = e && e.message; }\n    expect(threw).toEqual(true);\n    expect(!!msg).toEqual(true);\n  });\n\n  test('withAbort resolves if not aborted', async () => {\n    const ac = new AbortController();\n    const val = await withAbort(async (signal) => { await nap(20); return signal.aborted ? -1 : 7; }, ac.signal);\n    expect(val).toEqual(7);\n  });\n\n  test('withAbort rejects when signal aborts', async () => {\n    const ac = new AbortController();\n    let threw = false;\n    try {\n      const p = withAbort(async () => { await nap(100); return 1; }, ac.signal);\n      setTimeout(()=>ac.abort(new Error('Cancelled')), 20);\n      await p;\n    } catch{ threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort aborts when any source aborts', async () => {\n    const a = new AbortController();\n    const b = new AbortController();\n    const c = composeAbort(a.signal, b.signal);\n    expect(c.aborted).toEqual(false);\n\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 'ok'; }, c);\n    setTimeout(()=> b.abort(new Error('Bailed')), 10);\n    try { await p; } catch{ threw = true; }\n    expect(threw).toEqual(true);\n    expect(c.aborted).toEqual(true);\n  });\n\n  test('composeAbort is already aborted if any input is aborted', () => {\n    const a = new AbortController();\n    a.abort(new Error('early'));\n    const c = composeAbort(a.signal, new AbortController().signal);\n    expect(c.aborted).toEqual(true);\n  });\n});\n",
    "testsTs": "import helpers from './abortable-helpers';\nconst { withTimeout, withAbort, composeAbort, sleep } = helpers as unknown as {\n  withTimeout: <T>(p: Promise<T>, ms: number, reason?: any) => Promise<T>,\n  withAbort: <T>(factory: (signal: AbortSignal) => Promise<T>, signal: AbortSignal) => Promise<T>,\n  composeAbort: (...signals: AbortSignal[]) => AbortSignal,\n  sleep: (ms: number) => Promise<void>\n};\n\nfunction _sleep(ms: number){ return new Promise<void>(r=>setTimeout(r, ms)); }\nconst nap = typeof sleep === 'function' ? sleep : _sleep;\n\ndescribe('Abortable Helpers (TS)', () => {\n  test('withTimeout resolves fast', async () => {\n    const res = await withTimeout(Promise.resolve(5), 100);\n    expect(res).toEqual(5);\n  });\n\n  test('withTimeout rejects on timeout', async () => {\n    let threw = false;\n    try { await withTimeout(nap(200).then(()=>42), 10, new Error('Timeout')); }\n    catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('withAbort resolves when not aborted', async () => {\n    const ac = new AbortController();\n    const v = await withAbort(async (signal) => { await nap(15); return signal.aborted ? -1 : 9; }, ac.signal);\n    expect(v).toEqual(9);\n  });\n\n  test('withAbort rejects when aborted', async () => {\n    const ac = new AbortController();\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 1; }, ac.signal);\n    setTimeout(()=>ac.abort(new Error('cancel')), 10);\n    try { await p; } catch { threw = true; }\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort aborts if any input aborts', async () => {\n    const a = new AbortController();\n    const b = new AbortController();\n    const sig = composeAbort(a.signal, b.signal);\n    let threw = false;\n    const p = withAbort(async () => { await nap(100); return 'ok'; }, sig);\n    setTimeout(()=>a.abort(new Error('stop')), 10);\n    try { await p; } catch { threw = true; }\n    expect(sig.aborted).toEqual(true);\n    expect(threw).toEqual(true);\n  });\n\n  test('composeAbort reflects already-aborted inputs', () => {\n    const a = new AbortController(); a.abort(new Error('early'));\n    const sig = composeAbort(a.signal);\n    expect(sig.aborted).toEqual(true);\n  });\n});\n"
  },
  {
    "id": "js-streaming-ndjson-parser",
    "title": "Streaming NDJSON Parser (Web Streams)",
    "type": "coding",
    "technology": "javascript",
    "importance": 5,
    "difficulty": "hard",
    "tags": [
      "Streams",
      "Web Streams API",
      "TextDecoder",
      "Backpressure",
      "Parsing",
      "NDJSON"
    ],
    "description": {
      "summary": "Implement a **streaming** parser for NDJSON (newline-delimited JSON). Read from a `ReadableStream<Uint8Array>`, decode incrementally, split on newlines, parse each line into an object, and recover from malformed lines via a callback without stopping the stream.",
      "arguments": [
        {
          "name": "stream",
          "type": "ReadableStream<Uint8Array>",
          "desc": "Binary stream producing UTF-8 chunks of text containing one JSON object per line."
        },
        {
          "name": "onError",
          "type": "(line: string, err: any) => void (optional)",
          "desc": "Called when a line fails to parse. The parser must **continue** parsing subsequent lines."
        }
      ],
      "returns": {
        "type": "Promise<any[]>",
        "desc": "Resolves with an array of successfully parsed objects (malformed lines are skipped but reported via `onError`)."
      },
      "examples": [
        "// Given a Response with NDJSON body\nconst res = await fetch('/events.ndjson');\nconst objects = await parseNDJSON(res.body, (line, err) => console.warn('bad line:', line, err));\n// objects => an array of parsed items, in order"
      ]
    },
    "starterCode": "/*\n * parseNDJSON(stream, onError?)\n * - Consume a ReadableStream<Uint8Array> using a reader\n * - Use TextDecoder with { stream: true } to correctly handle UTF-8 boundaries\n * - Accumulate into a string buffer; split by \"\\n\" to get complete lines\n * - Keep the trailing partial line in the buffer and prepend the next chunk\n * - For each non-empty line, JSON.parse; on error, call onError(line, err) and continue\n * - After the stream ends, flush the decoder and process the final buffer\n */\nexport default async function parseNDJSON(stream, onError) {\n  // TODO: implement as described above\n}\n\n// CommonJS fallback for runners that require module.exports\ntry { if (typeof module !== 'undefined') module.exports = parseNDJSON; } catch (_) {}\n",
    "starterCodeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: any) => void\n): Promise<any[]> {\n  // TODO: implement\n  return []\n}\n\n// CommonJS fallback\n// @ts-ignore\ntry { if (typeof module !== 'undefined') (module as any).exports = parseNDJSON; } catch (_) {}\n",
    "solutionBlock": {
      "overview": "Goal: build a robust streaming NDJSON parser that respects backpressure, decodes UTF-8 across chunk boundaries, preserves order, and isolates per-line JSON errors so parsing continues.",
      "approaches": [
        {
          "title": "Approach 1: Built-ins pipeline (easiest)",
          "prose": "Use `TextDecoderStream` to handle UTF-8 boundaries and a tiny `TransformStream` to split lines. Minimal state, readable code.",
          "codeJs": "export default async function parseNDJSON(stream, onError){\n  if (!stream?.pipeThrough) throw new Error('ReadableStream expected');\n  const lineSplitter = new TransformStream({\n    start(){ this.buf = ''; },\n    transform(chunk, controller){\n      this.buf += chunk; const parts = this.buf.split('\\n');\n      this.buf = parts.pop() ?? '';\n      for (const line of parts){ const t=line.trim(); if (t) controller.enqueue(t); }\n    },\n    flush(controller){ const t = this.buf.trim(); if (t) controller.enqueue(t); }\n  });\n\n  const out = [];\n  const reader = stream\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(lineSplitter)\n    .getReader();\n\n  while (true){\n    const { value, done } = await reader.read(); if (done) break;\n    try { out.push(JSON.parse(value)); } catch (e){ onError?.(value, e); }\n  }\n  try{ reader.releaseLock(); }catch{}\n  return out;\n}",
          "codeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: unknown) => void\n): Promise<any[]> {\n  if (!('pipeThrough' in stream)) throw new Error('ReadableStream expected');\n\n  const lineSplitter = new TransformStream<string, string>({\n    start() { (this as any).buf = ''; },\n    transform(chunk, controller) {\n      (this as any).buf += chunk;\n      const parts = (this as any).buf.split('\\n');\n      (this as any).buf = parts.pop() ?? '';\n      for (const line of parts) {\n        const t = line.trim();\n        if (t) controller.enqueue(t);\n      }\n    },\n    flush(controller) {\n      const t = ((this as any).buf as string).trim();\n      if (t) controller.enqueue(t);\n    }\n  });\n\n  const out: any[] = [];\n  const reader = stream\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(lineSplitter)\n    .getReader();\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    try { out.push(JSON.parse(value)); } catch (e) { onError?.(value, e); }\n  }\n  try { reader.releaseLock(); } catch {}\n  return out;\n}"
        },
        {
          "title": "Approach 2: Async iterator style (clean & concise)",
          "prose": "Consume bytes with a reader and keep a tiny string buffer. Less plumbing than a pipeline; still clear and efficient.",
          "codeJs": "export default async function parseNDJSON(stream, onError){\n  const reader = stream.getReader(); const dec = new TextDecoder();\n  let buf = '', out = [];\n  const drain = () => { const parts = buf.split('\\n'); buf = parts.pop() ?? '';\n    for (let l of parts){ l = l.trim(); if(!l) continue; try{ out.push(JSON.parse(l)); }catch(e){ onError?.(l,e); } }\n  };\n  while(true){ const {value,done}=await reader.read(); if(done) break;\n    buf += dec.decode(value,{stream:true}); drain(); }\n  buf += dec.decode(); drain(); const tail=buf.trim();\n  if(tail){ try{ out.push(JSON.parse(tail)); }catch(e){ onError?.(tail,e); } }\n  try{ reader.releaseLock(); }catch{}\n  return out;\n}",
          "codeTs": "export default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: unknown) => void\n): Promise<any[]> {\n  const reader = stream.getReader();\n  const dec = new TextDecoder();\n  let buf = '';\n  const out: any[] = [];\n\n  const drain = () => {\n    const parts = buf.split('\\n');\n    buf = parts.pop() ?? '';\n    for (let l of parts) {\n      const t = l.trim();\n      if (!t) continue;\n      try { out.push(JSON.parse(t)); }\n      catch (e) { onError?.(t, e); }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buf += dec.decode(value, { stream: true });\n    drain();\n  }\n\n  buf += dec.decode();\n  drain();\n  const tail = buf.trim();\n  if (tail) {\n    try { out.push(JSON.parse(tail)); }\n    catch (e) { onError?.(tail, e); }\n  }\n\n  try { reader.releaseLock(); } catch {}\n  return out;\n}"
        },
        {
          "title": "Approach 3: Backpressure-focused reader loop (most control)",
          "prose": "The robust, production-ready variant you already have: explicit reader loop, `{ stream: true }` decoding, careful cleanup. Best when you need tight control over resource management or metrics.",
          "codeJs": "/*\n * Streaming NDJSON parser\n * - Efficient: processes data chunk-by-chunk (low memory) and preserves order\n * - Robust: isolates malformed lines via onError callback and continues\n * - Correct decoding: uses TextDecoder(stream:true) for UTF-8 boundaries\n */\nexport default async function parseNDJSON(stream, onError) {\n  if (!stream || typeof stream.getReader !== 'function') {\n    throw new Error('parseNDJSON: expected a ReadableStream<Uint8Array>');\n  }\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n  const out = [];\n\n  const drainLines = () => {\n    const parts = buffer.split('\\n');\n    buffer = parts.pop() ?? '';\n    for (let line of parts) {\n      line = line.trim();\n      if (line === '') continue;\n      try {\n        out.push(JSON.parse(line));\n      } catch (err) {\n        if (typeof onError === 'function') onError(line, err);\n      }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, { stream: true });\n    drainLines();\n  }\n\n  buffer += decoder.decode();\n  drainLines();\n  const tail = buffer.trim();\n  if (tail !== '') {\n    try { out.push(JSON.parse(tail)); }\n    catch (err) { if (typeof onError === 'function') onError(tail, err); }\n  }\n\n  try { reader.releaseLock(); } catch (_) {}\n  return out;\n}\n\ntry { if (typeof module !== 'undefined') module.exports = parseNDJSON; } catch (_) {}\n",
          "codeTs": "/*\n * Streaming NDJSON parser (TypeScript)\n * Same logic, with typed signatures for clarity.\n */\nexport default async function parseNDJSON(\n  stream: ReadableStream<Uint8Array>,\n  onError?: (line: string, err: any) => void\n): Promise<any[]> {\n  if (!stream || typeof (stream as any).getReader !== 'function') {\n    throw new Error('parseNDJSON: expected a ReadableStream<Uint8Array>');\n  }\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n  const out: any[] = [];\n\n  const drainLines = () => {\n    const parts = buffer.split('\\n');\n    buffer = parts.pop() ?? '';\n    for (let raw of parts) {\n      const line = raw.trim();\n      if (line === '') continue;\n      try { out.push(JSON.parse(line)); }\n      catch (err) { if (onError) onError(line, err); }\n    }\n  };\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, { stream: true });\n    drainLines();\n  }\n\n  buffer += decoder.decode();\n  drainLines();\n  const tail = buffer.trim();\n  if (tail !== '') {\n    try { out.push(JSON.parse(tail)); }\n    catch (err) { if (onError) onError(tail, err); }\n  }\n\n  try { reader.releaseLock(); } catch {}\n  return out;\n}\n\n// CommonJS fallback\n// @ts-ignore\ntry { if (typeof module !== 'undefined') (module as any).exports = parseNDJSON; } catch {}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Forgetting `{ stream: true }` on `TextDecoder.decode` can corrupt multi-byte characters split across chunks.",
          "Dropping the trailing partial line between chunks leads to truncated/invalid JSON.",
          "Throwing on a single bad line halts the entire parse â€” prefer `onError` and continue."
        ],
        "edgeCases": [
          "CRLF endings: `\\r\\n` â€” use `trim()` before parsing to remove stray `\\r`.",
          "Empty lines: skip safely.",
          "Final line without trailing `\\n`: parse it after flushing the decoder."
        ],
        "techniques": [
          "Respect backpressure with `getReader()` and `await reader.read()`.",
          "Incremental decode using `TextDecoder` with stream mode.",
          "Carry-over buffer + split-on-newline to align record boundaries."
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "MDN â€“ Streams API",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/Streams_API"
        },
        {
          "title": "MDN â€“ TextDecoder",
          "url": "https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder"
        }
      ]
    },
    "tests": "import parseNDJSON from './ndjson-parser';\n\n// Helper: build a ReadableStream<Uint8Array> that emits given string chunks\nconst te = new TextEncoder();\nfunction streamFromStrings(chunks) {\n  return new ReadableStream({\n    start(controller) {\n      let i = 0;\n      const pump = () => {\n        if (i >= chunks.length) { controller.close(); return; }\n        controller.enqueue(te.encode(chunks[i++]));\n        setTimeout(pump, 0); // async to exercise the reader loop\n      };\n      pump();\n    }\n  });\n}\n\nfunction expectEqual(a, b){ expect(JSON.stringify(a)).toEqual(JSON.stringify(b)); }\n\ndescribe('Streaming NDJSON Parser', () => {\n  test('parses lines across arbitrary chunk boundaries', async () => {\n    const chunks = [\n      '{\"a\":1}\\n{\"b\"',\n      ':2}\\n{\"c\":3}\\n',\n    ];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{a:1},{b:2},{c:3}]);\n  });\n\n  test('handles last line without trailing newline', async () => {\n    const chunks = ['{\"x\":1}\\n{\"y\":2}'];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{x:1},{y:2}]);\n  });\n\n  test('skips blank lines and trims CRLF', async () => {\n    const chunks = ['\\r\\n', '{\"n\":1}\\r\\n', '\\n', '{\"m\":2}\\n'];\n    const res = await parseNDJSON(streamFromStrings(chunks));\n    expectEqual(res, [{n:1},{m:2}]);\n  });\n\n  test('reports malformed lines via onError and continues', async () => {\n    const bad = []; // collect bad lines\n    const chunks = ['{\"ok\":1}\\n', '{bad json}\\n', '{\"ok\":2}\\n'];\n    const res = await parseNDJSON(streamFromStrings(chunks), (line, err) => { bad.push(line); });\n    expectEqual(res, [{ok:1},{ok:2}]);\n    expectEqual(bad, ['{bad json}']);\n  });\n});\n",
    "testsTs": "import parseNDJSON from './ndjson-parser';\n\nconst te = new TextEncoder();\nfunction streamFromStrings(chunks: string[]): ReadableStream<Uint8Array> {\n  return new ReadableStream<Uint8Array>({\n    start(controller) {\n      let i = 0;\n      const pump = () => {\n        if (i >= chunks.length) { controller.close(); return; }\n        controller.enqueue(te.encode(chunks[i++]));\n        setTimeout(pump, 0);\n      };\n      pump();\n    }\n  });\n}\n\nfunction expectEqual(a: any, b: any){ expect(JSON.stringify(a)).toEqual(JSON.stringify(b)); }\n\ndescribe('Streaming NDJSON Parser (TS)', () => {\n  test('parses across chunk boundaries', async () => {\n    const res = await parseNDJSON(streamFromStrings(['{\"a\":1}\\n{\"b\"', ':2}\\n']));\n    expectEqual(res, [{a:1},{b:2}]);\n  });\n\n  test('no trailing newline', async () => {\n    const res = await parseNDJSON(streamFromStrings(['{\"x\":1}\\n{\"y\":2}']));\n    expectEqual(res, [{x:1},{y:2}]);\n  });\n\n  test('error isolation', async () => {\n    const errors: string[] = [];\n    const res = await parseNDJSON(streamFromStrings(['{\"ok\":1}\\n','{oops}\\n','{\"ok\":2}\\n']), (line) => errors.push(line));\n    expectEqual(res, [{ok:1},{ok:2}]);\n    expectEqual(errors, ['{oops}']);\n  });\n});\n"
  },
  {
    "id": "js-array-prototype-map",
    "title": "Implement Array.prototype.map",
    "type": "coding",
    "companies": [
      "amazon",
      "apple"
    ],
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "Arrays",
      "Callbacks",
      "Iteration",
      "Polyfills"
    ],
    "teaches": [
      "How built-in array iteration works under the hood",
      "Correct callback invocation and thisArg binding",
      "Handling sparse arrays (holes) correctly",
      "Spec-aware details: boxing, length coercion, property checks"
    ],
    "description": {
      "summary": "Recreate the native `.map()` method **without using it**. Your `myMap` must call the callback for each existing index, pass `(value, index, array)`, respect `thisArg`, and return a new array with the mapped values. It must **skip holes** (no callback for missing indices) and preserve array length.",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "(currentValue: any, index: number, array: any[]) => any",
          "desc": "Function to execute on each existing element."
        },
        {
          "name": "thisArg",
          "type": "any (optional)",
          "desc": "Value to use as `this` when executing callback."
        }
      ],
      "returns": {
        "type": "Array",
        "desc": "A new array with the results of calling `callbackFn` on every existing element."
      },
      "examples": [
        "[1, 2, 3].myMap(x => x * 2) // => [2, 4, 6]",
        "[, 10, , 30].myMap((v,i) => i) // => [ , 1, , 3 ] (holes preserved)",
        "[1].myMap(function(x){ return this.add + x }, { add: 5 }) // => [6]"
      ]
    },
    "starterCode": "/* Boilerplate â€” replace the throw with a correct implementation */\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};\n",
    "starterCodeTs": "declare global {\n  interface Array<T> {\n    myMap<U>(\n      callbackFn: (value: T, index: number, array: Array<T>) => U,\n      thisArg?: any\n    ): Array<U>;\n  }\n}\n\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};\n",
    "solutionBlock": {
      "overview": "Goal: implement a `.map()`-like method that iterates indices 0..lengthâˆ’1, calls the callback with `(value, index, array)`, respects `thisArg`, **skips holes**, and returns a new array with the same length. Approach 1 is the simplest practical variant; Approach 2 is closer to the spec.",
      "approaches": [
        {
          "title": "Approach 1: Simple for-loop (practical baseline)",
          "prose": "Idea: create an output array of the same length and fill it as we go. Only call the callback for **real** elements (skip holes) and write each result at the same index.\n\nHow it works\n1) Read the length once: `len = this.length`.\n2) Pre-create the result array: `out = new Array(len)` (so length/holes are preserved).\n3) Loop `k = 0 â†’ len âˆ’ 1`.\n4) If `Object.hasOwn(this, k)` is true, the slot exists â†’ call the callback with context: `callbackFn.call(thisArg, this[k], k, this)`.\n5) Put the returned value at `out[k]`.\n6) Return `out`.\n\nWhy it works\n- `Object.hasOwn` skips missing indices (holes), matching how native `map` behaves on sparse arrays.\n- Writing results by index keeps output length and hole positions identical to the input.\n\nComplexity\n- Time: O(n) (single pass).  Space: O(n) for the output array.",
          "codeJs": "Array.prototype.myMap = function (callbackFn, thisArg) {\n  const len = this.length;\n  const out = new Array(len);\n  for (let k = 0; k < len; k++) {\n    if (Object.hasOwn(this, k)) {\n      out[k] = callbackFn.call(thisArg, this[k], k, this);\n    }\n  }\n  return out;\n};\n",
          "codeTs": "interface Array<T> {\n  myMap<U>(\n    callbackFn: (value: T, index: number, array: Array<T>) => U,\n    thisArg?: any\n  ): Array<U>;\n}\n\nArray.prototype.myMap = function <T, U>(this: T[], callbackFn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[] {\n  const len: number = this.length;\n  const out = new Array<U>(len);\n  for (let k = 0; k < len; k++) {\n    if (Object.hasOwn(this, k)) {\n      out[k] = callbackFn.call(thisArg, (this as T[])[k], k, this as T[]);\n    }\n  }\n  return out;\n};\n"
        },
        {
          "title": "Approach 2: Spec-leaning (ToObject + length coercion + `k in O`)",
          "prose": "Idea: mirror native semantics more closely. Convert `this` to an object, coerce `length` safely, and use `k in O` so inherited numeric properties count as elements (like the real `.map()`).\n\nHow it works\n1) Box the receiver: `const O = Object(this)`.\n2) Coerce length: `len = Math.max(0, Math.floor(Number(O.length) || 0))`.\n3) Create `out = new Array(len)`.\n4) Loop `k = 0 â†’ len âˆ’ 1`.\n5) If `(k in O)` is true, call `callbackFn.call(thisArg, O[k], k, O)` and assign to `out[k]`.\n6) Return `out`.\n\nWhy it works\n- `k in O` matches the specâ€™s property lookup rules (own or inherited).\n- Pre-sized array keeps indices aligned with the original.\n\nComplexity\n- Time: O(n).  Space: O(n) for the output array.",
          "codeJs": "Array.prototype.myMap = function (callbackFn, thisArg) {\n  const O = Object(this);\n  const len = Math.max(0, Math.floor(Number(O.length) || 0));\n  const out = new Array(len);\n  for (let k = 0; k < len; k++) {\n    if (k in O) {\n      out[k] = callbackFn.call(thisArg, O[k], k, O);\n    }\n  }\n  return out;\n};\n",
          "codeTs": "Array.prototype.myMap = function <T, U>(this: T[], callbackFn: (value: T, index: number, array: Array<T>) => U, thisArg?: any): U[] {\n  const O = Object(this) as Record<string | number, T> & { length: number };\n  const len: number = Math.max(0, Math.floor(Number(O.length) || 0));\n  const out = new Array<U>(len);\n  for (let k = 0; k < len; k++) {\n    if (k in O) {\n      out[k] = callbackFn.call(thisArg, O[k] as T, k, O as unknown as T[]);\n    }\n  }\n  return out;\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Calling the callback for holes: use `Object.hasOwn(this, k)` or be intentional with `k in O`.",
          "`thisArg` is ignored by arrow functions by designâ€”use a normal function if you need `this`.",
          "Forgetting to preserve length/holes (e.g., using `push`) changes the array shape."
        ],
        "edgeCases": [
          "Sparse arrays like `[,10,,30]` â†’ callbacks should run only for existing indices.",
          "Inherited numeric keys: Approach 2 includes them; Approach 1 does not.",
          "Mutations during mapping can affect later iterations (same as native)."
        ],
        "techniques": [
          "Coerce the receiver with `Object(this)` when you want spec-accurate behavior.",
          "Coerce length safely with `Math.floor(Number(len) || 0)` (or `>>> 0` if allowed).",
          "Use `.call(thisArg, value, index, array)` to bind callback context.",
          "Preallocate the output array to keep indices aligned."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-filter",
        "js-array-prototype-reduce",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN â€“ Array.prototype.map()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"
        },
        {
          "title": "ECMAScript Spec â€“ Array.prototype.map",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.map"
        }
      ]
    },
    "tests": "const identity = (x) => x;\nconst square = (n) => n * n;\n\ndescribe('Array.prototype.myMap', () => {\n  test('identity', () => {\n    expect([10].myMap(identity)).toEqual([10]);\n    expect([10, 20].myMap(identity)).toEqual([10, 20]);\n  });\n\n  test('square', () => {\n    expect([-4].myMap(square)).toEqual([16]);\n    expect([5].myMap(square)).toEqual([25]);\n  });\n\n  test('skips holes and preserves length', () => {\n    const a = [, 10, , 30];\n    const r = a.myMap((v, i) => i);\n    expect(r.length).toBe(4);\n    expect(0 in r).toBe(false);\n    expect(1 in r).toBe(true);\n    expect(2 in r).toBe(false);\n    expect(3 in r).toBe(true);\n  });\n\n  test('binds thisArg', () => {\n    const ctx = { add: 5 };\n    const out = [1].myMap(function (x) { return this.add + x; }, ctx);\n    expect(out).toEqual([6]);\n  });\n});\n",
    "testsTs": "// @ts-nocheck\nconst _shimMap = (arr, cb, thisArg) => {\n  const O = Object(arr);\n  let len = Math.max(0, Math.floor(Number(O.length) || 0));\n  const A = new Array(len);\n  for (let k = 0; k < len; k++) {\n    if (k in O) A[k] = cb.call(thisArg, O[k], k, O);\n  }\n  return A;\n};\n\nconst callMap = (arr, cb, thisArg) =>\n  typeof arr.myMap === 'function' ? arr.myMap(cb, thisArg) : _shimMap(arr, cb, thisArg);\n\nconst identity = (element) => element;\nconst square = (element) => element * element;\n\ndescribe('Array.prototype.myMap', () => {\n  test('identity', () => {\n    expect(callMap([10], identity)).toEqual([10]);\n    expect(callMap([10, 20], identity)).toEqual([10, 20]);\n  });\n\n  test('square', () => {\n    expect(callMap([-4], square)).toEqual([16]);\n    expect(callMap([5], square)).toEqual([25]);\n  });\n});\n"
  },
  {
    "id": "js-array-prototype-reduce",
    "title": "Implement Array.prototype.reduce",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "amazon",
      "apple"
    ],
    "importance": 4,
    "difficulty": "medium",
    "tags": [
      "Arrays",
      "Callbacks",
      "Iteration",
      "Polyfills",
      "Accumulators"
    ],
    "teaches": [
      "How array reduction works under the hood",
      "Accumulator initialization with or without an initial value",
      "Handling sparse arrays (holes) correctly",
      "Throwing on empty arrays without an initial value"
    ],
    "description": {
      "summary": "Recreate the native `.reduce()` method **without using it**. Your `myReduce` must call the reducer with `(accumulator, currentValue, index, array)` only for existing indices, handle an optional `initialValue`, and return the final accumulator. If no `initialValue` is provided, use the **first existing element** as the initial accumulator. If there is **no existing element** and no `initialValue`, throw a `TypeError`.",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "(accumulator: any, currentValue: any, index: number, array: any[]) => any",
          "desc": "Reducer function applied to each existing element."
        },
        {
          "name": "initialValue",
          "type": "any (optional)",
          "desc": "Value to use as the first accumulator. If omitted, the first existing element is used."
        }
      ],
      "returns": {
        "type": "any",
        "desc": "The final accumulated value after iterating through the array."
      },
      "examples": [
        "[1, 2, 3].myReduce((acc, x) => acc + x, 0) // => 6",
        "[, 1, , 3].myReduce((acc, x) => acc + x)   // => 4 (skips holes; starts at 1)",
        "[].myReduce((a, x) => a + x, 10)           // => 10"
      ]
    },
    "starterCode": "/* Boilerplate â€” replace the throw with a correct implementation */\nArray.prototype.myReduce = function (callbackFn, initialValue) {\n  throw 'Not implemented!';\n};\n",
    "starterCodeTs": "declare global {\n  interface Array<T> {\n    myReduce<U>(\n      callbackFn: (accumulator: U, currentValue: T, index: number, array: Array<T>) => U,\n      initialValue: U\n    ): U;\n    myReduce(\n      callbackFn: (accumulator: T, currentValue: T, index: number, array: Array<T>) => T\n    ): T;\n  }\n}\n\nArray.prototype.myReduce = function (callbackFn: any, initialValue?: any) {\n  throw 'Not implemented!';\n};\n",
    "solutionBlock": {
      "overview": "What a correct `.reduce()` must do: (1) Work on the receiver and read its `length` directly. (2) If `initialValue` is provided, start with it; otherwise find the first existing element as the initial accumulator (skip holes) or throw on empty. (3) For each existing index, call `callbackFn(acc, value, index, array)` and store back to `acc`. (4) Skip holes using an own-property check. (5) Return the final `acc`.",
      "approaches": [
        {
          "title": "Approach 1: Simple for-loop (practical baseline)",
          "prose": "Iterate 0..length-1, seed the accumulator from `initialValue` or the first present element, and skip holes with an own-property check. Clear, fast, and mirrors everyday expectations.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = O.length >>> 0; // coerce to uint32 without changing semantics\n  let k = 0;\n  let acc;\n  if (arguments.length > 1) {\n    acc = initialValue;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(O, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      acc = callbackFn(acc, O[k], k, O);\n    }\n  }\n  return acc;\n};\n",
          "codeTs": "declare global {\n  interface Array<T> {\n    myReduce<U>(cb: (acc: U, cur: T, idx: number, arr: T[]) => U, initialValue: U): U;\n    myReduce(cb: (acc: T, cur: T, idx: number, arr: T[]) => T): T;\n  }\n}\n\nArray.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as T[] & { length: number };\n  const len: number = (O.length >>> 0);\n  let k = 0;\n  let acc: any;\n  if (arguments.length > 2 || (arguments.length === 2 && initialValue !== undefined)) {\n    acc = initialValue as U;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(O, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = (O as any)[k++];\n  }\n  for (; k < len; k++) {\n    if (Object.prototype.hasOwnProperty.call(O, k)) {\n      acc = (callbackFn as any)(acc, (O as any)[k], k, O);\n    }\n  }\n  return acc as any;\n};\n"
        },
        {
          "title": "Approach 2: Spec-leaning (`ToObject`, length coercion, `k in O`)",
          "prose": "Closer to native semantics: coerce `this` with `Object(this)`, coerce length with `Math.floor(Number(...))`, and use `k in O` to honor inherited index accessors (native does). Still skips actual holes when nothing is inherited at that index.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = Math.max(0, Math.floor(Number(O.length) || 0));\n  let k = 0;\n  let acc;\n  if (arguments.length > 1) {\n    acc = initialValue;\n  } else {\n    while (k < len && !(k in O)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) {\n    if (k in O) acc = callbackFn(acc, O[k], k, O);\n  }\n  return acc;\n};\n",
          "codeTs": "Array.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as Record<number, T> & { length: number };\n  const len: number = Math.max(0, Math.floor(Number(O.length) || 0));\n  let k = 0;\n  let acc: any;\n  if (arguments.length > 2 || (arguments.length === 2 && initialValue !== undefined)) {\n    acc = initialValue as U;\n  } else {\n    while (k < len && !(k in O)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (; k < len; k++) if (k in O) acc = (callbackFn as any)(acc, O[k], k, O as any);\n  return acc as any;\n};\n"
        },
        {
          "title": "Approach 3: Helper-driven (readability: `nextPresentIndex`)",
          "prose": "Extract the â€˜find next present elementâ€™ logic into a tiny helper. This makes the seeding + iteration steps very explicit and easy to reason about for sparse arrays.",
          "codeJs": "Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const O = Object(this);\n  const len = O.length >>> 0;\n  const nextPresentIndex = (start) => {\n    let i = start; while (i < len && !Object.prototype.hasOwnProperty.call(O, i)) i++; return i;\n  };\n  let k = 0;\n  let acc;\n  if (arguments.length > 1) {\n    acc = initialValue; k = nextPresentIndex(0);\n  } else {\n    k = nextPresentIndex(0);\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = O[k++];\n  }\n  for (k = nextPresentIndex(k); k < len; k = nextPresentIndex(k + 1)) {\n    acc = callbackFn(acc, O[k], k, O);\n  }\n  return acc;\n};\n",
          "codeTs": "Array.prototype.myReduce = function <T, U>(\n  this: T[],\n  callbackFn: ((acc: U, cur: T, idx: number, arr: T[]) => U) | ((acc: T, cur: T, idx: number, arr: T[]) => T),\n  initialValue?: U\n): U | T {\n  const O = Object(this) as T[] & { length: number };\n  const len: number = (O.length >>> 0);\n  const hasOwn = Object.prototype.hasOwnProperty;\n  const nextPresentIndex = (start: number): number => {\n    let i = start; while (i < len && !hasOwn.call(O, i)) i++; return i;\n  };\n  let k = 0;\n  let acc: any;\n  if (arguments.length > 2 || (arguments.length === 2 && initialValue !== undefined)) {\n    acc = initialValue as U; k = nextPresentIndex(0);\n  } else {\n    k = nextPresentIndex(0);\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = (O as any)[k++];\n  }\n  for (k = nextPresentIndex(k); k < len; k = nextPresentIndex(k + 1)) {\n    acc = (callbackFn as any)(acc, (O as any)[k], k, O);\n  }\n  return acc as any;\n};\n"
        }
      ]
    },
    "notes": {
      "pitfalls": [
        "Using `this[0]` as the seed even when index 0 is a hole â€” must scan for the **first present** element.",
        "Forgetting to skip holes (use own-property checks or `k in O` as appropriate).",
        "Not throwing on an empty array when `initialValue` is omitted."
      ],
      "edgeCases": [
        "All holes (e.g., `[,,,]`) with no `initialValue` â†’ throw `TypeError`.",
        "Arrays with leading holes (e.g., `[,1,,3]`) â†’ seed from `1` when `initialValue` is omitted.",
        "Arrays with getters on inherited indices: if you use `k in O`, inherited accessors may participate."
      ],
      "techniques": [
        "Coerce the receiver with `Object(this)` before reading `length`.",
        "Seed from `initialValue` when provided; otherwise scan for the first present element.",
        "Use `hasOwnProperty.call(O, k)` to skip holes consistently."
      ]
    },
    "followUpQuestions": [
      "js-array-prototype-map",
      "js-array-prototype-filter",
      "js-array-prototype-some"
    ],
    "resources": [
      {
        "title": "MDN â€“ Array.prototype.reduce()",
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"
      },
      {
        "title": "ECMAScript Spec (Reduce)",
        "url": "https://tc39.es/ecma262/#sec-array.prototype.reduce"
      }
    ],
    "tests": "const sum = (a, x) => a + x;\nconst pair = (a, x, i) => a.concat([[i, x]]);\n\n// helper for throw assertions (no toThrow in this runner)\nconst expectThrowsTypeError = (fn) => {\n  let ok = false;\n  try { fn(); } catch (e) { ok = e instanceof TypeError; }\n  expect(ok).toBe(true);\n};\n\ndescribe('Array.prototype.myReduce', () => {\n  test('with initialValue on dense arrays', () => {\n    expect([1, 2, 3].myReduce(sum, 0)).toBe(6);\n    expect([5].myReduce(sum, 10)).toBe(15);\n  });\n\n  test('without initialValue uses first existing element (handles leading holes)', () => {\n    const a = [, 1, , 3];\n    expect(a.myReduce(sum)).toBe(4);\n  });\n\n  test('skips holes (sparse arrays) with initialValue', () => {\n    const a = [, 1, , 3];\n    expect(a.myReduce(sum, 0)).toBe(4);\n  });\n\n  test('passes index and array correctly', () => {\n    const out = [10, 20].myReduce(pair, []);\n    expect(out).toEqual([[0, 10], [1, 20]]);\n  });\n\n  test('empty array with initialValue returns initialValue', () => {\n    expect([].myReduce(sum, 42)).toBe(42);\n  });\n\n  test('empty array without initialValue throws TypeError', () => {\n    expectThrowsTypeError(() => [].myReduce(sum));\n  });\n});\n",
    "testsTs": "// @ts-nocheck\nconst _shimReduce = (arr, cb, initProvided, initVal) => {\n  const len = arr.length;\n  let k = 0;\n  let acc;\n  if (initProvided) {\n    acc = initVal;\n  } else {\n    while (k < len && !Object.prototype.hasOwnProperty.call(arr, k)) k++;\n    if (k >= len) throw new TypeError('Reduce of empty array with no initial value');\n    acc = arr[k++];\n  }\n  for (; k < len; k++) if (Object.prototype.hasOwnProperty.call(arr, k)) acc = cb(acc, arr[k], k, arr);\n  return acc;\n};\n\nconst callReduce = (arr, cb, ...rest) =>\n  typeof arr.myReduce === 'function'\n    ? arr.myReduce(cb, ...rest)\n    : _shimReduce(arr, cb, rest.length > 0, rest[0]);\n\nconst sum = (a, x) => a + x;\n\nconst expectThrowsTypeError = (fn) => {\n  let ok = false; try { fn(); } catch (e) { ok = e instanceof TypeError; } expect(ok).toBe(true);\n};\n\ndescribe('Array.prototype.myReduce (TS)', () => {\n  test('sum with initialValue', () => {\n    expect(callReduce([1, 2, 3], sum, 0)).toBe(6);\n  });\n  test('sum without initialValue (holes at start)', () => {\n    expect(callReduce([,1,,3], sum)).toBe(4);\n  });\n  test('sparse array skipping with initialValue', () => {\n    expect(callReduce([,1,,3], sum, 0)).toBe(4);\n  });\n  test('empty + initial returns initial', () => {\n    expect(callReduce([], sum, 7)).toBe(7);\n  });\n  test('empty without initial throws', () => {\n    expectThrowsTypeError(() => callReduce([], sum));\n  });\n});\n"
  },
  {
    "id": "js-array-prototype-filter",
    "title": "Implement Array.prototype.filter",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "amazon",
      "apple"
    ],
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "callbacks",
      "iteration",
      "polyfills",
      "core-js"
    ],
    "description": {
      "summary": "Recreate the native `Array.prototype.filter()` method as `myFilter`. It should call a provided callback once for each element in the array, include the element in the new array if the callback returns a truthy value, skip holes in sparse arrays, and support an optional `thisArg` for context.",
      "arguments": [
        {
          "name": "callbackFn",
          "type": "function",
          "desc": "Function to test each element. It receives (element, index, array) as arguments."
        },
        {
          "name": "thisArg",
          "type": "any",
          "desc": "Value to use as `this` when executing `callbackFn`."
        }
      ],
      "returns": {
        "type": "Array",
        "desc": "A new array with elements that passed the test implemented by `callbackFn`."
      },
      "examples": [
        "// Filter even numbers\n[1, 2, 3, 4, 5].myFilter(n => n % 2 === 0) // => [2, 4]",
        "// Filter by context\n[1, 2, 3, 4, 5].myFilter(function(n) { return n > this.min; }, { min: 3 }) // => [4, 5]"
      ]
    },
    "starterCode": "Array.prototype.myFilter = function(callbackFn, thisArg) {\n  throw new Error('Not implemented');\n};\n",
    "starterCodeTs": "interface Array<T> {\n  myFilter<U extends T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];\n}\n\nArray.prototype.myFilter = function<T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[] {\n  throw new Error('Not implemented');\n};\n",
    "solutionBlock": {
      "overview": "Goal: implement a `.filter()`-like method that iterates indices 0..length-1, calls the predicate with `(value, index, array)`, **skips holes**, respects `thisArg`, and returns a **new** array of values for which the predicate is truthy.",
      "approaches": [
        {
          "title": "Approach 1: Variadic for-loop using own-property check (simplest)",
          "prose": "Idea: build a new array while looping once. Only call the predicate for **real** elements (skip holes), bind `thisArg`, and push when the predicate is truthy.\n\nHow it works\n1) Guardrails: throw if called on null/undefined or if `callbackFn` isnâ€™t a function.\n2) Coerce the receiver: `const arr = Object(this)` so we can safely read `length`.\n3) Snapshot `length` once: `len = arr.length >>> 0`.\n4) Create an empty result array: `const result = []`.\n5) Loop `i = 0 â†’ len - 1`:\n   â€¢ If `Object.hasOwn(arr, i)` is **true**, the slot exists (not a hole).\n   â€¢ Read `val = arr[i]`.\n   â€¢ Run predicate with context: `callbackFn.call(thisArg, val, i, arr)`.\n   â€¢ If truthy, `result.push(val)`.\n6) Return `result`.\n\nWhy it works\n- `Object.hasOwn` skips missing indices â†’ no predicate calls for holes.\n- Using `.call(thisArg, ...)` mirrors native `filter`â€™s `this` handling.\n- We only scan once and push in order â†’ same output order as the input.\n\nComplexity\n- Time: O(n) â€” one pass.\n- Space: O(k) â€” number of kept items.",
          "codeJs": "Array.prototype.myFilter = function(callbackFn, thisArg) {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(callbackFn + ' is not a function');\n  const arr = Object(this);\n  const len = arr.length >>> 0;\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    if (Object.hasOwn(arr, i)) {\n      const val = arr[i];\n      if (callbackFn.call(thisArg, val, i, arr)) result.push(val);\n    }\n  }\n  return result;\n};\n",
          "codeTs": "interface Array<T> {\n  myFilter<U extends T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[];\n}\n\nArray.prototype.myFilter = function<T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[] {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n  const arr = Object(this) as { [k: number]: T; length: number };\n  const len = arr.length >>> 0;\n  const result: T[] = [];\n  for (let i = 0; i < len; i++) {\n    if (Object.hasOwn(arr, i)) {\n      const val = arr[i];\n      if (callbackFn.call(thisArg, val, i, arr)) result.push(val);\n    }\n  }\n  return result;\n};\n"
        },
        {
          "title": "Approach 2: Spec-leaning â€” include inherited numeric keys with `k in O`",
          "prose": "Idea: behave closer to the spec by considering numeric keys that come from the prototype chain (`k in O`). That allows inherited getters at numeric indices to participate.\n\nHow it works\n1) Validate inputs (same as Approach 1).\n2) Coerce the receiver: `const O = Object(this)`.\n3) Coerce length once: `len = Math.max(0, Math.floor(Number(O.length) || 0))`.\n4) Prepare `out = []`.\n5) Loop `k = 0 â†’ len - 1`:\n   â€¢ If `(k in O)` is **true**, treat it as an element (own or inherited).\n   â€¢ Get `v = O[k]` (may trigger an inherited getter).\n   â€¢ If `callbackFn.call(thisArg, v, k, O)` is truthy â†’ `out.push(v)`.\n6) Return `out`.\n\nWhy it works\n- `k in O` mirrors ECMAScript iteration semantics for array methods that consult the prototype chain.\n- Still returns a dense array of matches in the original order.\n\nComplexity\n- Time: O(n).\n- Space: O(k).",
          "codeJs": "Array.prototype.myFilter = function(callbackFn, thisArg) {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(callbackFn + ' is not a function');\n  const O = Object(this);\n  const len = Math.max(0, Math.floor(Number(O.length) || 0));\n  const out = [];\n  for (let k = 0; k < len; k++) {\n    if (k in O) {\n      const v = O[k];\n      if (callbackFn.call(thisArg, v, k, O)) out.push(v);\n    }\n  }\n  return out;\n};\n",
          "codeTs": "Array.prototype.myFilter = function<T>(callbackFn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): T[] {\n  if (this == null) throw new TypeError('Array.prototype.myFilter called on null/undefined');\n  if (typeof callbackFn !== 'function') throw new TypeError(String(callbackFn) + ' is not a function');\n  const O = Object(this) as Record<number, T> & { length: number };\n  const len: number = Math.max(0, Math.floor(Number(O.length) || 0));\n  const out: T[] = [];\n  for (let k = 0; k < len; k++) {\n    if (k in O) {\n      const v = O[k];\n      if (callbackFn.call(thisArg, v, k, O as any)) out.push(v);\n    }\n  }\n  return out;\n};\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Calling the predicate for holes â€” use `Object.hasOwn` or `k in O` depending on whether you want to include inherited indices.",
          "Mutating the array while filtering can affect subsequent iterations (same as native).",
          "Forgetting to validate `callbackFn` and `this` can cause confusing errors."
        ],
        "edgeCases": [
          "Sparse arrays: `[1, , 3]` â†’ predicate is not called for the missing index when using own-property checks.",
          "Inherited getters at numeric keys: with `k in O`, those can be considered elements.",
          "`thisArg` binding: arrow functions ignore `thisArg` by design."
        ],
        "techniques": [
          "Coerce the receiver with `Object(this)` and read `length` once.",
          "Prefer `>>> 0` or `Math.floor(Number(...))` to safely coerce `length`.",
          "Use `.call(thisArg, value, index, array)` to pass context."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-map",
        "js-array-prototype-reduce",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN â€“ Array.prototype.filter()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"
        },
        {
          "title": "ECMAScript Spec (Filter)",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.filter"
        }
      ]
    },
    "tests": "describe('Array.prototype.myFilter', () => {\n  test('filters even numbers', () => {\n    const res = [1, 2, 3, 4, 5].myFilter(x => x % 2 === 0);\n    expect(res).toEqual([2, 4]);\n  });\n\n  test('returns empty array when nothing matches', () => {\n    const res = [1, 3, 5].myFilter(x => x % 2 === 0);\n    expect(res).toEqual([]);\n  });\n\n  test('does not mutate original array', () => {\n    const arr = [1, 2, 3];\n    arr.myFilter(x => x > 1);\n    expect(arr).toEqual([1, 2, 3]);\n  });\n\n  test('uses thisArg correctly', () => {\n    const ctx = { min: 3 };\n    const res = [1, 2, 3, 4, 5].myFilter(function(x) { return x > this.min; }, ctx);\n    expect(res).toEqual([4, 5]);\n  });\n\n  test('skips holes in sparse arrays', () => {\n    const arr = [1, , 3];\n    const res = arr.myFilter(x => true);\n    expect(res).toEqual([1, 3]);\n  });\n});\n",
    "testsTs": "describe('Array.prototype.myFilter (TypeScript)', () => {\n  it('should filter even numbers', () => {\n    const result = [1, 2, 3, 4, 5].myFilter(n => n % 2 === 0);\n    expect(result).toEqual([2, 4]);\n  });\n\n  it('should handle empty results correctly', () => {\n    const result = [1, 3, 5].myFilter(n => n % 2 === 0);\n    expect(result).toEqual([]);\n  });\n\n  it('should use thisArg for context', () => {\n    const ctx = { min: 3 };\n    const result = [1, 2, 3, 4, 5].myFilter(function(x) { return x > this.min; }, ctx);\n    expect(result).toEqual([4, 5]);\n  });\n});\n"
  },
  {
    "id": "js-array-foreach",
    "title": "Implement Array.forEach (no prototype mutation)",
    "type": "coding",
    "technology": "javascript",
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "arrays",
      "iteration",
      "callbacks",
      "edge-cases"
    ],
    "description": {
      "summary": "Write a `forEach` helper that invokes a callback for each existing element in an array, in order, without mutating prototypes. Tests sparse arrays, callback binding, and mutation during iteration.",
      "arguments": [
        {
          "name": "arr",
          "type": "Array<any>",
          "desc": "Source array to iterate. Sparse slots must be skipped."
        },
        {
          "name": "callbackFn",
          "type": "(value:any, index:number, array:any[]) => void",
          "desc": "Function to invoke for each present element."
        },
        {
          "name": "thisArg",
          "type": "any (optional)",
          "desc": "Value of `this` inside `callbackFn`."
        }
      ],
      "returns": {
        "type": "void",
        "desc": "No return value (returns `undefined`)."
      },
      "examples": [
        "// Sum values\nlet sum = 0; arrayForEach([1,2,3], v => { sum += v; }); // sum = 6",
        "// Respect thisArg\nconst ctx = { seen: [] }; arrayForEach(['a','b'], function (v) { this.seen.push(v); }, ctx); // ctx.seen = ['a','b']",
        "// Skip holes\nconst a = [1, , 3]; arrayForEach(a, (v, i) => { /* called for i=0 and i=2 only */ });"
      ]
    },
    "starterCode": "export default function arrayForEach(arr, callbackFn, thisArg) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function arrayForEach<T>(\n  arr: (T | undefined)[],\n  callbackFn: (value: T, index: number, array: (T | undefined)[]) => void,\n  thisArg?: any,\n): void {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Behave like native `Array.prototype.forEach` without touching prototypes: walk leftâ†’right over **existing** indices, call the callback with `(value, index, array)` bound to `thisArg`, **skip holes**, snapshot `length` once, and return `undefined`.",
      "approaches": [
        {
          "title": "Approach 1: Snapshot length + own-property check (recommended)",
          "prose": "1. Validate inputs (`Array.isArray` + function check).\n2. Snapshot `len = arr.length` so appends arenâ€™t visited.\n3. Loop `i = 0..len-1` and call callback only if `hasOwn.call(arr, i)`.\n4. Bind `thisArg` with `.call` and return `undefined`.\n\nâœ… Skips holes, ignores new elements, matches spec behavior.",
          "codeJs": "export default function arrayForEach(arr, callbackFn, thisArg) {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n  const len = arr.length;\n  const hasOwn = Object.prototype.hasOwnProperty;\n  for (let i = 0; i < len; i++) {\n    if (hasOwn.call(arr, i)) {\n      callbackFn.call(thisArg, arr[i], i, arr);\n    }\n  }\n  return undefined;\n}\n",
          "codeTs": "export default function arrayForEach<T>(\n  arr: (T | undefined)[],\n  callbackFn: (value: T, index: number, array: (T | undefined)[]) => void,\n  thisArg?: any,\n): void {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n  const len = arr.length;\n  const hasOwn = Object.prototype.hasOwnProperty;\n  for (let i = 0; i < len; i++) {\n    if (hasOwn.call(arr, i)) {\n      callbackFn.call(thisArg, arr[i] as T, i, arr);\n    }\n  }\n}\n"
        },
        {
          "title": "Approach 2: Spec-leaning â€” ToObject + `k in O` (includes inherited numeric keys)",
          "prose": "1. Convert to object: `const O = Object(arr)` and coerce `len` safely.\n2. Loop `k = 0..len-1` and check `(k in O)` to include inherited indices.\n3. Call `callbackFn.call(thisArg, O[k], k, O)` and return `undefined`.\n\nâœ… Mirrors spec property access and includes inherited numeric keys.",
          "codeJs": "export default function arrayForEach(arr, callbackFn, thisArg) {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n  const O = Object(arr);\n  const len = Math.max(0, Math.floor(Number(O.length) || 0));\n  for (let k = 0; k < len; k++) {\n    if (k in O) callbackFn.call(thisArg, O[k], k, O);\n  }\n  return undefined;\n}\n",
          "codeTs": "export default function arrayForEach<T>(\n  arr: (T | undefined)[],\n  callbackFn: (value: T, index: number, array: (T | undefined)[]) => void,\n  thisArg?: any,\n): void {\n  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');\n  if (typeof callbackFn !== 'function') throw new TypeError('callbackFn must be a function');\n  const O = Object(arr) as Record<number, T | undefined> & { length: number };\n  const len: number = Math.max(0, Math.floor(Number(O.length) || 0));\n  for (let k = 0; k < len; k++) {\n    if (k in O) callbackFn.call(thisArg, O[k] as T, k, O as any);\n  }\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Iterating past the initial length â€” always snapshot `length` first.",
          "Calling the callback for holes â€” use own-property checks unless you intentionally want inherited keys.",
          "Mutations during iteration (e.g., delete/append) can change what you visit; snapshot + own-check keeps behavior predictable."
        ],
        "edgeCases": [
          "Sparse arrays like `[1, , 3]`: callback runs for indices 0 and 2 only.",
          "Elements deleted before their turn are skipped (`hasOwn` becomes false).",
          "Arrow functions ignore `thisArg`; use a normal function if you need `this`."
        ],
        "techniques": [
          "Snapshot `length` at the start to avoid chasing moving targets.",
          "Use `hasOwnProperty.call(arr, i)` to skip holes cleanly.",
          "Bind `this` with `.call(thisArg, value, index, array)`.",
          "Return `undefined` explicitly to mirror native `forEach`."
        ]
      },
      "followUpQuestions": [
        "js-array-prototype-map",
        "js-array-prototype-filter",
        "js-array-prototype-some"
      ],
      "resources": [
        {
          "title": "MDN â€“ Array.prototype.forEach()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"
        },
        {
          "title": "ECMAScript Spec â€“ Array.prototype.forEach",
          "url": "https://tc39.es/ecma262/#sec-array.prototype.foreach"
        }
      ]
    },
    "tests": "import arrayForEach from './file';\n\ndescribe('arrayForEach', () => {\n  test('iterates in order', () => {\n    const seen = [];\n    arrayForEach([3, 1, 2], (v) => seen.push(v));\n    expect(seen).toEqual([3, 1, 2]);\n  });\n\n  test('binds thisArg', () => {\n    const ctx = { out: '' };\n    arrayForEach(['a', 'b'], function (v) { this.out += v; }, ctx);\n    expect(ctx.out).toBe('ab');\n  });\n\n  test('skips holes (edge)', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a = [1, , 3];\n    const seen = [];\n    arrayForEach(a, (v, i) => seen.push([v, i]));\n    expect(seen).toEqual([[1, 0], [3, 2]]);\n  });\n});\n",
    "testsTs": "import arrayForEach from './file';\n\ndescribe('arrayForEach (TypeScript)', () => {\n  it('iterates in order', () => {\n    const a = [3, 1, 2];\n    const seen: number[] = [];\n    arrayForEach(a, (v) => { seen.push(v as number); });\n    expect(seen).toEqual([3, 1, 2]);\n  });\n\n  it('binds thisArg', () => {\n    const ctx = { out: '' };\n    arrayForEach(['a', 'b'], function (v) { this.out += v; }, ctx);\n    expect(ctx.out).toBe('ab');\n  });\n\n  it('skips holes (edge)', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const a = [1, , 3];\n    const result: Array<[number, number]> = [];\n    arrayForEach(a, (v, i) => { if (v !== undefined) result.push([v as number, i]); });\n    expect(result).toEqual([[1, 0], [3, 2]]);\n  });\n});\n"
  },
  {
    "id": "js-array-sort",
    "title": "Sort Numbers with Array.prototype.sort",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "amazon"
    ],
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "Array",
      "sorting"
    ],
    "description": {
      "summary": "Implement a function `sortNumbers(arr, ascending = true)` that returns a **new array** of numbers sorted numerically in ascending or descending order. The original array must not be mutated, and you should use `Array.prototype.sort()` correctly with a compare function.",
      "arguments": [
        {
          "name": "arr",
          "type": "number[]",
          "desc": "An array of numbers to sort."
        },
        {
          "name": "ascending",
          "type": "boolean",
          "desc": "If `true` (default), sort in ascending order; if `false`, sort in descending order."
        }
      ],
      "returns": {
        "type": "number[]",
        "desc": "A new array containing the sorted numbers."
      },
      "examples": [
        "// Basic ascending sort\nsortNumbers([3, 1, 10]) // => [1, 3, 10]",
        "// Descending sort\nsortNumbers([3, 1, 10], false) // => [10, 3, 1]",
        "// Handles negative numbers\nsortNumbers([-2, 5, 0, -10]) // => [-10, -2, 0, 5]",
        "// Original array is not mutated\nconst nums = [5, 2, 11]\nconst sorted = sortNumbers(nums)\n// nums is still [5, 2, 11]"
      ]
    },
    "starterCode": "export default function sortNumbers(arr, ascending = true) {\n  // TODO:\n  // 1. Do NOT mutate the original array.\n  // 2. Use Array.prototype.sort() with a numeric compare function.\n  // 3. Respect the `ascending` flag.\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function sortNumbers(arr: number[], ascending = true): number[] {\n  // TODO:\n  // 1. Do NOT mutate the original array.\n  // 2. Use Array.prototype.sort() with a numeric compare function.\n  // 3. Respect the `ascending` flag.\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: sort an array of numbers **numerically**, not lexicographically, using `Array.prototype.sort()` â€” and return a **new** sorted array without mutating the original.\n\nThis tests understanding of:\n- How `.sort()` works by default (string/lexicographic behavior).\n- Writing a numeric compare function (`(a, b) => a - b`).\n- Avoiding mutation by cloning the input first.",
      "approaches": [
        {
          "title": "Approach 1: Clone + numeric compare function (canonical)",
          "prose": "Idea: make a shallow copy of the array, then call `.sort()` with a compare function that works on numbers.\n\n### ðŸ§  Step-by-step reasoning\n1. Clone the input: `const copy = [...arr]` (or `arr.slice()`). This prevents mutating the original.\n2. Decide the sort direction based on `ascending`:\n   - Ascending: `(a, b) => a - b`\n   - Descending: `(a, b) => b - a`\n3. Call `copy.sort(compareFn)` and return `copy`.\n\n**Why use it:**\n- Explicit numeric comparison avoids the default lexicographic behavior like `[10, 2].sort() // ['10', '2']`.\n- Clear control over ascending/descending.\n- No surprises from in-place mutation of the original array.",
          "codeJs": "export default function sortNumbers(arr, ascending = true) {\n  // Clone to avoid mutating the original\n  const copy = [...arr];\n\n  copy.sort((a, b) => {\n    if (ascending) {\n      return a - b; // negative if a < b, positive if a > b\n    }\n    return b - a;   // flipped for descending\n  });\n\n  return copy;\n}\n",
          "codeTs": "export default function sortNumbers(arr: number[], ascending = true): number[] {\n  // Clone to avoid mutating the original\n  const copy = [...arr];\n\n  copy.sort((a, b) => {\n    if (ascending) {\n      return a - b; // negative if a < b, positive if a > b\n    }\n    return b - a;   // flipped for descending\n  });\n\n  return copy;\n}\n"
        },
        {
          "title": "Approach 2: Always sort ascending, then reverse if needed",
          "prose": "Idea: keep the compare function simple by always sorting ascending, then reverse the array when `ascending` is `false`.\n\n### Steps\n1. Clone the input: `const copy = [...arr]`.\n2. Sort numerically ascending with `copy.sort((a, b) => a - b)`.\n3. If `ascending` is `false`, call `copy.reverse()`.\n4. Return `copy`.\n\n**Why use it:**\n- Keeps the compare function minimal.\n- Makes the sort order logic easy to read (especially for beginners).",
          "codeJs": "export default function sortNumbers(arr, ascending = true) {\n  const copy = [...arr];\n  copy.sort((a, b) => a - b); // numeric ascending\n  if (!ascending) {\n    copy.reverse();\n  }\n  return copy;\n}\n",
          "codeTs": "export default function sortNumbers(arr: number[], ascending = true): number[] {\n  const copy = [...arr];\n  copy.sort((a, b) => a - b); // numeric ascending\n  if (!ascending) {\n    copy.reverse();\n  }\n  return copy;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Default `.sort()` casts values to strings and sorts lexicographically: `[10, 2].sort()` â†’ `[10, 2]`, not `[2, 10]`.",
          "`.sort()` **mutates** the array itâ€™s called on â€” always clone when you must not change the input.",
          "Compare functions must return a negative value if `a` comes before `b`, positive if `a` comes after `b`, and `0` if their relative order doesnâ€™t matter.",
          "If `arr` contains non-numbers (`NaN`, strings, etc.), numeric comparison can produce surprising results. In this kata we assume valid numbers."
        ],
        "edgeCases": [
          "Empty array â†’ returns `[]`.",
          "Single-element array â†’ unchanged.",
          "Already sorted array â†’ returns a sorted copy; original is still intact.",
          "All equal numbers â†’ order is effectively unchanged."
        ],
        "techniques": [
          "Using spread syntax (`[...]`) or `.slice()` to clone arrays.",
          "Writing numeric compare functions for `.sort()`.",
          "Controlling sort direction with a flag.",
          "Understanding mutation vs. immutability when working with arrays."
        ]
      },
      "followUpQuestions": [
        "js-unique-array",
        "js-flatten-once"
      ],
      "resources": [
        {
          "title": "MDN â€“ Array.prototype.sort()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"
        },
        {
          "title": "MDN â€“ Array.prototype.reverse()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse"
        }
      ]
    },
    "tests": "import sortNumbers from './sortNumbers';\n\ndescribe('sortNumbers', () => {\n  test('sorts numbers ascending by default', () => {\n    expect(sortNumbers([3, 1, 10])).toEqual([1, 3, 10]);\n    expect(sortNumbers([-2, 5, 0, -10])).toEqual([-10, -2, 0, 5]);\n  });\n\n  test('sorts numbers descending when ascending is false', () => {\n    expect(sortNumbers([3, 1, 10], false)).toEqual([10, 3, 1]);\n    expect(sortNumbers([-2, 5, 0, -10], false)).toEqual([5, 0, -2, -10]);\n  });\n\n  test('does not mutate the original array', () => {\n    const nums = [5, 2, 11];\n    const copy = [...nums];\n    const sorted = sortNumbers(nums);\n\n    expect(sorted).toEqual([2, 5, 11]);\n    expect(nums).toEqual(copy); // original remains unchanged\n  });\n\n  test('handles empty and single-element arrays', () => {\n    expect(sortNumbers([])).toEqual([]);\n    expect(sortNumbers([42])).toEqual([42]);\n  });\n});\n",
    "testsTs": "import sortNumbers from './sortNumbers';\n\ndescribe('sortNumbers (TypeScript)', () => {\n  it('sorts numbers ascending by default', () => {\n    expect(sortNumbers([3, 1, 10])).toEqual([1, 3, 10]);\n    expect(sortNumbers([-2, 5, 0, -10])).toEqual([-10, -2, 0, 5]);\n  });\n\n  it('sorts numbers descending when ascending is false', () => {\n    expect(sortNumbers([3, 1, 10], false)).toEqual([10, 3, 1]);\n    expect(sortNumbers([-2, 5, 0, -10], false)).toEqual([5, 0, -2, -10]);\n  });\n\n  it('does not mutate the original array', () => {\n    const nums = [5, 2, 11];\n    const copy = [...nums];\n    const sorted = sortNumbers(nums);\n\n    expect(sorted).toEqual([2, 5, 11]);\n    expect(nums).toEqual(copy);\n  });\n\n  it('handles empty and single-element arrays', () => {\n    expect(sortNumbers([])).toEqual([]);\n    expect(sortNumbers([42])).toEqual([42]);\n  });\n});\n"
  },
  {
    "id": "js-create-counter",
    "title": "Create a Counter Function",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "closures",
      "functions",
      "state",
      "increment"
    ],
    "description": {
      "summary": "Implement a function that returns a counter function. Each call to the returned function should increment and return the next integer, starting from the initial number `n`. Tests closure scope and persistent state handling.",
      "arguments": [
        {
          "name": "n",
          "type": "number",
          "desc": "The starting integer for the counter."
        }
      ],
      "returns": {
        "type": "Function",
        "desc": "A function that returns the next integer each time itâ€™s called."
      },
      "examples": [
        "// Example 1\nconst counter = createCounter(10);\ncounter(); // => 10\ncounter(); // => 11\ncounter(); // => 12",
        "// Example 2\nconst counter = createCounter(-2);\ncounter(); // => -2\ncounter(); // => -1\ncounter(); // => 0"
      ]
    },
    "starterCode": "export default function createCounter(n) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function createCounter(n: number): () => number {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: keep state across calls using a closure so each counter instance tracks its own increasing value.",
      "approaches": [
        {
          "title": "Approach: Closure-based counter (recommended)",
          "prose": "1. Capture the starting value `n` in the outer functionâ€™s scope.\n2. Return an inner function that can still see and modify `n` (closure).\n3. On each call, read the current value, then increment `n`.\n4. Return the value you read (pre-increment result).",
          "codeJs": "export default function createCounter(n) {\n  return function() {\n    const current = n;\n    n += 1;\n    return current;\n  };\n}\n",
          "codeTs": "export default function createCounter(n: number): () => number {\n  return function(): number {\n    const current = n;\n    n += 1;\n    return current;\n  };\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Using a global variable will share state across all counters â€” use a closure per instance.",
          "Returning `++n` vs. current value changes behavior (off-by-one). This task expects returning the current and then incrementing.",
          "Mutating objects captured in closures can cause shared state; here we keep only a primitive number."
        ],
        "edgeCases": [
          "Negative starts (e.g., `-2`) should count upward correctly.",
          "Large numbers work until you hit `Number.MAX_SAFE_INTEGER` (then precision issues can appear).",
          "Multiple counters created from separate calls must not interfere with each other."
        ],
        "techniques": [
          "Leverage lexical scoping: inner function closes over `n`.",
          "Prefer returning a function over exposing mutable objects to keep encapsulation tight."
        ]
      },
      "followUpQuestions": [
        "js-memoize-function"
      ],
      "resources": [
        {
          "title": "MDN â€“ Closures",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
        },
        {
          "title": "You Donâ€™t Know JS Yet â€“ Scope & Closures (free book)",
          "url": "https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures"
        }
      ]
    },
    "tests": "import createCounter from './file';\n\ndescribe('createCounter', () => {\n  test('increments sequentially', () => {\n    const counter = createCounter(10);\n    expect(counter()).toBe(10);\n    expect(counter()).toBe(11);\n    expect(counter()).toBe(12);\n  });\n\n  test('works with negative numbers', () => {\n    const counter = createCounter(-2);\n    expect(counter()).toBe(-2);\n    expect(counter()).toBe(-1);\n    expect(counter()).toBe(0);\n  });\n\n  test('separate counters maintain independent state', () => {\n    const c1 = createCounter(0);\n    const c2 = createCounter(100);\n    expect(c1()).toBe(0);\n    expect(c2()).toBe(100);\n    expect(c1()).toBe(1);\n    expect(c2()).toBe(101);\n  });\n});\n",
    "testsTs": "import createCounter from './file';\n\ndescribe('createCounter (TypeScript)', () => {\n  it('increments sequentially', () => {\n    const counter = createCounter(5);\n    expect(counter()).toBe(5);\n    expect(counter()).toBe(6);\n    expect(counter()).toBe(7);\n  });\n\n  it('works with negative numbers', () => {\n    const counter = createCounter(-2);\n    expect(counter()).toBe(-2);\n    expect(counter()).toBe(-1);\n    expect(counter()).toBe(0);\n  });\n\n  it('independent counters maintain separate state', () => {\n    const c1 = createCounter(1);\n    const c2 = createCounter(50);\n    expect(c1()).toBe(1);\n    expect(c2()).toBe(50);\n    expect(c1()).toBe(2);\n    expect(c2()).toBe(51);\n  });\n});\n"
  },
  {
    "id": "js-is-object-empty",
    "title": "Check if an Object or Array is Empty",
    "type": "coding",
    "technology": "javascript",
    "importance": 3,
    "difficulty": "easy",
    "tags": [
      "objects",
      "arrays",
      "basics",
      "validation"
    ],
    "description": {
      "summary": "Implement a function that determines whether a given object or array is empty. Tests your ability to handle both array and object structures and reason about length and key-value pairs.",
      "arguments": [
        {
          "name": "obj",
          "type": "Object | Array",
          "desc": "An object or array parsed from JSON."
        }
      ],
      "returns": {
        "type": "boolean",
        "desc": "Returns `true` if empty; otherwise `false`."
      },
      "examples": [
        "// Example 1\nisEmpty({ x: 5, y: 42 }); // => false",
        "// Example 2\nisEmpty({}); // => true",
        "// Example 3\nisEmpty([null, false, 0]); // => false"
      ]
    },
    "starterCode": "export default function isEmpty(obj) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default function isEmpty(obj: Record<string, any> | any[]): boolean {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: return `true` only when the input is an object or array with no elements or keys.",
      "approaches": [
        {
          "title": "Approach: Handle arrays and objects separately",
          "prose": "1. **Array check:** If it's an array, simply return whether its length is 0.\n2. **Object check:** If it's an object, get its own enumerable keys with `Object.keys()` and check if that list is empty.\n3. **Invalid input:** Throw a `TypeError` for non-object types like strings or numbers.\n4. **Return result:** Return a boolean indicating emptiness for the recognized type.",
          "codeJs": "export default function isEmpty(obj) {\n  if (Array.isArray(obj)) return obj.length === 0;\n  if (obj && typeof obj === 'object') return Object.keys(obj).length === 0;\n  throw new TypeError('Expected object or array');\n}\n",
          "codeTs": "export default function isEmpty(obj: Record<string, any> | any[]): boolean {\n  if (Array.isArray(obj)) return obj.length === 0;\n  if (obj && typeof obj === 'object') return Object.keys(obj).length === 0;\n  throw new TypeError('Expected object or array');\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Checking `Object.keys()` on `null` or `undefined` will throw â€” always guard with `obj && typeof obj === 'object'`.",
          "Strings also have `.length`, but should not be considered valid inputs here.",
          "Prototype-inherited properties are ignored by `Object.keys()`, which is correct for this task."
        ],
        "edgeCases": [
          "`[]` â†’ true (no elements).",
          "`{}` â†’ true (no keys).",
          "`[null, false, 0]` â†’ false (contains items even if falsy).",
          "`Object.create(null)` â†’ true (no enumerable keys)."
        ],
        "techniques": [
          "Use `Array.isArray()` for accurate array detection.",
          "Prefer `Object.keys()` over `for...in` to ignore prototype properties."
        ]
      },
      "followUpQuestions": [
        "js-deep-equal"
      ],
      "resources": [
        {
          "title": "MDN â€“ Object.keys()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"
        },
        {
          "title": "MDN â€“ Array.isArray()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
        }
      ]
    },
    "tests": "import isEmpty from './file';\n\ndescribe('isEmpty', () => {\n  test('returns false for non-empty object', () => {\n    expect(isEmpty({ x: 5, y: 42 })).toBe(false);\n  });\n\n  test('returns true for empty object', () => {\n    expect(isEmpty({})).toBe(true);\n  });\n\n  test('returns false for non-empty array', () => {\n    expect(isEmpty([null, false, 0])).toBe(false);\n  });\n});\n",
    "testsTs": "import isEmpty from './file';\n\ndescribe('isEmpty (TypeScript)', () => {\n  it('returns false for non-empty object', () => {\n    expect(isEmpty({ x: 5, y: 42 })).toBe(false);\n  });\n\n  it('returns true for empty object', () => {\n    expect(isEmpty({})).toBe(true);\n  });\n\n  it('returns false for non-empty array', () => {\n    expect(isEmpty([1, 2, 3])).toBe(false);\n  });\n});\n"
  },
  {
    "id": "js-add-two-promises",
    "title": "Add Two Promises",
    "type": "coding",
    "technology": "javascript",
    "companies": [
      "google"
    ],
    "importance": 4,
    "difficulty": "easy",
    "tags": [
      "promises",
      "async",
      "functions",
      "basics"
    ],
    "description": {
      "summary": "Implement a function that takes two promises resolving to numbers and returns a new promise that resolves to their sum. Tests async/await usage and Promise handling.",
      "arguments": [
        {
          "name": "promise1",
          "type": "Promise<number>",
          "desc": "A promise that resolves with a number."
        },
        {
          "name": "promise2",
          "type": "Promise<number>",
          "desc": "Another promise that resolves with a number."
        }
      ],
      "returns": {
        "type": "Promise<number>",
        "desc": "A promise resolving with the sum of the two resolved values."
      },
      "examples": [
        "// Example 1\nconst p1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\nconst p2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\nawait addTwoPromises(p1, p2); // => 7",
        "// Example 2\nconst p1 = new Promise(resolve => setTimeout(() => resolve(10), 50));\nconst p2 = new Promise(resolve => setTimeout(() => resolve(-12), 30));\nawait addTwoPromises(p1, p2); // => -2"
      ]
    },
    "starterCode": "export default async function addTwoPromises(promise1, promise2) {\n  throw new Error('Not implemented');\n}\n",
    "starterCodeTs": "export default async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\n  throw new Error('Not implemented');\n}\n",
    "solutionBlock": {
      "overview": "Goal: combine two asynchronous results and return a promise that resolves to their sum.",
      "approaches": [
        {
          "title": "Approach: Resolve both concurrently using Promise.all",
          "prose": "1. **Wait for both promises:** Use `Promise.all()` so both resolve in parallel.\n2. **Destructure results:** Extract the resolved values `[a, b]` from the array returned by `Promise.all()`.\n3. **Sum and return:** Add the numbers and return the result â€” wrapped automatically in a promise since the function is `async`.\n4. **Performance:** Both promises run concurrently, so total time equals the slower oneâ€™s resolution.",
          "codeJs": "export default async function addTwoPromises(promise1, promise2) {\n  const [a, b] = await Promise.all([promise1, promise2]);\n  return a + b;\n}\n",
          "codeTs": "export default async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\n  const [a, b] = await Promise.all([promise1, promise2]);\n  return a + b;\n}\n"
        }
      ],
      "notes": {
        "pitfalls": [
          "Avoid chaining with nested `.then()` â€” it's harder to read and may resolve sequentially.",
          "If either promise rejects, `Promise.all` rejects immediately (propagating the error).",
          "Always `await` or return the result â€” otherwise it wonâ€™t resolve properly."
        ],
        "edgeCases": [
          "Both promises resolve instantly â†’ works fine (microtask scheduling).",
          "One promise resolves slower â†’ result waits for the slower one.",
          "If any promise rejects â†’ the function rejects too (like native Promise.all)."
        ],
        "techniques": [
          "`Promise.all()` for concurrent resolution.",
          "`async/await` for clean and readable syntax.",
          "Destructuring arrays to extract resolved results."
        ]
      },
      "followUpQuestions": [],
      "resources": [
        {
          "title": "MDN â€“ Promise.all()",
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
        },
        {
          "title": "JavaScript.info â€“ Promises, async/await",
          "url": "https://javascript.info/async-await"
        }
      ]
    },
    "tests": "import addTwoPromises from './file';\n\ndescribe('addTwoPromises', () => {\n  test('resolves with sum of positive numbers', async () => {\n    const p1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\n    const p2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(7);\n  });\n\n  test('handles negative and positive mix', async () => {\n    const p1 = new Promise(resolve => setTimeout(() => resolve(10), 50));\n    const p2 = new Promise(resolve => setTimeout(() => resolve(-12), 30));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(-2);\n  });\n\n  test('works with zero values (edge)', async () => {\n    const result = await addTwoPromises(Promise.resolve(0), Promise.resolve(0));\n    expect(result).toBe(0);\n  });\n});\n",
    "testsTs": "import addTwoPromises from './file';\n\ndescribe('addTwoPromises (TypeScript)', () => {\n  test('resolves with sum of positive numbers', async () => {\n    const p1 = new Promise<number>(resolve => setTimeout(() => resolve(2), 20));\n    const p2 = new Promise<number>(resolve => setTimeout(() => resolve(5), 60));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(7);\n  });\n\n  test('handles mix of negative and positive', async () => {\n    const p1 = new Promise<number>(resolve => setTimeout(() => resolve(10), 50));\n    const p2 = new Promise<number>(resolve => setTimeout(() => resolve(-12), 30));\n    const result = await addTwoPromises(p1, p2);\n    expect(result).toBe(-2);\n  });\n\n  test('works with immediately resolved promises (edge)', async () => {\n    const result = await addTwoPromises(Promise.resolve(3), Promise.resolve(4));\n    expect(result).toBe(7);\n  });\n});\n"
  }
]