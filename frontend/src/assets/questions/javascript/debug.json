[
    {
        "id": "js-debug-off-by-one",
        "title": "Fix off-by-one in `chunk`",
        "difficulty": "intermediate",
        "importance": 3,
        "tags": [
            "arrays",
            "bugs",
            "edge-cases"
        ],
        "description": {
            "text": "The current implementation of `chunk(arr, size)` occasionally drops the last group or returns an empty chunk when size divides the length exactly. Find and fix the bug.",
            "examples": [
                "chunk([1,2,3,4,5], 2) // [[1,2],[3,4],[5]]",
                "chunk([1,2,3,4], 2)   // [[1,2],[3,4]]"
            ]
        },
        "starterCode": "export default function chunk(arr, size){\n  if(!Array.isArray(arr) || size <= 0) return [];\n  const out = [];\n  for(let i = 0; i <= arr.length; i += size){ // BUG: '<='\n    out.push(arr.slice(i, i + size));\n  }\n  return out;\n}\n",
        "tests": "test('splits into uneven groups', () => {\n  const fn = __user_fn__;\n  expect(fn([1,2,3,4,5], 2)).toEqual([[1,2],[3,4],[5]]);\n});\n\ntest('exactly divisible should not add empty chunk', () => {\n  const fn = __user_fn__;\n  expect(fn([1,2,3,4], 2)).toEqual([[1,2],[3,4]]);\n});\n",
        "solution": "export default function chunk(arr, size){\n  if(!Array.isArray(arr) || size <= 0) return [];\n  const out = [];\n  for(let i = 0; i < arr.length; i += size){\n    out.push(arr.slice(i, i + size));\n  }\n  return out;\n}\n"
    },
    {
        "id": "js-debug-mutating-input",
        "title": "Stop mutating input in `unique`",
        "difficulty": "easy",
        "importance": 2,
        "tags": [
            "arrays",
            "immutability"
        ],
        "description": {
            "text": "`unique(arr)` must return a new array of unique items while leaving the input array untouched.",
            "examples": [
                "const a = [2,2,1,3,1];\nconst b = unique(a);\n// b: [2,1,3]\n// a must remain [2,2,1,3,1]"
            ]
        },
        "starterCode": "export default function unique(arr){\n  // BUG: sorts in-place and mutates input\n  return Array.from(new Set(arr.sort()));\n}\n",
        "tests": "test('returns unique values', () => {\n  const fn = __user_fn__;\n  expect(fn([2,2,1,3,1])).toEqual([2,1,3]);\n});\n\ntest('does not mutate input', () => {\n  const fn = __user_fn__;\n  const a = [2,2,1,3,1];\n  fn(a);\n  expect(a).toEqual([2,2,1,3,1]);\n});\n",
        "solution": "export default function unique(arr){\n  return Array.from(new Set(arr.slice()));\n}\n"
    },
    {
        "id": "js-debug-async-race",
        "title": "Fix async race in `fetchWithCache`",
        "difficulty": "hard",
        "importance": 4,
        "tags": [
            "async",
            "cache",
            "promises"
        ],
        "description": {
            "text": "Multiple simultaneous calls with the same key should share the same in-flight request. Fix the race so only one network call happens per key until it resolves."
        },
        "starterCode": "const cache = new Map();\nconst inflight = new Map();\n\nexport default async function fetchWithCache(key, fetcher){\n  if(cache.has(key)) return cache.get(key);\n  // BUG: not sharing in-flight promise\n  const p = fetcher().then(res => { cache.set(key, res); inflight.delete(key); return res; });\n  inflight.set(key, p);\n  return p;\n}\n",
        "tests": "test('shares in-flight promise', async () => {\n  const fn = __user_fn__;\n  let calls = 0;\n  const fetcher = async () => { calls++; await new Promise(r=>setTimeout(r,20)); return 'OK'; };\n  const [a,b,c] = await Promise.all([fn('k', fetcher), fn('k', fetcher), fn('k', fetcher)]);\n  expect(a).toBe('OK');\n  expect(b).toBe('OK');\n  expect(c).toBe('OK');\n  expect(calls).toBe(1);\n});\n",
        "solution": "const cache = new Map();\nconst inflight = new Map();\n\nexport default async function fetchWithCache(key, fetcher){\n  if(cache.has(key)) return cache.get(key);\n  if(inflight.has(key)) return inflight.get(key);\n  const p = fetcher().then(res => { cache.set(key, res); inflight.delete(key); return res; });\n  inflight.set(key, p);\n  return p;\n}\n"
    }
]