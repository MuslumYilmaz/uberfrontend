{
    "key": "O",
    "title": "Optimizations & Deep dive",
    "blocks": [
        {
            "type": "text",
            "text": "In this step, the interviewer checks whether you can keep a real upload pipeline fast and resilient: preprocessing cost, upload stability, progress UX, and memory safety."
        },
        {
            "type": "divider"
        },
        {
            "type": "columns",
            "columns": [
                {
                    "blocks": [
                        {
                            "type": "text",
                            "text": "**How you should frame optimizations:**\n\"Even a single-image upload can be expensive: decoding, resizing, and uploading large files can jank the UI. Iâ€™ll keep image work off the main thread when possible, throttle progress updates, and make retries safe.\""
                        }
                    ]
                },
                {
                    "blocks": [
                        {
                            "type": "text",
                            "text": "**What the interviewer listens for:**\n- Awareness of **image decoding/resizing cost** and main-thread impact.\n- Stable **progress + retry** behavior on flaky networks.\n- Memory hygiene (object URLs, avoiding base64 blobs).\n- A path to extend to multi-image or chunked uploads."
                        }
                    ]
                }
            ]
        },
        {
            "type": "callout",
            "variant": "info",
            "title": "How you should act here",
            "text": "Pick a few realistic risks: large files, slow networks, and janky UI. Explain exactly how you avoid them."
        },
        {
            "type": "divider"
        },
        {
            "type": "columns",
            "columns": [
                {
                    "blocks": [
                        {
                            "type": "checklist",
                            "title": "Performance & memory hygiene",
                            "items": [
                                "Use `createImageBitmap` + OffscreenCanvas or a Web Worker for resize/compress.",
                                "Throttle progress updates (e.g., 100-200ms) to avoid re-render storms.",
                                "Revoke old `previewUrl` on replace/remove/unmount.",
                                "Avoid base64 in state; keep File + object URL only.",
                                "Use `AbortController` to cancel in-flight uploads on replace/remove.",
                                "Cap memory usage if multiple previews are added later."
                            ]
                        }
                    ]
                },
                {
                    "blocks": [
                        {
                            "type": "checklist",
                            "title": "UX & accessibility polish",
                            "items": [
                                "Ensure the main control is a clear, focusable target (button or label-wrap around file input) with descriptive text.",
                                "Display error messages in a region with `role=\"alert\"` or wired via `aria-describedby` so screen readers announce them immediately.",
                                "Use distinct visual cues for each state (idle, uploading, uploaded, error), not just color changes.",
                                "Make sure \"Replace\" and \"Remove\" are reachable by keyboard and have clear labels (not just icons).",
                                "On error, keep focus in a sensible place (e.g. on the control or on the first action), so the user can fix the problem quickly.",
                                "On mobile, avoid cramped layouts: give enough padding around the button, preview, and actions so taps are reliable."
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "type": "table",
            "title": "Deep-dive angles you can bring up",
            "columns": [
                "Topic",
                "Risk",
                "How you address it"
            ],
            "rows": [
                [
                    "Large files",
                    "Decoding/resizing blocks the main thread.",
                    "Use `createImageBitmap` or a worker + OffscreenCanvas for preprocessing."
                ],
                [
                    "Flaky networks",
                    "Uploads fail mid-flight; users lose progress.",
                    "Retry with backoff, allow cancel, and resume if the backend supports chunking."
                ],
                [
                    "Progress updates",
                    "High-frequency events cause re-render storms.",
                    "Throttle progress UI updates to a fixed cadence."
                ],
                [
                    "Object URL lifecycle",
                    "Multiple previews leak memory over time.",
                    "Revoke URLs on replace/remove/unmount and avoid base64."
                ],
                [
                    "Mobile responsiveness",
                    "Preview/actions overflow on small screens.",
                    "Use a vertical layout and limit preview size with `object-fit`."
                ]
            ]
        },
        {
            "type": "steps",
            "title": "Example deep-dive: upload cancel + retry",
            "steps": [
                {
                    "title": "1. Start upload with AbortController",
                    "text": "Create an AbortController per upload and store it in state. Set status to uploading and expose Cancel."
                },
                {
                    "title": "2. Handle cancel",
                    "text": "On cancel/replace, call `controller.abort()`, reset progress, and revoke preview URLs."
                },
                {
                    "title": "3. Retry with backoff",
                    "text": "On failure, show Retry and attempt again with exponential backoff."
                },
                {
                    "title": "4. Throttle progress UI",
                    "text": "Update progress at a fixed cadence to keep rendering stable."
                }
            ]
        },
        {
            "type": "stats",
            "items": [
                {
                    "label": "Main risk",
                    "value": "Main-thread jank",
                    "helperText": "Move resize/compress off-thread."
                },
                {
                    "label": "Key UX lever",
                    "value": "Progress + retry",
                    "helperText": "Users trust the upload if they can see and recover."
                },
                {
                    "label": "Deep-dive hook",
                    "value": "Cancel + backoff",
                    "helperText": "Use AbortController and exponential retry."
                }
            ]
        },
        {
            "type": "callout",
            "variant": "warning",
            "title": "Key message to land",
            "text": "The deep dive is about performance and reliability: keep image work off the main thread, throttle progress updates, and make retry/cancel safe."
        }
    ]
}
