[
    {
        "id": "infinite-scroll-list",
        "title": "Infinite Scroll List",
        "companies": [
            "google"
        ],
        "description": "Design an infinite scroll list that progressively loads more items from a paginated API as the user scrolls down. Focus on achieving smooth scrolling, clear loading/error states, and keeping DOM size reasonable as the list grows.\n\nKey considerations include: when to load more data, how to detect scroll boundaries efficiently, how to show skeleton placeholders without causing layout jumps, and when it becomes necessary to introduce list virtualization.",
        "tags": [
            "infinite-scroll",
            "virtualization",
            "performance",
            "ux"
        ],
        "type": "system-design"
    },
    {
        "id": "notification-toast-system",
        "title": "Notification Toast System",
        "companies": [
            "google",
            "netflix"
        ],
        "description": "Design a global toast/alert system that can be triggered from anywhere in the app (e.g. `toast.success()`, `toast.error()`). Focus on global state, rendering through a portal, stacking multiple toasts, auto-dismiss timers, and accessible behavior.\n\nKey considerations include: how to expose a simple global API, how to manage timers and cleanup safely, how to handle z-index and stacking order, and how to support responsive placements (top-right, bottom-left, mobile full-width) with good ARIA roles and focus handling.",
        "tags": [
            "toast",
            "notifications",
            "global-state"
        ],
        "type": "system-design"
    },
    {
        "id": "multi-step-form-autosave",
        "title": "Multi-step Form with Autosave",
        "description": "Design a 4-step form with validation, step transitions, a progress bar, and automatic autosave to localStorage. Users should be able to refresh or leave the page and continue where they left off. Key considerations include form architecture, throttled/debounced autosave, inline vs submit validation, dirty-state tracking, and restoring from saved drafts.",
        "tags": [
            "forms",
            "autosave",
            "validation"
        ],
        "type": "system-design"
    },
    {
        "id": "realtime-search-debounce-cache",
        "title": "Real-time Search with Debounce & Caching",
        "description": "Design a real-time search module where results update as the user types, focusing only on the frontend side: state management, debouncing, and caching. Assume there is some abstract async search function in the background, but your job is to design how the input, debounced calls, cache, and UI states work.\n\nKey considerations include: choosing debounce (and explaining why) vs throttle, maintaining a client-side cache of query → results so repeated queries are instant, simulating cancellation of outdated requests (ignoring late responses), handling slow typing vs fast typing without flicker or stale results, and designing UX states for empty query, loading, no results, and error.",
        "tags": [
            "search",
            "debounce",
            "caching"
        ],
        "type": "system-design"
    },
    {
        "id": "dashboard-widgets-draggable-resizable",
        "title": "Dashboard with Draggable & Resizable Widgets",
        "companies": [
            "google"
        ],
        "description": "Design a customizable dashboard made of widgets that the user can rearrange and resize. Widgets live on a grid layout, can be dragged to change position, and resized via handles. The dashboard layout is persisted (e.g. localStorage snapshot) so the user sees the same configuration on reload.\n\nKey considerations include: drag & drop architecture for widgets, grid-based layout with snapping and collision handling, resize handles with min/max constraints, re-render optimizations so drag/resize feel smooth (60 FPS target), and saving/restoring layout snapshots for each user.",
        "tags": [
            "dashboard",
            "drag-drop",
            "performance"
        ],
        "type": "system-design"
    },
    {
        "id": "live-chart-high-frequency-updates",
        "title": "Live Chart Rendering (High Frequency Updates)",
        "description": "Design a live line chart that updates roughly every 500ms (e.g. streaming metrics, stock prices, telemetry). Focus purely on the frontend side: how to feed data into the chart, render updates efficiently, and keep the UI smooth over time.\n\nKey considerations include: choosing between incremental updates (append/shift points) vs full redraw per tick, understanding the trade-offs between using a charting library (ECharts, Chart.js, etc.) and custom canvas/WebGL rendering, and designing a requestAnimationFrame-driven render loop so the chart stays smooth without over-drawing.\n\nYou should be prepared to talk about: memory management as data grows (sliding window, bounded buffers), how to handle bursts of updates (queueing vs dropping frames), when to use OffscreenCanvas or Web Workers to offload work from the main thread, and strategies like downsampling/aggregation for very large datasets so the chart stays responsive even after running for a long time.",
        "tags": [
            "charts",
            "real-time",
            "performance"
        ],
        "type": "system-design"
    },
    {
        "id": "component-design-system-architecture",
        "title": "Component-driven Design System Architecture",
        "description": "Design a component-based design system for a mid-to-large scale product: buttons, inputs, tabs, banners, dialogs, and more. Focus on how the system is structured, how teams consume it, and how it evolves safely over time.\n\nKey considerations include: token-driven theming (semantic tokens, color scales, dark/high-contrast variants), CSS architecture decisions (CSS variables, utility classes, BEM, or Tailwind-style tokens), accessibility-first component APIs (keyboard behavior, ARIA attributes, focus management), and support for dark mode, high contrast, and RTL from day one.\n\nYou should be prepared to talk about: consistent component APIs (props, events, slots), how to ensure long-term maintainability, versioning and breaking-change strategy, tree-shaking-friendly structure, and bundle-size optimizations like dynamic imports and granular code splitting.",
        "tags": [
            "design-system",
            "theming",
            "performance"
        ],
        "type": "system-design"
    },
    {
        "id": "image-upload-preview",
        "title": "Image Upload & Preview Component",
        "description": "Design a component that lets users upload an image, instantly preview it, validate its size and type, and simulate a short upload process. Focus purely on the frontend side: handling file inputs, using URL.createObjectURL for previewing, validation flows, accessible error messaging, mobile-friendly layout, drag-and-drop (optional), and smooth state transitions.\n\nKey considerations include: file type + max-size validation, immediate preview, upload skeleton/loading state, allowing users to replace/remove the image, managing object URLs safely, and addressing accessibility concerns like keyboard navigation and ARIA error roles.",
        "tags": [
            "images",
            "upload",
            "validation"
        ],
        "type": "system-design"
    },
    {
        "id": "flashcard-language-trainer",
        "title": "Flashcard-based Language Learning App",
        "companies": [
            "amazon"
        ],
        "description": "Design a web app that uses flash cards to help users learn a foreign language. The front side shows a word in the user's language; when hovered or clicked it flips to reveal the foreign-language word. Focus on server–client communication (APIs for decks, cards, and progress), a smooth flip interaction, and responsive, accessible UI.\n\nKey considerations include: how to fetch and paginate cards for a deck, how to track and persist per-user progress (\"knew it\" / \"didn't know it\"), how to design the flip interaction for both mouse and touch, how to cache data for low-latency study sessions (including offline-friendly behavior), and how to keep animations and rendering smooth as decks grow.",
        "tags": [
            "flashcards",
            "language-learning",
            "accessibility"
        ],
        "type": "system-design"
    }
]