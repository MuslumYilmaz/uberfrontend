{
    "key": "R",
    "title": "Reflect & Requirements",
    "blocks": [
        {
            "type": "text",
            "text": "We want a scrollable list that feels endless: as the user scrolls near the bottom, new items are fetched and rendered seamlessly. We assume there is already an HTTP API that returns paginated items (page/size or cursor-based). Our job on the frontend is to keep scrolling smooth, loading states clear, and memory usage under control."
        },
        {
            "type": "divider"
        },
        {
            "type": "columns",
            "columns": [
                {
                    "blocks": [
                        {
                            "type": "text",
                            "text": "### What are we building?\nA reusable InfiniteScrollList component that:\n- Renders an initial batch of items.\n- Detects when the user is near the bottom (IntersectionObserver).\n- Fetches the next page and appends items.\n- Shows skeleton loaders while fetching.\n- Handles errors and allows retry.\n- Optionally supports virtualization for very long lists."
                        }
                    ]
                },
                {
                    "blocks": [
                        {
                            "type": "text",
                            "text": "### What is the interviewer testing?\n- Understanding of IntersectionObserver vs scroll events.\n- Skeleton vs spinner usage and UX trade-offs.\n- When and how to apply list virtualization.\n- How to avoid memory leaks and runaway event listeners.\n- Error, retry and empty-state handling.\n- Basic performance reasoning (FPS, re-renders)."
                        }
                    ]
                }
            ]
        },
        {
            "type": "callout",
            "variant": "info",
            "title": "Think like a frontend engineer",
            "text": "Treat the backend as a black box that exposes a clean API. Focus your design on components, state, rendering strategy, and user experience under slow network, large data sets, and errors."
        },
        {
            "type": "divider"
        },
        {
            "type": "steps",
            "title": "High-level user flow",
            "steps": [
                {
                    "title": "Initial load",
                    "text": "User opens the page → first page of items is fetched and rendered with skeletons."
                },
                {
                    "title": "Scroll near bottom",
                    "text": "IntersectionObserver fires when sentinel element enters the viewport."
                },
                {
                    "title": "Load more",
                    "text": "Component requests the next page, shows skeleton placeholders at the bottom, and appends new items."
                },
                {
                    "title": "End / errors",
                    "text": "If there are no more items, show an \"End of list\" state. If a request fails, show an inline error with a Retry button."
                }
            ]
        },
        {
            "type": "columns",
            "columns": [
                {
                    "blocks": [
                        {
                            "type": "checklist",
                            "title": "Clarifying questions (frontend)",
                            "items": [
                                "How many items can exist in total (tens, thousands, hundreds of thousands)?",
                                "Does the API support page/limit, cursor, or both?",
                                "Are items fixed-height or variable-height? (Impacts virtualization strategy.)",
                                "Do we need to preserve scroll position when the user navigates away and back?",
                                "Is the list read-only, or can items change while the user is scrolling?"
                            ]
                        }
                    ]
                },
                {
                    "blocks": [
                        {
                            "type": "checklist",
                            "title": "Non-functional expectations (from FE view)",
                            "items": [
                                "Scrolling should remain smooth (no jank) on mid-range laptops and phones.",
                                "Loading states should feel responsive and avoid layout jumps.",
                                "Memory usage should not grow unbounded for very long sessions.",
                                "The list should be accessible: keyboard/reader users can still reach all items.",
                                "The component should be reusable with different item renderers (cards, rows, etc.)."
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "type": "stats",
            "items": [
                {
                    "label": "Target scroll FPS",
                    "value": "≈ 60 FPS",
                    "helperText": "No noticeable stutter while new items load"
                },
                {
                    "label": "Batch size",
                    "value": "20–50 items",
                    "helperText": "Small enough for fast renders, large enough to avoid over-fetching"
                },
                {
                    "label": "Max in-DOM items (without virtualization)",
                    "value": "≈ 300–500",
                    "helperText": "Beyond this, we strongly consider virtualization"
                }
            ]
        },
        {
            "type": "callout",
            "variant": "warning",
            "title": "Core design tension",
            "text": "The more items we keep in the DOM, the heavier the page becomes. The more aggressively we virtualize, the more careful we must be with scroll position, keyboard navigation, and SEO/crawlers. The design must balance smooth UX with implementation complexity."
        }
    ]
}